<!DOCTYPE html>
<html lang="zh">
<head>
    <title>objdump:显示二进制文件信息</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="keywords" content="dev-coco, Linux命令手册, Linux命令"/>
    <meta name="robots" content="index,follow"/>
    <meta name="description" content="objdump:显示二进制文件信息 — 最专业的Linux命令大全"/>
    <link rel="icon" href="https://dev-coco.github.io/images/WebIcon.png">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
    <script src="https://dev-coco.github.io/js/love.js" async="async"></script>
    <link rel="stylesheet" href="https://dev-coco.github.io/css/site.css">
</head>
<body>
    <div class="container">
<h1 style="text-align:left;"><img class="logo" alt="dev-coco" src="https://dev-coco.github.io/images/WebIcon.png"> Dev-Coco</h1>
<div class="menu">
  <a href="https://dev-coco.github.io/">主页</a>
  <a href="https://dev-coco.github.io/blog">博客</a>
  <a href="https://dev-coco.github.io/Featured-Software.html">软件</a>
  <a href="https://dev-coco.github.io/Online-Tools/">在线工具</a>
  <a href="https://dev-coco.github.io/Linux-Command/">Linux命令</a>
  <a target="_blank" href="https://github.com/dev-coco">Github</a>
</div>
<h1>objdump</h1><p>显示二进制文件信息</p>
<h2>补充说明</h2><p><strong>objdump命令</strong> 是用查看目标文件或者可执行的目标文件的构成的gcc工具。</p>
<h3>选项</h3><pre><code>-a --archive-headers
<span># 显示档案库的成员信息,类似ls -l将lib*.a的信息列出。 </span>

-b bfdname --target<span>=</span>bfdname
<span># 指定目标码格式。这不是必须的，objdump能自动识别许多格式，比如： </span>

objdump -b oasys -m vax -h fu.o
<span># 显示fu.o的头部摘要信息，明确指出该文件是Vax系统下用Oasys编译器生成的目标文件。objdump -i将给出这里可以指定的目标码格式列表。 </span>

-C --demangle
<span># 将底层的符号名解码成用户级名字，除了去掉所开头的下划线之外，还使得C++函数名以可理解的方式显示出来。 </span>
--debugging
-g
<span># 显示调试信息。企图解析保存在文件中的调试信息并以C语言的语法显示出来。仅仅支持某些类型的调试信息。有些其他的格式被readelf -w支持。 </span>

-e --debugging-tags
<span># 类似-g选项，但是生成的信息是和ctags工具相兼容的格式。 </span>
--disassemble
-d
<span># 从objfile中反汇编那些特定指令机器码的section。 </span>

-D --disassemble-all
<span># 与 -d 类似，但反汇编所有section. </span>

--prefix-addresses
<span># 反汇编的时候，显示每一行的完整地址。这是一种比较老的反汇编格式。 </span>

-EB
-EL
--endian<span>=</span><span>{</span>big<span>|</span>little<span>}</span>
<span># 指定目标文件的小端。这个项将影响反汇编出来的指令。在反汇编的文件没描述小端信息的时候用。例如S-records. </span>

-f
--file-headers
显示objfile中每个文件的整体头部摘要信息。

-h
--section-headers
--headers
显示目标文件各个section的头部摘要信息。

-H
--help
简短的帮助信息。

-i
--info
显示对于 -b 或者 -m 选项可用的架构和目标格式列表。

-j name
--section<span>=</span>name
仅仅显示指定名称为name的section的信息

-l
--line-numbers
用文件名和行号标注相应的目标代码，仅仅和-d、-D或者-r一起使用使用-ld和使用-d的区别不是很大，在源码级调试的时候有用，要求编译时使用了-g之类的调试编译选项。

-m machine
--architecture<span>=</span>machine
指定反汇编目标文件时使用的架构，当待反汇编文件本身没描述架构信息的时候<span>(</span>比如S-records<span>)</span>，这个选项很有用。可以用-i选项列出这里能够指定的架构.

--reloc
-r
显示文件的重定位入口。如果和-d或者-D一起使用，重定位部分以反汇编后的格式显示出来。

--dynamic-reloc
-R
显示文件的动态重定位入口，仅仅对于动态目标文件意义，比如某些共享库。

-s
--full-contents
显示指定section的完整内容。默认所有的非空section都会被显示。

-S
--source
尽可能反汇编出源代码，尤其当编译的时候指定了-g这种调试参数时，效果比较明显。隐含了-d参数。

--show-raw-insn
反汇编的时候，显示每条汇编指令对应的机器码，如不指定--prefix-addresses，这将是缺省选项。

--no-show-raw-insn
反汇编时，不显示汇编指令的机器码，如不指定--prefix-addresses，这将是缺省选项。

--start-address<span>=</span>address
从指定地址开始显示数据，该选项影响-d、-r和-s选项的输出。

--stop-address<span>=</span>address
显示数据直到指定地址为止，该项影响-d、-r和-s选项的输出。

-t
--syms
显示文件的符号表入口。类似于nm -s提供的信息

-T
--dynamic-syms
显示文件的动态符号表入口，仅仅对动态目标文件意义，比如某些共享库。它显示的信息类似于 nm -D<span>|</span>--dynamic 显示的信息。

-V
--version
版本信息

--all-headers
-x
显示所可用的头信息，包括符号表、重定位入口。-x 等价于-a -f -h -r -t 同时指定。

-z
--disassemble-zeroes
一般反汇编输出将省略大块的零，该选项使得这些零块也被反汇编。

@file 可以将选项集中到一个文件中，然后使用这个@file选项载入。</code></pre>
<h3>实例</h3><p>首先，在给出后面大部分测试所基于的源代码以及编译指令。 源代码如下： </p>
<pre><code>root@localhost <span>[</span>test<span>]</span><span># nl mytest.cpp </span></code></pre>
<pre><code>void <span>printTest</span><span>(</span><span>)</span> <span>{</span>
    char a<span>;</span>
    a <span>=</span> <span>'a'</span><span>;</span>
<span>}</span>

void <span>printTest2</span><span>(</span><span>)</span> <span>{</span>
int a <span>=</span> <span>2</span><span>;</span>
<span>a</span><span>+=</span><span>2</span><span>;</span>
<span>}</span> </code></pre>
<p>对以上源代码进行编译，如下： </p>
<pre><code><span>[</span>root@localhost test<span>]</span><span># g++ -c -g mytest.cpp </span></code></pre>
<p>这里，生成的文件是mytest.o，为了方便测试包含了调试的信息，对可执行文件的测试，显示的结果类似。 </p>
<p> *<em>查看当前使用的objdump的版本号： *</em> </p>
<pre><code><span>[</span>root@localhost test<span>]</span><span># objdump -V </span>
GNU objdump <span>2.17</span>.50.0.6-14.el5 <span>20061020</span>
Copyright <span>2005</span> <span>free</span> Software Foundation, Inc.
This program is <span>free</span> software<span>;</span> you may redistribute it under the terms of
the GNU General Public License.  This program has absolutely no warranty. </code></pre>
<p> *<em>查看档案库文件中的信息： *</em> </p>
<pre><code><span>[</span>root@localhost test<span>]</span><span># objdump -a libmy2.a </span>
In archive libmy2.a:
myfile.o:     <span>file</span> <span>format</span> elf32-i386
rwxrwxrwx <span>0</span>/0   <span>2724</span> Nov <span>16</span> <span>16</span>:06 <span>2009</span> myfile.o
mytest.o:     <span>file</span> <span>format</span> elf32-i386
rw-r--r-- <span>0</span>/0    <span>727</span> Jul <span>13</span> <span>15</span>:32 <span>2011</span> mytest.o </code></pre>
<p> <em>*这里，libmy2.a是一个使用ar命令将多个</em>.o目标文件打包而生成的静态库。命令的输出类似<code>ar -tv</code>，相比较<code>ar -tv</code>输出如下： ** </p>
<pre><code><span>[</span>root@localhost test<span>]</span><span># ar -tv libmy2.a </span>
rwxrwxrwx <span>0</span>/0   <span>2724</span> Nov <span>16</span> <span>16</span>:06 <span>2009</span> myfile.o
rw-r--r-- <span>0</span>/0    <span>727</span> Jul <span>13</span> <span>15</span>:32 <span>2011</span> mytest.o </code></pre>
<p>显示可用的架构和目标结构列表： </p>
<pre><code><span>[</span>root@localhost test<span>]</span><span># objdump -i </span>
BFD header <span>file</span> version <span>2.17</span>.50.0.6-14.el5 <span>20061020</span>
elf32-i386
<span>(</span>header little endian, data little endian<span>)</span>
  i386
a.out-i386-linux
<span>(</span>header little endian, data little endian<span>)</span>
  i386
efi-app-ia32
<span>(</span>header little endian, data little endian<span>)</span>
  i386
elf64-x86-64
<span>(</span>header little endian, data little endian<span>)</span>
  i386
elf64-little
<span>(</span>header little endian, data little endian<span>)</span>
  i386
elf64-big
<span>(</span>header big endian, data big endian<span>)</span>
  i386
elf32-little
<span>(</span>header little endian, data little endian<span>)</span>
  i386
elf32-big
<span>(</span>header big endian, data big endian<span>)</span>
  i386
srec
<span>(</span>header endianness unknown, data endianness unknown<span>)</span>
  i386
symbolsrec
<span>(</span>header endianness unknown, data endianness unknown<span>)</span>
  i386
tekhex
<span>(</span>header endianness unknown, data endianness unknown<span>)</span>
  i386
binary
<span>(</span>header endianness unknown, data endianness unknown<span>)</span>
  i386
ihex
<span>(</span>header endianness unknown, data endianness unknown<span>)</span>
  i386
trad-core
<span>(</span>header endianness unknown, data endianness unknown<span>)</span>

              elf32-i386 a.out-i386-linux efi-app-ia32 elf64-x86-64
          i386 elf32-i386 a.out-i386-linux efi-app-ia32 elf64-x86-64

              elf64-little elf64-big elf32-little elf32-big srec symbolsrec
          i386 elf64-little elf64-big elf32-little elf32-big srec symbolsrec

              tekhex binary ihex trad-core
          i386 tekhex binary ihex --------- </code></pre>
<p>这里，显示的信息是相对于 -b 或者 -m 选项可用的架构和目标格式列表。 </p>
<p> *<em>显示mytest.o文件中的text段的内容： *</em> </p>
<pre><code><span>[</span>root@localhost test<span>]</span><span># objdump --section=.text -s mytest.o </span>
mytest.o:     <span>file</span> <span>format</span> elf32-i386
Contents of section .text:
0000 5589e583 ec10c645 ff61c9c3 5589e583  U<span>..</span><span>..</span><span>..</span>E.a<span>..</span>U<span>..</span>.
0010 ec10c745 fc020000 008345fc 02c9c3    <span>..</span>.E<span>..</span><span>..</span><span>..</span>E<span>..</span><span>..</span> </code></pre>
<p>这里注意，不能单独使用-j或者--section，例如<code>objdump --section=.text mytest.o</code>是不会运行成功的。 </p>
<p> *<em>反汇编mytest.o中的text段内容，并尽可能用源代码形式表示： *</em> </p>
<pre><code><span>[</span>root@localhost test<span>]</span><span># objdump -j .text -S mytest.o </span>
mytest.o:     <span>file</span> <span>format</span> elf32-i386
Disassembly of section .text:
00000000 <span>&lt;</span>_Z9printTestv<span>></span>:
void printTest<span>(</span><span>)</span>
   <span>0</span>:   <span>55</span>                      push   %ebp
   <span>1</span>:   <span>89</span> e5                   mov    %esp,%ebp
   <span>3</span>:   <span>83</span> ec <span>10</span>                sub    <span>&#36;0x10</span>,%esp
<span>{</span>
        char a<span>;</span>
        a <span>=</span> <span>'a'</span><span>;</span>
   <span>6</span>:   c6 <span>45</span> ff <span>61</span>             movb   <span>&#36;0x61</span>,0xffffffff<span>(</span>%ebp<span>)</span>
<span>}</span>
   a:   c9                      leave
   b:   c3                      ret

000000c <span>&lt;</span>_Z10printTest2v<span>></span>:
void printTest2<span>(</span><span>)</span>
   c:   <span>55</span>                      push   %ebp
   d:   <span>89</span> e5                   mov    %esp,%ebp
   f:   <span>83</span> ec <span>10</span>                sub    <span>&#36;0x10</span>,%esp
<span>{</span>
        int a <span>=</span> <span>2</span><span>;</span>
  <span>12</span>:   c7 <span>45</span> fc 02 00 00 00    movl   <span>&#36;0x2</span>,0xfffffffc<span>(</span>%ebp<span>)</span>
        <span>a</span><span>+=</span><span>2</span><span>;</span>
  <span>19</span>:   <span>83</span> <span>45</span> fc 02             addl   <span>&#36;0x2</span>,0xfffffffc<span>(</span>%ebp<span>)</span>
<span>}</span>
  1d:   c9                      leave
  1e:   c3                      ret    </code></pre>
<p>这里注意，不能单独使用-j或者--section，例如<code>objdump -j .text mytest.o是不会运行成功的</code>。另外-S命令对于包含调试信息的目标文件，显示的效果比较好，如果编译时没有指定g++的-g选项，那么目标文件就不包含调试信息，那么显示效果就差多了。 </p>
<p> *<em>反汇编出mytest.o的源代码: *</em> </p>
<pre><code><span>[</span>root@localhost test<span>]</span><span># objdump -S mytest.o </span>
mytest.o:     <span>file</span> <span>format</span> elf32-i386

Disassembly of section .text:

00000000 <span>&lt;</span>_Z9printTestv<span>></span>:
void printTest<span>(</span><span>)</span>
   <span>0</span>:   <span>55</span>                      push   %ebp
   <span>1</span>:   <span>89</span> e5                   mov    %esp,%ebp
   <span>3</span>:   <span>83</span> ec <span>10</span>                sub    <span>&#36;0x10</span>,%esp
<span>{</span>
        char a<span>;</span>
        a <span>=</span> <span>'a'</span><span>;</span>
   <span>6</span>:   c6 <span>45</span> ff <span>61</span>             movb   <span>&#36;0x61</span>,0xffffffff<span>(</span>%ebp<span>)</span>
<span>}</span>
   a:   c9                      leave
   b:   c3                      ret

0000000c <span>&lt;</span>_Z10printTest2v<span>></span>:
void printTest2<span>(</span><span>)</span>
   c:   <span>55</span>                      push   %ebp
   d:   <span>89</span> e5                   mov    %esp,%ebp
   f:   <span>83</span> ec <span>10</span>                sub    <span>&#36;0x10</span>,%esp
<span>{</span>
       int a <span>=</span> <span>2</span><span>;</span>
  <span>12</span>:   c7 <span>45</span> fc 02 00 00 00    movl   <span>&#36;0x2</span>,0xfffffffc<span>(</span>%ebp<span>)</span>
        <span>a</span><span>+=</span><span>2</span><span>;</span>
  <span>19</span>:   <span>83</span> <span>45</span> fc 02             addl   <span>&#36;0x2</span>,0xfffffffc<span>(</span>%ebp<span>)</span>
<span>}</span>
  1d:   c9                      leave
  1e:   c3                      ret    </code></pre>
<p>这里，尤其当编译的时候指定了-g这种调试参数时，反汇编的效果比较明显。隐含了-d参数。 </p>
<p> *<em>显示文件的符号表入口: *</em> </p>
<pre><code><span>[</span>root@localhost test<span>]</span><span># objdump -t mytest.o </span>
mytest.o:     <span>file</span> <span>format</span> elf32-i386

SYMBOL TABLE:
00000000 l    <span>df</span> *ABS*  00000000 mytest.cpp
00000000 l    d  .text  00000000 .text
00000000 l    d  .data  00000000 .data
00000000 l    d  .bss   00000000 .bss
00000000 l    d  .debug_abbrev  00000000 .debug_abbrev
00000000 l    d  .debug_info    00000000 .debug_info
00000000 l    d  .debug_line    00000000 .debug_line
00000000 l    d  .debug_frame   00000000 .debug_frame
00000000 l    d  .debug_loc     00000000 .debug_loc
00000000 l    d  .debug_pubnames        00000000 .debug_pubnames
00000000 l    d  .debug_aranges 00000000 .debug_aranges
00000000 l    d  .note.GNU-stack        00000000 .note.GNU-stack
00000000 l    d  .comment       00000000 .comment
00000000 g     F .text  0000000c _Z9printTestv
00000000         *UND*  00000000 __gxx_personality_v0
0000000c g     F .text  00000013 _Z10printTest2v </code></pre>
<p>这里，输出的信息类似<code>nm -s</code>命令的输出，相比较之下，nm命令的输出如下： </p>
<pre><code><span>[</span>root@localhost test<span>]</span><span># nm -s mytest.o </span>
0000000c T _Z10printTest2v
00000000 T _Z9printTestv
         U __gxx_personality_v0 </code></pre>
<p> *<em>显示文件的符号表入口，将底层符号解码并表示成用户级别: *</em> </p>
<pre><code><span>[</span>root@localhost test<span>]</span><span># objdump -t -C mytest.o </span>
mytest.o:     <span>file</span> <span>format</span> elf32-i386
SYMBOL TABLE:
00000000 l    <span>df</span> *ABS*  00000000 mytest.cpp
00000000 l    d  .text  00000000 .text
00000000 l    d  .data  00000000 .data
00000000 l    d  .bss   00000000 .bss
00000000 l    d  .debug_abbrev  00000000 .debug_abbrev
00000000 l    d  .debug_info    00000000 .debug_info
00000000 l    d  .debug_line    00000000 .debug_line
00000000 l    d  .debug_frame   00000000 .debug_frame
00000000 l    d  .debug_loc     00000000 .debug_loc
00000000 l    d  .debug_pubnames        00000000 .debug_pubnames
00000000 l    d  .debug_aranges 00000000 .debug_aranges
00000000 l    d  .note.GNU-stack        00000000 .note.GNU-stack
00000000 l    d  .comment       00000000 .comment
00000000 g     F .text  0000000c printTest<span>(</span><span>)</span>
00000000         *UND*  00000000 __gxx_personality_v0
0000000c g     F .text  00000013 printTest2<span>(</span><span>)</span> </code></pre>
<p>这里，和没-C相比，printTest2函数可读性增加了。 </p>
<p> *<em>反汇编目标文件的特定机器码段： *</em> </p>
<pre><code><span>[</span>root@localhost test<span>]</span><span># objdump -d mytest.o </span>
mytest.o:     <span>file</span> <span>format</span> elf32-i386
Disassembly of section .text:

00000000 <span>&lt;</span>_Z9printTestv<span>></span>:
   <span>0</span>:   <span>55</span>                      push   %ebp
   <span>1</span>:   <span>89</span> e5                   mov    %esp,%ebp
   <span>3</span>:   <span>83</span> ec <span>10</span>                sub    <span>&#36;0x10</span>,%esp
   <span>6</span>:   c6 <span>45</span> ff <span>61</span>             movb   <span>&#36;0x61</span>,0xffffffff<span>(</span>%ebp<span>)</span>
   a:   c9                      leave
  b:   c3                      ret

0000000c <span>&lt;</span>_Z10printTest2v<span>></span>:
   c:   <span>55</span>                      push   %ebp
   d:   <span>89</span> e5                   mov    %esp,%ebp
   f:   <span>83</span> ec <span>10</span>                sub    <span>&#36;0x10</span>,%esp
  <span>12</span>:   c7 <span>45</span> fc 02 00 00 00    movl   <span>&#36;0x2</span>,0xfffffffc<span>(</span>%ebp<span>)</span>
  <span>19</span>:   <span>83</span> <span>45</span> fc 02             addl   <span>&#36;0x2</span>,0xfffffffc<span>(</span>%ebp<span>)</span>
  1d:   c9                      leave
  1e:   c3                      ret    </code></pre>
<p>这里，对text段的内容进行了反汇编。 </p>
<p> *<em>反汇编特定段，并将汇编代码对应的文件名称和行号对应上： *</em> </p>
<pre><code><span>[</span>root@localhost test<span>]</span><span># objdump -d -l mytest.o</span>
mytest.o:     <span>file</span> <span>format</span> elf32-i386
Disassembly of section .text:

00000000 <span>&lt;</span>_Z9printTestv<span>></span>:
_Z9printTestv<span>(</span><span>)</span>:
/root/test/04_libraryTest/mytest.cpp:1
   <span>0</span>:   <span>55</span>                      push   %ebp
   <span>1</span>:   <span>89</span> e5                   mov    %esp,%ebp
   <span>3</span>:   <span>83</span> ec <span>10</span>                sub    <span>&#36;0x10</span>,%esp
/root/test/04_libraryTest/mytest.cpp:4
   <span>6</span>:   c6 <span>45</span> ff <span>61</span>             movb   <span>&#36;0x61</span>,0xffffffff<span>(</span>%ebp<span>)</span>
/root/test/04_libraryTest/mytest.cpp:5
   a:   c9                      leave
   b:   c3                      ret

0000000c <span>&lt;</span>_Z10printTest2v<span>></span>:
_Z10printTest2v<span>(</span><span>)</span>:
/root/test/04_libraryTest/mytest.cpp:6
   c:   <span>55</span>                      push   %ebp
   d:   <span>89</span> e5                   mov    %esp,%ebp
   f:   <span>83</span> ec <span>10</span>                sub    <span>&#36;0x10</span>,%esp
/root/test/04_libraryTest/mytest.cpp:8
  <span>12</span>:   c7 <span>45</span> fc 02 00 00 00    movl   <span>&#36;0x2</span>,0xfffffffc<span>(</span>%ebp<span>)</span>
/root/test/04_libraryTest/mytest.cpp:9
  <span>19</span>:   <span>83</span> <span>45</span> fc 02             addl   <span>&#36;0x2</span>,0xfffffffc<span>(</span>%ebp<span>)</span>
/root/test/04_libraryTest/mytest.cpp:10
  1d:   c9                      leave
  1e:   c3                      ret    </code></pre>
<p>这里，项&quot;-d&quot;从objfile中反汇编那些特定指令机器码的section，而使用&quot;-l&quot;指定用文件名和行号标注相应的目标代码，仅仅和-d、-D或者-r一起使用，使用-ld和使用-d的区别不是很大，在源码级调试的时候有用，要求编译时使用了-g之类的调试编译选项。 </p>
<p> *<em>显示目标文件各个段的头部摘要信息： *</em> </p>
<pre><code><span>[</span>root@localhost test<span>]</span><span># objdump -h mytest.o </span>
mytest.o:     <span>file</span> <span>format</span> elf32-i386

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  <span>0</span> .text         0000001f  00000000  00000000  00000034  <span>2</span>**2
                  CONTENTS, ALLOC, LOAD, readonly, CODE
  <span>1</span> .data         00000000  00000000  00000000  00000054  <span>2</span>**2
                  CONTENTS, ALLOC, LOAD, DATA
  <span>2</span> .bss          00000000  00000000  00000000  00000054  <span>2</span>**2
                  ALLOC
  <span>3</span> .debug_abbrev 00000046  00000000  00000000  00000054  <span>2</span>**0
                  CONTENTS, READONLY, DEBUGGING
  <span>4</span> .debug_info   000000ed  00000000  00000000  0000009a  <span>2</span>**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  <span>5</span> .debug_line   0000003e  00000000  00000000  00000187  <span>2</span>**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  <span>6</span> .debug_frame  00000044  00000000  00000000  000001c8  <span>2</span>**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  <span>7</span> .debug_loc    00000058  00000000  00000000  0000020c  <span>2</span>**0
                  CONTENTS, READONLY, DEBUGGING
  <span>8</span> .debug_pubnames 0000002f  00000000  00000000  00000264  <span>2</span>**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  <span>9</span> .debug_aranges 00000020  00000000  00000000  00000293  <span>2</span>**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
<span>10</span> .comment      0000002e  00000000  00000000  000002b3  <span>2</span>**0
                  CONTENTS, READONLY
<span>11</span> .note.GNU-stack 00000000  00000000  00000000  000002e1  <span>2</span>**0
                  CONTENTS, READONLY </code></pre>
<p>这里，更多的内容参见<code>man objdump</code>中的这个选项。</p>
<p style="text-align:right"><a href="https://dev-coco.github.io/Linux-Command/"><img alt="Linux命令, Linux命令手册" src="https://dev-coco.github.io/images/Linux-Penguin-Icon.png" style="width:48px" />Linux命令手册</a></p>
        </div>
</body>
</html>
